From 893069457ebac75052159679536e8b18fda3e314 Mon Sep 17 00:00:00 2001
From: Holger Freyther <ich@tamarin.(none)>
Date: Fri, 12 Sep 2008 14:26:34 +0200
Subject: [PATCH] [gcc] EPSON modified sources

---
 config.sub                               |    2 +
 gcc/Makefile.in                          |    1 -
 gcc/builtins.def                         |    6 +
 gcc/c-decl.c                             |    1 +
 gcc/config.gcc                           |   15 +
 gcc/config/c33/c33-protos.h              |   36 +
 gcc/config/c33/c33.c                     | 4086 ++++++++++++++++++++++++++++++
 gcc/config/c33/c33.h                     | 2347 +++++++++++++++++
 gcc/config/c33/c33.md                    | 1241 +++++++++
 gcc/config/c33/lib1funcs.s               |  315 +++
 gcc/config/c33/libgcc/Makefile           |   45 +
 gcc/config/c33/libgcc/adddf3.lst         |  847 +++++++
 gcc/config/c33/libgcc/adddf3.s           |  778 ++++++
 gcc/config/c33/libgcc/addsf3.lst         |  399 +++
 gcc/config/c33/libgcc/addsf3.s           |  368 +++
 gcc/config/c33/libgcc/divdf3.lst         |  719 ++++++
 gcc/config/c33/libgcc/divdf3.s           |  669 +++++
 gcc/config/c33/libgcc/divhi3.lst         |  118 +
 gcc/config/c33/libgcc/divhi3.s           |  112 +
 gcc/config/c33/libgcc/divsf3.lst         |  413 +++
 gcc/config/c33/libgcc/divsf3.s           |  384 +++
 gcc/config/c33/libgcc/divsi3.lst         |  150 ++
 gcc/config/c33/libgcc/divsi3.s           |  141 +
 gcc/config/c33/libgcc/extsfdf.lst        |  174 ++
 gcc/config/c33/libgcc/extsfdf.s          |  161 ++
 gcc/config/c33/libgcc/fcmpd.lst          |  108 +
 gcc/config/c33/libgcc/fcmpd.s            |   99 +
 gcc/config/c33/libgcc/fcmps.lst          |  101 +
 gcc/config/c33/libgcc/fcmps.s            |   92 +
 gcc/config/c33/libgcc/fixdfi.lst         |  140 +
 gcc/config/c33/libgcc/fixdfi.s           |  128 +
 gcc/config/c33/libgcc/fixdfui.lst        |  154 ++
 gcc/config/c33/libgcc/fixdfui.s          |  140 +
 gcc/config/c33/libgcc/fixsfi.lst         |  110 +
 gcc/config/c33/libgcc/fixsfi.s           |  101 +
 gcc/config/c33/libgcc/fixsfui.lst        |  127 +
 gcc/config/c33/libgcc/fixsfui.s          |  113 +
 gcc/config/c33/libgcc/flosidf.lst        |  107 +
 gcc/config/c33/libgcc/flosidf.s          |  100 +
 gcc/config/c33/libgcc/flosisf.lst        |  102 +
 gcc/config/c33/libgcc/flosisf.s          |   96 +
 gcc/config/c33/libgcc/libgcc.a           |  Bin 0 -> 21742 bytes
 gcc/config/c33/libgcc/modhi3.lst         |  105 +
 gcc/config/c33/libgcc/modhi3.s           |   99 +
 gcc/config/c33/libgcc/modsi3.lst         |  138 +
 gcc/config/c33/libgcc/modsi3.s           |  129 +
 gcc/config/c33/libgcc/muldf3.lst         |  475 ++++
 gcc/config/c33/libgcc/muldf3.s           |  443 ++++
 gcc/config/c33/libgcc/mulsf3.lst         |  327 +++
 gcc/config/c33/libgcc/mulsf3.s           |  301 +++
 gcc/config/c33/libgcc/negdf2.lst         |   41 +
 gcc/config/c33/libgcc/negdf2.s           |   37 +
 gcc/config/c33/libgcc/negsf2.lst         |   38 +
 gcc/config/c33/libgcc/negsf2.s           |   34 +
 gcc/config/c33/libgcc/scan64.lst         |   51 +
 gcc/config/c33/libgcc/scan64.s           |   48 +
 gcc/config/c33/libgcc/sedscr             |   16 +
 gcc/config/c33/libgcc/trncdfsf.lst       |  126 +
 gcc/config/c33/libgcc/trncdfsf.s         |  113 +
 gcc/config/c33/libgcc1.S                 |  317 +++
 gcc/config/c33/t-c33                     |   35 +
 gcc/cp/decl.c                            |  133 +
 gcc/cppinit.c                            |   56 +-
 gcc/cpplib.c                             |    5 +-
 gcc/cppmain.c                            |   97 +-
 gcc/final.c                              |   84 +
 gcc/gcc.c                                |    5 +
 gcc/line-map.c                           |   21 +-
 gcc/protoize.c                           |    2 +
 gcc/toplev.c                             |   51 +
 gcc/tree.h                               |    2 -
 gcc/varasm.c                             |   15 +-
 include/obstack.h                        |   16 +
 libstdc++-v3/include/c_std/std_cstring.h |    4 -
 74 files changed, 18679 insertions(+), 31 deletions(-)
 mode change 100755 => 100644 config.sub
 create mode 100644 gcc/config/c33/c33-protos.h
 create mode 100644 gcc/config/c33/c33.c
 create mode 100644 gcc/config/c33/c33.h
 create mode 100644 gcc/config/c33/c33.md
 create mode 100644 gcc/config/c33/lib1funcs.s
 create mode 100644 gcc/config/c33/libgcc/Makefile
 create mode 100644 gcc/config/c33/libgcc/adddf3.lst
 create mode 100644 gcc/config/c33/libgcc/adddf3.s
 create mode 100644 gcc/config/c33/libgcc/addsf3.lst
 create mode 100644 gcc/config/c33/libgcc/addsf3.s
 create mode 100644 gcc/config/c33/libgcc/divdf3.lst
 create mode 100644 gcc/config/c33/libgcc/divdf3.s
 create mode 100644 gcc/config/c33/libgcc/divhi3.lst
 create mode 100644 gcc/config/c33/libgcc/divhi3.s
 create mode 100644 gcc/config/c33/libgcc/divsf3.lst
 create mode 100644 gcc/config/c33/libgcc/divsf3.s
 create mode 100644 gcc/config/c33/libgcc/divsi3.lst
 create mode 100644 gcc/config/c33/libgcc/divsi3.s
 create mode 100644 gcc/config/c33/libgcc/extsfdf.lst
 create mode 100644 gcc/config/c33/libgcc/extsfdf.s
 create mode 100644 gcc/config/c33/libgcc/fcmpd.lst
 create mode 100644 gcc/config/c33/libgcc/fcmpd.s
 create mode 100644 gcc/config/c33/libgcc/fcmps.lst
 create mode 100644 gcc/config/c33/libgcc/fcmps.s
 create mode 100644 gcc/config/c33/libgcc/fixdfi.lst
 create mode 100644 gcc/config/c33/libgcc/fixdfi.s
 create mode 100644 gcc/config/c33/libgcc/fixdfui.lst
 create mode 100644 gcc/config/c33/libgcc/fixdfui.s
 create mode 100644 gcc/config/c33/libgcc/fixsfi.lst
 create mode 100644 gcc/config/c33/libgcc/fixsfi.s
 create mode 100644 gcc/config/c33/libgcc/fixsfui.lst
 create mode 100644 gcc/config/c33/libgcc/fixsfui.s
 create mode 100644 gcc/config/c33/libgcc/flosidf.lst
 create mode 100644 gcc/config/c33/libgcc/flosidf.s
 create mode 100644 gcc/config/c33/libgcc/flosisf.lst
 create mode 100644 gcc/config/c33/libgcc/flosisf.s
 create mode 100644 gcc/config/c33/libgcc/libgcc.a
 create mode 100644 gcc/config/c33/libgcc/modhi3.lst
 create mode 100644 gcc/config/c33/libgcc/modhi3.s
 create mode 100644 gcc/config/c33/libgcc/modsi3.lst
 create mode 100644 gcc/config/c33/libgcc/modsi3.s
 create mode 100644 gcc/config/c33/libgcc/muldf3.lst
 create mode 100644 gcc/config/c33/libgcc/muldf3.s
 create mode 100644 gcc/config/c33/libgcc/mulsf3.lst
 create mode 100644 gcc/config/c33/libgcc/mulsf3.s
 create mode 100644 gcc/config/c33/libgcc/negdf2.lst
 create mode 100644 gcc/config/c33/libgcc/negdf2.s
 create mode 100644 gcc/config/c33/libgcc/negsf2.lst
 create mode 100644 gcc/config/c33/libgcc/negsf2.s
 create mode 100644 gcc/config/c33/libgcc/scan64.lst
 create mode 100644 gcc/config/c33/libgcc/scan64.s
 create mode 100644 gcc/config/c33/libgcc/sedscr
 create mode 100644 gcc/config/c33/libgcc/trncdfsf.lst
 create mode 100644 gcc/config/c33/libgcc/trncdfsf.s
 create mode 100644 gcc/config/c33/libgcc1.S
 create mode 100644 gcc/config/c33/t-c33

diff --git a/config.sub b/config.sub
old mode 100755
new mode 100644
index 2ab7f25..5afcd75
--- a/config.sub
+++ b/config.sub
@@ -341,6 +341,8 @@ case $basic_machine in
 	| ymp-* \
 	| z8k-*)
 		;;
+	c33-*) # K.Watanabe gcc-3.3.2
+	        ;;
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
index 67076d3..f8ed175 100644
--- a/gcc/Makefile.in
+++ b/gcc/Makefile.in
@@ -660,7 +660,6 @@ HOST_VARRAY = $(BUILD_PREFIX)varray.o
 # currently being compiled, in both source trees, to be examined as well.
 INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \
 	   -I$(srcdir)/config -I$(srcdir)/../include
-
 # Always use -I$(srcdir)/config when compiling.
 .c.o:
 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)
diff --git a/gcc/builtins.def b/gcc/builtins.def
index c208b75..f76b74f 100644
--- a/gcc/builtins.def
+++ b/gcc/builtins.def
@@ -738,6 +738,10 @@ DEF_BUILTIN (BUILT_IN_ABORT,
 	     1, 0, 0,
 	     ATTR_NORETURN_NOTHROW_LIST)
 
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* -fno-builtin を外すと、exit() / _exit() 関数は、型が違うとなる。        */
+/* この定義をコメントにして、exit() / _exit() 関数を built in 関数から外す */
+#if 0
 DEF_BUILTIN (BUILT_IN_EXIT,
 	     "__builtin_exit",
 	     NOT_BUILT_IN,
@@ -753,6 +757,8 @@ DEF_BUILTIN (BUILT_IN__EXIT,
 	     BT_FN_VOID_INT,
 	     1, 0, 1,
 	     ATTR_NORETURN_NOTHROW_LIST)
+#endif	     
+/* DEL K.Watanabe V1.7 <<<<<<< */
 
 DEF_BUILTIN (BUILT_IN__EXIT2,
 	     "__builtin__Exit",
diff --git a/gcc/c-decl.c b/gcc/c-decl.c
index 5cb5270..dc1a232 100644
--- a/gcc/c-decl.c
+++ b/gcc/c-decl.c
@@ -4891,6 +4891,7 @@ get_parm_info (void_at_end)
 	   args are passed in their declared types.  */
 	tree type = TREE_TYPE (decl);
 	DECL_ARG_TYPE (decl) = type;
+
 	if (PROMOTE_PROTOTYPES
 	    && INTEGRAL_TYPE_P (type)
 	    && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))
diff --git a/gcc/config.gcc b/gcc/config.gcc
index 25b3be4..6d91434 100644
--- a/gcc/config.gcc
+++ b/gcc/config.gcc
@@ -2697,6 +2697,21 @@ v850-*-*)
 	c_target_objs="v850-c.o"
 	cxx_target_objs="v850-c.o"
 	;;
+	
+# ADD K.Watanabe V1.7 >>>>>>>
+c33-*-*)			
+		cpu_type=c33
+		tm_file="dbxelf.h elfos.h svr4.h c33/c33.h"		
+		xm_file="c33/xm-c33.h"
+		tmake_file=c33/t-c33
+		if test x$stabs = xyes
+		then
+			tm_file="${tm_file} dbx.h"
+		fi
+		use_collect2=no
+		;;	
+# ADD K.Watanabe V1.7 <<<<<<<	
+
 vax-*-bsd*)			# VAXen running BSD
 	tm_file="${tm_file} vax/bsd.h"
 	use_collect2=yes
diff --git a/gcc/config/c33/c33-protos.h b/gcc/config/c33/c33-protos.h
new file mode 100644
index 0000000..4221ab0
--- /dev/null
+++ b/gcc/config/c33/c33-protos.h
@@ -0,0 +1,36 @@
+extern void override_options PARAMS((void));
+extern rtx function_arg PARAMS(( CUMULATIVE_ARGS *,enum machine_mode,tree,int ));
+extern int const_costs PARAMS(());
+extern void print_operand PARAMS(());
+extern void print_operand_address PARAMS(());
+extern void final_prescan_insn PARAMS((rtx insn,rtx *,int ));
+extern char * output_move_single PARAMS(());
+extern char * output_move_double PARAMS(( rtx * ));
+extern char * output_btst PARAMS(( rtx * ));
+extern char * output_bclr PARAMS(( rtx * ));
+extern char * output_bset PARAMS(( rtx * ));
+extern int call_address_operand PARAMS(( rtx,enum machine_mode ));
+extern int power_of_two_operand PARAMS(());
+extern int not_power_of_two_operand PARAMS(());
+extern int general_operand_post_inc PARAMS(( rtx,enum machine_mode ));
+extern int compute_register_save_size PARAMS(( long * ));
+extern int compute_frame_size PARAMS(());
+extern void expand_prologue PARAMS(());
+extern void expand_epilogue PARAMS(());
+extern void notice_update_cc PARAMS(());
+extern c33_data_area c33_get_data_area PARAMS(( tree ));
+extern void c33_encode_data_area PARAMS(( tree )); 
+extern int c33_interrupt_function_p PARAMS((void));
+extern void c33_select_section PARAMS(( tree,int ));
+extern int nshift_operator PARAMS(( rtx,enum machine_mode ));
+extern int expand_a_shift PARAMS(( enum machine_mode,int,rtx* ));
+extern char * emit_a_shift PARAMS(( enum rtx_code,rtx * ));
+extern void print_options PARAMS(( FILE * ));
+extern void declare_object PARAMS(());
+extern void c33_output_aligned_bss PARAMS(( FILE *,tree,char*,int,int ));
+extern void c33_output_common PARAMS(( FILE *,tree,char *,int,int ));
+extern void c33_output_local PARAMS(( FILE *,tree,char *,int,int ));
+extern void asm_file_start PARAMS(( FILE * ));
+extern void expand_block_move PARAMS(( rtx* ));
+extern char * output_block_move PARAMS(( rtx,rtx*,int ));
+extern int c33_adjust_insn_length PARAMS(( rtx,int ));
diff --git a/gcc/config/c33/c33.c b/gcc/config/c33/c33.c
new file mode 100644
index 0000000..6422a28
--- /dev/null
+++ b/gcc/config/c33/c33.c
@@ -0,0 +1,4086 @@
+/* Subroutines for insn-output.c for EPSON C33 series
+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+   Contributed by Jeff Law (law@cygnus.com).
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/***********************/
+/* #include            */
+/***********************/
+#include "config.h"
+#include "system.h"
+#include "tree.h"
+#include "rtl.h"
+#include "regs.h"
+#include "hard-reg-set.h"
+#include "real.h"
+#include "insn-config.h"
+#include "conditions.h"
+#include "output.h"
+#include "insn-attr.h"
+#include "flags.h"
+#include "recog.h"
+#include "expr.h"
+#include "function.h"
+#include "toplev.h"
+#include "ggc.h"
+#include "integrate.h"
+#include "tm_p.h"
+#include "target.h"
+#include "target-def.h"
+
+#ifndef streq
+#define streq(a,b) (strcmp (a, b) == 0)
+#endif
+
+/***********************/
+/* #define             */
+/***********************/
+#define GDA_REGNUM	15
+#define ZDA_REGNUM	14
+#define TDA_REGNUM	13
+#define SDA_REGNUM	12
+
+
+// ADD K.Watanabe V1.8 >>>>>>>
+/***********************/
+/*     prototype       */
+/***********************/
+void override_options ();
+rtx function_arg ( CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type, int named );
+static void const_double_split ( rtx x, HOST_WIDE_INT *p_high, HOST_WIDE_INT *p_low );
+static int const_costs_int ( HOST_WIDE_INT value );
+int const_costs ( rtx r, enum rtx_code c );
+void print_operand ( FILE *file, rtx x, int code );
+void print_operand_address ( FILE *file, rtx addr );
+void final_prescan_insn ( rtx insn, rtx *operand, int num_operands );
+char * output_move_single ( rtx *operands, int unsignedp );
+char *output_move_double ( rtx *operands );
+char *output_btst ( rtx *operands );
+char *output_bclr ( rtx *operands );
+char *output_bset ( rtx *operands );
+int call_address_operand ( rtx op, enum machine_mode mode );
+int power_of_two_operand ( rtx op, enum machine_mode mode );
+int not_power_of_two_operand ( rtx op, enum machine_mode mode );
+int general_operand_post_inc ( rtx op, enum machine_mode mode );
+int compute_register_save_size ( long *p_reg_saved );
+int compute_frame_size ( int size, long *p_reg_saved );
+static int check_call_being ();
+static int check_mlt_being ();
+void expand_prologue ( FILE *file );
+void expand_epilogue ( FILE *file );
+void notice_update_cc ( rtx exp, rtx insn );
+c33_data_area c33_get_data_area ( tree decl );
+static void c33_set_data_area ( tree decl, c33_data_area data_area );
+void c33_encode_data_area ( tree decl );
+int c33_interrupt_function_p (void);
+void c33_select_section ( tree decl, int reloc );
+int nshift_operator ( rtx x, enum machine_mode mode );
+int expand_a_shift ( enum machine_mode mode, int code, rtx operands[] );
+char *emit_a_shift ( enum rtx_code code, rtx *operands );
+void print_options ( FILE *out );
+void declare_object ( FILE *stream, char *name, 
+                       char *init_string, char *final_string, int size );
+void c33_output_aligned_bss ( FILE * file, tree decl, char * name, int size, int align );
+void c33_output_common ( FILE * file, tree decl, char * name, int size, int align );
+void c33_output_local ( FILE * file, tree decl, char * name, int size, int align );
+void asm_file_start ( FILE *file );
+static void block_move_loop ( rtx dest_reg, rtx src_reg, 
+                                              int bytes, int align, rtx orig_src );
+static void block_move_call ( rtx dest_reg, rtx src_reg, rtx bytes_rtx );
+void expand_block_move ( rtx operands[] );
+char * output_block_move ( rtx insn, rtx operands[], int num_regs );
+int c33_adjust_insn_length ( rtx insn, int length );
+static tree c33_handle_interrupt_attribute ( tree *node, tree name, 
+            tree args ATTRIBUTE_UNUSED, int flags ATTRIBUTE_UNUSED, bool *no_add_attrs );
+static tree c33_handle_section_attribute ( tree *node, tree name, 
+            tree args ATTRIBUTE_UNUSED, int flags ATTRIBUTE_UNUSED, bool *no_add_attrs );
+static tree c33_handle_data_area_attribute ( tree *node, tree name, 
+            tree args ATTRIBUTE_UNUSED, int flags ATTRIBUTE_UNUSED, bool *no_add_attrs );
+static void c33_encode_section_info ( tree decl, int first );
+static void c33_asm_out_constructor ( rtx symbol, int priority ATTRIBUTE_UNUSED );
+static void c33_asm_out_destructor ( rtx symbol, int priority ATTRIBUTE_UNUSED );
+static void c33_unique_section ( tree decl, int reloc );
+int c33_output_addr_const_extra ( FILE * file, rtx x );
+static const char *c33_strip_name_encoding ( const char *str );
+// ADD K.Watanabe V1.8 <<<<<<<
+
+
+/************************/
+/* C33: Global variable */
+/************************/
+/* ADD K.Watanabe V1.7 >>>>>>> */
+const struct attribute_spec c33_attribute_table[];
+
+#undef TARGET_ASM_CONSTRUCTOR
+#define TARGET_ASM_CONSTRUCTOR  c33_asm_out_constructor
+
+#undef TARGET_ASM_DESTRUCTOR
+#define TARGET_ASM_DESTRUCTOR   c33_asm_out_destructor
+
+#undef TARGET_ATTRIBUTE_TABLE
+#define TARGET_ATTRIBUTE_TABLE c33_attribute_table
+
+#undef  TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE expand_prologue
+
+#undef  TARGET_ASM_FUNCTION_EPILOGUE
+#define TARGET_ASM_FUNCTION_EPILOGUE expand_epilogue
+
+#undef  TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION  c33_select_section
+
+#undef TARGET_ASM_SELECT_RTX_SECTION
+#define TARGET_ASM_SELECT_RTX_SECTION const_section
+
+#undef TARGET_ENCODE_SECTION_INFO
+#define TARGET_ENCODE_SECTION_INFO c33_encode_section_info
+
+#undef TARGET_ASM_UNIQUE_SECTION
+#define TARGET_ASM_UNIQUE_SECTION	c33_unique_section
+
+// ADD K.Watanabe V1.8 >>>>>>>
+#undef TARGET_STRIP_NAME_ENCODING
+#define TARGET_STRIP_NAME_ENCODING c33_strip_name_encoding
+// ADD K.Watanabe V1.8 <<<<<<<
+
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+/* Information about the various small memory areas.  */
+/* C33: The default maximum value of the gda size is 16 byte. */
+
+struct small_memory_info small_memory[ (int)SMALL_MEMORY_max ] =
+{
+  /* name	value		max		physical max */
+  { "tda",	(char *)0,	0,		8192 },
+  { "sda",	(char *)0,	0,		8192 },
+  { "zda",	(char *)0,	0,		8192 },
+  /* >>>>> change iruma m.takeishi '03.09.22
+      C33: Change the default from "-mgda=4" to "=0".
+  { "gda",	(char *)0,	4,		8192 },
+  */
+  { "gda",	(char *)0,	0,		8192 },
+};
+
+/* C33: Change the variable for the interrupt function. */
+/* True if we don't need to check any more if the current
+   function is an interrupt handler */
+static int c33_interrupt_cache_p = FALSE;
+
+/* Whether current function is an interrupt handler.  */
+static int c33_interrupt_p = FALSE;
+
+#ifdef LEAF_REGISTERS
+/* C33: The array which maps the normal reigster number to the interrupt leaf function. */
+char leaf_reg_remap[] =
+  { -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, -1, -1, -1, -1, -1, -1, -1
+};
+
+#endif /*  */
+
+/* Files to separate the text and the data output, so that all of the data
+   can be emitted before the text, which will mean that the assembler will
+   generate smaller code, based on the global pointer.  */
+FILE *asm_out_data_file;
+FILE *asm_out_text_file;
+
+/* Strings to hold which cpu and instruction set architecture to use. */
+char *c33_cpu_string;		/* for -mcpu=<xxx> */
+
+/* C33: Set the default GP number. */
+/* >>>>> change iruma m.takeishi '03.10.08 */
+/* 
+int gp_max = 4;
+*/
+int gp_max = 1;
+/* <<<<< change iruma m.takeishi '03.10.08 */
+char *gp_no;			/* for -mdp=<xxx> */
+
+/* C33: specification for gdp */
+int gdp = GDA_REGNUM;		/* C33: the register number for gdp */
+char *gdp_string;		/* for -mgdp=xxx */
+
+struct gdp_select
+{
+    char *name;
+    int	number;
+};
+
+struct gdp_select select_table[] =
+  {
+    /* name	number */
+    { "dp",	GDA_REGNUM },
+    { "zdp",	ZDA_REGNUM },
+    { "tdp",	TDA_REGNUM },
+    { "sdp",	SDA_REGNUM },
+    { "r15",	GDA_REGNUM },
+    { "r14",	ZDA_REGNUM },
+    { "r13",	TDA_REGNUM },
+    { "r12",	SDA_REGNUM },
+    { NULL,	0  }
+  };
+
+/* Sometimes certain combinations of command options do not make
+   sense on a particular target machine.  You can define a macro
+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
+   defined, is executed once just after all the command options have
+   been parsed.
+
+   Don't use this macro to turn on various extra optimizations for
+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
+void
+override_options ()
+{
+  	int i;
+	
+  /* parse -mdp=n switch */
+  if (gp_no != NULL)
+    {
+      if (!isdigit (*gp_no))
+	{
+	  error ("dp=%s is not numeric.", gp_no);
+	}
+
+      else
+	{
+          i = read_integral_parameter (gp_no, gp_no - 5, 4);
+	  if (i > 6)
+	    error ("dp=%s is too large.", gp_no);
+	  else if (i < 1)
+	    error ("dp=%s is too small.", gp_no);
+	  else
+	    gp_max = i;
+	}
+    }
+    
+    /* ADD K.Watanabe V1.7 >>>>>>> */
+    /* C33: "-mdp" in not supported.
+	        So display warning if the value is set except 1. */
+	
+    if( gp_max != 1 ){
+	    warning ( "-mdp=%d -- It does not support formally. Use it as AS IS.",gp_max );
+	}	    
+    /* ADD K.Watanabe V1.7 <<<<<<< */
+        
+  /* parse -mgdp=xxx switch */
+  if (gdp_string != NULL)
+    {
+      struct gdp_select *sel;
+
+      gdp = 0;
+      for (sel = &select_table[0]; sel->name != NULL; sel++) 
+	{
+	  if (streq (gdp_string, sel->name)) {
+	    gdp = sel->number;
+	    break;
+	  }
+	}
+    }
+    
+  if (gdp == 0)
+    {
+      error ("gdp=%s is invalid.", gdp_string);
+      gdp = GDA_REGNUM;
+    }
+
+  if (gdp < 16 - gp_max)
+    {
+      error ("-mdp=%s does not support -mgdp=%s.", gp_no, gdp_string);
+      gdp = GDA_REGNUM;
+    }
+
+    /* ADD K.Watanabe V1.7 >>>>>>> */
+    /* C33: "-mgdp" in not supported.
+	        So display warning if the value is set except 15. ( Its meaing is %r15 ). */
+    if( gdp != 15 ){
+	    warning ( "-mgdp=r%d -- It does not support formally. Use it as AS IS.",gdp );
+	}	    
+    /* ADD K.Watanabe V1.7 <<<<<<< */
+    
+  if (c33_cpu_string == (char *) 0)
+    {
+      if ((TARGET_C33ADV) && (TARGET_C33PE))
+	error ("-mc33adv conflicts with -mc33pe.");
+      else if (TARGET_C33ADV)
+        c33_cpu_string = C33_CPU_STRING_DEFAULT_ADVANCED;
+      else if (TARGET_C33PE)
+        c33_cpu_string = C33_CPU_STRING_DEFAULT_C33PE;
+      else 
+        c33_cpu_string = C33_CPU_STRING_DEFAULT;
+    }
+
+  /* Parse -mgda=nnn switches */
+  for (i = (int)SMALL_MEMORY_GDA; i < (int)SMALL_MEMORY_max; i++)
+    {
+      if (small_memory[i].value)
+	{
+	  if (!isdigit (*small_memory[i].value))
+	    error ("%s=%s is not numeric.",
+		   small_memory[i].name,
+		   small_memory[i].value);
+	  else
+	    {
+	      small_memory[i].max = read_integral_parameter (small_memory[i].value, small_memory[i].value - 6, 4);
+	      if (small_memory[i].max > small_memory[i].physical_max)
+		error ("%s=%s is too large.",
+		   small_memory[i].name,
+		   small_memory[i].value);
+	    }
+	}
+    }
+
+	/* ADD K.Watanabe V1.7 >>>>>>> */
+    /* C33: "-mgda" in not supported.
+	        So display warning if the value is set except 0. */
+	if( small_memory [(int) SMALL_MEMORY_GDA].max != 0 ){
+		warning ( "-mgda=%d -- It does not support formally. Use it as AS IS.",small_memory [(int) SMALL_MEMORY_GDA].max );
+	}
+	/* ADD K.Watanabe V1.7 <<<<<<< */
+
+  /* check -me[zts]da and -mdp=n switch */
+  if (TARGET_EXT_ZDA)
+    {
+      if (gp_max < 2){
+	  	error ("-mdp=%s does not support -mezda.", gp_no);
+	  	target_flags &= ~MASK_EXT_ZDA;
+	  }
+	  
+      /* ADD K.Watanabe V1.7 >>>>>>> */
+      /* C33: "-mezda" in not supported.
+	        So display warning if "-mezda" is set. */
+      warning ( "-mezda -- It does not support formally. Use it as AS IS." );   
+      /* ADD K.Watanabe V1.7 <<<<<<< */
+	}
+
+  if (TARGET_EXT_TDA)
+    {
+      if (gp_max < 3){
+		  error ("-mdp=%s does not support -metda.", gp_no);
+		  target_flags &= ~MASK_EXT_TDA;
+		}
+		
+      /* ADD K.Watanabe V1.7 >>>>>>> */
+      /* C33: "-metda" in not supported.
+	        So display warning if "-metda" is set. */
+      warning ( "-metda -- It does not support formally. Use it as AS IS." );   
+      /* ADD K.Watanabe V1.7 <<<<<<< */
+	
+    }
+  
+  if (TARGET_EXT_SDA)
+    {
+      if (gp_max < 4){
+		  error ("-mdp=%s does not support -mesda.", gp_no);
+		  target_flags &= ~MASK_EXT_SDA;
+		}
+		
+      /* ADD K.Watanabe V1.7 >>>>>>> */
+      /* C33: "-mesda" in not supported.
+	        So display warning if "-mesda" is set. */
+      warning ( "-mesda -- It does not support formally. Use it as AS IS." );   
+      /* ADD K.Watanabe V1.7 <<<<<<< */
+   }
+   
+   	/* ADD K.Watanabe V1.7 >>>>>>> */
+   	if( !TARGET_C33ADV ){
+	   if( flag_pic && TARGET_EXT_32 ){
+	   		error ("-fPIC conflicts with -medda32.");
+	   }
+	}	   
+   	/* ADD K.Watanabe V1.7 <<<<<<< */
+}
+
+/* Return an RTX to represent where a value with mode MODE will be returned
+   from a function.  If the result is 0, the argument is pushed. */
+   
+/* C33: English above is incorrect.
+        This function returns RTX which represents where arguments 
+        with mode MODE will be set.
+        If the result is 0, the argument is pushed.                */
+rtx
+function_arg (cum, mode, type, named)
+     CUMULATIVE_ARGS *cum;
+     enum machine_mode mode;
+     tree type;
+     int named;
+
+{
+  rtx result = 0;
+  int size, align;
+
+/* C33: 1. The argument is pushed if if is variable argument. */
+  if (!named)
+    return NULL_RTX;
+
+/* C33: 2. Decide the size which corresponds to the mode. */
+  if (mode == BLKmode)
+    {
+      return 0;		/* C33: Structure is passed through the stack. */
+    }
+  else
+    size = GET_MODE_SIZE (mode);
+
+/* C33: 3. Decide the accumlation arguments size after adjusting alignment. */
+  if (type)
+    align = TYPE_ALIGN (type) / BITS_PER_UNIT;
+
+  else
+    align = size;
+  cum->nbytes = (cum->nbytes + align - 1) & ~(align - 1);
+
+/* C33: 4. The argument is pushed if the accumlation arguments is beyond 4 bytes. */
+  if (cum->nbytes > 4 * UNITS_PER_WORD)
+    return 0;
+
+  if (type == NULL_TREE && cum->nbytes + size > 4 * UNITS_PER_WORD)
+    return 0;
+
+/* C33: 5. The argument is passed through the stack, if the mode is 'DFmode' and
+           already used argument registers is 3 or more. */
+  if (mode == DFmode)
+    {
+
+      /* C33: Do argument registers be used 3 or more? */
+      if (cum->nbytes >= ((4 - 1) * UNITS_PER_WORD))
+	return (rtx) 0;		/* C33: passed through the stack */
+    }
+
+/* C33: 6. Decide the argumtent register No. according to the accumlation argument size. */
+  switch (cum->nbytes / UNITS_PER_WORD)
+    {
+    case 0:
+      result = gen_rtx (REG, mode, 6);
+      break;
+    case 1:
+      result = gen_rtx (REG, mode, 7);
+      break;
+    case 2:
+      result = gen_rtx (REG, mode, 8);
+      break;
+    case 3:
+      result = gen_rtx (REG, mode, 9);
+      break;
+    default:
+      result = 0;
+    }
+
+/* C33: 7. Return the result. */
+  return result;
+
+/* C33: 8. Terminating process. */
+}
+
+
+/* Return the high and low words of a CONST_DOUBLE */
+static void
+const_double_split (x, p_high, p_low)
+     rtx x;
+     HOST_WIDE_INT *p_high;
+     HOST_WIDE_INT *p_low;
+
+{
+  if (GET_CODE (x) == CONST_DOUBLE)
+    {
+      long t[2];
+      REAL_VALUE_TYPE rv;
+      switch (GET_MODE (x))
+	{
+	case DFmode:
+	  REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+	  REAL_VALUE_TO_TARGET_DOUBLE (rv, t);
+	  *p_high = t[1];	/* since v850 is little endian */
+	  *p_low = t[0];	/* high is second word */
+	  return;
+	case SFmode:
+	  REAL_VALUE_FROM_CONST_DOUBLE (rv, x);
+	  REAL_VALUE_TO_TARGET_SINGLE (rv, *p_high);
+	  *p_low = 0;
+	  return;
+	case VOIDmode:
+	case DImode:
+	  *p_high = CONST_DOUBLE_HIGH (x);
+	  *p_low = CONST_DOUBLE_LOW (x);
+	  return;
+	}
+    }
+  fatal_insn ("const_double_split got a bad insn:", x);
+}
+
+
+/* Return the cost of the rtx R with code CODE.  */
+/* C33: ld.w %rd, sign6 */
+static int
+const_costs_int (value)
+     HOST_WIDE_INT value;
+
+{
+  if (CONST_OK_FOR_SIGNED6 (value))	/* 6 bit signed */
+    return 1;
+
+  else if (CONST_OK_FOR_SIGNED19 (value))	/* 19 bit signed */
+    return 2;
+
+  else
+    return 3;
+}
+
+int
+const_costs (r, c)
+     rtx r;
+     enum rtx_code c;
+
+{
+  HOST_WIDE_INT high, low;
+  switch (c)
+    {
+    case CONST_INT:
+      return const_costs_int (INTVAL (r));
+    case CONST_DOUBLE:
+      return 20;		/* C33: Big value. */
+    case SYMBOL_REF:
+    case LABEL_REF:
+    case CONST:
+    default:
+      return 3;			/* C33: sign32 */
+    }
+}
+
+
+/* Print operand X using operand code CODE to assembly language output file
+   FILE.  */
+/********************************************************************************************
+Format		: void print_operand (file, x, code)
+Input		: FILE *file -- pointer for the output file
+              rtx x
+              int code -- kind of opecode
+Output		: None
+Return		: None
+Explanation	: Add necessary information to opecode.
+*********************************************************************************************/
+void print_operand (file, x, code)
+     FILE *file;
+     rtx x;
+     int code;
+{
+  HOST_WIDE_INT high, low;
+  HOST_WIDE_INT value;
+  
+  switch (code)
+    {
+    case 'b':			 /* C33: branch */
+    case 'B':			 /* C33: branch -- inverse condition */
+	      switch (code == 'B' ? reverse_condition (GET_CODE (x)) : GET_CODE (x))
+		{
+			case NE:
+			  fprintf (file, "ne");
+			  break;
+			case EQ:
+			  fprintf (file, "eq");
+			  break;
+			case GE:
+			  fprintf (file, "ge");
+			  break;
+			case GT:
+			  fprintf (file, "gt");
+			  break;
+			case LE:
+			  fprintf (file, "le");
+			  break;
+			case LT:
+			  fprintf (file, "lt");
+			  break;
+			case GEU:
+			  fprintf (file, "uge");
+			  break;
+			case GTU:
+			  fprintf (file, "ugt");
+			  break;
+			case LEU:
+			  fprintf (file, "ule");
+			  break;
+			case LTU:
+			  fprintf (file, "ult");
+			  break;
+			default:
+			  abort ();
+		}
+      	break;
+      	
+    case 'M':			/* C33: bit operaion (btst, bset) */
+      fprintf (file, "%d", exact_log2 (0xff & INTVAL (x)));
+      break;
+    case 'm':			/* C33: bit operaion (bclr) */
+      fprintf (file, "%d", exact_log2 (0xff & ~(INTVAL (x))));
+      break;
+      
+    case 'W':			/* C33: print the instruction suffix -- sign extention */
+	      /* C33: Is the mode dst or src? */
+	      switch (GET_MODE (x))
+		{
+			default:
+			  abort ();
+			case QImode:
+			  fputs (".b", file);
+			  break;
+			case HImode:
+			  fputs (".h", file);
+			  break;
+			case SImode:
+			  fputs (".w", file);
+			  break;
+			case SFmode:
+			  fputs (".w", file);
+			  break;
+		}
+	      break;
+	      
+    case 'w':			/* C33: print the instruction suffix -- zero extention */
+
+	      /* C33: Is the mode dst or src? */
+	      switch (GET_MODE (x))
+		{
+			default:
+			  abort ();
+			case QImode:
+			  fputs (".ub", file);
+			  break;
+			case HImode:
+			  fputs (".uh", file);
+			  break;
+			case SImode:
+			  fputs (".w", file);
+			  break;
+			case SFmode:
+			  fputs (".w", file);
+			  break;
+		}
+	    break;
+	      
+    case 'p':			/* SYMBOL_REF/LABEL_REF/CONST */
+    					/* C33: The offset process in the case that symbols are reffered. */
+        {
+          char* name;
+
+		  if ((GET_CODE (x) == SYMBOL_REF) || (GET_CODE (x) == LABEL_REF))
+		    name = XSTR (x, 0);
+		  else if (GET_CODE (x) == CONST)
+		    name = XSTR (XEXP (XEXP (x, 0), 0), 0);
+		  else
+		    abort ();
+
+		  if (ZDA_NAME_P (name))
+		    {
+		      if (TARGET_EXT_ZDA)
+		        {
+		          fprintf (file, "ext zoff_hi(");
+		          print_operand_address (file, x);
+		          fprintf (file, ")\n\t");
+		        }
+		      fprintf (file, "ext zoff_lo(");
+		      print_operand_address (file, x);
+		      fprintf (file, ")");
+		    }
+		  else if (TDA_NAME_P (name))
+		    {
+		      if (TARGET_EXT_TDA)
+		        {
+		          fprintf (file, "ext toff_hi(");
+		          print_operand_address (file, x);
+		          fprintf (file, ")\n\t");
+		        }
+		      fprintf (file, "ext toff_lo(");
+		      print_operand_address (file, x);
+		      fprintf (file, ")");
+		    }
+		  else if (SDA_NAME_P (name))
+		    {
+		      if (TARGET_EXT_SDA)
+		        {
+		          fprintf (file, "ext soff_hi(");
+		          print_operand_address (file, x);
+		          fprintf (file, ")\n\t");
+		        }
+		      fprintf (file, "ext soff_lo(");
+		      print_operand_address (file, x);
+		      fprintf (file, ")");
+		    }
+		  else if (GDA_NAME_P (name))
+		    {
+		      fprintf (file, "ext goff_lo(");
+
+		      print_operand_address (file, x);
+		      fprintf (file, ")");
+		    }
+		  else
+		    {
+				if(TARGET_C33ADV){
+			    	fprintf (file, "ext dpoff_h(");
+			        print_operand_address (file, x);
+		    	    fprintf (file, ")\n\text dpoff_m(");
+		    	    
+			       	print_operand_address (file, x);		/* ADD K.Watanabe V1.4 */
+			       	fprintf (file, ")");					/* ADD K.Watanabe V1.4 */
+	           	} else {
+           		/* CHG K.Watanabe V1.7 >>>>>>> */
+           		/************************************************************/
+           		/* C33: In the case that symbol address is reffered.        */
+           		/* ( no -medda32 )											*/
+       			/* ext		doff_hi()										*/
+       			/* ext		doff_lo()										*/
+       			/* add		%rn,%r15										*/
+       			/*															*/
+				/* ( -medda32 )												*/
+				/*  xld.w	%rn,xxxx										*/	
+           		/************************************************************/
+           			if( TARGET_EXT_32 ){
+           				;
+           			} else {
+				       fprintf (file, "ext doff_hi(");
+				       print_operand_address (file, x);
+				       fprintf (file, ")\n\text doff_lo(");
+				       	print_operand_address (file, x);		/* ADD K.Watanabe V1.7 */
+				       	fprintf (file, ")");					/* ADD K.Watanabe V1.7 */
+					}				       
+	           	}
+	            /* CHG K.Watanabe V1.7 <<<<<<< */
+	           	
+		       	// print_operand_address (file, x);		/* DEL K.Watanabe V1.4 */
+		       	// fprintf (file, ")");					/* DEL K.Watanabe V1.4 */
+		    }
+        }
+        break;
+
+    case 'P':		/* C33: The offset process in the case that the memory is accessed. */
+      {
+		rtx xx;
+	        char* name;
+
+		xx = XEXP(x, 0);	/* C33: "x" means "MEM", so "xx" shall be "CONST" or "SYMBOL_REF". */
+		if (GET_CODE (xx) == SYMBOL_REF)
+		  name = XSTR (xx, 0);
+		else if (GET_CODE (xx) == CONST)
+		  name = XSTR (XEXP (XEXP (xx, 0), 0), 0);
+		else
+		  abort ();
+
+		if (ZDA_NAME_P (name))
+		  {
+		    if (TARGET_EXT_ZDA)
+		      {
+		        fprintf (file, "ext zoff_hi(");
+		        print_operand_address (file, xx);
+		        fprintf (file, ")\n\t");
+		      }
+		    fprintf (file, "ext zoff_lo(");
+		    print_operand_address (file, xx);
+		    fprintf (file, ")");
+		  }
+		else if (TDA_NAME_P (name))
+		  {
+		    if (TARGET_EXT_TDA)
+		      {
+		        fprintf (file, "ext toff_hi(");
+		        print_operand_address (file, xx);
+		        fprintf (file, ")\n\t");
+		      }
+		    fprintf (file, "ext toff_lo(");
+		    print_operand_address (file, xx);
+		    fprintf (file, ")");
+		  }
+		else if (SDA_NAME_P (name))
+		  {
+		    if (TARGET_EXT_SDA)
+		      {
+		        fprintf (file, "ext soff_hi(");
+		        print_operand_address (file, xx);
+		        fprintf (file, ")\n\t");
+		      }
+		    fprintf (file, "ext soff_lo(");
+		    print_operand_address (file, xx);
+		    fprintf (file, ")");
+		  }
+		else if (GDA_NAME_P (name))
+		  {
+		    fprintf (file, "ext goff_lo(");
+
+		    print_operand_address (file, xx);
+		    fprintf (file, ")");
+		  }
+		else
+		  {
+			if(TARGET_C33ADV){
+		        fprintf (file, "ext dpoff_h(");
+		        print_operand_address (file, xx);
+		        fprintf (file, ")\n\text dpoff_m(");
+		        
+			    print_operand_address (file, xx);		/* ADD K.Watanabe V1.4 */
+			    fprintf (file, ")");					/* ADD K.Watanabe V1.4 */
+			    
+			/* CHG K.Watanabe V1.7 >>>>>>> */
+			} else {
+           		/************************************************************/
+       			/* ext		doff_hi( symbol )								*/
+       			/* ext		doff_lo( symbol )								*/
+       			/*		↓              									*/
+				/*  xld.w	%rn,symbol										*/
+           		/************************************************************/
+	           	if (TARGET_EXT_32){
+				    ;									/* C33:  It can't come here. */
+	           	} else {
+				    fprintf (file, "ext doff_hi(");
+				    print_operand_address (file, xx);
+				    fprintf (file, ")\n\text doff_lo(");
+				        
+					print_operand_address (file, xx);		
+					fprintf (file, ")");					
+				}				   
+	        }
+			/* CHG K.Watanabe V1.7 <<<<<<< */
+	        
+		    //print_operand_address (file, xx);		/* DEL K.Watanabe V1.4 */
+		    //fprintf (file, ")");					/* DEL K.Watanabe V1.4 */
+		  }
+      }
+      break;
+      
+    case 'q':					/* C33:  Second operand in the case that symbol is refferd. */
+      {
+        char* name;
+
+        if ((GET_CODE (x) == SYMBOL_REF) || (GET_CODE (x) == LABEL_REF))
+          name = XSTR (x, 0);
+        else if (GET_CODE (x) == CONST)
+          name = XSTR (XEXP (XEXP (x, 0), 0), 0);
+        else
+          abort ();
+
+        if (ZDA_NAME_P (name))
+          fprintf (file, "%%r14");
+        else if (TDA_NAME_P (name))
+          fprintf (file, "%%r13");
+        else if (SDA_NAME_P (name))
+          fprintf (file, "%%r12");
+        else if (GDA_NAME_P (name))
+          fprintf (file, "%s", reg_names[gdp]);
+        else
+		  if(TARGET_C33ADV)
+            {
+              fprintf (file, "dpoff_l(");
+              print_operand_address (file, x);
+              fprintf (file, ")");
+            }
+          else
+            {
+           		/* CHG K.Watanabe V1.7 >>>>>>> */
+           		/************************************************************/
+           		/* C33: In the case that symbol address is referred.        */
+           		/* ( no -medda32 )											*/
+       			/* ext		doff_hi()										*/
+       			/* ext		doff_lo()										*/
+       			/* add		%rn,%r15										*/
+       			/*															*/
+				/* ( -medda32 )												*/
+				/*  xld.w	%rn,xxxx										*/	
+           		/************************************************************/
+           		if( TARGET_EXT_32 ){
+			        print_operand_address (file, x);
+			    } else {    
+             		fprintf (file, "%%r15");
+             	}	
+           		/* CHG K.Watanabe V1.7 <<<<<<< */             	
+            }
+      }
+      break;
+    case 'Q':					/* C33: The register which saves the memory access address. */
+    							/* C33: [ %rn ] */
+      {
+        rtx xx;
+        char* name;
+
+        xx = XEXP(x, 0);	    /* C33: "x" means "MEM", so "xx" shall be "CONST" or "SYMBOL_REF". */
+        if (GET_CODE (xx) == CONST)
+          name = XSTR (XEXP (XEXP (xx, 0), 0), 0);
+        else if (GET_CODE (xx) == SYMBOL_REF)
+          name = XSTR (xx, 0);
+        else
+          abort ();
+
+        if (ZDA_NAME_P (name))
+          fprintf (file, "%%r14");
+        else if (TDA_NAME_P (name))
+          fprintf (file, "%%r13");
+        else if (SDA_NAME_P (name))
+          fprintf (file, "%%r12");
+        else if (GDA_NAME_P (name))
+          fprintf (file, "%s", reg_names[gdp]);
+        else
+		  if(TARGET_C33ADV)
+            {
+              fprintf (file, "%%dp+dpoff_l(");
+              print_operand_address (file, xx);
+              fprintf (file, ")");
+            }
+          else 
+            {
+           		/* CHG K.Watanabe V1.7 >>>>>>> */
+           		/************************************************************/
+       			/* ext		doff_hi( symbol )								*/
+       			/* ext		doff_lo( symbol )								*/
+       			/*		↓              									*/	
+				/*  xld.w	%rn,symbol										*/
+           		/************************************************************/
+            	if( TARGET_EXT_32 ){
+            		;							/* C33: It can't come here. */
+            	} else {
+           		/* CHG K.Watanabe V1.7 <<<<<<< */         	
+            		fprintf (file, "%%r15");
+            	}	
+            }
+      }
+      break;
+    case 'R':			/* 2nd word of a double.  */
+      switch (GET_CODE (x))
+	{
+	case REG:
+	  fputs (reg_names[REGNO (x) + 1], file);
+	  break;
+	case MEM:
+/* CHG K.Watanabe V1.7 >>>>>>> */	
+/*	
+	  print_operand_address (file,
+				 XEXP (adj_offsettable_operand (x, 4), 0));
+*/
+	  print_operand_address (file,
+				 XEXP (adjust_address (x, SImode, 4), 0));
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+	  break;
+	default:
+	  break;
+	}
+      break;
+    case 'F':			/* high word of CONST_DOUBLE */
+      if (GET_CODE (x) == CONST_INT)
+	fprintf (file, "%d", (INTVAL (x) >= 0) ? 0 : -1);
+
+      else if (GET_CODE (x) == CONST_DOUBLE)
+
+	{
+	  const_double_split (x, &high, &low);
+	  fprintf (file, "0x%lx", (long) high);
+	}
+
+      else
+	abort ();
+      break;
+    case 'f':			/* C33: hex notation float for debug */
+      {
+	REAL_VALUE_TYPE type;	
+	char s[30];	
+	/* CHG K.Watanabe V1.7 >>>>>>> */
+	#if 0
+	REAL_VALUE_FROM_CONST_DOUBLE (type, x);
+	REAL_VALUE_TO_DECIMAL (type, "%.20e", s); 
+	#endif
+	
+	real_to_decimal (s, CONST_DOUBLE_REAL_VALUE (x), sizeof (s), 0, 1);
+	/* CHG K.Watanabe V1.7 <<<<<<< */	
+	fprintf (file, s);
+      }
+      break;
+    case 'v':			/* C33: hex notation for debug */
+      fprintf (file, "0x%x", INTVAL (x));
+      break;
+    case '#':
+
+      /* C33: ".d" is not output, if there is not the delay slot instruction. */
+      if (dbr_sequence_length () != 0)
+	fputs (".d", file);
+      break;
+    default:
+      switch (GET_CODE (x))
+	{
+	case MEM:
+	  if (GET_CODE (XEXP (x, 0)) == CONST_INT)
+	    output_address (gen_rtx
+			    (PLUS, SImode, gen_rtx (REG, SImode, 0),
+			     XEXP (x, 0)));
+
+	  else
+	    output_address (XEXP (x, 0));
+	  break;
+	case REG:
+	  /* %rd / %rs */
+	  /* C33: It comes here in the case that the insturction is both load and save. */
+	  fputs (reg_names[REGNO (x)], file);
+	  break;
+
+	case CONST_INT:
+	case SYMBOL_REF:
+	case CONST:
+	case LABEL_REF:
+	case CODE_LABEL:
+	  print_operand_address (file, x);
+	  break;
+	default:
+	  abort ();
+	}
+      break;
+    }
+}
+
+/* Output assembly language output for the address ADDR to FILE.  */
+void
+print_operand_address (file, addr)
+     FILE *file;
+     rtx addr;
+
+{
+  switch (GET_CODE (addr))
+    {
+    case REG:
+      print_operand (file, addr, 0);
+      break;
+    case POST_INC:
+      print_operand (file, XEXP (addr, 0), 0);
+      break;
+    case PLUS:
+      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)
+	{
+	  print_operand (file, XEXP (addr, 1), 0);
+	  if (INTVAL (XEXP (addr, 0)) >= 0)
+	    fprintf (file, "+");
+	  print_operand (file, XEXP (addr, 0), 0);
+	}
+
+      else
+	{
+	  print_operand (file, XEXP (addr, 0), 0);
+	  if (INTVAL (XEXP (addr, 1)) >= 0)
+	    fprintf (file, "+");
+	  print_operand (file, XEXP (addr, 1), 0);
+	}
+      break;
+    default:
+      output_addr_const (file, addr);
+      break;
+    }
+}
+
+
+/* Output all insn addresses and their sizes into the assembly language
+   output file.  This is helpful for debugging whether the length attributes
+   in the md file are correct.  This is not meant to be a user selectable
+   option.  */
+
+void
+final_prescan_insn (insn, operand, num_operands)
+     rtx insn, *operand;
+     int num_operands;
+{
+  /* This holds the last insn address.  */
+  static int last_insn_address = 0;
+
+  int uid = INSN_UID (insn);
+
+  if (TARGET_ADDRESSES)
+    {
+    /* CHG K.Watanabe V1.7 >>>>>>> */
+/*
+      fprintf (asm_out_file, "; 0x%x %d\n", insn_addresses[uid],
+               insn_addresses[uid] - last_insn_address);
+      last_insn_address = insn_addresses[uid];
+*/
+      fprintf (asm_out_file, "; 0x%x %d\n", INSN_ADDRESSES(uid),
+               INSN_ADDRESSES(uid) - last_insn_address);
+      last_insn_address = INSN_ADDRESSES(uid);
+      /* CHG K.Watanabe V1.7 <<<<<<< */
+    }
+}
+
+/* Return appropriate code to load up a 1, 2, or 4 integer/floating
+   point value.  */
+   
+/*****************************************************************************************************
+Format		: char * output_move_single (operands, unsignedp)
+Input		: rtx *operands -- pointer for operand
+              int unsignedp -- true in the case of zero extention
+Output		: None
+Return		: assember string output
+Explanation	: ・Output "ld.x" instruction.
+              ・There is not the instruction of memory saving and memory loading in one instruction
+                in the case of "-medda32" && "!adv" && "default data area".
+*****************************************************************************************************/   
+char * output_move_single (operands, unsignedp)
+     rtx *operands;
+     int unsignedp;		/* C33: true in the case of zero extention */
+
+{
+  	rtx dst = operands[0];
+	rtx src = operands[1];
+	rtx xx;	
+	char* name;
+	
+  	if (REG_P (dst)){
+      	if (REG_P (src)) {						/* C33: register to register */
+	  		if (unsignedp == TRUE){
+		    	return "ld%w1\t%0,%1";			/* C33: zero extention */
+	    	} else {
+	      		return "ld%W1\t%0,%1";			/* C33: sign extention */
+	    	}
+		} else if (GET_CODE (src) == CONST_INT) {	/* C33: immediate to register */
+		  	return "xld.w\t%0,%1\t;%v1";
+		} else if (GET_CODE (src) == CONST_DOUBLE && GET_MODE (src) == SFmode) {
+		  	return "xld.w\t%0,%F1\t;%f1";		/* C33: immediate to register */
+		} else if (GET_CODE (src) == MEM) {		/* C33: memory to register */
+		  	if (GET_CODE (XEXP (src, 0)) == POST_INC){
+		      	if (unsignedp == TRUE){
+			  		return "ld%w1\t%0,[%1]+";	/* C33: zero extention */
+				} else {
+			  		return "ld%W1\t%0,[%1]+";	/* C33: sign extention */
+				}
+	    	} else if (GET_CODE (XEXP (src, 0)) == REG){
+	      		if (unsignedp == TRUE){
+		  			return "ld%w1\t%0,[%1]";	/* C33: zero extention */
+				} else {
+		  			return "ld%W1\t%0,[%1]";	/* C33: sign extention */
+				}
+	    	} else if (GET_CODE (XEXP (src, 0)) == PLUS){
+	      		if (unsignedp == TRUE) {
+		  			return "xld%w1\t%0,[%1]";	/* C33: zero extention */
+				} else {
+		  			return "xld%W1\t%0,[%1]";	/* C33: sign extention */
+				}
+	    	} else {
+	      		if (unsignedp == TRUE) {
+		  			return "%P1\n\tld%w1\t%0,[%Q1]";	/* C33: zero extention */
+				} else {
+		  			return "%P1\n\tld%W1\t%0,[%Q1]";	/* C33: sign extention */
+				}
+			}	
+		} else if (GET_CODE (src) == LABEL_REF			/* C33: symbol to register */
+	       	|| GET_CODE (src) == SYMBOL_REF || GET_CODE (src) == CONST) {
+
+	  		/* C33: 2 instructions at addition in the case that indirect of "GP" can be used. */
+			if (TARGET_C33ADV){
+        		/* char *name; */
+
+            	if ((GET_CODE (src) == SYMBOL_REF) || (GET_CODE (src) == LABEL_REF))
+            		name = XSTR (src, 0);
+            	else 
+                	name = XSTR (XEXP (XEXP (src, 0), 0), 0);
+
+            	if (ENCODED_NAME_P (name))
+            		return "%p1\n\tadd\t%0,%q1";						/* C33: s/t/z/g data area */
+            	else 
+            		return "ld.w\t%0,%%dp\n\t%p1\n\tadd\t%0,%q1";		/* C33: default data area */
+       		} 
+       		/* CHG K.Watanabe V1.7 >>>>>>> */
+       		else 
+       		{					
+       			if ((GET_CODE (src) == SYMBOL_REF) || (GET_CODE (src) == LABEL_REF)){
+            		name = XSTR (src, 0);
+            	} else {
+                	name = XSTR (XEXP (XEXP (src, 0), 0), 0);
+				}
+				
+           		/************************************************************/
+           		/* C33: In the case of symbol address is referred.			*/
+           		/* ( no -medda32 )											*/
+       			/* ext		doff_hi()										*/
+       			/* ext		doff_lo()										*/
+       			/* add		%rn,%r15										*/
+       			/*															*/
+				/* ( -medda32 )												*/
+				/*  xld.w	%rn,xxxx										*/	
+           		/************************************************************/
+           		
+	    		/* return "%p1\n\tadd\t%0,%q1";	*/
+	    		if ( ( ENCODED_NAME_P (name) )){						/* C33: s/t/z/g data area */
+		        	return "%p1\n\tadd\t%0,%q1";						
+		        } else {												/* C33: default data area */
+			        if ( TARGET_EXT_32 ){
+			        	return "%p1xld.w\t%0,%q1";			        	/* C33: "-medda32" option */
+			        }else{
+			        	return "%p1\n\tadd\t%0,%q1";					/* C33: Not "-medda32" option */
+			        }
+				}			        
+	    	}									
+	    	/* CHG K.Watanabe V1.7 <<<<<<< */	
+		}
+    } else if (GET_CODE (dst) == MEM) {									/* C33: register to memory */
+      	if (REG_P (src)) {
+	  		if (GET_CODE (XEXP (dst, 0)) == POST_INC){
+		  		return "ld%W1\t[%0]+,%1";			/* C33: sign extention */
+	    	} else if (GET_CODE (XEXP (dst, 0)) == REG) {
+		  		return "ld%W1\t[%0],%1";			/* C33: sign extention */
+	    	} else if (GET_CODE (XEXP (dst, 0)) == PLUS){
+		  		return "xld%W1\t[%0],%1";			/* C33: sign extention */
+	    	} else {
+		  		return "%P0\n\tld%W1\t[%Q0],%1";	/* C33: sign extention */
+	    	}
+		}
+    }
+  	fatal_insn ("output_move_single:", gen_rtx (SET, VOIDmode, dst, src));
+  	return "";
+}
+
+/* Return appropriate code to load up an 8 byte integer or
+   floating point value */
+char *
+output_move_double (operands)
+     rtx *operands;
+
+{
+  enum machine_mode mode = GET_MODE (operands[0]);
+  rtx dst = operands[0];
+  rtx src = operands[1];
+
+  /* C33: register to register */
+  if (register_operand (dst, mode) && register_operand (src, mode))
+
+    {
+      if (REGNO (src) + 1 == REGNO (dst))
+	return "ld.w\t%R0,%R1\n\tld.w\t%0,%1";
+
+      else
+	return "ld.w\t%0,%1\n\tld.w\t%R0,%R1";
+    }
+
+  /* C33: immediate to register */
+  if (GET_CODE (src) == CONST_INT)	/* C33: Double type or long long type in the case that 
+                                            only sign is set in high order register. */
+    {
+      HOST_WIDE_INT high_low[2];
+      int i;
+      rtx xop[10];
+      high_low[0] = INTVAL (src);
+      high_low[1] = (INTVAL (src) >= 0) ? 0 : -1;
+      for (i = 0; i < 2; i++)
+
+	{
+	  xop[0] = gen_rtx (REG, SImode, REGNO (dst) + i);
+	  xop[1] = GEN_INT (high_low[i]);
+	  
+	  // CHG K.Watanabe V1.8 >>>>>>>
+	  #if 0
+	  output_asm_insn (output_move_single (xop), xop);
+	  #endif
+	  
+	  output_asm_insn (output_move_single (xop,1), xop);
+	  // CHG K.Watanabe V1.8 <<<<<<<
+	}
+      return "";
+    }
+
+  else if (GET_CODE (src) == CONST_DOUBLE)
+
+    {
+      split_double (src, operands + 2, operands + 3);
+      if (GET_MODE (src) == DFmode)
+
+	{
+	  return "xld.w\t%0,%v2\t;double %f1\n\txld.w\t%R0,%v3";
+	}
+
+      else
+
+	{
+	  return "xld.w\t%0,%2\t;long long\n\txld.w\t%R0,%3";
+	}
+    }
+
+  /* C33: memory to register */
+  if (GET_CODE (src) == MEM)
+
+    {
+      int ptrreg = -1;
+      int dreg = REGNO (dst);
+      rtx inside = XEXP (src, 0);
+      if (GET_CODE (inside) == REG)
+	ptrreg = REGNO (inside);
+
+      else if (GET_CODE (inside) == SUBREG)
+      /* CHG K.Watanabe V1.7 >>>>>>> */
+      /*
+	    ptrreg = REGNO (SUBREG_REG (inside)) + SUBREG_WORD (inside);
+	  */  
+	    ptrreg = subreg_regno (inside);
+      /* CHG K.Watanabe V1.7 <<<<<<< */
+      else if (GET_CODE (inside) == PLUS)
+	ptrreg = REGNO (XEXP (inside, 0));
+      if (dreg == ptrreg)
+	return "xld.w\t%R0,[%R1]\t;output_move_double\n\txld.w\t%0,[%1]";
+
+      else
+	return "xld.w\t%0,[%1]\t;output_move_double\n\txld.w\t%R0,[%R1]";
+    }
+
+  /* C33: register to memory */
+  if (GET_CODE (dst) == MEM)
+    return "xld.w\t[%0],%1\t;output_move_double\n\txld.w\t[%R0],%R1";
+  fatal_insn ("output_move_double:", gen_rtx (SET, VOIDmode, dst, src));
+  return "";
+}
+
+char *
+output_btst (operands)
+     rtx *operands;
+
+{
+  rtx dst = operands[0];
+  rtx src = operands[1];
+
+  if (GET_CODE (src) == MEM)
+    {
+      if (GET_CODE (XEXP (src, 0)) == REG)
+	{
+	  return "btst\t[%1],%M4";
+	}
+      else if (GET_CODE (XEXP (src, 0)) == PLUS)
+	{
+	  return "xbtst\t[%1],%M4";
+	}
+      else
+	{
+	  return "%P1\n\tbtst\t[%Q1],%M4";
+	}
+    }
+  fatal_insn ("output_btst:", gen_rtx (SET, VOIDmode, dst, src));
+  return "";
+}
+
+
+char *
+output_bclr (operands)
+     rtx *operands;
+
+{
+  rtx dst = operands[0];
+  rtx src = operands[1];
+
+  if (GET_CODE (src) == MEM)
+    {
+      if (GET_CODE (XEXP (src, 0)) == REG)
+	{
+	  return "bclr\t[%1],%m4";
+	}
+      else if (GET_CODE (XEXP (src, 0)) == PLUS)
+	{
+	  return "xbclr\t[%1],%m4";
+	}
+      else
+	{
+	  return "%P1\n\tbclr\t[%Q1],%m4";
+	}
+    }
+  fatal_insn ("output_bclr:", gen_rtx (SET, VOIDmode, dst, src));
+  return "";
+}
+
+
+char *
+output_bset (operands)
+     rtx *operands;
+
+{
+  rtx dst = operands[0];
+  rtx src = operands[1];
+
+  if (GET_CODE (src) == MEM)
+    {
+      if (GET_CODE (XEXP (src, 0)) == REG)
+	{
+	  return "bset\t[%1],%M4";
+	}
+      else if (GET_CODE (XEXP (src, 0)) == PLUS)
+	{
+	  return "xbset\t[%1],%M4";
+	}
+      else
+	{
+	  return "%P1\n\tbset\t[%Q1],%M4";
+	}
+    }
+  fatal_insn ("output_bset:", gen_rtx (SET, VOIDmode, dst, src));
+  return "";
+}
+
+/* Return true if OP is a valid call operand.  */
+int
+call_address_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+
+{
+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == REG);
+}
+
+/* C33: for bit operation */
+int
+power_of_two_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+
+{
+  if (GET_CODE (op) != CONST_INT)
+    return 0;
+  if (exact_log2 (INTVAL (op)) == -1)
+    return 0;
+  return 1;
+}
+
+int
+not_power_of_two_operand (op, mode)
+     rtx op;
+     enum machine_mode mode;
+
+{
+  unsigned int mask;
+  if (mode == QImode)
+    mask = 0xff;
+
+  else if (mode == HImode)
+    mask = 0xffff;
+
+  else if (mode == SImode)
+    mask = 0xffffffff;
+
+  else
+    return 0;
+  if (GET_CODE (op) != CONST_INT)
+    return 0;
+  if (exact_log2 (~INTVAL (op) & mask) == -1)
+    return 0;
+  return 1;
+}
+
+
+/* Return true is OP is a valid operand for an integer move instruction. */
+int
+general_operand_post_inc (op, mode)
+     rtx op;
+     enum machine_mode mode;
+
+{
+  if (GET_CODE (op) == MEM && GET_CODE (XEXP (op, 0)) == POST_INC)
+    return 1;
+  return general_operand (op, mode);
+}
+
+
+int
+compute_register_save_size (p_reg_saved)
+     long *p_reg_saved;		/* C33: The information that which register is saved. */
+
+{
+  int size;
+  int i;
+
+  int interrupt_handler = c33_interrupt_function_p ();
+
+  long reg_saved = 0;
+  
+  /* >>>>> add iruma m.takeishi '03.10.03 */
+  long size_add = 0;
+  /* <<<<< add iruma m.takeishi '03.10.03 */
+
+
+
+/* C33: 1. Allocate the area for PC. */
+  size = 4;
+
+/* C33: How "ahr,alr" shall be done at the time of interrupt? */
+
+/* C33: 2. Count the registers which shall be saved. */
+  /* Count space for the register saves.  */
+  if (interrupt_handler)
+    {				/* C33: in the case of interrupt */
+      /* C33: for general purpose registers ( except %r15 ) */
+      for (i = 0; i < 15; i++)
+	{
+	  if (regs_ever_live[i] != 0)
+	    {
+	      /* >>>>> change iruma m.takeishi '03.10.06 */
+	      /* C33: The calculation method of bytes of registers shall be correspond to "expand_prologue".
+	              It is calculated from the maximum register No.                                         */
+	      /*
+	      size += 4;
+	      */
+	      size_add = (i +1)* 4;
+	      /* >>>>> change iruma m.takeishi '03.10.06 */
+	      reg_saved |= 1L << i;
+	    }
+
+	  else
+	    {
+
+	      /* EMPTY */
+	    }
+	}
+
+      /* >>>>> add iruma m.takeishi '03.10.03 */
+      size += size_add;
+      /* <<<<< add iruma m.takeishi '03.10.03 */
+    }
+
+  else
+    {				/* C33: normal function call */
+
+      /* C33: for general purpose registers ( except %r15 ) */
+      for (i = 0; i < 15; i++)
+	{
+	  /* C33: IF   Is this saved register under use? */
+	  if (regs_ever_live[i] && (!call_used_regs[i]))
+	    {
+
+	      /* YES */
+	      /* C33: Allocation of the area and registration of the register No. */
+	      /* >>>>> change iruma m.takeishi '03.10.03 */
+          /* C33: The calculation method of bytes of registers shall be correspond to "expand_prologue".
+	              It is calculated from the maximum register No.                                         */
+	      /*
+	      size += 4;
+	      */
+	      size_add = (i +1)* 4;
+	      /* <<<<< change iruma m.takeishi '03.10.03 */
+	      reg_saved |= 1L << i;
+	    }
+
+	  else
+	    {
+
+	      /* NO */
+
+	      /* EMPTY */
+	    }
+	}
+      
+      /* >>>>> add iruma m.takeishi '03.10.03 */
+      size += size_add;
+      /* <<<<< add iruma m.takeishi '03.10.03 */
+    }
+
+/* C33: 3. Return the saved register No. */
+  if (p_reg_saved)
+    *p_reg_saved = reg_saved;
+
+/* C33: 4. Return the saved area size. ( Containing PC size ) */
+  return size;
+
+/* C33: 5. Terminating process. */
+}
+
+
+int
+compute_frame_size (size, p_reg_saved)
+     int size;
+     long *p_reg_saved;
+
+{
+//  extern int current_function_outgoing_args_size;		/* DEL K.Watanabe V1.7 */
+  return (size + compute_register_save_size (p_reg_saved)
+	  + current_function_outgoing_args_size);}
+
+
+static int
+check_call_being ()
+{
+  /* C33: Changed because of containing "call.d" */
+  /* Return nonzero if this function has no function calls.  */
+  return !leaf_function_p ();
+}
+
+
+/* C33: 2000.07.19  New create.
+        The following function returns the number of "MLT" instructions in the function. */
+static int
+check_mlt_being ()
+{
+  int num = 0;
+  rtx insn;
+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))
+    {
+      /* C33: Reference from try_combine() in combine.c ( 1558th line ) */
+      if (GET_CODE (insn) == INSN
+	  && GET_CODE (PATTERN (insn)) == SET
+	  && GET_CODE (SET_SRC (PATTERN (insn))) == MULT)
+	{
+	  num++;
+	}
+    }
+  return num;
+}
+
+
+/* C33: 2000.07.19.         -- All corrected.  expand_prologue() & expand_epilogue()
+        2000.10.26 watanabe -- The regsieter assignment in the interrutp leaf function is changed from %r0.
+                               Stack frame supports 32bit value.
+                               Support the inturrupt function.
+        2001.11.14 watanabe -- "gp" number is variable from 1 to 6.
+                               
+    if( Theire is function call. ){
+
+	【 interrupt function ( There is function call. ) 】
+	pushn/popn %r9
+	alr ⇔ %r0
+	ahr ⇔ %r1		pushn/popn %r1 付加
+	SP scratch：%r0
+    }else{
+
+	【 interrupt function ( There is not function call. ) 】
+	if( reg_saved == 0 ){
+
+	    the process of (a): Not using registers. "run_alr_ahr == 0" in implicity.
+
+	}else{
+
+	    if( run_alr_ahr == 1 ){
+
+		the process of (b): 
+		if( There is the unused registers. ){
+
+		    the process of (b-1):
+			pushn/popn %r(i+2)
+			alr ⇔ %r(i+1)
+			ahr ⇔ %r(i+2)
+			SP scratch：%r0
+		}else{
+
+		    the process of (b-2):
+			pushn/popn %ri
+			alr ⇔ %r0
+			ahr ⇔ %r1		ADD pushn/popn %r1 
+			SP scratch：%r0
+
+		}
+
+	    }else{
+
+		the process of (c):
+		    pushn/popn %ri
+		    SP scratch：%r0
+
+	    }
+	}
+    }
+*/
+
+/****************************************************************************************************************************
+Format		: void expand_prologue ( FILE *file)
+Input		: pointer for the output file
+Output		: None
+Return		: None
+Explanation	: ・Do prologue process at the time of calling function.
+			  ・"expand_prlogue()" and "expand_epilogue()" must be a pair.
+			  ・The structure of the stack frame.
+			  						argument														|
+			  						return address													|
+			  																						|
+			  						☆Jump															|
+			  																						|
+			  						register protection 											|
+			  						( in the case of the normal function  --  %r0 - %r3				|
+			  						  in the case of the interrupt function -- all used registers )	|
+			  						local variable													↓	SP
+****************************************************************************************************************************/
+void expand_prologue (file)
+     FILE *file;
+
+{
+  char *fnname;
+  unsigned int i;
+  unsigned int size;		/* C33: for local variable ( for frame ) */
+  long reg_saved = 0;
+
+  int interrupt_handler = c33_interrupt_function_p ();
+
+/* C33: Note: This is considered to support for varialbe arguments. */
+
+/* C33: 1. Decide the size of local variables and arguments. */
+  size = get_frame_size () + current_function_outgoing_args_size;
+
+/* C33: 2. Decide the saved register No. */
+  compute_register_save_size (&reg_saved);
+
+/* C33: 4. Decide the maximun register No. which is saved. */
+
+  /* C33: Is there the saved register? */
+  if (reg_saved != 0)
+    {
+      /* C33: Yes, there is the saved register.
+              Decide the maximun register No. which is saved.
+              Check to all general purpose registers.           */
+      for (i = 31; i >= 0; i--)
+	{
+	  /* C33: Is the register saved? */
+	  if (((1L << i) & reg_saved) != 0)
+	    {
+	      /* C33: Yes, we have finded the maximum register No. */
+	      break;
+	    }
+	}
+    }
+
+/* C33: 5. Move "%sp". */
+  /* C33: Is the function interrupt? */
+  if (interrupt_handler)
+    {
+      /* C33: Yes, it is interrupt function */
+
+      /* C33: Is there function call? */
+      if (check_call_being ())
+	{
+	  /* C33: Yes, there is function call.
+	          Output "push" instruction.
+	          Save all except "gp".           */
+	  fprintf (file, "\tpushn\t%%r%d\n", 15 - gp_max);/* pushn   %rX     */
+
+	  /* C33: Save "alr, ahr" to the stack. */
+	  fprintf (file, "\tld.w\t%%r0,%%alr\n");	/* ld.w    %r0, %alr */
+	  fprintf (file, "\tld.w\t%%r1,%%ahr\n");	/* ld.w    %r1, %ahr */
+	  fprintf (file, "\tpushn\t%%r1\n");		/* pushn   %r1       */
+	}
+      else
+	{
+	  /* C33: No, there is not function call. */
+	  /* C33: Registers are used in the order of %r0,%r1,%r2,%r3,%r4,%r5,%r6,%r7,%r8,%r9
+	          in the case that there is not function call in the interrupt function.      */
+
+	  /* C33: Are registers used? */
+	  if (reg_saved == 0)
+	    {
+          /* C33: Registers are not used. */
+          /* C33: "push" instruction is unused. */
+
+	      /* C33: Is the movement of %sp which uses scrath registers necessary? */
+	      if (size > 0xffc)
+		{
+		  /* C33: Yes, it is necessary. */
+		  fprintf (file, "\tpushn\t%%r0\n");	/* pushn   %r0       */
+		}
+	    }
+	  else
+	    {
+	      /* C33: Registers are used. */
+	      /* C33: Is "ahr / alr" saved? */
+	      if (check_mlt_being ())
+		{
+		  /* C33: Yes, "ahr / alr" is saved. */
+		  
+		  /* C33: Is there general purpose register for saving "ahr,alr"? */
+		  if (i < 14 - gp_max)
+		    {
+			  /* C33: Yes, there is. */
+		      /* C33: Output "pushn" instruction. */
+		      fprintf (file, "\tpushn\t%%r%d\n", i + 2);	/* pushn    %r(i+2)         */
+		      fprintf (file, "\tld.w\t%%r%d,%%alr\n", i + 1);	/* ld.w     %r(i+1), %alr   */
+		      fprintf (file, "\tld.w\t%%r%d,%%ahr\n", i + 2);	/* ld.w     %r(i+2), %ahr   */
+		    }
+		  else
+		    {
+			  /* C33: No, there is not. ( So, save to the stack. )  */
+		      /* C33: Output "pushn" instruction. */
+		      fprintf (file, "\tpushn\t%%r%d\n", i);		/* pushn    %r?             */
+		      fprintf (file, "\tld.w\t%%r0,%%alr\n");		/* ld.w     %r0, %alr       */
+		      fprintf (file, "\tld.w\t%%r1,%%ahr\n");		/* ld.w     %r1, %ahr       */
+		      fprintf (file, "\tpushn\t%%r1\n");		/* pushn    %r1             */
+		    }
+		}
+	      else
+		{
+		  /* C33: No, "ahr / alr" is not saved. */
+		  /* C33: Output "pushn" instruction. */
+		  fprintf (file, "\tpushn\t%%r%d\n", i);		/* pushn    %r? */
+		}
+	    }			/* C33: endif( reg_saved == 0) */
+	}				/* C33: endif( function call ) */
+
+      /* C33: Is the movement of %sp necessary? */
+      if (size > 0xffc)
+	{
+	  /* C33: Yes, it is necessary. */
+	  fprintf (file, "\tld.w\t%%r0,%%sp\t;sub %%sp,%d\n", size);	/* ld.w     %r0, %sp        */
+	  fprintf (file, "\txsub\t%%r0,%d\t;\n", size);			/* xsub     %r0, imm32      */
+	  fprintf (file, "\tld.w\t%%sp,%%r0\t;\n");			/* ld.w     %sp, %r0        */
+	}
+      else if (size != 0)
+	{
+	  /* C33: Yes, it is necessary. */
+	  fprintf (file, "\tsub\t%%sp,%d\t;%d\n", (size >> 2), size);	/* sub      %sp, imm12      */
+	}
+      else
+	{
+  	  /* C33: No, it is not necessary. */
+	  /* EMPTY */
+	}
+    }
+  else
+    {
+      /* C33: No, the function is normal. */
+
+      /* C33: Is there the saved registers? */
+      if (reg_saved != 0)
+	{
+	  /* C33: Yes, there is. */
+
+	  /* C33: Output "pushn" instrcution. */
+	  fprintf (file, "\tpushn\t%%r%d\n", i);			/* pushn    %r?             */
+	}
+      else
+	{
+	  /* C33: No, there is not. */
+	  /* EMPTY */
+	}
+      /* C33: Use %r4 for the scratch register which is used for stack movement.
+              At this point, it is no problem that the register for storing returned values is destroyed. */
+      
+      /* C33: Is the movement of %sp necessary? */
+      if (size > 0xffc)
+	{
+	  /* C33: Yes, it is necessary by using the scrath registers. */
+	  fprintf (file, "\tld.w\t%%r4,%%sp\t;sub %%sp,%d\n", size);	/* ld.w     %r4, %sp   */
+	  fprintf (file, "\txsub\t%%r4,%d\t;\n", size);					/* xsub     %r4, imm32 */
+	  fprintf (file, "\tld.w\t%%sp,%%r4\t;\n");						/* ld.w     %sp, %r4   */
+	}
+      else if (size != 0)
+	{
+	  /* C33: Yes, it is necessary. */
+	  fprintf (file, "\tsub\t%%sp,%d\t;%d\n", (size >> 2), size);	/* sub      %sp, imm12 */
+	}
+      else
+	{
+	  /* C33: No, it is not necessary. */
+	  /* EMPTY */
+	}
+    }
+
+	/* ADD K.Watanabe V1.7 >>>>>>> */
+  	/* Set up frame pointer if it is necessary.  */
+  	if (frame_pointer_needed){
+	    fprintf ( file, "\tld.w	%%r0,%%sp\n" );
+	}    	
+	/* ADD K.Watanabe V1.7 <<<<<<< */
+	    
+/* 6. Return. */
+  return;
+
+/* C33: Terminating process. */
+}
+
+
+/*************************************************************************************************************
+Format		: void expand_epilogue (file)
+Input		: pointer for the output file
+Output		: None
+Return		: None
+Explanation	: ・Do epilogue process at the time of calling function.
+			  ・"expand_prlogue()" and "expand_epilogue()" must be a pair.
+*************************************************************************************************************/
+void expand_epilogue (file)
+     FILE *file;
+
+{
+  unsigned int i;
+  unsigned int size;		/* C33: for local variable ( for frame ) */
+  long reg_saved = 0;
+
+  int interrupt_handler = c33_interrupt_function_p ();
+
+/* C33: Note: This is considered to support for varialbe arguments. */
+
+/* C33: 1. Decide the size of local variables and arguments. */
+  size = get_frame_size () + current_function_outgoing_args_size;
+
+/* C33: 2. Decide the resotred register No. */
+  compute_register_save_size (&reg_saved);
+
+/* C33: 3. Decide the maximun register No. which is restored. */
+     
+  /* C33: If the resut is "i==0", there is not the restored register 
+          in the case of interrupt function.
+          In the case of normal function, there is not the restored register or it means %r0. */
+             
+  /* C33: Is there the saved register? */
+  if (reg_saved != 0)
+    {
+      /* C33: Yes, there is. */
+
+      /* C33: Check to all general purpose registers. */
+      for (i = 31; i >= 0; i--)
+	{
+  	  /* C33: Is the register restored? */
+	  if (((1L << i) & reg_saved) != 0)
+	    {
+	      /* C33: Yes, We have finded the maximum register No. */
+	      break;
+	    }
+	}
+    }
+
+/* C33: 4. Move "%sp". */
+/* C33: 5. Registers are saved. */
+/* C33: 6. Output return instruction. */
+
+  /* C33: Is the function interrupt? */
+  if (interrupt_handler)
+    {
+      /* C33: Yes, the interrupt function */
+
+      /* C33: Is the movement of %sp necessary? */
+      if (size > 0xffc)
+	{
+	  /* C33: Yes, it is necessary by using the scrath registers. */
+	  fprintf (file, "\tld.w\t%%r0,%%sp\t;add %%sp,%d\n", size);	/* ld.w     %r0, %sp        */
+	  fprintf (file, "\txadd\t%%r0,%d\t;\n", size);			/* xadd     %r0, imm32      */
+	  fprintf (file, "\tld.w\t%%sp,%%r0\t;\n");			/* ld.w     %sp, %r0        */
+	}
+      else if (size != 0)
+	{
+	  /* C33: Yes, it is necessary. */
+	  fprintf (file, "\tadd\t%%sp,%d\t;%d\n", (size >> 2), size);	/* add      %sp, imm12      */
+	}
+      else
+	{
+	  /* C33: No, it is not necessary. */
+	  /* EMPTY */
+	}
+
+      /* C33: Is there function call? */
+      if (check_call_being ())
+	{
+	  /* C33: Yes, there is function call. */
+
+	  /* C33: Restore "alr,ahr" from the stack. */
+	  fprintf (file, "\tpopn\t%%r1\n");						/* popn     %r1       */
+	  fprintf (file, "\tld.w\t%%alr,%%r0\n");				/* ld.w     %alr, %r0 */
+	  fprintf (file, "\tld.w\t%%ahr,%%r1\n");				/* ld.w     %ahr, %r1 */
+
+	  /* C33: Output "popn" instruction. */
+	  /* C33: Restore all except "gp". */
+	  fprintf (file, "\tpopn\t%%r%d\n", 15 - gp_max);		/* popn     %rX       */
+	}
+      else
+	{
+	  /* C33: No, there is not function call. */
+	  /* C33: Registers are used in the order of %r0,%r1,%r2,%r3,%r4,%r5,%r6,%r7,%r8,%r9
+	          in the case that there is not function call in the interrupt function.      */
+
+	  /* C33: Are registers used? */
+	  if (reg_saved == 0)
+	    {
+	      /* C33: Registers is not used. */
+
+	      /* C33: Does %sp move by using the scrath registers? */
+	      if (size > 0xffc)
+		{
+		  /* C33: Yes, it does. */
+		  fprintf (file, "\tpopn\t%%r0\n");			/* popn     %r0             */
+		}
+	      else
+		{
+		  /* C33: No, it does not. */
+		  /* EMPTY */
+		}
+	      /* "pop" instruction is unused. */
+	    }
+	  else
+	    {
+	      /* C33: Registers is used. */
+
+	      /* C33: Is "ahr alr" saved? */
+	      if (check_mlt_being ())
+		{
+		  /* C33: Yes, "ahr alr" is saved. */
+
+		  /* C33: Is there general purpose register for saving "ahr,alr"? */
+		  if (i < 14 - gp_max)
+		    {
+			  /* C33: Yes, there is. */
+			
+		      /* C33: Restore "alr,ahr" from the register. */
+		      fprintf (file, "\tld.w\t%%alr,%%r%d\n", i + 1);	/* ld.w     %alr, %r(i+1)   */
+		      fprintf (file, "\tld.w\t%%ahr,%%r%d\n", i + 2);	/* ld.w     %ahr, %r(i+2)   */
+
+		      /* C33: Output "popn" instruction. */
+		      fprintf (file, "\tpopn\t%%r%d\n", i + 2);		/* popn     %r(i+2)         */
+		    }
+		  else
+		    {
+			  /* C33: No, there is not. ( So, save to the stack. )  */
+			  
+		      /* C33: Restore "alr,ahr" from the stack. */
+		      fprintf (file, "\tpopn\t%%r1\n");			/* popn     %r1             */
+		      fprintf (file, "\tld.w\t%%alr,%%r0\n");		/* ld.w     %alr, %r0       */
+		      fprintf (file, "\tld.w\t%%ahr,%%r1\n");		/* ld.w     %ahr, %r1       */
+
+		      /* C33: Output "popn" instruction. */
+		      fprintf (file, "\tpopn\t%%r%d\n", i);		/* popn     %r?             */
+		    }
+		}
+	      else
+		{
+		  /* C33: No, "ahr alr" is not saved. */
+		  /* C33: Output "pop" instruction. */
+		  fprintf (file, "\tpopn\t%%r%d\n", i);			/* popn     %r?             */
+		}
+	    }			/* endif( reg_saved == 0) */
+	}			/* endif( Is there function call? ) */
+
+      /* C33: Output "reti" instruction. */
+      fprintf (file, "\treti\n");
+    }
+  else
+    {
+      /* C33: No, the normal function. */
+      /* C33: Use %r6 for the scratch register which is used for stack movement.
+              At this point, it is no problem that the register for storing returned values is destroyed. */
+
+      /* C33: Is the movement of %sp necessary? */
+      if (size > 0xffc)
+	{
+	  /* C33: Yes, it is necessary by using the scrath registers. */
+	  fprintf (file, "\tld.w\t%%r6,%%sp\t;add %%sp,%d\n", size);	/* ld.w     %r6, %sp        */
+	  fprintf (file, "\txadd\t%%r6,%d\t;\n", size);			/* xadd     %r6, imm32      */
+	  fprintf (file, "\tld.w\t%%sp,%%r6\t;\n");			/* ld.w     %sp, %r6        */
+	}
+      else if (size != 0)
+	{
+	  /* C33: Yes, it is necessary. */
+	  fprintf (file, "\tadd\t%%sp,%d\t;%d\n", (size >> 2), size);	/* add      %sp, imm12      */
+	}
+      else
+	{
+	  /* C33: No, it is not necessary. */
+	  /* EMPTY */
+	}
+
+      /* C33: Are there any registers to restore? */
+      if (reg_saved != 0)
+	{
+	  /* C33: Yes, there are registers to restore. */
+
+	  /* C33: Restore the registers. */
+	  fprintf (file, "\tpopn\t%%r%d\n", i);
+	}
+      else
+	{
+	  /* C33: No, there are not registers to restore. */
+	  /* EMPTY */
+	}
+
+      /* C33: Output "ret" instruction. */
+      fprintf (file, "\tret\n");
+    }
+
+/* C33: 8. Initialize for the commom variable. */
+  c33_interrupt_cache_p = FALSE;	/* C33: Interrupt judgement. */
+  c33_interrupt_p = FALSE;			/* C33: Interrupt judgement. */
+
+/* C33: 9. Return. */
+  return;
+
+/* C33: 10. Terminating process. */
+}
+
+
+/* C33: → conditions.h final.c */
+/* Update the condition code from the insn.  */
+void
+notice_update_cc (exp, insn)
+     rtx exp;
+     rtx insn;			
+{
+  if (GET_CODE (exp) == SET)
+    {
+
+      /* Jumps do not alter the cc's.  */
+      if (SET_DEST (exp) == pc_rtx)
+	return;
+
+      /* Moving register or memory into a register:
+         it doesn't alter the cc's, but it might invalidate
+         the RTX's which we remember the cc's came from.
+         (Note that moving a constant 0 or 1 MAY set the cc's).  */
+      if (REG_P (SET_DEST (exp))
+	  && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM
+	      || GET_RTX_CLASS (GET_CODE (SET_SRC (exp))) == '<'))
+	{
+	  if (cc_status.value1
+	      && reg_overlap_mentioned_p (SET_DEST (exp),
+					  cc_status.
+					  value1)) cc_status.value1 = 0;
+	  if (cc_status.value2
+	      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value2))
+	    cc_status.value2 = 0;
+	  return;
+	}
+
+      /* Moving register into memory doesn't alter the cc's.
+         It may invalidate the RTX's which we remember the cc's came from.  */
+      if (GET_CODE (SET_DEST (exp)) == MEM
+	  && (REG_P (SET_SRC (exp))
+	      || GET_RTX_CLASS (GET_CODE (SET_SRC (exp))) == '<'))
+
+	{
+	  if (cc_status.value1
+	      && reg_overlap_mentioned_p (SET_DEST (exp),
+					  cc_status.
+					  value1)) cc_status.value1 = 0;
+	  if (cc_status.value2
+	      && reg_overlap_mentioned_p (SET_DEST (exp),
+					  cc_status.
+					  value2)) cc_status.value2 = 0;
+	  return;
+	}
+
+      /* Function calls clobber the cc's.  */
+      else if (GET_CODE (SET_SRC (exp)) == CALL)
+	{
+	  CC_STATUS_INIT;
+	  return;
+	}
+
+      /* Tests and compares set the cc's in predictable ways.  */
+      else if (SET_DEST (exp) == cc0_rtx)
+	{
+	  CC_STATUS_INIT;
+	  cc_status.value1 = SET_SRC (exp);
+	  return;
+	}
+
+      /* Certain instructions effect the condition codes. */
+      else if (GET_MODE (SET_SRC (exp)) == SImode
+	       || GET_MODE (SET_SRC (exp)) == HImode
+	       || GET_MODE (SET_SRC (exp)) == QImode)
+	switch (GET_CODE (SET_SRC (exp)))
+	  {
+	  case ASHIFTRT:
+	  case LSHIFTRT:
+	  case ASHIFT:
+
+	    /* Shifts on the 386 don't set the condition codes if the
+	       shift count is zero. */
+	    if (GET_CODE (XEXP (SET_SRC (exp), 1)) != CONST_INT)
+	      {
+		CC_STATUS_INIT;
+		break;
+	      }
+
+	    /* We assume that the CONST_INT is non-zero (this rtx would
+	       have been deleted if it were zero. */
+	  case PLUS:
+	  case MINUS:
+	  case NEG:
+	  case AND:
+	  case IOR:
+	  case XOR:
+	    cc_status.flags = CC_NO_OVERFLOW;
+	    cc_status.value1 = SET_SRC (exp);
+	    cc_status.value2 = SET_DEST (exp);
+	    break;
+	  default:
+	    CC_STATUS_INIT;
+	  }
+
+      else
+	{
+	  CC_STATUS_INIT;
+	}
+    }
+
+  else if (GET_CODE (exp) == PARALLEL
+	   && GET_CODE (XVECEXP (exp, 0, 0)) == SET)
+    {
+      rtx p = XVECEXP (exp, 0, 0);
+      if ((GET_MODE (SET_SRC (p)) == SImode
+	   || GET_MODE (SET_SRC (p)) == HImode
+	   || GET_MODE (SET_SRC (p)) == QImode)
+	  && (GET_CODE (SET_SRC (p)) == ASHIFTRT
+	      || GET_CODE (SET_SRC (p)) == LSHIFTRT
+	      || GET_CODE (SET_SRC (p)) == ASHIFT))
+
+	{
+	  cc_status.flags = CC_NO_OVERFLOW;
+	  cc_status.value1 = SET_SRC (p);
+	  cc_status.value2 = SET_DEST (p);
+	}
+    }
+
+  else
+    {
+      CC_STATUS_INIT;
+    }
+}
+
+
+/* Retrieve the data area that has been chosen for the given decl.  */
+c33_data_area
+c33_get_data_area (decl)
+     tree decl;
+{
+  /* CHG K.Watanabe V1.7 >>>>>>> */
+/*  if (lookup_attribute ("sda", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE) */
+  if (lookup_attribute ("sda", DECL_ATTRIBUTES (decl)) != NULL_TREE)  
+  /* CHG K.Watanabe V1.7 <<<<<<< */
+    {
+      if (gp_max < 4)
+        return DATA_AREA_NORMAL;
+      else
+        return DATA_AREA_SDA;
+    }
+
+  /* CHG K.Watanabe V1.7 >>>>>>> */
+/*  if (lookup_attribute ("tda", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE) */
+  if (lookup_attribute ("tda", DECL_ATTRIBUTES (decl)) != NULL_TREE)  
+  /* CHG K.Watanabe V1.7 <<<<<<< */  
+    {
+      if (gp_max < 3)
+        return DATA_AREA_NORMAL;
+      else
+        return DATA_AREA_TDA;
+    }
+
+  /* CHG K.Watanabe V1.7 >>>>>>> */  
+/*  if (lookup_attribute ("zda", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE) */
+  if (lookup_attribute ("zda", DECL_ATTRIBUTES (decl)) != NULL_TREE)  
+  /* CHG K.Watanabe V1.7 <<<<<<< */    
+    {
+      if (gp_max < 2)
+        return DATA_AREA_NORMAL;
+      else
+        return DATA_AREA_ZDA;
+    }
+
+  /* CHG K.Watanabe V1.7 >>>>>>> */ 
+/*  if (lookup_attribute ("gda", DECL_MACHINE_ATTRIBUTES (decl)) != NULL_TREE) */
+  if (lookup_attribute ("gda", DECL_ATTRIBUTES (decl)) != NULL_TREE)  
+  /* CHG K.Watanabe V1.7 <<<<<<< */   
+    return DATA_AREA_GDA;
+
+  return DATA_AREA_NORMAL;
+}
+
+
+/* Store the indicated data area in the decl's attributes.  */
+static void
+c33_set_data_area (decl, data_area)
+     tree decl;
+     c33_data_area data_area;
+{
+  tree name;
+  
+  switch (data_area)
+    {
+    case DATA_AREA_SDA: name = get_identifier ("sda"); break;
+    case DATA_AREA_TDA: name = get_identifier ("tda"); break;
+    case DATA_AREA_ZDA: name = get_identifier ("zda"); break;
+    case DATA_AREA_GDA: name = get_identifier ("gda"); break;
+    default:
+      return;
+    }
+
+/* CHG K.Watanabe V1.7 >>>>>>> */
+/*
+  DECL_MACHINE_ATTRIBUTES (decl) = tree_cons
+    (name, NULL, DECL_MACHINE_ATTRIBUTES (decl));
+*/    
+  DECL_ATTRIBUTES (decl) = tree_cons
+    (name, NULL, DECL_ATTRIBUTES (decl));
+/* CHG K.Watanabe V1.7 <<<<<<< */
+}
+
+
+
+/* Return nonzero if ATTR is a valid attribute for DECL.
+   ATTRIBUTES are any existing attributes and ARGS are the arguments
+   supplied with ATTR.
+
+   Supported attributes:
+
+   interrupt_handler or interrupt: output a prologue and epilogue suitable
+   for an interrupt handler.  */
+
+/* Return nonzero if ATTR is a valid attribute for DECL.
+   ARGS are the arguments supplied with ATTR.  */
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused. */
+
+#if 0
+int
+c33_valid_machine_decl_attribute (decl, attr, args)
+     tree decl;
+     tree attr;
+     tree args;
+{
+  c33_data_area data_area;
+  c33_data_area area;
+  
+  if (args != NULL_TREE)
+    return 0;
+
+  if (is_attribute_p ("interrupt_handler", attr)
+      || is_attribute_p ("interrupt", attr))
+    return TREE_CODE (decl) == FUNCTION_DECL;
+
+  /* Implement data area attribute.  */
+  if (is_attribute_p ("sda", attr))
+    {
+      if (gp_max < 4)
+        {
+          error_with_decl (decl, "data area of '%s' cannot be specified for 'sda'.");
+          return 1;
+        }
+      else if (TREE_CODE (decl) == FUNCTION_DECL)
+        {
+          error_with_decl (decl, "'%s' cannot be specified for 'sda'.");
+          return 1;
+        }
+      else
+        data_area = DATA_AREA_SDA;
+    }
+  else if (is_attribute_p ("tda", attr))
+    {
+      if (gp_max < 3)
+        {
+          error_with_decl (decl, "data area of '%s' cannot be specified for 'tda'.");
+          return 1;
+        }
+      else if (TREE_CODE (decl) == FUNCTION_DECL)
+        {
+          error_with_decl (decl, "'%s' cannot be specified for 'tda'.");
+          return 1;
+        }
+      else
+        data_area = DATA_AREA_TDA;
+    }
+  else if (is_attribute_p ("zda", attr))
+    {
+      if (gp_max < 2)
+        {
+          error_with_decl (decl, "data area of '%s' cannot be specified for 'zda'.");
+          return 1;
+        }
+      else if (TREE_CODE (decl) == FUNCTION_DECL)
+        {
+          error_with_decl (decl, "'%s' cannot be specified for 'zda'.");
+          return 1;
+        }
+      else
+        data_area = DATA_AREA_ZDA;
+    }
+  else
+    return 0;
+  
+  switch (TREE_CODE (decl))
+    {
+    case VAR_DECL:
+      if (current_function_decl != NULL_TREE)
+	error_with_decl (decl, "\
+a data area attribute cannot be specified for local variables");
+      
+      /* Drop through.  */
+
+    case FUNCTION_DECL:
+      area = c33_get_data_area (decl);
+      if (area != DATA_AREA_NORMAL && data_area != area)
+	error_with_decl (decl, "\
+data area of '%s' conflicts with previous declaration");
+      
+      return 1;
+      
+    default:
+      break;
+    }
+  
+  return 0;
+}
+#endif
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+
+extern struct obstack * saveable_obstack;
+
+void
+c33_encode_data_area (decl)
+     tree decl;
+{
+  char * str = XSTR (XEXP (DECL_RTL (decl), 0), 0);
+  int    len = strlen (str);
+  char * newstr;
+
+  /* Map explict sections into the appropriate attribute */
+  if (c33_get_data_area (decl) == DATA_AREA_NORMAL)
+    {
+      if (DECL_SECTION_NAME (decl))
+	{
+	  char * name = TREE_STRING_POINTER (DECL_SECTION_NAME (decl));
+	  
+	  if (streq (name, ".zdata") || streq (name, ".zbss"))
+	    c33_set_data_area (decl, DATA_AREA_ZDA);
+
+	  else if (streq (name, ".sdata") || streq (name, ".sbss"))
+	    c33_set_data_area (decl, DATA_AREA_SDA);
+
+	  else if (streq (name, ".tdata") || streq (name, ".tbss"))
+	    c33_set_data_area (decl, DATA_AREA_TDA);
+
+	  else if (streq (name, ".gdata") || streq (name, ".gbss"))
+	    c33_set_data_area (decl, DATA_AREA_GDA);
+	}
+
+      /* If no attribute, support -mgda=n */
+      else
+	{
+
+	  int size = int_size_in_bytes (TREE_TYPE (decl));
+	  if (size <= 0)
+	    ;
+
+	  else if (size <= small_memory [(int) SMALL_MEMORY_GDA].max)
+	    {
+#if 0
+	      if ((TREE_CODE (decl) == VAR_DECL
+		    && TREE_READONLY (decl) && !TREE_SIDE_EFFECTS (decl))
+	    	    && (!DECL_INITIAL (decl)
+	    		|| TREE_CONSTANT (DECL_INITIAL (decl))))
+	        /* C33: Do not change the section if it is "const". */
+		;
+	      else
+	        /* C33: It is "DATA_AREA_GDA" if it is not "const". */
+	        c33_set_data_area (decl, DATA_AREA_GDA);
+#else
+	      if ((TREE_CODE (decl) == VAR_DECL
+		    && TREE_READONLY (decl) && !TREE_SIDE_EFFECTS (decl)))
+		{
+		  if (!DECL_INITIAL (decl))
+		    {
+		      ;
+	            }
+                  else if ((DECL_INITIAL (decl) == error_mark_node)
+			   || (TREE_CONSTANT (DECL_INITIAL (decl))))
+                    {
+                      ;
+                    }
+                  else
+                    {
+                  /* C33: It is "DATA_AREA_GDA" if it is not "const". */
+	              c33_set_data_area (decl, DATA_AREA_GDA);
+                    }
+                }
+	      else
+	        /* C33: It is "DATA_AREA_GDA" if it is not "const". */
+	        c33_set_data_area (decl, DATA_AREA_GDA);
+#endif
+	    }
+	}
+      
+      if (c33_get_data_area (decl) == DATA_AREA_NORMAL)
+	return;
+    }
+
+  /* CHG K.Watanabe V1.7 >>>>>>> */
+/* newstr = obstack_alloc (saveable_obstack, len + 2); */
+  newstr = alloca (len + 2);
+  /* CHG K.Watanabe V1.7 <<<<<<< */  
+
+  strcpy (newstr + 1, str);
+
+  switch (c33_get_data_area (decl))
+    {
+    case DATA_AREA_ZDA: *newstr = ZDA_NAME_FLAG_CHAR; break;
+    case DATA_AREA_TDA: *newstr = TDA_NAME_FLAG_CHAR; break;
+    case DATA_AREA_SDA: *newstr = SDA_NAME_FLAG_CHAR; break;
+    case DATA_AREA_GDA: *newstr = GDA_NAME_FLAG_CHAR; break;
+    default: abort ();
+    }
+
+  /* CHG K.Watanabe V1.7 >>>>>>> */  
+/*  XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr; */
+  XSTR (XEXP (DECL_RTL (decl), 0), 0) = ggc_alloc_string (newstr, len + 2);
+  /* CHG K.Watanabe V1.7 <<<<<<< */    
+}
+
+
+
+/* Return nonzero if FUNC is an interrupt function as specified
+   by the "interrupt" attribute.  */
+int
+c33_interrupt_function_p (void)
+{
+  tree a;
+  int ret = 0;
+  tree func = current_function_decl;	/* 001026 watanabe */
+  if (c33_interrupt_cache_p)
+    return c33_interrupt_p;
+  if (TREE_CODE (func) != FUNCTION_DECL)
+    return 0;
+    
+/* CHG K.Watanabe V1.7 >>>>>>> */    
+/*  a = lookup_attribute ("interrupt_handler", DECL_MACHINE_ATTRIBUTES (func)); */
+  a = lookup_attribute ("interrupt_handler", DECL_ATTRIBUTES (func));  
+/* CHG K.Watanabe V1.7 <<<<<<< */  
+  if (a != NULL_TREE)
+    ret = 1;
+
+  else
+    {
+/* CHG K.Watanabe V1.7 >>>>>>> */     
+/*      a = lookup_attribute ("interrupt", DECL_MACHINE_ATTRIBUTES (func)); */
+      a = lookup_attribute ("interrupt", DECL_ATTRIBUTES (func));
+/* CHG K.Watanabe V1.7 <<<<<<< */       
+      ret = a != NULL_TREE;
+    }
+
+  /* Its not safe to trust global variables until after function inlining has
+     been done.  */
+  if (reload_completed | reload_in_progress)
+    c33_interrupt_p = ret;
+  return ret;
+}
+
+
+/* C33: The following function is the quotation from mips.c. */
+/* Choose the section to use for DECL.  RELOC is true if its value contains
+   any relocatable expression.
+
+   Some of the logic used here needs to be replicated in
+   ENCODE_SECTION_INFO in mips.h so that references to these symbols
+   are done correctly.  Specifically, at least all symbols assigned
+   here to rom (.text and/or .rodata) must not be referenced via
+   ENCODE_SECTION_INFO with %gprel, as the rom might be too far away.
+
+   If you need to make a change here, you probably should check
+   ENCODE_SECTION_INFO to see if it needs a similar change.  */
+void
+c33_select_section (decl, reloc)
+     tree decl;
+     int reloc;
+{
+  /* For embedded applications, always put an object in read-only data
+     if possible, in order to reduce RAM usage.  */
+
+  if ((TREE_CODE (decl) == VAR_DECL
+        && TREE_READONLY (decl) && !TREE_SIDE_EFFECTS (decl)
+        && DECL_INITIAL (decl)
+        && (DECL_INITIAL (decl) == error_mark_node
+	    || TREE_CONSTANT (DECL_INITIAL (decl))))
+      && ! (flag_pic && reloc))
+    {
+      switch (c33_get_data_area (decl))
+        {
+        case DATA_AREA_ZDA:	rozdata_section (); break;
+        case DATA_AREA_TDA:	rotdata_section (); break;
+        case DATA_AREA_SDA:	rosdata_section (); break;
+        case DATA_AREA_GDA:	rogdata_section (); break;
+        default:	        READONLY_DATA_SECTION ();  break;
+        }
+    }
+
+       /* Deal with calls from output_constant_def_contents.  */
+  else if ((TREE_CODE (decl) != VAR_DECL
+        && (TREE_CODE (decl) != STRING_CST
+	    || !flag_writable_strings))
+      && ! (flag_pic && reloc))
+    READONLY_DATA_SECTION ();
+  else
+    {
+      switch (c33_get_data_area (decl))
+        {
+        case DATA_AREA_ZDA:	zdata_section (); break;
+        case DATA_AREA_TDA:	tdata_section (); break;
+        case DATA_AREA_SDA:	sdata_section (); break;
+        case DATA_AREA_GDA:	gdata_section (); break;
+        default:	        data_section ();  break;
+        }
+    }
+}
+
+
+/* Shifts.  */
+int
+nshift_operator (x, mode)
+     rtx x;
+     enum machine_mode mode;
+
+{
+  switch (GET_CODE (x))
+    {
+    case ASHIFTRT:
+    case LSHIFTRT:
+    case ASHIFT:
+    case ROTATE:
+    case ROTATERT:
+      return 1;
+    default:
+      return 0;
+    }
+}
+
+
+/* Called from the .md file to emit code to do shifts.
+   Returns a boolean indicating success
+   (currently this is always TRUE).  */
+int
+expand_a_shift (mode, code, operands)
+     enum machine_mode mode;
+     int code;
+     rtx operands[];
+
+{
+  emit_move_insn (operands[0], operands[1]);
+
+  /* need a loop to get all the bits we want  - we generate the
+     code at emit time, but need to allocate a scratch reg now  */
+  if ((TARGET_C33ADV || TARGET_C33PE))
+    emit_insn (gen_rtx (SET, VOIDmode, operands[0],
+                        gen_rtx (code, mode, operands[0],
+                                 operands[2])));
+  else
+    emit_insn (gen_rtx
+  	       (PARALLEL, VOIDmode,
+	        gen_rtvec (2,
+			   gen_rtx (SET, VOIDmode, operands[0],
+				    gen_rtx (code, mode, operands[0],
+					     operands[2])),
+			   gen_rtx (CLOBBER, VOIDmode,
+				    gen_rtx (SCRATCH, QImode, 0)))));
+  return 1;
+}
+
+
+/* Emit the assembler code for doing shifts.  */
+/********************************************************************************************
+Format		: char* emit_a_shift (code, operands)
+Input		: code -- rtx of code
+              operands -- rtx of operand
+Output		: None
+Return		: pointer for the output string
+Explanation	: Output shift instruction called from "insn_outfun()".
+*********************************************************************************************/
+char *
+emit_a_shift (code, operands)
+     enum rtx_code code;
+     rtx *operands;
+
+{
+  char *shift_type;
+  rtx xoperands[2];
+  static char mask_tab[] = {0x1, 0x3, 0x7, 0xf, 0x1f};
+
+  switch (code)
+    {
+    case ASHIFTRT:
+      shift_type = "sra";
+      break;
+    case LSHIFTRT:
+      shift_type = "srl";
+      break;
+    case ASHIFT:
+      shift_type = "sll";
+      break;
+    case ROTATE:
+      shift_type = "rl";
+      break;
+    case ROTATERT:
+      shift_type = "rr";
+      break;
+    }
+
+  if (GET_CODE (operands[2]) == CONST_INT)
+    {
+      int n = INTVAL (operands[2]) & 0x1f;
+
+      if ((code == LSHIFTRT) && (n > 27))
+        {
+          /* rl + and */
+          xoperands[0] = operands[0];
+          xoperands[1] = GEN_INT (32 - n);
+          output_asm_insn ("rl\t%0,%1", xoperands);
+          xoperands[1] = GEN_INT (mask_tab[31 - n]);
+          output_asm_insn ("and\t%0,%1", xoperands);
+        }
+      else if ((code == ASHIFT) && (n > 27))
+        {
+          /* and + rr */
+          xoperands[0] = operands[0];
+          xoperands[1] = GEN_INT (mask_tab[31 - n]);
+          output_asm_insn ("and\t%0,%1", xoperands);
+          xoperands[1] = GEN_INT (32 - n);
+          output_asm_insn ("rr\t%0,%1", xoperands);
+        }
+      else
+        {
+          /* C33: Inverse the direction if the value of rotate is 16 or more. */
+          if ((code == ROTATE) && (n > 16))
+            {
+               n = 32 - n;
+               shift_type = "rr";
+            }
+          else if ((code == ROTATERT) && (n > 16))
+            {
+               n = 32 - n;
+               shift_type = "rl";
+            }
+
+          while (n > 8)
+            {
+              n -= 8;
+              fprintf (asm_out_file, "\t%s", shift_type);
+              output_asm_insn ("%0,8", operands);
+            }
+          xoperands[0] = operands[0];
+          xoperands[1] = GEN_INT (n % 9);
+          fprintf (asm_out_file, "\t%s", shift_type);
+          output_asm_insn ("%0,%1", xoperands);
+        }
+    }
+  else
+    {				/* register */
+      output_asm_insn ("ld.w\t%3,%2", operands);
+      output_asm_insn ("and\t%3,0x1f", operands);
+      output_asm_insn ("cmp\t%3,0x08", operands);
+      fprintf (asm_out_file, "\tjrle\t4\n");
+      fprintf (asm_out_file, "\t%s", shift_type);
+      output_asm_insn ("%0,8", operands);
+      fprintf (asm_out_file, "\tjp.d\t-3\n");
+      output_asm_insn ("sub\t%3,8", operands);
+      fprintf (asm_out_file, "\t%s", shift_type);
+      output_asm_insn ("%0,%3", operands);
+    }
+  return "";
+}
+
+
+/* Print the options used in the assembly file.  */
+static struct
+{
+  char *name;
+  int value;
+}
+target_switches[] = TARGET_SWITCHES;
+
+void
+print_options (out)
+     FILE *out;
+
+{
+  /* CHG K.Watanabe V1.7 >>>>>>> */    
+  /*
+  extern char *language_string;
+  extern char *version_string;
+  */
+  char *language_string = "GNU C";
+  extern const char version_string[];
+  /* CHG K.Watanabe V1.7 <<<<<<< */  
+  extern char **save_argv;
+  int line_len;
+  int len;
+  int j;
+  char **p;
+  int mask = TARGET_DEFAULT;
+
+  /* Allow assembly language comparisons with -mdebug eliminating the
+     compiler version number and switch lists.  */
+  fprintf (out, "\n;  %s %s", language_string, version_string);
+
+#ifdef TARGET_VERSION_INTERNAL
+  TARGET_VERSION_INTERNAL (out);
+
+#endif /*  */
+#ifdef __GNUC__
+  fprintf (out, " compiled by GNU C\n\n");
+
+#else /*  */
+  fprintf (out, " compiled by CC\n\n");
+
+#endif /*  */
+  fprintf (out, ";  Cc1 defaults:");
+  line_len = 32767;
+  for (j = 0; j < sizeof target_switches / sizeof target_switches[0]; j++)
+    {
+      if (target_switches[j].name[0] != '\0'
+	  && target_switches[j].value > 0
+	  && (target_switches[j].value & mask) == target_switches[j].value)
+	{
+	  mask &= ~target_switches[j].value;
+	  len = strlen (target_switches[j].name) + 1;
+	  if (len + line_len > 79)
+	    {
+	      line_len = 2;
+	      fputs ("\n; ", out);
+	    }
+	  fprintf (out, " -m%s", target_switches[j].name);
+	  line_len += len;
+	}
+    }
+  fprintf (out, "\n\n;  Cc1 arguments (-cpu = %s):", c33_cpu_string);
+  line_len = 32767;
+  for (p = &save_argv[1]; *p != (char *) 0; p++)
+    {
+      char *arg = *p;
+      if (*arg == '-')
+	{
+	  len = strlen (arg) + 1;
+	  if (len + line_len > 79)
+	    {
+	      line_len = 2;
+	      fputs ("\n; ", out);
+	    }
+	  fprintf (out, " %s", *p);
+	  line_len += len;
+	}
+    }
+  fputs ("\n\n", out);
+}
+
+
+/* Emit either a label, .comm, or .lcomm directive, and mark
+   that the symbol is used, so that we don't emit an .extern
+   for it in asm_file_end.  */
+void
+declare_object (stream, name, init_string, final_string, size)
+     FILE *stream;
+     char *name;
+     char *init_string;
+     char *final_string;
+     int size;
+
+{
+  fputs (init_string, stream);	/* "", "\t.comm\t", or "\t.lcomm\t" */
+  assemble_name (stream, name);
+  fprintf (stream, final_string, size);	/* ":\n", ",%u\n", ",%u\n" */
+}
+
+
+extern tree last_assemble_variable_decl;
+extern int size_directive_output;
+
+/* A version of asm_output_aligned_bss() that copes with the special
+   data areas of the c33. */
+/* Called via the macro ASM_OUTPUT_ALIGNED_BSS */
+void
+c33_output_aligned_bss (file, decl, name, size, align)
+     FILE * file;
+     tree decl;
+     char * name;
+     int size;
+     int align;
+{
+  /* DEL K.Watanabe V1.7 >>>>>>> */
+  /* ASM_GLOBALIZE_LABEL (file, name); */
+  /* DEL K.Watanabe V1.7 <<<<<<< */
+   
+  switch (c33_get_data_area (decl))
+    {
+    case DATA_AREA_ZDA:
+      zbss_section ();
+      break;
+
+    case DATA_AREA_SDA:
+      sbss_section ();
+      break;
+
+    case DATA_AREA_TDA:
+      tbss_section ();    /* C33: Though v850 has only "tdata", c33 has both. */
+      break;
+      
+    case DATA_AREA_GDA:
+      gbss_section ();
+      break;	/* GNU-GCC-045 2002/3/6 watanabe */
+      
+    default:
+      bss_section ();
+      break;
+    }
+  
+  ASM_OUTPUT_ALIGN (file, floor_log2 (align / BITS_PER_UNIT));
+#ifdef ASM_DECLARE_OBJECT_NAME
+  last_assemble_variable_decl = decl;
+  ASM_DECLARE_OBJECT_NAME (file, name, decl);
+#else
+  /* Standard thing is just output label for the object.  */
+  ASM_OUTPUT_LABEL (file, name);
+#endif /* ASM_DECLARE_OBJECT_NAME */
+  ASM_OUTPUT_SKIP (file, size ? size : 1);
+}
+
+
+/* Called via the macro ASM_OUTPUT_ALIGNED_DECL_COMMON */
+void
+c33_output_common (file, decl, name, size, align)
+     FILE * file;
+     tree decl;
+     char * name;
+     int size;
+     int align;
+{
+  if (decl == NULL_TREE)
+    {
+      fprintf (file, "\t%s\t", COMMON_ASM_OP);
+    }
+  else
+    {
+      switch (c33_get_data_area (decl))
+	{
+	case DATA_AREA_ZDA:
+	  fprintf (file, "\t%s\t", ZCOMMON_ASM_OP);
+	  break;
+
+	case DATA_AREA_SDA:
+	  fprintf (file, "\t%s\t", SCOMMON_ASM_OP);
+	  break;
+
+	case DATA_AREA_TDA:
+	  fprintf (file, "\t%s\t", TCOMMON_ASM_OP);
+	  break;
+      
+	case DATA_AREA_GDA:
+	  fprintf (file, "\t%s\t", GCOMMON_ASM_OP);
+	  break;
+      
+	default:
+	  fprintf (file, "\t%s\t", COMMON_ASM_OP);
+	  break;
+	}
+    }
+  
+  assemble_name (file, name);
+  fprintf (file, ",%u,%u\n", size, align / BITS_PER_UNIT);
+}
+
+
+/* Called via the macro ASM_OUTPUT_ALIGNED_DECL_LOCAL */
+void
+c33_output_local (file, decl, name, size, align)
+     FILE * file;
+     tree decl;
+     char * name;
+     int size;
+     int align;
+{
+  fprintf (file, "\t%s\t", LOCAL_ASM_OP);
+  assemble_name (file, name);
+  fprintf (file, "\n");
+  ASM_OUTPUT_ALIGNED_DECL_COMMON (file, decl, name, size, align);
+}
+
+
+/* Output assembly code for the start of the file.  */
+void
+asm_file_start (file)
+     FILE *file;
+{
+  output_file_directive (file, main_input_filename);
+  
+  print_options (file);
+}
+
+
+/* Write a loop to move a constant number of bytes.
+   Generate load/stores as follows:
+
+   do {
+     temp1 = src[0];
+     temp2 = src[1];
+     ...
+     temp<last> = src[MAX_MOVE_REGS-1];
+     dest[0] = temp1;
+     dest[1] = temp2;
+     ...
+     dest[MAX_MOVE_REGS-1] = temp<last>;
+     src += MAX_MOVE_REGS;
+     dest += MAX_MOVE_REGS;
+   } while (src != final);
+
+   This way, no NOP's are needed, and only MAX_MOVE_REGS+3 temp
+   registers are needed.
+
+   Aligned moves move MAX_MOVE_REGS*4 bytes every (2*MAX_MOVE_REGS)+3
+   cycles, unaligned moves move MAX_MOVE_REGS*4 bytes every
+   (4*MAX_MOVE_REGS)+3 cycles, assuming no cache misses.  */
+
+#define MAX_MOVE_REGS 2
+#define MAX_MOVE_BYTES (MAX_MOVE_REGS * UNITS_PER_WORD)
+static void
+block_move_loop (dest_reg, src_reg, bytes, align, orig_src)
+     rtx dest_reg;		/* register holding destination address */
+     rtx src_reg;		/* register holding source address */
+     int bytes;			/* # bytes to move */
+     int align;			/* alignment */
+     rtx orig_src;		/* original source for making a reg note */
+
+{
+  rtx dest_mem = gen_rtx (MEM, BLKmode, dest_reg);
+  rtx src_mem = gen_rtx (MEM, BLKmode, src_reg);
+  rtx align_rtx = GEN_INT (align);
+  rtx label;
+  rtx final_src;
+  rtx bytes_rtx;
+  int leftover;
+
+  /* C33: If transmission byte is less than 16 byte. */
+  if (bytes < 2 * MAX_MOVE_BYTES)
+
+    /* C33: Stop processing. */
+    abort ();
+  leftover = bytes % MAX_MOVE_BYTES;
+  bytes -= leftover;
+
+  /* C33: Create the label rtx. */
+  label = gen_label_rtx ();
+
+  /* C33: Create the register rtx which saves the transmission end address. */
+  final_src = gen_reg_rtx (Pmode);
+  bytes_rtx = GEN_INT (bytes);
+
+  /* C33: Emit the rtx whick decides the transmission end address. */
+  emit_insn (gen_addsi3 (final_src, src_reg, bytes_rtx));
+
+  /* C33: Emit the label rtx. */
+  emit_label (label);
+  bytes_rtx = GEN_INT (MAX_MOVE_BYTES);
+
+  /* C33: Emit the rtx of transmission instruction array. */
+  emit_insn (gen_movstrsi_internal (dest_reg, src_reg, bytes_rtx, align_rtx));
+  /* C33: Emit the rtx of "cmp" instruction. */
+  emit_insn (gen_cmpsi (src_reg, final_src));
+
+  /* C33: Emit the rtx of "jump" instruction. */
+  emit_jump_insn (gen_bne (label));
+  if (leftover)
+
+    /* C33: Emit the rtx of transmission instruction array. */
+    emit_insn (gen_movstrsi_internal
+	       (dest_reg, src_reg, GEN_INT (leftover), align_rtx));
+}
+
+
+/* Use a library function to move some bytes.  */
+static void
+block_move_call (dest_reg, src_reg, bytes_rtx)
+     rtx dest_reg;
+     rtx src_reg;
+     rtx bytes_rtx;
+
+{
+
+  /* C33: If it is not "VOIDmode", and not "Pmode". */
+  /* We want to pass the size as Pmode, which will normally be SImode
+     but will be DImode if we are using 64 bit longs and pointers.  */
+  if (GET_MODE (bytes_rtx) != VOIDmode && GET_MODE (bytes_rtx) != Pmode)
+
+    /* C33: Yes, it is not "VOIDmode", and not "Pmode". */
+
+    /* C33: Change the mode to Pmode. */
+    bytes_rtx = convert_to_mode (Pmode, bytes_rtx, TRUE);
+
+#ifdef TARGET_MEM_FUNCTIONS
+  /* C33: Emit the rtx for calling memcpy library. */
+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, "memcpy"), 0, VOIDmode, 3,
+		     dest_reg, Pmode, src_reg, Pmode, bytes_rtx, Pmode);
+
+#else /*  */
+  /* C33: Emit the rtx for calling bcopy library. */
+  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, "bcopy"), 0, VOIDmode, 3,
+		     src_reg, Pmode, dest_reg, Pmode, bytes_rtx, Pmode);
+
+#endif /*  */
+
+  /* C33: Terminating process. */
+}
+
+
+/* Expand string/block move operations.
+
+   operands[0] is the pointer to the destination.
+   operands[1] is the pointer to the source.
+   operands[2] is the number of bytes to move.
+   operands[3] is the alignment.  */
+void
+expand_block_move (operands)
+     rtx operands[];
+
+{
+  rtx bytes_rtx = operands[2];
+  rtx align_rtx = operands[3];
+  int constp = (GET_CODE (bytes_rtx) == CONST_INT);
+  int bytes = (constp ? INTVAL (bytes_rtx) : 0);
+  int align = INTVAL (align_rtx);
+  rtx orig_src = operands[1];
+  rtx src_reg;
+  rtx dest_reg;
+
+  /* C33: If the transmission byte is less than 0. */
+  if (constp && bytes <= 0)
+
+    /* C33: Terminating process. */
+    return;
+
+  /* C33: If alignment is more than word. */
+  if (align > UNITS_PER_WORD)
+
+    /* C33: Fix to the word unit. */
+    align = UNITS_PER_WORD;
+
+  /* C33: Set the pair of scratch registers. */
+  /* Move the address into scratch registers.  */
+  dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));
+  src_reg = copy_addr_to_reg (XEXP (orig_src, 0));
+
+  /* C33:
+     IF   Optimize is enabled.
+          There is The transmission data.
+          The number of transmission is 2 or less. */
+  if (constp && optimize && bytes != 0 && (bytes / align) <= 2)
+
+    /* C33: Yes, the number of transmission is 2 or less. */
+
+    /* C33: Emit the rtx of transmission instruction array. */
+    emit_insn (gen_movstrsi_internal
+	       (dest_reg, src_reg, bytes_rtx, align_rtx));
+  else
+    /* C33, No, the number of transmission is 3 or more. */
+
+    /* IF
+          There is "-mno-memcpy" option.( It means default ) */
+  if (TARGET_MEMCPY)
+
+    /* YES memcpy */
+
+    /* C33: Emit the rtx for calling memcopy library. */
+    block_move_call (dest_reg, src_reg, bytes_rtx);
+
+
+  /* C33: There is "-mno-memcpy" option.
+          ELSE IF     the transmission byte is 16 or less */
+  else if (constp && bytes <= 2 * MAX_MOVE_BYTES)
+    /* C33: Yes, the transmission byte is 16 or less. */
+
+    /* C33: Emit the rtx of transmission instruction array. */
+    emit_insn (gen_movstrsi_internal
+	       (dest_reg, src_reg, bytes_rtx, align_rtx));
+  
+  /* C33: ELSE IF
+          The alignment is word and the optimize is enabled. */
+  else if (constp && align >= UNITS_PER_WORD && optimize)
+
+    /* YES */
+
+    /* C33: Create the rtl sequence of the block transmission loop. */
+    block_move_loop (dest_reg, src_reg, bytes, align, orig_src);
+
+  /* C33: ELSE IF
+          The alignment is not word and the optimize is enabled. */
+  else if (constp && optimize)
+
+    {
+
+      /* If the alignment is not word aligned, generate a test at
+         runtime, to see whether things wound up aligned, and we
+         can use the faster lw/sw instead ulw/usw.  */
+      rtx temp = gen_reg_rtx (Pmode);
+      rtx aligned_label = gen_label_rtx ();
+      rtx join_label = gen_label_rtx ();
+      int leftover = bytes % MAX_MOVE_BYTES;
+      bytes -= leftover;
+
+      /* C33: Create the instructions which are address calculation and
+              jump destination calculation for transmitting by loop. */
+      emit_insn (gen_iorsi3 (temp, src_reg, dest_reg));
+      emit_insn (gen_andsi3 (temp, temp, GEN_INT (UNITS_PER_WORD - 1)));
+      emit_insn (gen_cmpsi (temp, const0_rtx));
+      emit_jump_insn (gen_beq (aligned_label));
+
+      /* C33: Create the transmission loop which transmits 1byte at a time. */
+      /* Unaligned loop.  */
+      block_move_loop (dest_reg, src_reg, bytes, 1, orig_src);
+      emit_jump_insn (gen_jump (join_label));
+      emit_barrier ();
+
+      /* C33: Create the transmission loop by word unit. */
+      /* Aligned loop.  */
+      emit_label (aligned_label);
+      block_move_loop (dest_reg, src_reg, bytes, UNITS_PER_WORD, orig_src);
+      emit_label (join_label);
+
+      /* C33: Create the transmission instruction which can transmit 
+                                               less than the loop tranmit by word unit. */
+      /* Bytes at the end of the loop.  */
+      if (leftover)
+
+	{
+	  emit_insn (gen_movstrsi_internal
+		     (dest_reg, src_reg, GEN_INT (leftover),
+		      GEN_INT (align)));}
+    }
+
+  else
+    /* C33: Yes, the specification of byte number is not constants 
+            or does not have the optimization. */
+    
+    /* C33: Emit the rtx for calling memcopy library. */
+    block_move_call (dest_reg, src_reg, bytes_rtx);
+}
+
+
+/********************************************************************************************
+Format		: char* output_block_move (insn, operands, num_regs)
+Input		: 
+Output		: None
+Return		: 
+Explanation	: Output load instruction called from "insn_outfun()".
+*********************************************************************************************/
+char *
+output_block_move (insn, operands, num_regs)
+     rtx insn;
+     rtx operands[];
+     int num_regs;		/* C33: The number of registers which can be used for transmission. */
+{
+  rtx dest_reg = operands[0];
+  rtx src_reg = operands[1];
+  int bytes = INTVAL (operands[2]);
+  int align = INTVAL (operands[3]);
+  int num = 0;
+  int last_operand = num_regs + 4;
+  int safe_regs = 4;
+  int i;
+  rtx xoperands[10];
+  struct
+  {
+    char *load;			/* load insn without nop */
+    char *store;		/* store insn */
+    enum machine_mode mode;	/* mode to use on (MEM) */
+  }
+  load_store[4];
+
+  /* Detect a bug in GCC, where it can give us a register
+     the same as one of the addressing registers and reduce
+     the number of registers available.  */
+  for (i = 4;
+       i < last_operand
+       && safe_regs < (sizeof (xoperands) / sizeof (xoperands[0])); i++)
+
+    {
+      if (!reg_mentioned_p (operands[i], operands[0])
+	  && !reg_mentioned_p (operands[i], operands[1]))
+	xoperands[safe_regs++] = operands[i];
+    }
+  if (safe_regs < last_operand)
+
+    {
+      xoperands[0] = operands[0];
+      xoperands[1] = operands[1];
+      xoperands[2] = operands[2];
+      xoperands[3] = operands[3];
+      return output_block_move (insn, xoperands, safe_regs - 4);
+    }
+
+  /* If we are given global or static addresses, and we would be
+     emitting a few instructions, try to save time by using a
+     temporary register for the pointer.  */
+
+  /* C33:  IF   The number of registers which can be used for transmission
+                is 3 or more, and the numer of transmission is 3 or more.   */
+  if (num_regs > 2 && (bytes > 2 * align))
+
+    {
+      /* C33: IF  The address of memory from which to transmit is the label or the constants. */
+      if (CONSTANT_P (src_reg))
+	{
+
+	  /* C33: Get the "template" register. */
+	  src_reg = operands[3 + num_regs--];
+
+	  /* C33: Output the instruction which loads the address of memory 
+	          from which to transmit to the "template" register.      */
+	  xoperands[1] = operands[1];
+	  xoperands[0] = src_reg;
+	  output_asm_insn ("xld.w\t%0,%1", xoperands);
+	}
+
+      /* C33: IF  The address of memory to which to transmit is the label or the symbols or the constants. */
+      if (CONSTANT_P (dest_reg))
+	{
+
+	  /* C33: Get the "template" register. */
+	  dest_reg = operands[3 + num_regs--];
+
+	  /* C33: Output the instruction which loads the address of memory 
+	          from which to trasmit to the "template" register.          */
+	  xoperands[1] = operands[0];
+	  xoperands[0] = dest_reg;
+	  output_asm_insn ("xld.w\t%0,%1", xoperands);
+	}
+    }
+
+  /* C33:  IF   The number of registers which can be used for transmission is 4 or more. */
+  if (num_regs > (sizeof (load_store) / sizeof (load_store[0])))
+
+    /* C33: The number of registers which can be used shall be 4 or less. */
+    num_regs = (sizeof (load_store) / sizeof (load_store[0]));
+
+  /* C33: WHILE       Until all transmitted data is output. */
+  while (bytes > 0)
+
+    {
+
+      /* C33: IF    The transmission bytes and alignment are 4byte or more. */
+      if (bytes >= 4 && align >= 4)
+
+	{
+
+	  /* C33: Transmit by word unit. */
+	  load_store[num].load = "ld.w\t%0,[%1]+";
+	  load_store[num].store = "ld.w\t[%1]+,%0";
+	  load_store[num].mode = SImode;
+	  bytes -= 4;
+	}
+
+      /* C33:  ELSE IF    The transmission bytes and alignment are 2byte or more. */
+      else if (bytes >= 2 && align >= 2)
+
+	{
+	  /* C33: Transmit by half unit. */
+	  load_store[num].load = "ld.h\t%0,[%1]+";
+	  load_store[num].store = "ld.h\t[%1]+,%0";
+	  load_store[num].mode = HImode;
+	  bytes -= 2;
+	}
+
+      /* C33: ELSE  transmit except by word or by half. */
+      else
+
+	{
+
+	  /* byte転送 */
+	  load_store[num].load = "ld.b\t%0,[%1]+";
+	  load_store[num].store = "ld.b\t[%1]+,%0";
+	  load_store[num].mode = QImode;
+	  bytes--;
+	}
+
+      /* Emit load/stores now if we have run out of registers or are
+         at the end of the move.  */
+
+      /* C33: IF     All registers for transmission have been used, 
+                     or all instructions which transmit all data have been output.        */
+      if (++num == num_regs || bytes == 0)
+
+	{
+
+	  /* C33: Output the load instruction. */
+	  for (i = 0; i < num; i++)
+
+	    {
+	      if (!operands[i + 4])
+		abort ();
+
+	      /* C33: IF   The mode of "temp" register which saves temporarily
+	                   the content of memory to transmit is different from the mode of data to transmit. */
+	      if (GET_MODE (operands[i + 4]) != load_store[i].mode)
+
+		/* C33: Change the mode of "temp" register which saves temporarily the data. */
+		operands[i + 4] =
+		  gen_rtx (REG, load_store[i].mode, REGNO (operands[i + 4]));
+
+	      /* C33: Output the instruction which loads the content of memory 
+	              from which to transmit to "temp" register.                */
+	      xoperands[0] = operands[i + 4];
+	      xoperands[1] = gen_rtx (MEM, load_store[i].mode, src_reg);
+	      output_asm_insn (load_store[i].load, xoperands);
+	    }
+
+	  /* C33: Output the store instruction. */
+	  for (i = 0; i < num; i++)
+
+	    {
+	      /* C33: Output the instruction which loads the content of "temp" register 
+	              to the memory to which to transmit.                               */
+	      xoperands[0] = operands[i + 4];
+	      xoperands[1] = gen_rtx (MEM, load_store[i].mode, dest_reg);
+	      output_asm_insn (load_store[i].store, xoperands);
+	    }
+
+	  /* C33: Set 0 to the register number which is used for transmission. */
+	  num = 0;		/* reset load_store */
+	}
+    }
+
+  /* C33: Terminating process. */
+  return "";
+}
+
+
+/* Given INSN and its current length LENGTH, return the adjustment
+   (in bytes) to correctly compute INSN's length.
+
+   We use this to get the lengths of various memory references correct.  */
+/*****************************************************************************************************
+Format		: int c33_adjust_insn_length (insn, length)
+Input		: rtx insn   -- INSN checked.
+              int length -- Unused.
+Output		: None
+Return		: The instruction lengths corrected.( by byte unit )
+Explanation	: ・Called from "shorten_branches()".
+              ・Correct the instruction lengths.
+              ・It is not necessary for adjusting here, because "m -> r" and "r -> m" 
+                are not created in the case of "-medda32" && "defaut data area".
+*****************************************************************************************************/
+// CHG K.Watanabe V1.8 >>>>>>>
+#if 0
+c33_adjust_insn_length (insn, length)
+#endif
+
+int c33_adjust_insn_length (insn, length)
+// CHG K.Watanabe V1.8 <<<<<<<
+     rtx insn;
+     int length;
+{
+  rtx pat;
+  pat = PATTERN (insn);
+
+  /* Ajust length for symbol/label->reg. */
+  if (GET_CODE (pat) == SET
+      && (GET_CODE (SET_DEST (pat)) != PC)
+      && (GET_CODE (SET_SRC (pat)) == LABEL_REF
+          || GET_CODE (SET_SRC (pat)) == SYMBOL_REF
+          || GET_CODE (SET_SRC (pat)) == CONST))
+    {
+      /* This insn might need a length adjustment.  */
+      rtx addr;
+      char *name;
+
+	  /***************************************************/
+	  /* C33: Get the symobl address.                    */
+	  /***************************************************/
+      if (GET_CODE (SET_SRC (pat)) == SYMBOL_REF
+          || GET_CODE (SET_SRC (pat)) == LABEL_REF)
+        name = XSTR (SET_SRC (pat), 0);
+      else
+        name = XSTR (XEXP (XEXP (SET_SRC (pat), 0), 0), 0);
+
+      if (ENCODED_NAME_P (name))
+			if ((TARGET_EXT_ZDA && ZDA_NAME_P (name))
+	    		|| (TARGET_EXT_TDA && TDA_NAME_P (name))
+	    		|| (TARGET_EXT_SDA && SDA_NAME_P (name)))
+	  			return 0;		/* [stz] data area extended */
+			else
+          		return -2;		/* [stzg] data area */
+      else
+        	if (TARGET_C33ADV)
+          		return 2;		/* default data area */
+        	else
+          		return 0; 
+    }
+
+  /* Adjust length for reg->mem and mem->reg copies.  */
+  if (GET_CODE (pat) == SET
+      && (GET_CODE (SET_SRC (pat)) == MEM
+	  || GET_CODE (SET_DEST (pat)) == MEM))
+    {
+      /* This insn might need a length adjustment.  */
+      rtx addr;
+      int mode;
+      char *name;
+
+      if (GET_CODE (SET_SRC (pat)) == MEM)
+	{
+	  addr = XEXP (SET_SRC (pat), 0);
+	  mode = GET_MODE (SET_SRC (pat));
+	}
+      else
+	{
+	  addr = XEXP (SET_DEST (pat), 0);
+	  mode = GET_MODE (SET_DEST (pat));
+	}
+
+      switch (mode)
+        {
+	case DFmode:
+	case DImode:
+	  if (GET_CODE (addr) == REG)
+	    return -6;
+	  else if (GET_CODE (addr) == PLUS)
+	    return 0;
+	  else
+	    {
+	      printf("c33_adjust_insn_length: MEM\n");// debug
+	      return 0;
+	    }
+	  break;
+
+	default:
+	  switch (GET_CODE (addr))
+            {
+	    case REG:
+	      return -4;
+	      break;
+
+	    case PLUS:
+              if (GET_CODE (XEXP (addr, 0)) == REG
+	          && REGNO (XEXP (addr, 0)) == STACK_POINTER_REGNUM
+	          && GET_CODE (XEXP (addr, 1)) == CONST_INT)
+	        {
+	          switch (mode)
+                    {
+	            case QImode:
+	              if (CONST_OK_FOR_IMM6 (INTVAL (XEXP (addr, 1))))
+	                return -4;
+	              if (CONST_OK_FOR_IMM19 (INTVAL (XEXP (addr, 1))))
+	                return -2;
+	              break;
+
+	            case HImode:
+	              if (CONST_OK_FOR_IMM7 (INTVAL (XEXP (addr, 1))))
+	                return -4;
+	              if (CONST_OK_FOR_IMM19 (INTVAL (XEXP (addr, 1))))
+	                return -2;
+	              break;
+
+	            case SImode:
+	            default:
+	              if (CONST_OK_FOR_IMM8 (INTVAL (XEXP (addr, 1))))
+	                return -4;
+	              if (CONST_OK_FOR_IMM19 (INTVAL (XEXP (addr, 1))))
+	                return -2;
+	              break;
+	            }
+	        }
+	      else
+	        {
+	          if (CONST_OK_FOR_IMM13 (INTVAL (XEXP (addr, 1))))
+	            return -2;
+	        }
+	      break;
+
+	  /****************************************************************/
+	  /* C33: Reference the symbol.( loading memory / saving memory ) */
+	  /****************************************************************/
+	    case SYMBOL_REF:
+	      	name = XSTR (addr, 0);
+
+	      	/* C33: It is -2 except in the case of "dafault data area". */
+	      	if (ENCODED_NAME_P (name))
+	        	if ((TARGET_EXT_ZDA && ZDA_NAME_P (name))
+	            	|| (TARGET_EXT_TDA && TDA_NAME_P (name))
+	            	|| (TARGET_EXT_SDA && SDA_NAME_P (name)))
+	          		return 0;		/* [stz] data area extended */
+	        	else
+                  	return -2;		/* [stzg] data area */
+	      	else
+	      		if (TARGET_C33ADV)
+	          		return 2;		/* default data area */
+	        	else
+	          		return 0;
+	      	break;
+
+	    case CONST:
+	    	name = XSTR (XEXP (XEXP (addr, 0), 0), 0);
+
+	      	/* It is -2 except in the case of "dafault data area". */
+	      	if (ENCODED_NAME_P (name))
+	      		if ((TARGET_EXT_ZDA && ZDA_NAME_P (name))
+	            	|| (TARGET_EXT_TDA && TDA_NAME_P (name))
+	            	|| (TARGET_EXT_SDA && SDA_NAME_P (name)))
+	          		return 0;		/* [stz] data area extended */
+	        	else
+                  	return -2;		/* [stzg] data area */
+	      	else
+	        	if (TARGET_C33ADV)
+	          		return 2;		/* default data area */
+	        	else
+	          		return 0;
+	      	break;
+	    	}
+        }
+        
+    /* ADD K.Watanabe V1.4 >>>>>>> */    
+    } else {
+    	/*******************************************************************************************/
+    	/*   @SIGN_EXTEND( MEM ) -> REG 														   */
+    	/*     C33: In the case that the argument is the global variable of "char" / "short" type. */
+    	/*   AZERO_EXTEND( MEM ) -> REG 														   */
+    	/*     C33: In the case that the argument is the global variable of "unsigned char" /      */
+    	/*          "unsigned short" type.                                                         */
+    	/*******************************************************************************************/
+    	rtx addr;
+      	int mode;
+      	char *name;
+		int i_chk_flg;
+		
+		i_chk_flg = 0; 
+		if( GET_CODE (pat) == SET ){
+			if( GET_CODE (SET_DEST (pat)) == REG ){
+				if( ( GET_CODE (SET_SRC (pat)) == SIGN_EXTEND ) || ( GET_CODE (SET_SRC (pat)) == ZERO_EXTEND ) ){
+					if( GET_CODE( SUBREG_REG( SET_SRC (pat) ) ) == MEM ){
+						i_chk_flg = 1;
+						addr = XEXP( SUBREG_REG( SET_SRC (pat) ),0 );
+						mode = GET_MODE ( SUBREG_REG( SET_SRC (pat) ) );							
+					}
+				}
+			}			
+		}	
+		
+		/* SIGN_EXTEND( MEM ) -> REG */
+		/* ZERO_EXTEND( MEM ) -> REG */
+		if( i_chk_flg == 1 ){
+	    	switch (mode){
+				case DFmode:
+				case DImode:
+			  		break;
+			  		
+				default:
+			  		switch (GET_CODE (addr)){
+			    		case REG:
+			    		case PLUS:
+			      			break;
+
+				  		/****************************************************************/
+				   	    /* C33: Reference the symbol.( loading memory / saving memory ) */
+				  		/****************************************************************/
+				    	case SYMBOL_REF:
+				      		name = XSTR (addr, 0);
+				      		
+			      			/* It is -2 except in the case of "dafault data area". */
+				      		if ( ( ENCODED_NAME_P (name) ) ){
+				      			if( (TARGET_EXT_ZDA && ZDA_NAME_P (name))
+					            		|| (TARGET_EXT_TDA && TDA_NAME_P (name))
+					            		|| (TARGET_EXT_SDA && SDA_NAME_P (name)) ){
+					          		return 0;		/* [stz] data area extended */
+					        	} else {
+				                  	return -2;		/* [stzg] data area */
+				                }  	
+				      		} 		          		
+				      		break;
+				      		
+				    	case CONST:
+				    		name = XSTR (XEXP (XEXP (addr, 0), 0), 0);
+
+							/* It is -2 except in the case of "dafault data area". */
+				      		if ( ( ENCODED_NAME_P (name) ) ){
+				      			if( (TARGET_EXT_ZDA && ZDA_NAME_P (name))
+					            		|| (TARGET_EXT_TDA && TDA_NAME_P (name))
+					            		|| (TARGET_EXT_SDA && SDA_NAME_P (name)) ){
+					          		return 0;		/* [stz] data area extended */
+					        	} else {
+				                  	return -2;		/* [stzg] data area */
+				                }  	
+				      		} 
+				      		break;
+				    }	
+		    }
+		}		    
+    }	
+   	/* ADD K.Watanabe V1.4 <<<<<<< */
+   	
+   	/* ADD K.Watanabe V1.7 >>>>>>> */
+   	/* C33: Add the process because the adjustment of instruction lengths was not described
+   	        in the case of outputting multiple shift instrcutions.                          */
+   	        
+	if( ( GET_CODE (pat) == PARALLEL )
+		&& ( GET_CODE (XVECEXP (pat, 0, 0)) == SET ) ){
+		
+      	rtx p = XVECEXP (pat, 0, 0);
+  	   	enum rtx_code code;
+      	code = GET_CODE (SET_SRC (p));
+		if( ( code == ASHIFTRT )
+	      		|| ( code == LSHIFTRT )
+	      		|| ( code == ASHIFT )
+	      		|| ( code == ROTATE )
+	      		|| ( code == ROTATERT ) ) {
+			if( GET_CODE( XEXP (SET_SRC (p), 1) ) == CONST_INT ){
+		      	int n = INTVAL( (XEXP (SET_SRC (p), 1)) ) & 0x1f;
+				int i_ret = 0;
+				
+				if ((code == LSHIFTRT) && (n > 27)){
+          			;
+        		} else if ((code == ASHIFT) && (n > 27)){
+          			;
+        		} else {
+          			/* C33: Inverse the rotate in the case of 16 or more. */
+          			if ((code == ROTATE) && (n > 16)){
+               			n = 32 - n;
+            		} else if ((code == ROTATERT) && (n > 16)) {
+              			n = 32 - n;
+            		}
+			        while (n > 8){
+			        	n -= 8;
+					    i_ret += 2;
+			        }
+			    }		        
+			    return i_ret;
+		    }
+		}
+    }
+	/* ADD K.Watanabe V1.7 <<<<<<< */
+   	   	
+  	return 0;
+}
+
+
+/* ADD K.Watanabe V1.7 >>>>>>> */
+const struct attribute_spec c33_attribute_table[] =
+{
+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
+  { "interrupt_handler", 0, 0, true,  false, false, c33_handle_interrupt_attribute },
+  { "section",           0, 0, true,  false, false, c33_handle_section_attribute },  
+  { "sda",               0, 0, true,  false, false, c33_handle_data_area_attribute },
+  { "tda",               0, 0, true,  false, false, c33_handle_data_area_attribute },
+  { "zda",               0, 0, true,  false, false, c33_handle_data_area_attribute },  
+  { NULL,                0, 0, false, false, false, NULL }
+};
+
+
+/* Handle an "interrupt" attribute; arguments as in            */
+/*  struct attribute_spec.handler.                             */
+/* C33: Quoted from v850.                                      */
+static tree
+c33_handle_interrupt_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning ("`%s' attribute only applies to functions",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+
+static tree
+c33_handle_section_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning ("`%s' attribute only applies to functions",
+	       IDENTIFIER_POINTER (name));
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
+
+/* Handle a "sda", "tda" or "zda" attribute; arguments as in   */
+/*  struct attribute_spec.handler.                             */
+/* C33: Quoted from v850.
+        The following function is correspond to that which is removed "interrupt_handler"
+        from c33_valid_machine_decl_attribute() in v2.95.2.                                */
+static tree
+c33_handle_data_area_attribute (node, name, args, flags, no_add_attrs)
+     tree *node;
+     tree name;
+     tree args ATTRIBUTE_UNUSED;
+     int flags ATTRIBUTE_UNUSED;
+     bool *no_add_attrs;
+{
+  c33_data_area data_area;
+  c33_data_area area;
+  tree decl = *node;
+  
+  /* Implement data area attribute.  */
+  if (is_attribute_p ("sda", name))
+    {
+      if (gp_max < 4)
+        {
+          error_with_decl (decl, "data area of '%s' cannot be specified for 'sda'.");
+          return NULL_TREE;
+        }
+      else if (TREE_CODE (decl) == FUNCTION_DECL)
+        {
+          error_with_decl (decl, "'%s' cannot be specified for 'sda'.");
+          return NULL_TREE;
+        }
+      else
+        data_area = DATA_AREA_SDA;
+    }
+  else if (is_attribute_p ("tda", name))
+    {
+      if (gp_max < 3)
+        {
+          error_with_decl (decl, "data area of '%s' cannot be specified for 'tda'.");
+          return NULL_TREE;
+        }
+      else if (TREE_CODE (decl) == FUNCTION_DECL)
+        {
+          error_with_decl (decl, "'%s' cannot be specified for 'tda'.");
+          return NULL_TREE;
+        }
+      else
+        data_area = DATA_AREA_TDA;
+    }
+  else if (is_attribute_p ("zda", name))
+    {
+      if (gp_max < 2)
+        {
+          error_with_decl (decl, "data area of '%s' cannot be specified for 'zda'.");
+          return NULL_TREE;
+        }
+      else if (TREE_CODE (decl) == FUNCTION_DECL)
+        {
+          error_with_decl (decl, "'%s' cannot be specified for 'zda'.");
+          return NULL_TREE;
+        }
+      else
+        data_area = DATA_AREA_ZDA;
+    }
+  else
+    abort ();
+  
+  switch (TREE_CODE (decl))
+    {
+    case VAR_DECL:
+      if (current_function_decl != NULL_TREE)
+	error_with_decl (decl, "\
+a data area attribute cannot be specified for local variables");
+      
+      /* Drop through.  */
+
+    case FUNCTION_DECL:
+      area = c33_get_data_area (decl);
+      if (area != DATA_AREA_NORMAL && data_area != area)
+	error_with_decl (decl, "\
+data area of '%s' conflicts with previous declaration");
+      
+      break;
+      
+    default:
+      break;
+    }
+  
+  return NULL_TREE;
+}
+
+
+static void
+c33_encode_section_info (decl, first)
+     tree decl;
+     int first;
+{
+  if (first && TREE_CODE (decl) == VAR_DECL
+      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))
+    c33_encode_data_area (decl);
+}
+
+
+static void
+c33_asm_out_constructor (symbol, priority)
+     rtx symbol;
+     int priority ATTRIBUTE_UNUSED;
+{
+    ctors_section ();							
+    fprintf (asm_out_file, "\t%s\t ", ".long");	
+    assemble_name (asm_out_file, XSTR (symbol, 0));				
+    fprintf (asm_out_file, "\n");					
+}
+
+
+static void
+c33_asm_out_destructor (symbol, priority)
+     rtx symbol;
+     int priority ATTRIBUTE_UNUSED;
+{
+    dtors_section ();                   		
+    fprintf (asm_out_file, "\t%s\t ", ".long");		
+    assemble_name (asm_out_file, XSTR (symbol, 0));              	
+    fprintf (asm_out_file, "\n");						
+}
+
+/* CHG K.Watanabe V1.7 >>>>>>> */
+#if 0
+/*****************************************************************************************************
+Format		: static void c33_unique_section (tree decl,int reloc)
+Input		: tree decl
+              int reloc
+Output		: None
+Return		: None
+Explanation	: ・Output ".gnu.linkonce." section.
+              ・Created from mips_unique_section() in mips.c.
+              ・Do not output ".gnu.linkonce." section of "S/T/Z/G" data area 
+                because "S/T/Z/G" data area is not supported no more.
+                The following function is described as comment for preparation in the case that 
+                "S/T/Z/G" data area is supported.
+                If "S/T/Z/G" data area is supported in the future, the description is needed 
+                in the "*.lds" file for ".gnu.linkonce." section of "S/T/Z/G" data area.
+*****************************************************************************************************/
+static void
+c33_unique_section (decl, reloc)
+     tree decl;
+     int reloc;
+{
+  int len;							
+  char *name, *string, *prefix;					
+  static const char *const cp_prefixes[11][2] = {
+    { ".text.", ".gnu.linkonce.t." },
+    { ".rozdata.", ".gnu.linkonce.zr." },
+    { ".rotdata.", ".gnu.linkonce.tr." },
+    { ".rosdata.", ".gnu.linkonce.sr." },
+    { ".rodata.", ".gnu.linkonce.r." },
+    { ".rodata.", ".gnu.linkonce.r." },
+    { ".zdata.", ".gnu.linkonce.zd." },
+    { ".tdata.", ".gnu.linkonce.td." },
+    { ".sdata.", ".gnu.linkonce.sd." },
+    { ".gdata.", ".gnu.linkonce.gd." },
+    { ".data.", ".gnu.linkonce.d." }
+  };
+  int i_sec;
+  			
+  	i_sec = -1;							
+	name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));	
+	name = (* targetm.strip_name_encoding) (name);		
+					
+    if (TREE_CODE (decl) == FUNCTION_DECL){
+		i_sec = 0;	
+	} else if (DECL_INITIAL (decl) == 0
+           || DECL_INITIAL (decl) == error_mark_node) {
+		switch (c33_get_data_area (decl)){
+	    	case DATA_AREA_ZDA:	
+				// i_sec = 6;			// C33: Not supported.
+	    		break;
+	        case DATA_AREA_TDA:	
+				// i_sec = 7;			// C33: Not supported.
+	        	break;
+	        case DATA_AREA_SDA:	
+				// i_sec = 8;			// C33: Not supported.
+	        	break;
+	        case DATA_AREA_GDA:	
+				// i_sec = 9;			// C33: Not supported.
+	        	break;
+	        default:
+				i_sec = 10;
+	        	break;	
+        }		
+    } else if (decl_readonly_section (decl, reloc)) {
+		switch (c33_get_data_area (decl)){
+	    	case DATA_AREA_ZDA:	
+				// i_sec = 1;			// C33: Not supported.
+	    		break;
+	        case DATA_AREA_TDA:	
+				// i_sec = 2;			// C33: Not supported.
+	        	break;
+	        case DATA_AREA_SDA:	
+				// i_sec = 3;			// C33: Not supported.
+	        	break;
+	        case DATA_AREA_GDA:	
+				// i_sec = 4;			// C33: Not supported.
+	        	break;
+	        default:
+				i_sec = 5;
+	        	break;	
+        }
+    } else {						
+		switch (c33_get_data_area (decl)){
+	    	case DATA_AREA_ZDA:	
+				// i_sec = 6;			// C33: Not supported.
+	    		break;
+	        case DATA_AREA_TDA:	
+				// i_sec = 7;			// C33: Not supported.
+	        	break;
+	        case DATA_AREA_SDA:	
+				// i_sec = 8;			// C33: Not supported.
+	        	break;
+	        case DATA_AREA_GDA:	
+				// i_sec = 9;			// C33: Not supported.
+	        	break;
+	        default:
+				i_sec = 10;
+	        	break;	
+        }				
+    }							
+	    
+	if( i_sec != -1 ){
+	    prefix = cp_prefixes[i_sec][DECL_ONE_ONLY (decl)];
+	      	
+	  	len = strlen (name) + strlen (prefix);		
+	  	string = alloca (len + 1);					
+	  	sprintf (string, "%s%s", prefix, name);			
+										
+	  	DECL_SECTION_NAME (decl) = build_string (len, string);	
+	}	  	
+}
+#endif
+
+/* C33: Do not output "gnu.linkonce." because the address calculation is sometimes not correct
+        at the time of linking in V1.7 release.                                                */
+static void
+c33_unique_section (decl, reloc)
+     tree decl;
+     int reloc;
+{
+	
+}
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+/* When assemble_integer is used to emit the offsets for a switch
+   table it can encounter (TRUNCATE:HI (MINUS:SI (LABEL_REF:SI) (LABEL_REF:SI))).
+   output_addr_const will normally barf at this, but it is OK to omit
+   the truncate and just emit the difference of the two labels.  The
+   .hword directive will automatically handle the truncation for us.
+   Returns 1 if rtx was handled, 0 otherwise.  */
+/* C33: Quoted from v850. */
+
+int
+c33_output_addr_const_extra (file, x)
+     FILE * file;
+     rtx x;
+{
+  if (GET_CODE (x) != TRUNCATE)
+    return 0;
+
+  x = XEXP (x, 0);
+
+  /* We must also handle the case where the switch table was passed a
+     constant value and so has been collapsed.  In this case the first
+     label will have been deleted.  In such a case it is OK to emit
+     nothing, since the table will not be used.
+     (cf gcc.c-torture/compile/990801-1.c).  */
+  if (GET_CODE (x) == MINUS
+      && GET_CODE (XEXP (x, 0)) == LABEL_REF
+      && GET_CODE (XEXP (XEXP (x, 0), 0)) == CODE_LABEL
+      && INSN_DELETED_P (XEXP (XEXP (x, 0), 0)))
+    return 1;
+
+  output_addr_const (file, x);
+  return 1;
+}
+
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+
+// ADD K.Watanabe V1.8 >>>>>>>
+static const char *
+c33_strip_name_encoding (str)
+     const char *str;
+{
+  return str + ENCODED_NAME_P (str);
+}
+// ADD K.Watanabe V1.8 <<<<<<<
diff --git a/gcc/config/c33/c33.h b/gcc/config/c33/c33.h
new file mode 100644
index 0000000..2a7273e
--- /dev/null
+++ b/gcc/config/c33/c33.h
@@ -0,0 +1,2347 @@
+/* Definitions of target machine for GNU compiler. EPSON C33 series
+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+   Contributed by Jeff Law (law@cygnus.com).
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Delete the following line, because it is specified to include 
+        in the order of dbxelf.h / elfos.h / svr4.h / c33.h
+        in gcc/config.gcc. ( reference to v850 )                       */
+
+/* #include "svr4.h"	*//* Automatically does #undef CPP_PREDEFINES */
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/**************************************************************/
+/* C33: Definition is necessary to correspond to C+           */
+/**************************************************************/
+/* Don't assume anything about the header files.  */
+#define NO_IMPLICIT_EXTERN_C
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/*******************************************************************************/
+/* C33: Definition is necessary to re-define in c33.h, 
+        this definition was described in svr4.h in v2.95.2.                    */
+/*******************************************************************************/
+
+/* This is how to allocate empty space in some section.  The .zero
+   pseudo-op is used for this on most c33 assemblers.  */
+#undef  SKIP_ASM_OP   
+#define SKIP_ASM_OP	".zero"
+
+#undef ASM_OUTPUT_SKIP
+#define ASM_OUTPUT_SKIP(FILE,SIZE) \
+  fprintf (FILE, "\t%s\t%u\n", SKIP_ASM_OP, (SIZE))
+
+#undef  READONLY_DATA_SECTION
+#define READONLY_DATA_SECTION() const_section ()
+
+#undef ALIGN_ASM_OP
+#define ALIGN_ASM_OP ".align"
+
+
+// CHG K.Watanabe V1.8 >>>>>>>
+#if 0
+#undef  ASM_OUTPUT_EXTERNAL_LIBCALL
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)				\
+  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))
+#endif
+
+#undef  ASM_OUTPUT_EXTERNAL_LIBCALL
+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)				\
+    do { fputs ("\t.global ", FILE); assemble_name (FILE, XSTR (FUN, 0)); fputs ("\n", FILE);} while (0)
+// CHG K.Watanabe V1.8 <<<<<<<
+
+
+// DEL K.Watanabe V1.8 >>>>>>>
+#if 0
+#define ASM_GLOBALIZE_LABEL(FILE, NAME)	\
+  do { fputs ("\t.global ", FILE); assemble_name (FILE, NAME); fputs ("\n", FILE);} while (0)
+#endif
+// DEL K.Watanabe V1.8 <<<<<<<
+
+
+/* Define the strings used for the special c33 .type and .size directives.
+   These strings generally do not vary from one system running c33 to
+   another, but if a given system (e.g. m88k running svr) needs to use
+   different pseudo-op names for these, they may be overridden in the
+   file which includes this one.  */
+
+#undef  TYPE_ASM_OP
+#define TYPE_ASM_OP	".type"
+
+#undef  SIZE_ASM_OP
+#define SIZE_ASM_OP	".size"
+
+/* C33: Define the following definitions in order not to create _main() function,
+        though they are unused sections.                                          */
+#undef INIT_SECTION_ASM_OP
+#define INIT_SECTION_ASM_OP	".section\t.init"
+#undef FINI_SECTION_ASM_OP
+#define FINI_SECTION_ASM_OP	".section\t.fini"
+
+
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/* C33: Set #undef because the linker did not correspond to weak symbol
+        at the time of releasing of GNU33 V1.7.                          */
+#undef ASM_WEAKEN_LABEL
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+
+/* These macros generate the special .type and .size directives which
+   are used to set the corresponding fields of the linker symbol table
+   entries in an ELF object file under c33.  These macros also output
+   the starting labels for the relevant functions/objects.  */
+   
+
+/* C33: If the following four definitions is used, a warning occurrs.
+        Probably the linker is too old.                                       
+   ASM_DECLARE_FUNCTION_NAME -- definition of v2.95.2                         
+   ASM_DECLARE_OBJECT_NAME   -- definition of v2.95.2                         
+   ASM_FINISH_DECLARE_OBJECT -- definition of v2.95.2                         
+   ASM_DECLARE_FUNCTION_SIZE -- definition of of v3.3.2 in rs6000/linux64.h   */
+
+/* Write the extra assembler code needed to declare a function properly.
+   Some c33 assemblers need to also have something extra said about the
+   function's return value.  We allow for that here.  */
+
+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
+  do {									\
+    fprintf (FILE, "\t%s\t ", TYPE_ASM_OP);				\
+    assemble_name (FILE, NAME);						\
+    putc (',', FILE);							\
+    fprintf (FILE, TYPE_OPERAND_FMT, "function");			\
+    putc ('\n', FILE);							\
+    ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));			\
+    ASM_OUTPUT_LABEL(FILE, NAME);					\
+  } while (0)
+
+/* Write the extra assembler code needed to declare an object properly.  */
+
+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)			\
+  do {									\
+    fprintf (FILE, "\t%s\t ", TYPE_ASM_OP);				\
+    assemble_name (FILE, NAME);						\
+    putc (',', FILE);							\
+    fprintf (FILE, TYPE_OPERAND_FMT, "object");				\
+    putc ('\n', FILE);							\
+    size_directive_output = 0;						\
+    if (!flag_inhibit_size_directive && DECL_SIZE (DECL))		\
+      {									\
+	size_directive_output = 1;					\
+	fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);				\
+	assemble_name (FILE, NAME);					\
+	putc (',', FILE);						\
+	fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,				\
+		 int_size_in_bytes (TREE_TYPE (DECL)));			\
+	fputc ('\n', FILE);						\
+      }									\
+    ASM_OUTPUT_LABEL(FILE, NAME);					\
+  } while (0)
+
+/* Output the size directive for a decl in rest_of_decl_compilation
+   in the case where we did not do so before the initializer.
+   Once we find the error_mark_node, we know that the value of
+   size_directive_output was set
+   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */
+
+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)	 \
+do {									 \
+     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);			 \
+     if (!flag_inhibit_size_directive && DECL_SIZE (DECL)		 \
+         && ! AT_END && TOP_LEVEL					 \
+	 && DECL_INITIAL (DECL) == error_mark_node			 \
+	 && !size_directive_output)					 \
+       {								 \
+	 size_directive_output = 1;					 \
+	 fprintf (FILE, "\t%s\t ", SIZE_ASM_OP);			 \
+	 assemble_name (FILE, name);					 \
+	 putc (',', FILE);						 \
+	 fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,			 \
+		  int_size_in_bytes (TREE_TYPE (DECL))); 		 \
+	fputc ('\n', FILE);						 \
+       }								 \
+   } while (0)
+
+/* This is how to declare the size of a function.  */
+#define	ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)			\
+  do									\
+    {									\
+      if (!flag_inhibit_size_directive)					\
+	{								\
+	  fputs ("\t.size\t.", (FILE));					\
+	  assemble_name ((FILE), (FNAME));				\
+	  fputs (",.-.", (FILE));					\
+	  assemble_name ((FILE), (FNAME));				\
+	  putc ('\n', (FILE));						\
+	}								\
+    }									\
+  while (0)
+  
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+
+#define GCC33_VERSION "20070709R"
+
+/*************/
+/* A: Driver */
+/*************/
+#undef ASM_SPEC
+#define ASM_SPEC "%{mc33adv:-mc33adv} %{mc33pe:-mc33pe} %{medda32:-medda32} %{mc33401:-mc33401} %{mc33401_2:-mc33401_2}"
+
+#define CPP_SPEC "\
+                  %{mc33adv:-D__c33adv} \
+                  %{mc33pe:-D__c33pe} \
+                  %{mc33401:-D__c33401} \
+                  %{mc33401_2:-D__c33401_2} \
+                  %{!mc33401:%{!mc33401_2:%{!mc33adv:%{!mc33pe:-D__c33std}}}} \
+                 "
+
+#undef LIB_SPEC
+#undef ENDFILE_SPEC 
+#undef LINK_SPEC
+#undef STARTFILE_SPEC 
+#define LIB_SPEC ""
+#define STARTFILE_SPEC "" 
+
+/**********************/
+/* B: Run-time Target */
+/**********************/
+
+/* C33: If the following line is not defined, a compile error occurrs.  */
+/* Names to predefine in the preprocessor for this target machine.  */
+#define CPP_PREDEFINES "-D__c33"
+
+/* Run-time compilation parameters selecting different hardware subsets.  */
+
+extern int target_flags;
+
+/* Target flags bits, see below for an explanation of the bits.  */
+#define MASK_LONG_CALLS		0x00000001
+#define MASK_MEMCPY		0x00000002	/* call memcpy instead of inline code*/
+#define MASK_DEBUG		0x40000000
+
+#define MASK_C33                0x00000010
+#define MASK_C33ADV             0x00000020
+#define MASK_C33PE              0x00000040
+
+#define MASK_C33401             0x00000000
+#define MASK_C33401_2           0x00000000 
+
+#define MASK_ADDRESSES		0x00000100
+
+#define MASK_EXT_ZDA		0x00001000
+#define MASK_EXT_TDA		0x00002000
+#define MASK_EXT_SDA		0x00004000
+#define MASK_EXT_32			0x00008000					/* ADD K.Watanabe V1.4 */
+
+#ifndef MASK_DEFAULT
+#define MASK_DEFAULT            MASK_C33
+#endif
+
+#define TARGET_C33    		(target_flags & MASK_C33)
+#define TARGET_C33ADV   	(target_flags & MASK_C33ADV)
+#define TARGET_C33PE    	(target_flags & MASK_C33PE)
+
+
+/* Macros used in the machine description to test the flags.  */
+
+/* C33: Distinguish function call with one ext from function call with two ext. */
+#define TARGET_LONG_CALLS	(target_flags & MASK_LONG_CALLS)
+
+/* call memcpy instead of inline code */
+#define TARGET_MEMCPY		(target_flags & MASK_MEMCPY)
+
+/* General debug flag */
+#define TARGET_DEBUG		(target_flags & MASK_DEBUG)
+
+/* Dump recorded insn lengths into the output file.  This helps debug the
+   md file.  */
+#define TARGET_ADDRESSES	(target_flags & MASK_ADDRESSES)
+
+#define TARGET_EXT_ZDA		(target_flags & MASK_EXT_ZDA)
+#define TARGET_EXT_TDA		(target_flags & MASK_EXT_TDA)
+#define TARGET_EXT_SDA		(target_flags & MASK_EXT_SDA)
+#define TARGET_EXT_32		(target_flags & MASK_EXT_32)		/* ADD K.Watanabe V1.4 */
+
+/* Macro to define tables used to set the flags.
+   This is a list in braces of pairs in braces,
+   each pair being { "NAME", VALUE }
+   where VALUE is the bits to set or minus the bits to clear.
+   An empty string NAME is used to identify the default VALUE.  */
+
+#define TARGET_SWITCHES	{						\
+   { "long-calls",		MASK_LONG_CALLS }, 			\
+   { "no-long-calls",		-MASK_LONG_CALLS },			\
+   { "memcpy",			MASK_MEMCPY },				\
+   { "no-memcpy",		-MASK_MEMCPY },				\
+   { "debug",			MASK_DEBUG },				\
+   { "c33",			MASK_C33 },				\
+   { "c33adv",			MASK_C33ADV },				\
+   { "c33401",			MASK_C33401 },				\
+   { "c33401_2",		MASK_C33401_2 },				\
+   { "c33pe",			MASK_C33PE },				\
+   { "addresses",	       	MASK_ADDRESSES },			\
+   { "ezda",		       	MASK_EXT_ZDA },				\
+   { "etda",		       	MASK_EXT_TDA },				\
+   { "esda",		       	MASK_EXT_SDA },				\
+   { "edda32",	       		MASK_EXT_32 },				\
+   EXTRA_SWITCHES							\
+   { "",			TARGET_DEFAULT}}
+
+#ifndef EXTRA_SWITCHES
+#define EXTRA_SWITCHES
+#endif
+
+#ifndef TARGET_DEFAULT
+#define TARGET_DEFAULT 		MASK_DEFAULT | MASK_MEMCPY
+#endif
+
+
+/* Print subsidiary information on the compiler version in use.  */
+
+#ifndef TARGET_VERSION
+/* >>>>> change iruma m.takeishi '03.09.22 */
+/*
+#define TARGET_VERSION fprintf (stderr, " (EPSON C33)");
+*/
+
+/* c33 xgcc, cpp, cc1 version */
+/* if version is upped, change below version. */
+#define C33_TARGET_VERSION " (EPSON C33, rev 1.8 '07.07.09)"
+
+#define TARGET_VERSION fprintf (stderr, C33_TARGET_VERSION);
+/* <<<<< change iruma m.takeishi '03.09.22 */
+#endif
+
+/* CHG K.Watanabe V1.7 >>>>>>> */
+#if 0
+#ifndef TARGET_VERSION_INTERNAL
+#define TARGET_VERSION_INTERNAL(STREAM)					\
+  fprintf (STREAM, " --- gcc33v2 %s", GCC33_VERSION)
+#endif
+#endif
+
+#ifndef TARGET_VERSION_INTERNAL
+#define TARGET_VERSION_INTERNAL(STREAM)					\
+  fprintf (STREAM, " --- gcc33 %s", GCC33_VERSION)
+#endif
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+/* Information about the various small memory areas.  */
+struct small_memory_info {
+  char *name;
+  char *value;
+  long max;
+  long physical_max;
+};
+
+enum small_memory_type {
+  /* gp1 data area, using R12 as base register */
+  SMALL_MEMORY_SDA = 0,
+  /* gp2 data area, using R13 as base register */
+  SMALL_MEMORY_TDA,
+  /* gp3 data area, using R14 as base register */
+  SMALL_MEMORY_ZDA,
+  /* gp4 data area, using R15 as base register */
+  SMALL_MEMORY_GDA,
+  SMALL_MEMORY_max
+};
+
+extern struct small_memory_info small_memory[(int)SMALL_MEMORY_max];
+
+
+extern char *c33_cpu_string;
+extern char *gp_no;
+extern int  gp_max;
+extern char *gdp_string;
+
+/* This macro is similar to `TARGET_SWITCHES' but defines names of
+   command options that have values.  Its definition is an
+   initializer with a subgrouping for each command option.
+
+   Each subgrouping contains a string constant, that defines the
+   fixed part of the option name, and the address of a variable.  The
+   variable, type `char *', is set to the variable part of the given
+   option if the fixed part matches.  The actual option name is made
+   by appending `-m' to the specified name.
+
+   Here is an example which defines `-mshort-data-NUMBER'.  If the
+   given option is `-mshort-data-512', the variable `m88k_short_data'
+   will be set to the string `"512"'.
+
+          extern char *m88k_short_data;
+          #define TARGET_OPTIONS \
+           { { "short-data-", &m88k_short_data } } */
+
+#define TARGET_OPTIONS							\
+{									\
+  { "cpu=",	&c33_cpu_string, "" },					\
+  { "cpu-",	&c33_cpu_string, "" },					\
+  { "dp=",	&gp_no, "" },						\
+  { "dp-",	&gp_no, "" },						\
+  { "gda=",	&small_memory[ (int)SMALL_MEMORY_GDA ].value, 		\
+      "Set the max size of data eligible for the GDA area"  },		\
+  { "gda-",	&small_memory[ (int)SMALL_MEMORY_GDA ].value, "" },	\
+  { "gdp=",	&gdp_string, "" },					\
+  { "gdp-",	&gdp_string, "" },					\
+}
+
+#define C33_CPU_STRING_DEFAULT	        "S1C332xx"
+#define C33_CPU_STRING_DEFAULT_ADVANCED	"S1C334xx"
+#define C33_CPU_STRING_DEFAULT_C33PE	"S1C336xx"
+
+/* Sometimes certain combinations of command options do not make
+   sense on a particular target machine.  You can define a macro
+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if
+   defined, is executed once just after all the command options have
+   been parsed.
+
+   Don't use this macro to turn on various extra optimizations for
+   `-O'.  That is what `OPTIMIZATION_OPTIONS' is for.  */
+#define OVERRIDE_OPTIONS override_options ()
+
+
+/* Show we can debug even without a frame pointer.  */
+#define CAN_DEBUG_WITHOUT_FP
+
+
+/* Some machines may desire to change what optimizations are
+   performed for various optimization levels.   This macro, if
+   defined, is executed once just after the optimization level is
+   determined and before the remainder of the command options have
+   been parsed.  Values set in this macro are used as the default
+   values for the other command line options.
+
+   LEVEL is the optimization level specified; 2 if `-O2' is
+   specified, 1 if `-O' is specified, and 0 if neither is specified.
+
+   You should not use this macro to change options that are not
+   machine-specific.  These should uniformly selected by the same
+   optimization level on all supported machines.  Use this macro to
+   enable machine-specific optimizations.
+
+   *Do not examine `write_symbols' in this macro!* The debugging
+   options are not supposed to alter the generated code. */
+
+/* C33: "flag_omit_frame_pointer = 1" is default when you specify the optimize. */
+#define OPTIMIZATION_OPTIONS(LEVEL, SIZE)				\
+{									\
+  if (LEVEL >= 0)							\
+    flag_omit_frame_pointer = 1;					\
+									\
+  /* C33: Disable the following flgas in C33, though elabled in -O2 and over. */	\
+  flag_schedule_insns = 0;						\
+  flag_schedule_insns_after_reload = 0;					\
+                                                                        \
+  /* C33: "-fno-common" shall be dafault in C33. GNU-GCC-050 2002/6/4 watanabe */     \
+  flag_no_common = 1;                                                   \
+}
+
+/* >>>>> add iruma m.takeishi '03.09.22 */
+/* C33:  Define the following line in order to work EPSON-code in gcc core files. */
+#define EPSON 1
+/* <<<<< add iruma m.takeishi '03.09.22 */
+
+
+
+
+/*********************/
+/* C: Storage Layout */
+/*********************/
+
+/* Target machine storage layout */
+
+/* Define this if most significant bit is lowest numbered
+   in instructions that operate on numbered bit-fields.
+   This is not true on the EPSON C33.  */
+#define BITS_BIG_ENDIAN 0
+/* C33: C33 is little endian. */
+
+/* Define this if most significant byte of a word is the lowest numbered.  */
+/* This is not true on the EPSON C33.  */
+#define BYTES_BIG_ENDIAN 0
+
+/* Define this if most significant word of a multiword number is lowest
+   numbered.
+   This is not true on the EPSON C33.  */
+#define WORDS_BIG_ENDIAN 0
+
+/* Number of bits in an addressable storage unit */
+#define BITS_PER_UNIT 8
+
+/* Width in bits of a "word", which is the contents of a machine register.
+   Note that this is not necessarily the width of data type `int';
+   if using 16-bit ints on a 68000, this would still be 32.
+   But on a machine with 16-bit registers, this would be 16.  */
+#define BITS_PER_WORD		32
+
+/* Width of a word, in units (bytes).  */
+#define UNITS_PER_WORD		4
+
+/* Width in bits of a pointer.
+   See also the macro `Pmode' defined below.  */
+#define POINTER_SIZE 		32
+
+/* Define this macro if it is advisable to hold scalars in registers
+   in a wider mode than that declared by the program.  In such cases,
+   the value is constrained to be within the bounds of the declared
+   type, but kept valid in the wider mode.  The signedness of the
+   extension may differ from that of the type.
+
+   Some simple experiments have shown that leaving UNSIGNEDP alone
+   generates the best overall code.  */
+
+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \
+  if (GET_MODE_CLASS (MODE) == MODE_INT \
+      && GET_MODE_SIZE (MODE) < 4)      \
+    { (MODE) = SImode; }
+
+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */
+#define PARM_BOUNDARY		32
+
+/* The stack goes in 32 bit lumps.  */
+#define STACK_BOUNDARY 		32
+
+/* Allocation boundary (in *bits*) for the code of a function.
+   16 is the minimum boundary; 32 would give better performance.  */
+#define FUNCTION_BOUNDARY	16
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT	32
+
+/* No structure field wants to be aligned rounder than this.  */
+#define BIGGEST_FIELD_ALIGNMENT 32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY	32
+
+/* C33: The alignment of ".data" section shall be 4 byte boundary. */
+/* If defined, a C expression to compute the alignment for a static
+   variable.  TYPE is the data type, and ALIGN is the alignment that
+   the object would ordinarily have.  The value of this macro is used
+   instead of that alignment to align the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   One use of this macro is to increase alignment of medium-size
+   data to make it all fit in fewer cache lines.  Another is to
+   cause character arrays to be word-aligned so that `strcpy' calls
+   that copy constants to character arrays can be done inline.  */
+
+#undef DATA_ALIGNMENT
+#define DATA_ALIGNMENT(TYPE, ALIGN)					\
+  ((((ALIGN) < BITS_PER_WORD)						\
+    && (TREE_CODE (TYPE) == ARRAY_TYPE					\
+	|| TREE_CODE (TYPE) == UNION_TYPE				\
+	|| TREE_CODE (TYPE) == RECORD_TYPE)) ? BITS_PER_WORD : (ALIGN))
+
+/* C33: The alignment of ".data" section shall be 4 byte boundary. */
+/* If defined, a C expression to compute the alignment given to a
+   constant that is being placed in memory.  CONSTANT is the constant
+   and ALIGN is the alignment that the object would ordinarily have.
+   The value of this macro is used instead of that alignment to align
+   the object.
+
+   If this macro is not defined, then ALIGN is used.
+
+   The typical use of this macro is to increase alignment for string
+   constants to be word aligned so that `strcpy' calls that copy
+   constants can be done inline.  */
+
+#define CONSTANT_ALIGNMENT(EXP, ALIGN)					\
+  ((TREE_CODE (EXP) == STRING_CST  || TREE_CODE (EXP) == CONSTRUCTOR)	\
+   && (ALIGN) < BITS_PER_WORD						\
+	? BITS_PER_WORD							\
+	: (ALIGN))
+
+/* Define this if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 1
+
+/******************/
+/* D: Type Layout */
+/******************/
+
+/* Define this as 1 if `char' should by default be signed; else as 0.
+
+   On the EPSON C33, loads do sign extension, so make this default. */
+#define DEFAULT_SIGNED_CHAR 1
+
+/* Define results of standard character escape sequences.  */
+#define TARGET_BELL 007
+#define TARGET_BS 010
+#define TARGET_TAB 011
+#define TARGET_NEWLINE 012
+#define TARGET_VT 013
+#define TARGET_FF 014
+#define TARGET_CR 015
+#define TARGET_ESC 033		/* ADD K.Watanabe V1.7 */
+
+/****************/
+/* E: Registers */
+/****************/
+
+/* Standard register usage.  */
+
+/* Number of actual hardware registers.
+   The hardware registers are assigned numbers for the compiler
+   from 0 to just below FIRST_PSEUDO_REGISTER.
+
+   All registers that the compiler knows about must be given numbers,
+   even those that are not normally considered general registers.  */
+
+
+/* %r0-%r15, .fp, .ap, %sp */
+#define FIRST_PSEUDO_REGISTER 19
+
+/* C33: New register arrangement in C33.
+	%r0-%r3		saved
+	%r4-%r5 	return
+	%r6-%r9		argument
+	%r10-%r15	fixed/gp */
+
+/* 1 for registers that have pervasive standard uses
+   and are not available for the register allocator.  */
+
+
+/* C33: Registers that the compiler can use. */
+#define FIXED_REGISTERS \
+  { 0, 0, 0, 0, 0, 0, 0, 0, \
+    0, 0, 1, 1, 1, 1, 1, 1, \
+    1, 1, 1 }
+
+/* 1 for registers not available across function calls.
+   These must include the FIXED_REGISTERS and also any
+   registers that can be used without being saved.
+   The latter must include the registers where values are returned
+   and the register where structure-value addresses are passed.
+   Aside from that, you can include as many other registers as you
+   like.  */
+
+
+/* C33: Registers used between function calls. */
+#define CALL_USED_REGISTERS \
+  { 0, 0, 0, 0, 1, 1, 1, 1, \
+    1, 1, 1, 1, 1, 1, 1, 1, \
+    1, 1, 1 }
+
+/* C33: ADD scratch registers by "-mgp=n". */
+#define CONDITIONAL_REGISTER_USAGE					\
+{									\
+  int regno;								\
+  for (regno = 6 - gp_max; regno > 0; regno--) {			\
+      fixed_regs[9 + regno] = 0;					\
+  }									\
+}
+
+/* List the order in which to allocate registers.  Each register must be
+   listed once, even those in FIXED_REGISTERS. */
+
+/* C33: Change the priority of register assignment. 
+        In order to reduce the use of "push / pop" in the normal function. */
+
+/* C33: Assign registers in the following order in C33.
+        Return gegisters, saved registers, and fixed registers.   */
+/* CHG K.Watanabe V1.4 >>>>>>> */ 
+#if 0
+#define REG_ALLOC_ORDER							\
+{									\
+   4,  5,			/* return registers */			\
+   6,  7,  8,  9,		/* argument registers */		\
+   0,  1,  2,  3,		/* saved registers */			\
+  10, 11, 12, 13,		/* fixed registers */			\
+  14, 15, 16, 17, 18		/* fixed registers */			\
+}
+#endif
+
+#define REG_ALLOC_ORDER							\
+{									\
+   4,  5,				/* return registers */			\
+   6,  7,  8,  9,		/* argument registers */		\
+  11, 12, 13, 14,		/* fixed registers */			\
+  0,  1,  2,  3,		/* saved registers */			\
+  10,													\
+  15, 16, 17, 18		/* fixed registers */			\
+}
+/* CHG K.Watanabe V1.4 <<<<<<< */
+
+
+/* Return number of consecutive hard regs needed starting at reg REGNO
+   to hold something of mode MODE.
+
+   This is ordinarily the length in words of a value of mode MODE
+   but can be less for certain modes in special long registers.  */
+
+/* C33: The number of hard registers needed to save the MODE data. */
+#define HARD_REGNO_NREGS(REGNO, MODE)   \
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* Value is 1 if hard register REGNO can hold a value of machine-mode
+   MODE.  */
+
+/* C33: "OK" is necessary for in even number in order to 
+        treat multi-word type such as double type or long long type.
+        %sp can hold only SI-mode.                                      */
+
+#define HARD_REGNO_MODE_OK(REGNO, MODE)                          \
+   ((((REGNO) == STACK_POINTER_REGNUM)                           \
+      && (GET_MODE_SIZE (MODE) == 4)) ||                         \
+    (((REGNO) != STACK_POINTER_REGNUM)                           \
+      && ((((REGNO) & 1) == 0) || (GET_MODE_SIZE (MODE) <= 4))))
+
+/* Value is 1 if it is a good idea to tie two pseudo registers
+   when one has mode MODE1 and one has mode MODE2.
+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,
+   for any hard reg, then this must be 0 for correct output.  */
+
+/* C33: All registers are same in C33 and any MODE can be held.
+        But the following line corresponds to V850. Just in case. */
+
+#define MODES_TIEABLE_P(MODE1, MODE2) \
+  (MODE1 == MODE2 || GET_MODE_SIZE (MODE1) <= 4 && GET_MODE_SIZE (MODE2) <= 4)
+
+/* This is the order in which to allocate registers for leaf functions.  */
+/* C33: Change the order of register assignment when the function is
+        the interrupt function which is the leaf function.
+        Because C33 can operate pushn/popn opecode only from %r0,
+        so this is the avoidance measure.                             */
+        
+
+#define REG_LEAF_ALLOC_ORDER \
+{  0,  1,  2,  3,  4,  5,	\
+   6,  7,  8,  9, 10,		\
+  11, 12, 13, 14, 15,		\
+  16, 17, 18 }
+
+
+// CHG K.Watanabe V1.8 >>>>>>>
+#if 0
+#define ORDER_REGS_FOR_LOCAL_ALLOC					\
+{									\
+  static int leaf[] = REG_LEAF_ALLOC_ORDER;				\
+  static int nonleaf[] = REG_ALLOC_ORDER;				\
+									\
+  bcopy ((c33_interrupt_function_p () && leaf_function_p()) ?		\
+	 leaf : nonleaf,						\
+         reg_alloc_order, FIRST_PSEUDO_REGISTER * sizeof (int));	\
+}
+#endif
+
+#define ORDER_REGS_FOR_LOCAL_ALLOC					\
+{									\
+  static int leaf[] = REG_LEAF_ALLOC_ORDER;				\
+  static int nonleaf[] = REG_ALLOC_ORDER;				\
+									\
+  memcpy (reg_alloc_order,                                      \
+          (c33_interrupt_function_p () && leaf_function_p()) ?	\
+	    leaf : nonleaf,							\
+          FIRST_PSEUDO_REGISTER * sizeof (int));			\
+}
+// CHG K.Watanabe V1.8 <<<<<<<
+
+
+/***********************/
+/* F: Register Classes */
+/***********************/
+
+/* Define the classes of registers for register constraints in the
+   machine description.  Also define ranges of constants.
+
+   One of the classes must always be named ALL_REGS and include all hard regs.
+   If there is more than one class, another class must be named NO_REGS
+   and contain no registers.
+
+   The name GENERAL_REGS must be the name of a class (or an alias for
+   another name such as ALL_REGS).  This is the class of registers
+   that is allowed by "g" or "r" in a register constraint.
+   Also, registers outside this class are allocated only when
+   instructions express preferences for them.
+
+   The classes must be numbered in nondecreasing order; that is,
+   a larger-numbered class must never be contained completely
+   in a smaller-numbered class.
+
+   For any two classes, it is very desirable that there be another
+   class that represents their union.  */
+
+enum reg_class {
+  NO_REGS, GENERAL_REGS, SP_REGS, BASE_REGS, ALL_REGS, LIM_REG_CLASSES
+};
+
+#define N_REG_CLASSES (int) LIM_REG_CLASSES
+
+/* Give names of register classes as strings for dump file.   */
+
+#define REG_CLASS_NAMES \
+{ "NO_REGS", "GENERAL_REGS", "SP_REGS", "BASE_REGS", "ALL_REGS", "LIM_REGS" }
+
+/* Define which registers fit in which classes.
+   This is an initializer for a vector of HARD_REG_SET
+   of length N_REG_CLASSES.  */
+
+#define REG_CLASS_CONTENTS  			\
+{  0x00000000,		/* No regs      */	\
+   0x0003ffff,		/* GENERAL_REGS */    	\
+   0x00040000,		/* SP_REGS */    	\
+   0x0007ffff,		/* BASE_REGS */    	\
+   0xffffffff,		/* ALL_REGS 	*/	\
+}
+
+/* The same information, inverted:
+   Return the class number of the smallest class containing
+   reg number REGNO.  This could be a conditional expression
+   or could index an array.  */
+
+#define REGNO_REG_CLASS(REGNO) \
+  ((REGNO) == STACK_POINTER_REGNUM ? SP_REGS : GENERAL_REGS)
+
+/* The class value for index registers, and the one for base regs.  */
+
+#define INDEX_REG_CLASS NO_REGS
+#define BASE_REG_CLASS  BASE_REGS
+
+/* Get reg_class from a letter such as appears in the machine description.  */
+#define REG_CLASS_FROM_LETTER(C) ((C) == 'f' ? SP_REGS : NO_REGS)
+
+/* Macros to check register numbers against specific register classes.  */
+
+/* These assume that REGNO is a hard or pseudo reg number.
+   They give nonzero only if REGNO is a hard reg of the suitable class
+   or a pseudo reg currently allocated to a suitable hard reg.
+   Since they use reg_renumber, they are safe only once reg_renumber
+   has been allocated, which happens in local-alloc.c.  */
+
+#define REGNO_OK_FOR_BASE_P(regno) \
+  ((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)
+
+#define REGNO_OK_FOR_INDEX_P(regno) 0
+
+/* Given an rtx X being reloaded into a reg required to be
+   in class CLASS, return the class of reg to actually use.
+   In general this is just CLASS; but on some machines
+   in some cases it is preferable to use a more restrictive class.  */
+
+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)
+
+/* Return the maximum number of consecutive registers
+   needed to represent mode MODE in a register of class CLASS.  */
+
+#define CLASS_MAX_NREGS(CLASS, MODE)	\
+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)
+
+/* The letters I, J, K, L, M, N, O, P in a register constraint string
+   can be used to stand for particular ranges of immediate operands.
+   This macro defines what the ranges are.
+   C is the letter, and VALUE is a constant value.
+   Return 1 if VALUE is in the range specified by C.  */
+
+/* C33: Characters are assigned in C33 as follows.
+	I: unused
+	J: unused
+	K: sign6	ld,add/sub,cmp,and/or/xor
+	L: sign19	ld,add/sub,cmp,and/or/xor
+	M: shift immediate data
+	N: shift immediate data
+	O: shift immediate data
+	P: unused
+*/
+
+#define CONST_OK_FOR_SIGNED6(VALUE)	((unsigned) (VALUE) + 0x20 < 0x40)
+#define CONST_OK_FOR_SIGNED9(VALUE)	((unsigned) (VALUE) + 0x100 < 0x200)
+#define CONST_OK_FOR_SIGNED19(VALUE)	((unsigned) (VALUE) + 0x40000 < 0x80000)
+
+#define	CONST_OK_FOR_IMM6(VALUE)	((unsigned)(VALUE) < 0x40)
+#define	CONST_OK_FOR_IMM7(VALUE)	((unsigned)(VALUE) < 0x80)
+#define	CONST_OK_FOR_IMM8(VALUE)	((unsigned)(VALUE) < 0x100)
+#define	CONST_OK_FOR_IMM13(VALUE)	((unsigned)(VALUE) < 0x2000)
+#define	CONST_OK_FOR_IMM19(VALUE)	((unsigned)(VALUE) < 0x80000)
+#define	CONST_OK_FOR_IMM26(VALUE)	((unsigned)(VALUE) < 0x4000000)
+
+#define	CONST_OK_FOR_M(VALUE)	((unsigned)(VALUE) <= 8)
+#define	CONST_OK_FOR_N(VALUE)	((unsigned)(VALUE) <= 16)
+#define	CONST_OK_FOR_O(VALUE)	((unsigned)(VALUE) <= 24)
+#define	CONST_OK_FOR_P(VALUE)	((unsigned)(VALUE) <= 26)	/* GNU-GCC-031 2001/12/27 watanabe */
+
+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \
+  ((C) == 'I' ? 0 : \
+   (C) == 'J' ? 0 : \
+   (C) == 'K' ? CONST_OK_FOR_SIGNED6(VALUE) : \
+   (C) == 'L' ? CONST_OK_FOR_SIGNED19(VALUE) : \
+   (C) == 'M' ? CONST_OK_FOR_M(VALUE) : \
+   (C) == 'N' ? CONST_OK_FOR_N(VALUE) : \
+   (C) == 'O' ? CONST_OK_FOR_O(VALUE) : \
+   (C) == 'P' ? CONST_OK_FOR_P(VALUE) : \
+   0)
+
+/* C33: If the following lines are not defined, the link error occurs. */
+/* Similar, but for floating constants, and defining letters G and H.
+   Here VALUE is the CONST_DOUBLE rtx itself.
+
+  `G' is a zero of some form.  */
+
+/* C33: Define character 'G' for floating-point numbers.
+        'G' is '0'. Correspond to H8300.                 */
+
+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \
+  ((C) == 'G' ? (VALUE) == CONST0_RTX(DFmode) \
+   : 0)
+
+/* A C expression that defines the optional machine-dependent
+   constraint letters that can be used to segregate specific types of
+   operands, usually memory references, for the target machine.
+   Normally this macro will not be defined.  If it is required for a
+   particular target machine, it should return 1 if VALUE corresponds
+   to the operand type represented by the constraint letter C.  If C
+   is not defined as an extra constraint, the value returned should
+   be 0 regardless of VALUE.
+
+   For example, on the ROMP, load instructions cannot have their
+   output in r0 if the memory reference contains a symbolic address.
+   Constraint letter `Q' is defined as representing a memory address
+   that does *not* contain a symbolic address.  An alternative is
+   specified with a `Q' constraint on the input and `r' on the
+   output.  The next alternative specifies `m' on the input and a
+   register class that does not include r0 on the output.  */
+
+#define EXTRA_CONSTRAINT(OP, C)					\
+ ((C) == 'Q'   ? 0						\
+  : (C) == 'R' ? 0						\
+  : (C) == 'S' ? (GET_CODE (OP) == SYMBOL_REF)			\
+  : (C) == 'T' ? 0						\
+  : (C) == 'U' ? 0						\
+  : 0)
+
+/************************/
+/* G: Stack and Calling */
+/************************/
+
+/* G-1: Basic Stack Layout */
+
+/* Stack layout; function entry, exit and calling.  */
+
+/* Define this if pushing a word on the stack
+   makes the stack pointer a smaller address.  */
+
+#define STACK_GROWS_DOWNWARD
+
+/* Define this if the nominal address of the stack frame
+   is at the high-address end of the local variables;
+   that is, each additional local variable allocated
+   goes at a more negative offset in the frame.  */
+/* C33: The frame pointer is used as plus offset in C33. */
+
+/* #define FRAME_GROWS_DOWNWARD */
+/* #define ARGS_GROWS_DOWNWARD */
+
+/* Offset within stack frame to start allocating local variables at.
+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the
+   first local allocated.  Otherwise, it is the offset to the BEGINNING
+   of the first local allocated.  */
+
+/* C33: %fp and %sp shall be in common in C33.
+        Allocate the space for arguments of called function.  */
+        
+#define STARTING_FRAME_OFFSET (current_function_outgoing_args_size)
+
+/* Offset of first parameter from the argument pointer register value.  */
+/* Is equal to the size of the saved fp + pc, even if an fp isn't
+   saved since the value is used before we know.  */
+
+#define FIRST_PARM_OFFSET(FNDECL) 0
+
+/* G-2: Specifying How Stack Checking is Done */
+
+
+/* G-3: Registers That Address the Stack Frame */
+
+/* Specify the registers used for certain standard purposes.
+   The values of these macros are register numbers.  */
+
+/* Register to use for pushing function arguments.  */
+#define STACK_POINTER_REGNUM 18
+
+/* Base register for access to local variables of the function.  */
+/* CHG K.Watanabe V1.7 >>>>>>> */
+#if 0
+/* C33: The following definition shall be the temporary register.
+        It will be useless if it is assigned as saved register.   */
+
+#define FRAME_POINTER_REGNUM 16  
+#endif
+
+#define FRAME_POINTER_REGNUM 0  
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+
+/* Base register for access to arguments of the function.  */
+/* C33: Make the temporary register. */
+#define ARG_POINTER_REGNUM 17
+
+/* Register in which static-chain is passed to a function.  */
+/* >>>>> change iruma m.takeishi '04.04.01 */
+/* C33: The following line is corrected,
+        because forcibly terminated was occurred 
+        when the function was declared in the function,
+        
+ *  
+ *  int main() {
+ *      int sub () {};
+ *  }
+ */
+/* #define STATIC_CHAIN_REGNUM 9 */
+
+#define STATIC_CHAIN_REGNUM 9
+/* <<<<< change iruma m.takeishi '04.04.01 */
+
+/* G-4: Eliminating Frame Pointer and Arg Pointer */
+
+/* Value should be nonzero if functions must have frame pointers.
+   Zero means the frame pointer need not be set up (and parms
+   may be accessed via the stack pointer) in functions that seem suitable.
+   This is computed in `reload', in reload1.c.  */
+#define FRAME_POINTER_REQUIRED 0
+
+/* If defined, this macro specifies a table of register pairs used to
+   eliminate unneeded registers that point into the stack frame.  If
+   it is not defined, the only elimination attempted by the compiler
+   is to replace references to the frame pointer with references to
+   the stack pointer.
+
+   The definition of this macro is a list of structure
+   initializations, each of which specifies an original and
+   replacement register.
+
+   On some machines, the position of the argument pointer is not
+   known until the compilation is completed.  In such a case, a
+   separate hard register must be used for the argument pointer.
+   This register can be eliminated by replacing it with either the
+   frame pointer or the argument pointer, depending on whether or not
+   the frame pointer has been eliminated.
+
+   In this case, you might specify:
+        #define ELIMINABLE_REGS  \
+        {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
+         {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
+         {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+   Note that the elimination of the argument pointer with the stack
+   pointer is specified first since that is the preferred elimination. */
+
+#define ELIMINABLE_REGS  \
+	{{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM}, \
+	 {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM}, \
+	 {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}
+
+/* A C expression that returns non-zero if the compiler is allowed to
+   try to replace register number FROM-REG with register number
+   TO-REG.  This macro need only be defined if `ELIMINABLE_REGS' is
+   defined, and will usually be the constant 1, since most of the
+   cases preventing register elimination are things that the compiler
+   already knows about. */
+
+#define CAN_ELIMINATE(FROM, TO) 1 
+
+/* This macro is similar to `INITIAL_FRAME_POINTER_OFFSET'.  It
+   specifies the initial difference between the specified pair of
+   registers.  This macro must be defined if `ELIMINABLE_REGS' is
+   defined. */
+
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+{									\
+  if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)	\
+    (OFFSET) = 0;							\
+  else if ((FROM) == ARG_POINTER_REGNUM)				\
+   (OFFSET) = compute_frame_size (get_frame_size (), (long *)0);	\
+  else {								\
+    abort ();								\
+  }									\
+}
+
+/* G-5: Passing Function Arguments on the Stack */
+
+/* A guess for the C33.  */
+/* CHG K.Watanabe V1.7 >>>>>>> */
+/* #define PROMOTE_PROTOTYPES */
+#define PROMOTE_PROTOTYPES 1
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+/* Keep the stack pointer constant throughout the function.  */
+
+/* CHG K.Watanabe V1.7 >>>>>>> */
+/* #define ACCUMULATE_OUTGOING_ARGS */
+#define ACCUMULATE_OUTGOING_ARGS 1
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+/* When a parameter is passed in a register, stack space is still
+   allocated for it.  */
+/* C33: When a parameter is passed through the register,
+        stack space is not allocated for it in C33. */
+#define REG_PARM_STACK_SPACE(DECL) (0)
+
+
+/* Value is the number of bytes of arguments automatically
+   popped when returning from a subroutine call.
+   FUNDECL is the declaration node of the function (as a tree),
+   FUNTYPE is the data type of the function (as a tree),
+   or for a library call it is an identifier node for the subroutine name.
+   SIZE is the number of bytes of arguments passed on the stack.  */
+
+#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0
+
+/* G-6: Passing Arguments in Registers */
+
+/* Define where to put the arguments to a function.
+   Value is zero to push the argument on the stack,
+   or a hard register in which to store the argument.
+
+   MODE is the argument's machine mode.
+   TYPE is the data type of the argument (as a tree).
+    This is null for libcalls where that information may
+    not be available.
+   CUM is a variable of type CUMULATIVE_ARGS which gives info about
+    the preceding args and about the function being called.
+   NAMED is nonzero if this argument is a named parameter
+    (otherwise it is an extra parameter matching an ellipsis).  */
+
+struct rtx_def *function_arg();
+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \
+  function_arg (&CUM, MODE, TYPE, NAMED)
+
+/* C33: Do not define the following line according to MIPS. */
+
+/* Define a data type for recording info about an argument list
+   during the scan of that argument list.  This data type should
+   hold all necessary information about the function itself
+   and about the args processed so far, enough to enable macros
+   such as FUNCTION_ARG to determine where the next arg should go.  */
+
+#define CUMULATIVE_ARGS struct cum_arg
+struct cum_arg { int nbytes; };
+
+/* Initialize a variable CUM of type CUMULATIVE_ARGS
+   for a call to a function whose data type is FNTYPE.
+   For a library call, FNTYPE is 0.  */
+
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)	\
+ ((CUM).nbytes = 0)
+
+/* Update the data in CUM to advance over an argument
+   of mode MODE and data type TYPE.
+   (TYPE is null for libcalls where that information may not be available.)  */
+
+/* C33: The structure are passed through the stack.
+	    Do not add in the case that the parameter is passed in DFmode
+	    because registers are not used in this type.                   */
+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)			\
+ ((CUM).nbytes += ((MODE) == BLKmode					\
+  ? 0									\
+  : ((MODE) == DFmode							\
+      ? (((CUM).nbytes  < ((4-1) * UNITS_PER_WORD))		 	\
+          ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD)	\
+          : 0)								\
+      : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) & -UNITS_PER_WORD)))
+
+
+/* 1 if N is a possible register number for function argument passing.  */
+
+#define FUNCTION_ARG_REGNO_P(N) (N >= 6 && N <= 9)
+
+/* G-7: How Scalar Function Values Are Returned */
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its FUNCTION_DECL;
+   otherwise, FUNC is 0.   */
+
+#define FUNCTION_VALUE(VALTYPE, FUNC) \
+  gen_rtx (REG, TYPE_MODE (VALTYPE), 4)
+
+/* C33: If the following lines are not defined, the link error occurs. */
+/* Define how to find the value returned by a library function
+   assuming the value has mode MODE.  */
+
+#define LIBCALL_VALUE(MODE) \
+  gen_rtx (REG, MODE, 4)
+
+/* 1 if N is a possible register number for a function value.  */
+
+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 4)
+
+
+/* G-8: How Large Values Are Returned */
+
+/* C33: Define "DEFAULT_PCC_STRUCT_RETURN" as 0,
+        or the principle of the structure / the union does not obey
+        the "RETURN_IN_MEMORY".                                      */
+
+
+/* Return values > 8 bytes in length in memory.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* C33: Though define RETURN_IN_MEMORY as (TYPE_MODE (TYPE) == BLKmode) in MIPS,
+        shall the structure / the union be BLKmode?
+        ＮＯ(980903)  BLKmode may be string.                                      */
+
+#define RETURN_IN_MEMORY(TYPE)  \
+  (int_size_in_bytes (TYPE) > 8 || TYPE_MODE (TYPE) == BLKmode)
+
+/* Register in which address to store a structure value
+   is passed to a function.  On the C33 it's passed as
+   the first parameter.  */
+
+#define STRUCT_VALUE 0
+
+
+/* G-9: Caller-Saves Register Allocation */
+
+
+/* G-10: Function Entry and Exit */
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused. Define the following contents in TARGET_ASM_FUNCTION_PROLOGUE. */
+
+
+/* C33: Define function prologue. */
+/* #define FUNCTION_PROLOGUE(FILE, SIZE) expand_prologue(file); */
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,
+   the stack pointer does not matter.  The value is tested only in
+   functions that have frame pointers.
+   No definition is equivalent to always zero.  */
+
+#define EXIT_IGNORE_STACK 0
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused. Define the following contents in TARGET_ASM_FUNCTION_EPILOGUE */
+
+/* C33: Define function epilogue. */
+/* #define FUNCTION_EPILOGUE(FILE, SIZE) expand_epilogue(file); */
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+/* G-11: Generating Code for Profiling */
+
+/* C33: If the following line is not defined, the link error occurs. */
+/* Output assembler code to FILE to increment profiler label # LABELNO
+   for profiling a function entry.  */
+#define FUNCTION_PROFILER(FILE, LABELNO) ;
+
+/**************/
+/* H: Varargs */
+/**************/
+
+
+
+/******************/
+/* I: Trampolines */
+/******************/
+
+/* Length in units of the trampoline for entering a nested function.  */
+/* C33: Set 0 to length, because we don't define TRAMPOLINE_TEMPLATE */
+#define TRAMPOLINE_SIZE 0
+
+/* C33: If the following line is not defined, the link error occurs. */
+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) ;
+
+
+/********************/
+/* J: Library Calls */
+/********************/
+
+#define TARGET_MEM_FUNCTIONS
+
+/***********************/
+/* K: Addressing Modes */
+/***********************/
+
+/* Addressing modes, and classification of registers for them.  */
+
+#define HAVE_POST_INCREMENT 1
+
+/* 1 if X is an rtx for a constant that is a valid address.  */
+
+/* ??? This seems too exclusive.  May get better code by accepting more
+   possibilities here, in particular, should accept ZDA_NAME SYMBOL_REFs.  */
+
+#define CONSTANT_ADDRESS_P(X)   \
+  (GET_CODE (X) == CONST_INT	\
+   && CONST_OK_FOR_IMM26 (INTVAL (X)))	/* unsigned 26bit */
+
+/* Maximum number of registers that can appear in a valid memory address.  */
+
+#define MAX_REGS_PER_ADDRESS 1
+
+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
+   and check its validity for a certain class.
+   We have two alternate definitions for each of them.
+   The usual definition accepts all pseudo regs; the other rejects
+   them unless they have been allocated suitable hard regs.
+   The symbol REG_OK_STRICT causes the latter definition to be used.
+
+   Most source files want to accept pseudo regs in the hope that
+   they will get allocated to the class that the insn wants them to be in.
+   Source files for reload pass need to be strict.
+   After reload, it makes no difference, since pseudo regs have
+   been eliminated by then.  */
+
+#ifndef REG_OK_STRICT
+
+/* Nonzero if X is a hard reg that can be used as an index
+   or if it is a pseudo reg.  */
+#define REG_OK_FOR_INDEX_P(X) 0
+/* Nonzero if X is a hard reg that can be used as a base reg
+   or if it is a pseudo reg.  */
+#define REG_OK_FOR_BASE_P(X) 1
+#define REG_OK_FOR_INDEX_P_STRICT(X) 0
+#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))
+#define STRICT 0
+
+#else
+
+/* Nonzero if X is a hard reg that can be used as an index.  */
+#define REG_OK_FOR_INDEX_P(X) 0
+/* Nonzero if X is a hard reg that can be used as a base reg.  */
+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))
+#define STRICT 1
+
+#endif
+
+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression
+   that is a valid memory address for an instruction.
+   The MODE argument is the machine mode for the MEM expression
+   that wants to use this address.
+
+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,
+   except for CONSTANT_ADDRESS_P which is actually
+   machine-independent.  */
+
+/* Accept either REG or SUBREG where a register is valid.  */
+
+
+//#define RTX_OK_FOR_BASE_P(X)	(REG_P (X) && REG_OK_FOR_BASE_P (X))
+#define RTX_OK_FOR_BASE_P(X)						\
+  ((REG_P (X) && REG_OK_FOR_BASE_P (X))					\
+   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))			\
+       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))
+
+/* CHG K.Watanabe V1.7 >>>>>>> */
+/* C33: Reflect the option of "-medda32" in the following definition.
+        When the option is "-medda32 && !adv", 
+        forbid the access of symbols which use the data pointer.  */
+#if 0
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
+do {									\
+  if (RTX_OK_FOR_BASE_P (X)) goto ADDR;					\
+  if (GET_CODE (X) == SYMBOL_REF					\
+      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode)))		\
+     goto ADDR;								\
+  if (GET_CODE (X) == CONST						\
+      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode)))		\
+     goto ADDR;								\
+  if (GET_CODE (X) == PLUS						\
+      && CONSTANT_ADDRESS_P (XEXP (X, 1))				\
+      && ((MODE == QImode)						\
+	  || ((MODE == HImode) && (INTVAL (XEXP(X, 1)) % 2 == 0))	\
+	  || ((MODE == SImode) && (INTVAL (XEXP(X, 1)) % 4 == 0))	\
+	  || ((MODE == DImode) && (INTVAL (XEXP(X, 1)) % 4 == 0))	\
+	  || ((MODE == SFmode) && (INTVAL (XEXP(X, 1)) % 4 == 0))	\
+	  || ((MODE == DFmode) && (INTVAL (XEXP(X, 1)) % 4 == 0)))	\
+      && RTX_OK_FOR_BASE_P (XEXP (X, 0))) goto ADDR;			\
+} while (0)
+#endif
+
+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)				\
+do {									\
+  if (RTX_OK_FOR_BASE_P (X)) goto ADDR;					\
+  if (GET_CODE (X) == SYMBOL_REF					\
+      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode))		\
+      && ( !TARGET_EXT_32 || TARGET_C33ADV || ENCODED_NAME_P( XSTR(X, 0) ) ) )							\
+     goto ADDR;								\
+  if (GET_CODE (X) == CONST						\
+      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode))		\
+      && ( !TARGET_EXT_32 || TARGET_C33ADV || ENCODED_NAME_P( XSTR(XEXP(XEXP(X, 0),0),0) ) ) )			\
+     goto ADDR;								\
+  if (GET_CODE (X) == PLUS						\
+      && CONSTANT_ADDRESS_P (XEXP (X, 1))				\
+      && ((MODE == QImode)						\
+	  || ((MODE == HImode) && (INTVAL (XEXP(X, 1)) % 2 == 0))	\
+	  || ((MODE == SImode) && (INTVAL (XEXP(X, 1)) % 4 == 0))	\
+	  || ((MODE == DImode) && (INTVAL (XEXP(X, 1)) % 4 == 0))	\
+	  || ((MODE == SFmode) && (INTVAL (XEXP(X, 1)) % 4 == 0))	\
+	  || ((MODE == DFmode) && (INTVAL (XEXP(X, 1)) % 4 == 0)))	\
+      && RTX_OK_FOR_BASE_P (XEXP (X, 0))) goto ADDR;			\
+} while (0)
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+/* Try machine-dependent ways of modifying an illegitimate address
+   to be legitimate.  If we find one, return the new, valid address.
+   This macro is used in only one place: `memory_address' in explow.c.
+
+   OLDX is the address as it was before break_out_memory_refs was called.
+   In some cases it is useful to look at this to decide what needs to be done.
+
+   MODE and WIN are passed so that this macro can use
+   GO_IF_LEGITIMATE_ADDRESS.
+
+   It is always safe for this macro to do nothing.  It exists to recognize
+   opportunities to optimize the output.   */
+
+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}
+
+/* Go to LABEL if ADDR (a legitimate address expression)
+   has an effect that depends on the machine mode it is used for.  */
+
+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  {}
+
+/* Nonzero if the constant value X is a legitimate general operand.
+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */
+#define LEGITIMATE_CONSTANT_P(X)					\
+  (GET_CODE (X) == CONST_DOUBLE						\
+   || flag_pic								\
+   || !(GET_CODE (X) == CONST						\
+	&& GET_CODE (XEXP (X, 0)) == PLUS				\
+	&& GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF		\
+	&& GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT		\
+	&& ! CONST_OK_FOR_IMM26 (INTVAL (XEXP (XEXP (X, 0), 1)))))
+
+/*********************/
+/* L: Condition Code */
+/*********************/
+
+/* Tell final.c how to eliminate redundant test instructions.  */
+
+/* Here we define machine-dependent flags and fields in cc_status
+   (see `conditions.h').  No extra ones are needed for the vax.  */
+
+/* Store in cc_status the expressions
+   that the condition codes will describe
+   after execution of an instruction whose pattern is EXP.
+   Do not alter them if the instruction would not alter the cc's.  */
+
+#define NOTICE_UPDATE_CC(EXP, INSN) notice_update_cc(EXP, INSN)
+
+
+/************/
+/* M: Costs */
+/************/
+
+/* A part of a C `switch' statement that describes the relative costs
+   of constant RTL expressions.  It must contain `case' labels for
+   expression codes `const_int', `const', `symbol_ref', `label_ref'
+   and `const_double'.  Each case must ultimately reach a `return'
+   statement to return the relative cost of the use of that kind of
+   constant value in an expression.  The cost may depend on the
+   precise value of the constant, which is available for examination
+   in X, and the rtx code of the expression in which it is contained,
+   found in OUTER_CODE.
+
+   CODE is the expression code--redundant, since it can be obtained
+   with `GET_CODE (X)'. */
+
+#define CONST_COSTS(RTX,CODE,OUTER_CODE)				\
+  case CONST_INT:							\
+  case CONST_DOUBLE:							\
+  case CONST:								\
+  case SYMBOL_REF:							\
+  case LABEL_REF:							\
+    {									\
+      int _zxy = const_costs(RTX, CODE);				\
+      return (_zxy) ? COSTS_N_INSNS (_zxy) : 0;				\
+    }
+
+/* C33: According to V850 for now. */
+/* A crude cut at RTX_COSTS for the V850.  */
+
+/* Provide the costs of a rtl expression.  This is in the body of a
+   switch on CODE.
+
+   There aren't DImode MOD, DIV or MULT operations, so call them
+   very expensive.  Everything else is pretty much a constant cost.  */
+
+#define RTX_COSTS(RTX,CODE,OUTER_CODE)					\
+  case ASHIFT:		/* C33 */					\
+  case ASHIFTRT:	/* C33 */					\
+  case LSHIFTRT:	/* C33 */					\
+    {									\
+      rtx stRtxOpt1 = XEXP (RTX, 1);					\
+      									\
+      if (GET_CODE (stRtxOpt1) == CONST_INT) {				\
+									\
+        if (INTVAL(stRtxOpt1) <= 8)					\
+          return COSTS_N_INSNS(1);					\
+									\
+        if (INTVAL(stRtxOpt1) <= 16)					\
+          return COSTS_N_INSNS(2);					\
+									\
+        if (INTVAL(stRtxOpt1) <= 24)					\
+          return COSTS_N_INSNS(3);					\
+									\
+        return COSTS_N_INSNS(4);					\
+      }									\
+									\
+      return COSTS_N_INSNS(8);						\
+    }									\
+									\
+  case MOD:								\
+  case DIV:								\
+    return 60;								\
+  case MULT:								\
+    return 20;
+
+
+
+
+
+/*#define ADDRESS_COST(ADDR) c33_address_cost (ADDR) */
+/* C33: If the following line is not defined, 
+        the reference of SYMBOL_REF of the memory is changed to the reference of REG.
+        And the name is missed in this timing, and SIGSEGV occurs at the time of 
+        outputting .comm. ( Is this a bug ? )
+        reference to cse.c:find_best_add */
+        
+#define ADDRESS_COST(ADDR) 1	/* 000524 watanabe */
+
+
+/* C33: If the following lines are not defined, the compile error occurs. */
+/* Nonzero if access to memory by bytes or half words is no faster
+   than accessing full words.  */
+#define SLOW_BYTE_ACCESS 1
+
+#define ADJUST_INSN_LENGTH(INSN, LENGTH) \
+  LENGTH += c33_adjust_insn_length (INSN, LENGTH);
+
+
+/***************/
+/* N: Sections */
+/***************/
+
+/* The five different data regions on the c33.  */
+typedef enum 
+{
+  DATA_AREA_NORMAL,
+  DATA_AREA_SDA,
+  DATA_AREA_TDA,
+  DATA_AREA_ZDA,
+  DATA_AREA_GDA
+} c33_data_area;
+
+/* A list of names for sections other than the standard two, which are
+   `in_text' and `in_data'.  You need not define this macro on a
+   system with no other sections (that GCC needs to use).  */
+   
+/* One or more functions to be defined in `varasm.c'.  These
+   functions should do jobs analogous to those of `text_section' and
+   `data_section', for your additional sections.  Do not define this
+   macro if you do not define `EXTRA_SECTIONS'. */
+#undef	EXTRA_SECTION_FUNCTIONS
+
+/* A list of names for sections other than the standard two, which are
+   `in_text' and `in_data'.  You need not define this macro on a
+   system with no other sections (that GCC needs to use).  */
+   
+/* CHG K.Watanabe V1.7 >>>>>>> */
+/* C33: Because "in_ctros, in_dtros" are already defined in varasm.c,
+        delete them.                                                  */
+#if 0
+#undef	EXTRA_SECTIONS
+#define EXTRA_SECTIONS in_tdata, in_sdata, in_zdata, in_gdata,	\
+in_const, in_ctors, in_dtors,					\
+in_rozdata, in_rosdata, in_rotdata, in_rogdata,			\
+in_tbss, in_sbss, in_zbss, in_gbss,				\
+in_tcommon, in_scommon, in_zcommon, in_gcommon
+#endif
+
+#define EXTRA_SECTIONS in_tdata, in_sdata, in_zdata, in_gdata,	\
+in_const, 												\
+in_rozdata, in_rosdata, in_rotdata, in_rogdata,			\
+in_tbss, in_sbss, in_zbss, in_gbss,						\
+in_tcommon, in_scommon, in_zcommon, in_gcommon
+/* CHG K.Watanabe V1.7 <<<<<<<< */
+
+/* This could be done a lot more cleanly using ANSI C ... */
+
+/* CHG K.Watanabe V1.7 >>>>>>> */
+/* C33: Because "in_ctros, in_dtros" are already defined in varasm.c,
+        delete them.                                                  */
+#if 0
+#define EXTRA_SECTION_FUNCTIONS						\
+CONST_SECTION_FUNCTION							\
+CTORS_SECTION_FUNCTION							\
+DTORS_SECTION_FUNCTION							\
+									\
+void									\
+sdata_section ()							\
+{									\
+  if (in_section != in_sdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", SDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_sdata;						\
+    }									\
+}									\
+									\
+void									\
+rosdata_section ()							\
+{									\
+  if (in_section != in_rosdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", ROSDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_rosdata;						\
+    }									\
+}									\
+									\
+void									\
+sbss_section ()								\
+{									\
+  if (in_section != in_sbss)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", SBSS_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_sbss;						\
+    }									\
+}									\
+									\
+void									\
+tdata_section ()							\
+{									\
+  if (in_section != in_tdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", TDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_tdata;						\
+    }									\
+}									\
+									\
+void									\
+rotdata_section ()							\
+{									\
+  if (in_section != in_rotdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", ROTDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_rotdata;						\
+    }									\
+}									\
+									\
+void									\
+tbss_section ()								\
+{									\
+  if (in_section != in_tbss)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", TBSS_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_tbss;						\
+    }									\
+}									\
+									\
+void									\
+zdata_section ()							\
+{									\
+  if (in_section != in_zdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", ZDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_zdata;						\
+    }									\
+}									\
+									\
+void									\
+rozdata_section ()							\
+{									\
+  if (in_section != in_rozdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", ROZDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_rozdata;						\
+    }									\
+}									\
+									\
+void									\
+zbss_section ()								\
+{									\
+  if (in_section != in_zbss)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", ZBSS_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_zbss;						\
+    }									\
+}									\
+									\
+void									\
+gdata_section ()							\
+{									\
+  if (in_section != in_gdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", GDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_gdata;						\
+    }									\
+}									\
+									\
+void									\
+rogdata_section ()							\
+{									\
+  if (in_section != in_rogdata)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", ROGDATA_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_rogdata;						\
+    }									\
+}									\
+									\
+void									\
+gbss_section ()								\
+{									\
+  if (in_section != in_gbss)						\
+    {									\
+      if( i_32bit_Insn_Chk_Flg == 0 ){	\
+      	fprintf (asm_out_file, "%s\n", GBSS_SECTION_ASM_OP);		\
+      }		\
+      in_section = in_gbss;						\
+    }									\
+}
+#endif
+
+#define EXTRA_SECTION_FUNCTIONS						\
+void										\
+const_section ()							\
+{											\
+  if (in_section != in_const)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", CONST_SECTION_ASM_OP);		\
+      in_section = in_const;				\
+    }										\
+}											\
+											\
+void										\
+sdata_section ()							\
+{											\
+  if (in_section != in_sdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", SDATA_SECTION_ASM_OP);		\
+      in_section = in_sdata;				\
+    }										\
+}											\
+											\
+void										\
+rosdata_section ()							\
+{											\
+  if (in_section != in_rosdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", ROSDATA_SECTION_ASM_OP);		\
+      in_section = in_rosdata;				\
+    }										\
+}											\
+											\
+void										\
+sbss_section ()								\
+{											\
+  if (in_section != in_sbss)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", SBSS_SECTION_ASM_OP);		\
+      in_section = in_sbss;					\
+    }										\
+}											\
+											\
+void										\
+tdata_section ()							\
+{											\
+  if (in_section != in_tdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", TDATA_SECTION_ASM_OP);		\
+      in_section = in_tdata;				\
+    }										\
+}											\
+											\
+void										\
+rotdata_section ()							\
+{											\
+  if (in_section != in_rotdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", ROTDATA_SECTION_ASM_OP);		\
+      in_section = in_rotdata;				\
+    }										\
+}											\
+											\
+void										\
+tbss_section ()								\
+{											\
+  if (in_section != in_tbss)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", TBSS_SECTION_ASM_OP);		\
+      in_section = in_tbss;					\
+    }										\
+}											\
+											\
+void										\
+zdata_section ()							\
+{											\
+  if (in_section != in_zdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", ZDATA_SECTION_ASM_OP);		\
+      in_section = in_zdata;				\
+    }										\
+}											\
+											\
+void										\
+rozdata_section ()							\
+{											\
+  if (in_section != in_rozdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", ROZDATA_SECTION_ASM_OP);		\
+      in_section = in_rozdata;				\
+    }										\
+}											\
+											\
+void										\
+zbss_section ()								\
+{											\
+  if (in_section != in_zbss)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", ZBSS_SECTION_ASM_OP);		\
+      in_section = in_zbss;					\
+    }										\
+}											\
+											\
+void										\
+gdata_section ()							\
+{											\
+  if (in_section != in_gdata)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", GDATA_SECTION_ASM_OP);		\
+      in_section = in_gdata;				\
+    }										\
+}											\
+											\
+void										\
+rogdata_section ()							\
+{											\
+  if (in_section != in_rogdata)				\
+    {										\
+     fprintf (asm_out_file, "%s\n", ROGDATA_SECTION_ASM_OP);		\
+      in_section = in_rogdata;				\
+    }										\
+}											\
+											\
+void										\
+gbss_section ()								\
+{											\
+  if (in_section != in_gbss)				\
+    {										\
+      fprintf (asm_out_file, "%s\n", GBSS_SECTION_ASM_OP);		\
+      in_section = in_gbss;					\
+    }										\
+}
+/* CHG K.Watanabe V1.7 <<<<<<< */
+
+// 2001/6/5 watanabe
+/* C33: Though the value of "in_section" is different between "rosdata_section"
+        and "rotdata_section" in v850, it may be a bug, so we changed to call
+        the sections.                                                           */
+#define TEXT_SECTION_ASM_OP  "\t.section .text"
+#define DATA_SECTION_ASM_OP  "\t.section .data"
+#define BSS_SECTION_ASM_OP   "\t.section .bss"
+#define SDATA_SECTION_ASM_OP "\t.section .sdata,\"aw\""
+#define SBSS_SECTION_ASM_OP  "\t.section .sbss,\"aw\""
+#define ZDATA_SECTION_ASM_OP "\t.section .zdata,\"aw\""
+#define ZBSS_SECTION_ASM_OP  "\t.section .zbss,\"aw\""
+#define TDATA_SECTION_ASM_OP "\t.section .tdata,\"aw\""
+#define TBSS_SECTION_ASM_OP  "\t.section .tbss,\"aw\""
+#define GDATA_SECTION_ASM_OP "\t.section .gdata,\"aw\""
+#define GBSS_SECTION_ASM_OP  "\t.section .gbss,\"aw\""
+#define ROSDATA_SECTION_ASM_OP "\t.section .rosdata,\"a\""
+#define ROZDATA_SECTION_ASM_OP "\t.section .rozdata,\"a\""
+#define ROTDATA_SECTION_ASM_OP "\t.section .rotdata,\"a\""
+#define ROGDATA_SECTION_ASM_OP "\t.section .rogdata,\"a\""
+#undef	CONST_SECTION_ASM_OP
+#define CONST_SECTION_ASM_OP "\t.section .rodata"
+
+/* ADD K.Watanabe V1.7 >>>>>>> */
+#define CTORS_SECTION_ASM_OP	"\t.section .ctors,\"aw\""
+#define DTORS_SECTION_ASM_OP	"\t.section .dtors,\"aw\""
+
+/* Support a read-only data section.  */
+#define READONLY_DATA_SECTION_ASM_OP	"\t.section .rodata"
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+#define SCOMMON_ASM_OP 	       ".scomm"
+#define ZCOMMON_ASM_OP 	       ".zcomm"
+#define TCOMMON_ASM_OP 	       ".tcomm"
+#define GCOMMON_ASM_OP 	       ".gcomm"
+
+/* A C statement or statements to switch to the appropriate section
+   for output of EXP.  You can assume that EXP is either a `VAR_DECL'
+   node or a constant of some sort.  RELOC indicates whether the
+   initial value of EXP requires link-time relocations.  Select the
+   section by calling `text_section' or one of the alternatives for
+   other sections.
+
+   Do not define this macro if you put all read-only variables and
+   constants in the read-only data section (usually the text section).  */
+   
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused. Define the following contents in TARGET_ASM_SELECT_SECTION. */
+#if 0
+#undef  SELECT_SECTION
+#define SELECT_SECTION(EXP, RELOC) c33_select_section(EXP, RELOC)
+#endif
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+/* A C statement or statements to switch to the appropriate section
+   for output of RTX in mode MODE.  You can assume that RTX is some
+   kind of constant in RTL.  The argument MODE is redundant except in
+   the case of a `const_int' rtx.  Select the section by calling
+   `text_section' or one of the alternatives for other sections.
+
+   Do not define this macro if you put all constants in the read-only
+   data section.  */
+/* #define SELECT_RTX_SECTION(MODE, RTX) */
+
+
+#define OUTPUT_ADDR_CONST_EXTRA(FILE, X, FAIL)  \
+  if (! c33_output_addr_const_extra (FILE, X)) \
+     goto FAIL
+     
+/**********/
+/* O: PIC */
+/**********/
+
+/***********************/
+/* P: Assembler Format */
+/***********************/
+
+/* P-1: The Overall Framework of an Assembler File */
+/* Output at beginning/end of assembler file.  */
+#undef ASM_FILE_START
+#define ASM_FILE_START(FILE) asm_file_start(FILE)
+
+#define ASM_COMMENT_START ";"
+
+/* Output to assembler file text saying following lines
+   may contain character constants, extra white space, comments, etc.  */
+
+/* C33: If the following line is not defined, the compile error occurs. */
+#define ASM_APP_ON ";APP\n"
+
+/* Output to assembler file text saying following lines
+   no longer contain unusual constructs.  */
+
+/* C33: If the following line is not defined, the compile error occurs. */
+#define ASM_APP_OFF ";NO_APP\n"
+
+
+/* P-2: Output of Data */
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused. */
+#if 0
+/* This is how to output an assembler line defining a `double' constant.
+   It is .double or .float, depending.  */
+
+#define ASM_OUTPUT_DOUBLE(FILE, VALUE)			\
+do { char dstr[30];					\
+     REAL_VALUE_TO_DECIMAL ((VALUE), "%.20e", dstr);	\
+     fprintf (FILE, "\t.double %s\n", dstr);		\
+   } while (0)
+
+
+/* This is how to output an assembler line defining a `float' constant.  */
+#define ASM_OUTPUT_FLOAT(FILE, VALUE)			\
+do { char dstr[30];					\
+     REAL_VALUE_TO_DECIMAL ((VALUE), "%.20e", dstr);	\
+     fprintf (FILE, "\t.float %s\n", dstr);		\
+   } while (0)
+
+/* This is how to output an assembler line defining an `int' constant.  */
+
+#define ASM_OUTPUT_INT(FILE, VALUE)		\
+( fprintf (FILE, "\t.long "),			\
+  output_addr_const (FILE, (VALUE)),		\
+  fprintf (FILE, "\n"))
+
+/* Likewise for `char' and `short' constants.  */
+
+#define ASM_OUTPUT_SHORT(FILE, VALUE)		\
+( fprintf (FILE, "\t.hword "),			\
+  output_addr_const (FILE, (VALUE)),		\
+  fprintf (FILE, "\n"))
+
+#define ASM_OUTPUT_CHAR(FILE, VALUE)		\
+( fprintf (FILE, "\t.byte "),			\
+  output_addr_const (FILE, (VALUE)),		\
+  fprintf (FILE, "\n"))
+
+/* This is how to output an assembler line for a numeric constant byte.  */
+/* C33: If the following line is not defined, the compile error occurs. */
+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \
+  fprintf (FILE, "\t.byte 0x%x\n", (VALUE))
+
+#endif	/* #if 0 */
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+/* Define the parentheses used to group arithmetic operations
+   in assembler code.  */
+
+
+// DEL K.Watanabe V1.8 >>>>>>>
+#if 0
+/* C33: If the following line is not defined, the compile error occurs. */
+#define ASM_OPEN_PAREN "("
+#define ASM_CLOSE_PAREN ")"
+#endif
+// DEL K.Watanabe V1.8 <<<<<<<
+
+
+/* P-3: Output of Uninitialized Variables */
+
+/* This says how to output the assembler to define a global
+   uninitialized but not common symbol.  */
+
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  asm_output_aligned_bss ((FILE), (DECL), (NAME), (SIZE), (ALIGN))
+
+#undef  ASM_OUTPUT_ALIGNED_BSS 
+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \
+  c33_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* This says how to output the assembler to define a global
+   uninitialized, common symbol. */
+#undef  ASM_OUTPUT_ALIGNED_COMMON
+#undef  ASM_OUTPUT_COMMON
+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \
+     c33_output_common (FILE, DECL, NAME, SIZE, ALIGN)
+
+/* This says how to output the assembler to define a local
+   uninitialized symbol. */
+#undef  ASM_OUTPUT_ALIGNED_LOCAL
+#undef  ASM_OUTPUT_LOCAL
+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \
+     c33_output_local (FILE, DECL, NAME, SIZE, ALIGN)
+     
+
+/* P-4: Output and Generation of Labels */
+
+/* This is how to output the definition of a user-level label named NAME,
+   such as the label on a static function or variable NAME.  */
+
+/* C33: If the following line is not defined, the compile error occurs. */
+#define ASM_OUTPUT_LABEL(FILE, NAME)	\
+  do { assemble_name (FILE, NAME); fputs (":\n", FILE); } while (0)
+
+/* This is how to output a command to make the user-level label named NAME
+   defined for reference from other files.  */
+
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/* Globalizing directive for a label.  */
+#define GLOBAL_ASM_OP "\t.global\t"
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
+/* This is how to output a reference to a user-level label named NAME.
+   `assemble_name' uses this.  */
+
+// CHG K.Watanabe V1.8 >>>>>>>
+#if 0
+#undef ASM_OUTPUT_LABELREF
+#define ASM_OUTPUT_LABELREF(FILE, NAME)	          \
+  do {                                            \
+  char* real_name;                                \
+  STRIP_NAME_ENCODING (real_name, (NAME));        \
+  fprintf (FILE, "%s", real_name);                \
+  } while (0)           
+#endif
+
+#undef ASM_OUTPUT_LABELREF
+#define ASM_OUTPUT_LABELREF(FILE, NAME)	          \
+    asm_fprintf (FILE, "%U%s", (*targetm.strip_name_encoding) (NAME)) 
+// CHG K.Watanabe V1.8 <<<<<<<
+
+
+/* Store in OUTPUT a string (made with alloca) containing
+   an assembler-name for a local static variable named NAME.
+   LABELNO is an integer which is different for each call.  */
+
+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)	\
+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),	\
+  sprintf ((OUTPUT), "%s___%d", (NAME), (LABELNO)))
+
+/* This is how we tell the assembler that two symbols have the same value.  */
+
+#define ASM_OUTPUT_DEF(FILE,NAME1,NAME2) \
+  do { assemble_name(FILE, NAME1); 	 \
+       fputs(" = ", FILE);		 \
+       assemble_name(FILE, NAME2);	 \
+       fputc('\n', FILE); } while (0)
+
+
+/* P-5: How Initialization Functions Are Handled */
+
+/* P-6: Macros Controlling Initialization Routines */
+
+/* P-7: Output of Assembler Instructions */
+
+/* How to refer to registers in assembler output.
+   This sequence is indexed by compiler's hard-register-number (see above).  */
+#define REGISTER_NAMES							\
+{  "%r0",  "%r1",  "%r2",  "%r3",  "%r4",  "%r5",  "%r6" , "%r7",	\
+   "%r8",  "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15",	\
+   ".fp",  ".ap", "%sp" }
+
+#define FINAL_PRESCAN_INSN(insn, operand, nop) final_prescan_insn (insn, operand, nop)
+
+/* Print an instruction operand X on file FILE.
+   look in c33.c for details */
+
+#define PRINT_OPERAND(FILE, X, CODE)  print_operand (FILE, X, CODE)
+
+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) \
+  (((CODE) == '.') || ((CODE) == '#'))
+
+/* Print a memory operand whose address is X, on file FILE.
+   This uses a function in output-vax.c.  */
+
+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address (FILE, ADDR)
+
+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)
+#define ASM_OUTPUT_REG_POP(FILE,REGNO)
+
+
+/* P-8: Output of Dispatch Tables */
+
+/* C33: If the following line is not defined, the default is enabled and the error occurs.(defaults.h) */
+/* This is how to output an element of a case-vector that is absolute.  */
+
+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \
+  asm_fprintf (FILE, "\t.long .L%d\n", VALUE)
+
+/* P-9: Assembler Commands for Exception Regions */
+
+/* P-10: Assembler Commands for Alignment */
+
+#define ASM_OUTPUT_ALIGN(FILE,LOG)	\
+  if ((LOG) != 0)			\
+    fprintf (FILE, "\t.align %d\n", (LOG))
+
+
+/*********************/
+/* Q: Debugging Info */
+/*********************/
+
+/* We don't have to worry about dbx compatibility for the c33.  */
+#define DEFAULT_GDB_EXTENSIONS 1
+
+/* Use stabs debugging info by default.  */
+#undef PREFERRED_DEBUGGING_TYPE
+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Delete according to V850.
+        The following line is defined in defaults.h */
+#if 0
+#undef DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(REGNO) REGNO
+#endif
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+/************************/
+/* R: Cross-compilation */
+/************************/
+
+
+/***********/
+/* S: Misc */
+/***********/
+
+/* Define this if you have defined special-purpose predicates in the
+   file `MACHINE.c'.  This macro is called within an initializer of an
+   array of structures.  The first field in the structure is the name
+   of a predicate and the second field is an array of rtl codes.  For
+   each predicate, list all rtl codes that can be in expressions
+   matched by the predicate.  The list should have a trailing comma.  */
+
+/* C33: Why is "CONST" not in "special_symbolref_operand"? */
+
+#define PREDICATE_CODES							\
+{ "call_address_operand",	{ REG, SYMBOL_REF }},			\
+{ "power_of_two_operand",	{ CONST_INT }},				\
+{ "not_power_of_two_operand",	{ CONST_INT }},				\
+{ "general_operand_post_inc",	{ CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,	\
+			  	  LABEL_REF, SUBREG, REG, MEM}},
+
+
+/* Define to use software floating point emulator for REAL_ARITHMETIC and
+   decimal <-> binary conversion. */
+
+
+/* C33: If the following line is not defined, the compile error occurs. */
+/* Specify the machine mode that this machine uses
+   for the index in the tablejump instruction.  */
+#define CASE_VECTOR_MODE Pmode
+
+#define WORD_REGISTER_OPERATIONS
+
+
+/* Byte and short loads sign extend the value to a word.  */
+#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND
+
+
+// DEL K.Watanabe V1.8 >>>>>>>
+#if 0
+/* C33: If the following line is not defined, the compile error occurs. */
+/* This is the kind of divide that is easiest to do in the general case.  */
+#define EASY_DIV_EXPR TRUNC_DIV_EXPR
+#endif
+// DEL K.Watanabe V1.8 <<<<<<<<
+
+
+/* >>>>> delete iruma m.takeishi '04.02.24 */
+/* C33: Correction in which the change of the library specification was refrected.
+        Revert to the old code.                                                    */
+/* >>>>> add iruma m.takeishi '03.11.19 */
+/* C33: Change the libgcc function names which are the default call. */
+/* C33: /gcc/opttabs.c -- Overrideed in "init_optabs" function ( Only PE )*/
+#if 0
+#define INIT_TARGET_OPTABS \
+        if ( TARGET_C33PE ) { \
+            init_integral_libfuncs (sdiv_optab, "div_pe", '3'); \
+            init_integral_libfuncs (udiv_optab, "udiv_pe", '3'); \
+            init_integral_libfuncs (smod_optab, "mod_pe", '3'); \
+            init_integral_libfuncs (umod_optab, "umod_pe", '3'); \
+            \
+            \
+            init_floating_libfuncs (add_optab, "add_pe", '3'); \
+            init_floating_libfuncs (sub_optab, "sub_pe", '3'); \
+            /* >>>>> add iruma m.takeishi '03.12.22 */ \
+            init_floating_libfuncs (smul_optab, "mul_pe", '3'); \
+            /* <<<<< add iruma m.takeishi '03.12.22 */ \
+            init_floating_libfuncs (flodiv_optab, "div_pe", '3'); \
+            \
+            floatsisf_libfunc = gen_rtx_SYMBOL_REF (Pmode, "__float_pesisf"); \
+            floatsidf_libfunc = gen_rtx_SYMBOL_REF (Pmode, "__float_pesidf"); \
+            extendsfdf2_libfunc = gen_rtx_SYMBOL_REF (Pmode, "__extend_pesfdf2"); \
+        }
+/* <<<<< add iruma m.takeishi '03.11.19 */
+#endif
+/* <<<<< delete iruma m.takeishi '04.02.24 */
+
+
+/* C33: If the following line is not defined, the compile error occurs. */
+/* Max number of bytes we can move from memory to memory
+   in one reasonably fast instruction.  */
+#define MOVE_MAX	4
+
+
+/* C33: If the following line is not defined, the link error occurs. */
+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits
+   is done just by pretending it is already truncated.  */
+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1
+
+
+/* Specify the machine mode that pointers have.
+   After generation of rtl, the compiler makes no further distinction
+   between pointers and any other objects of this machine mode.  */
+#define Pmode SImode
+
+/* C33: If the following line is not defined, the compile error occurs. */
+/* A function address in a call instruction
+   is a byte address (for indexing purposes)
+   so give the MEM rtx a byte's mode.  */
+#define FUNCTION_MODE QImode
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused */
+#if 0
+/* A C expression whose value is nonzero if IDENTIFIER with arguments ARGS
+   is a valid machine specific attribute for DECL.
+   The attributes in ATTRIBUTES have previously been assigned to DECL.  */
+#define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \
+c33_valid_machine_decl_attribute (DECL, IDENTIFIER, ARGS)
+#endif
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+
+/******************/
+/* C33: X: Others */
+/******************/
+
+/* Implement ZDA, TDA, SDA, and GDA */
+
+/* DEL K.Watanabe V1.7 >>>>>>> */
+/* C33: Unused. Define the following contents in "TARGET_ENCODE_SECTION_INFO". */
+#if 0
+#define ENCODE_SECTION_INFO(DECL)					\
+do {									\
+  if ((TREE_STATIC (DECL) || DECL_EXTERNAL (DECL))			\
+      && TREE_CODE (DECL) == VAR_DECL)					\
+    c33_encode_data_area (DECL);					\
+} while (0)
+#endif
+/* DEL K.Watanabe V1.7 <<<<<<< */
+
+#define ZDA_NAME_FLAG_CHAR '@'
+#define TDA_NAME_FLAG_CHAR '%'
+#define SDA_NAME_FLAG_CHAR '&'
+#define GDA_NAME_FLAG_CHAR '$'
+
+#define ZDA_NAME_P(NAME) (*(NAME) == ZDA_NAME_FLAG_CHAR)
+#define TDA_NAME_P(NAME) (*(NAME) == TDA_NAME_FLAG_CHAR)
+#define SDA_NAME_P(NAME) (*(NAME) == SDA_NAME_FLAG_CHAR)
+#define GDA_NAME_P(NAME) (*(NAME) == GDA_NAME_FLAG_CHAR)
+
+#define ENCODED_NAME_P(SYMBOL_NAME)    \
+  (ZDA_NAME_P (SYMBOL_NAME)            \
+   || TDA_NAME_P (SYMBOL_NAME)         \
+   || SDA_NAME_P (SYMBOL_NAME)         \
+   || GDA_NAME_P (SYMBOL_NAME))
+
+
+// DEL K.Watanabe V1.8 >>>>>>>
+#if 0
+#define STRIP_NAME_ENCODING(VAR,SYMBOL_NAME) \
+     (VAR) = (SYMBOL_NAME) + ENCODED_NAME_P (SYMBOL_NAME)
+#endif
+// DEL K.Watanabe V1.8 <<<<<<<
+
+
+extern int const_costs ();
+extern void print_operand ();
+extern void print_operand_address ();
+extern char *output_move_single ();
+extern int power_of_two_operand ();
+extern int not_power_of_two_operand ();
+extern int compute_frame_size ();
+extern void expand_prologue ();
+extern void expand_epilogue ();
+extern void notice_update_cc ();
+extern void declare_object ();
+
diff --git a/gcc/config/c33/c33.md b/gcc/config/c33/c33.md
new file mode 100644
index 0000000..1371f97
--- /dev/null
+++ b/gcc/config/c33/c33.md
@@ -0,0 +1,1241 @@
+;; GCC machine description for EPSON C33
+;; Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+
+;;   Contributed by Jeff Law (law@cygnus.com).
+
+;; This file is part of GNU CC.
+
+;; GNU CC is free software; you can redistribute it and/or modify
+;; it under the terms of the GNU General Public License as published by
+;; the Free Software Foundation; either version 2, or (at your option)
+;; any later version.
+
+;; GNU CC is distributed in the hope that it will be useful,
+;; but WITHOUT ANY WARRANTY; without even the implied warranty of
+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;; GNU General Public License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GNU CC; see the file COPYING.  If not, write to
+;; the Free Software Foundation, 59 Temple Place - Suite 330,
+;; Boston, MA 02111-1307, USA.
+
+
+;; See file "rtl.def" for documentation on define_insn, match_*, et. al.
+
+
+;; Types of instructions (for scheduling purposes). C33: Add instrucutions for branch.
+
+(define_attr "type" "load,branch,other"
+  (const_string "other"))
+
+;; The size of instructions in bytes.
+
+(define_attr "length" "" 
+  (cond [(eq_attr "type" "branch")
+	 (if_then_else (and (ge (minus (pc) (match_dup 0))
+				(const_int -254))
+			    (le (minus (pc) (match_dup 0))
+;				(const_int 256)))
+				(const_int 258)))
+		       (const_int 2)
+		       (if_then_else (and (ge (minus (pc) (match_dup 0))
+					      (const_int -2097150))
+					  (le (minus (pc) (match_dup 0))
+					      (const_int 2097152)))
+				     (const_int 4)
+				     (const_int 6)))]
+	(const_int 200)))
+
+(define_function_unit "memory" 1 1 (eq_attr "type" "load") 2 0)
+
+; Definitions for filling branch delay slots.
+
+(define_attr "needs_delay_slot" "yes,no" (const_string "no"))
+
+(define_attr "in_delay_slot" "yes,no" (const_string "no"))
+
+(define_delay
+  (eq_attr "needs_delay_slot" "yes")
+  [(eq_attr "in_delay_slot" "yes") (nil) (nil)])
+
+;; ----------------------------------------------------------------------
+;; MOVE INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; movqi
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand_post_inc" "")
+	(match_operand:QI 1 "general_operand_post_inc" ""))]
+  ""
+  "
+{
+  /* One of the ops has to be in a register */
+  if (!register_operand (operand0, QImode)
+      && !register_operand (operand1, QImode))
+    operands[1] = copy_to_mode_reg (QImode, operand1);
+}")
+
+(define_insn "*movqi_internal"
+  [(set (match_operand:QI 0 "general_operand_post_inc" "=r,r,r,r,m,r,>")
+	(match_operand:QI 1 "general_operand_post_inc"      "r,K,n,m,r,>,r"))]
+  "register_operand (operands[0], QImode)
+   || register_operand (operands[1], QImode)"
+  "* return output_move_single (operands, TRUE);"
+  [(set_attr "length" "2,2,4,6,6,2,2")
+   (set_attr "type" "other,other,other,load,other,load,other")
+   (set_attr "in_delay_slot" "yes,yes,no,no,no,no,no")])
+
+;; movhi
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand_post_inc" "")
+	(match_operand:HI 1 "general_operand_post_inc" ""))]
+  ""
+  "
+{
+  /* One of the ops has to be in a register */
+  if (!register_operand (operand0, HImode)
+      && !register_operand (operand1, HImode))
+    operands[1] = copy_to_mode_reg (HImode, operand1);
+}")
+
+(define_insn "*movhi_internal"
+  [(set (match_operand:HI 0 "general_operand_post_inc" "=r,r,r,r,m,r,>")
+	(match_operand:HI 1 "general_operand_post_inc"      "r,K,n,m,r,>,r"))]
+  "register_operand (operands[0], HImode)
+   || register_operand (operands[1], HImode)"
+  "* return output_move_single (operands, TRUE);"
+  [(set_attr "length" "2,2,4,6,6,2,2")
+   (set_attr "type" "other,other,other,load,other,load,other")
+   (set_attr "in_delay_slot" "yes,yes,no,no,no,no,no")])
+
+
+;; movsi and helpers
+
+(define_expand "movsi"
+  [(set (match_operand:SI 0 "general_operand_post_inc" "")
+	(match_operand:SI 1 "general_operand_post_inc" ""))]
+  ""
+  "
+{
+  /* One of the ops has to be in a register */
+  if (!register_operand (operand0, SImode)
+      && !register_operand (operand1, SImode))
+    operands[1] = copy_to_mode_reg (SImode, operand1);
+}")
+
+(define_insn "*movsi_internal"
+  [(set (match_operand:SI 0 "general_operand_post_inc" "=r,r,f,r,r,r,r,m,r,>")
+	(match_operand:SI 1 "general_operand_post_inc"     "r,f,r,K,L,m,i,r,>,r"))]
+  "register_operand (operands[0], SImode)
+   || register_operand (operands[1], SImode)"
+  "* return output_move_single (operands, FALSE);"
+  [(set_attr "length" "2,2,2,2,4,6,6,6,2,2")
+   (set_attr "type" "other,other,other,other,other,load,other,other,load,other")
+   (set_attr "in_delay_slot" "yes,no,no,yes,no,no,no,no,no,no")])
+
+(define_expand "movdi"
+  [(set (match_operand:DI 0 "general_operand" "")
+	(match_operand:DI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* One of the ops has to be in a register */
+  if (!register_operand (operand0, DImode)
+      && !register_operand (operand1, DImode))
+    operands[1] = copy_to_mode_reg (DImode, operand1);
+}")
+
+;;; CHG K.Watanabe V1.7 >>>>>>> 
+
+;;;; (define_insn "*movdi_internal"
+;;;;   [(set (match_operand:DI 0 "general_operand" "=r,r,r,r,r,m,r")
+;;;; 	(match_operand:DI 1 "general_operand"  "r,K,L,i,m,r,iF"))]
+;;;;   "register_operand (operands[0], DImode)
+;;;;    || register_operand (operands[1], DImode)"
+;;;;   "* return output_move_double (operands);"
+;;;;   [(set_attr "length" "4,4,6,12,12,12,12")
+;;;;    (set_attr "type" "other,other,other,other,load,other,other")])
+
+(define_insn "*movdi_internal"
+[(set (match_operand:DI 0 "general_operand" "=r,r,r,r,r,m,r")
+(match_operand:DI 1 "general_operand"  "r,K,L,i,m,r,iF"))]
+"register_operand (operands[0], DImode)
+|| register_operand (operands[1], DImode)"
+"* return output_move_double (operands);"
+[(set_attr "length" "4,4,8,12,12,12,12")
+(set_attr "type" "other,other,other,other,load,other,other")])
+   
+;;; CHG K.Watanabe V1.7 <<<<<<<
+ 
+(define_expand "movsf"
+  [(set (match_operand:SF 0 "general_operand" "")
+	(match_operand:SF 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* One of the ops has to be in a register or 0 */
+  if (!register_operand (operand0, SFmode)
+      && !register_operand (operand1, SFmode))
+    operands[1] = copy_to_mode_reg (SFmode, operand1);
+}")
+
+(define_insn "*movsf_internal"
+  [(set (match_operand:SF 0 "general_operand" "=r,r,m,r")
+	(match_operand:SF 1 "general_operand"  "r,m,r,iF"))]
+  "register_operand (operands[0], SFmode)
+   || register_operand (operands[1], SFmode)"
+  "* return output_move_single (operands, FALSE);"
+  [(set_attr "length" "2,6,6,6")
+   (set_attr "type" "other,load,other,other")
+   (set_attr "in_delay_slot" "yes,no,no,no")])
+
+
+(define_expand "movdf"
+  [(set (match_operand:DF 0 "general_operand" "")
+	(match_operand:DF 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* One of the ops has to be in a register or 0 */
+  if (!register_operand (operand0, DFmode)
+      && !register_operand (operand1, DFmode))
+    operands[1] = copy_to_mode_reg (DFmode, operand1);
+}")
+
+(define_insn "*movdf_internal"
+  [(set (match_operand:DF 0 "general_operand" "=r,r,m,r")
+	(match_operand:DF 1 "general_operand"  "r,m,r,iF"))]
+  "register_operand (operands[0], DFmode)
+   || register_operand (operands[1], DFmode)"
+  "*
+{
+  rtx xoperands[10];
+
+  xoperands[0] = operands[0];
+  xoperands[1] = operands[1];
+  
+  output_asm_insn (output_move_double (xoperands), xoperands);
+  return \"\";
+}"
+  [(set_attr "length" "4,12,12,12")
+   (set_attr "type" "other,load,other,other")])
+
+;; ----------------------------------------------------------------------
+;; TEST INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;;; CHG K.Watanabe V1.7 >>>>>>>
+;;;; C33: The process of "tstsi" is sometimes omitted 
+;;;;      in the case that "tstsi" is defined and compiled with "-O".
+;;;;      In this case, the incorrect process is done in the case of
+;;;;      "negative numbers - positive numbers => overflow".
+;;;;      So disable "tstsi" in the case of "-O" or more.
+
+
+;; C33: The comparison is the essential after the operation,
+;;      if "tstsi" is defined.
+;;
+;;(define_insn "tstsi"
+;;  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
+;;  ""
+;;  "cmp\\t%0,0\\t;tstsi"
+;;  [(set_attr "length" "2")
+;;   (set_attr "in_delay_slot" "yes")])
+
+(define_insn "tstsi"
+  [(set (cc0) (match_operand:SI 0 "register_operand" "r"))]
+  "optimize == 0"
+  "cmp\\t%0,0\\t;tstsi"
+  [(set_attr "length" "2")
+   (set_attr "in_delay_slot" "yes")])
+
+;;; CHG K.Watanabe V1.7 <<<<<<<
+
+
+(define_insn "cmpsi"
+  [(set (cc0)
+    (compare (match_operand:SI 0 "register_operand" "r,r,r,r")
+	     (match_operand:SI 1 "nonmemory_operand" "r,K,L,n")))]
+  ""
+  "@
+  cmp\\t%0,%1
+  xcmp\\t%0,%1\\t;%v1
+  xcmp\\t%0,%1\\t;%v1
+  xcmp\\t%0,%1\\t;%v1"
+  [(set_attr "length" "2,2,4,6")
+   (set_attr "in_delay_slot" "yes,yes,no,no")])
+
+
+
+;; ----------------------------------------------------------------------
+;; ADD INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(plus:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
+		 (match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
+  ""
+  "*
+{
+  HOST_WIDE_INT value;
+  switch (which_alternative) {
+  case 0:	/* C33: In the case of matching the first restriction.( Add the register value. ) */
+    return \"add\\t%0,%2\";
+    break;
+  case 1:	/* C33: In the case of matching the second restriction.( Add the immediate. ) */
+  case 2:
+  case 3:
+    value = INTVAL(operands[2]);	/* C33: Take out the value of operand2. */
+    if (value > 0) {				/* C33: In the case that operand2 is positive numbers. */
+      return \"xadd\\t%0,%2\\t;%v2\";
+    }
+    else {							/* C33: In the case that operand2 is negative numbers. */
+      return \"xsub\\t%0,%n2\\t;%v2\";
+    }
+    break;
+
+  default:
+    abort();
+    return \"\";
+  }
+}"
+  [(set_attr "length" "2,2,4,6")
+   (set_attr "type" "other")
+   (set_attr "in_delay_slot" "yes,yes,no,no")])
+
+
+
+;; ----------------------------------------------------------------------
+;; SUBTRACT INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(minus:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
+		  (match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
+  ""
+  "*
+{
+  HOST_WIDE_INT value;
+  switch (which_alternative) {
+  case 0:	/* C33: In the case of matching the first restriction.( Subtract the register value. ) */
+    return \"sub\\t%0,%2\";
+    break;
+  case 1:	/* C33: In the case of matching the second restriction.( Subtract the immediate. ) */
+  case 2:
+  case 3:
+    value = INTVAL(operands[2]);	/* C33: Take out the value of operand2. */
+    if (value > 0) {				/* C33: In the case that operand2 is positive numbers. */
+      return \"xsub\\t%0,%2\\t;%v2\";
+    }
+    else {							/* C33: In the case that operand2 is negative numbers. */
+      return \"xadd\\t%0,%n2\\t;%v2\";
+    }
+    break;
+
+  default:
+    abort();
+    return \"\";
+  }
+}"
+  [(set_attr "length" "2,2,4,6")
+   (set_attr "type" "other")
+   (set_attr "in_delay_slot" "yes,yes,no,no")])
+
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (neg:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "not\\t%0,%1\\t;negsi2\\n\\tadd\\t%0,1"
+;  "not %0,%1; add %0,1\\t#negsi2"
+  [(set_attr "length" "4")])
+
+;;; C33: If we have 0 register, we can do above with one struction,
+;;;      but we don't have it, so do this with two instructions.
+;;;      There is the other method that substract %1 after load 0.
+             
+
+;; ----------------------------------------------------------------------
+;; MULTIPLY INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;;; DEL K.Watanabe V1.8 >>>>>>> 
+;;; compiler_known_isuues.txt -- No9
+;;; C33: The definition of "mulqihi3/umulqihi3" which defines 8bit multiplication is not necessary 
+;;;      because "mlt" instruction has only 16 bit multiplication and 32 bit multiplication.
+;;;      Delete this definition because char type multiplication in negative numbers is incorrect
+;;;      in the case that this definition is defined.
+;;;(define_insn "mulqihi3"
+;;;  [(set (match_operand:HI 0 "register_operand" "=r")
+;;;	(mult:HI
+;;;	  (sign_extend:HI (match_operand:QI 1 "register_operand" "r"))
+;;;	  (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
+;;;  ""
+;;;  "mlt.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; mulqihi3"
+;;;;  "mlt.h %1,%2; ld.w %0,alr\\t# mulqihi3"
+;;;  [(set_attr "length" "4")
+;;;   (set_attr "type" "other")])
+;;;
+;;;(define_insn "umulqihi3"
+;;;  [(set (match_operand:HI 0 "register_operand" "=r")
+;;;	(mult:HI
+;;;	  (zero_extend:HI (match_operand:QI 1 "register_operand" "r"))
+;;;	  (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
+;;;  ""
+;;;  "mltu.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; umulqihi3"
+;;;;  "mltu.h %1,%2; ld.w %0,alr\\t# umulqihi3"
+;;;  [(set_attr "length" "4")
+;;;   (set_attr "type" "other")])
+;; DEL K.Watanabe V1.8 <<<<<<<
+
+
+(define_insn "mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI
+	  (sign_extend:SI (match_operand:HI 1 "register_operand" "r"))
+	  (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
+  ""
+  "mlt.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; mulhisi3"
+;  "mlt.h %1,%2; ld.w %0,alr\\t# mulhisi3"
+  [(set_attr "length" "4")
+   (set_attr "type" "other")])
+
+(define_insn "umulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI
+	  (zero_extend:SI (match_operand:HI 1 "register_operand" "r"))
+	  (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
+  ""
+  "mltu.h\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; umulhisi3"
+;  "mltu.h %1,%2; ld.w %0,alr\\t# umulhisi3"
+  [(set_attr "length" "4")
+   (set_attr "type" "other")])
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI
+	  (match_operand:SI 1 "register_operand" "r")
+	  (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "mlt.w\\t%1,%2\\n\\tld.w\\t%0,%%alr\\t; mulsi3"
+;  "mlt.w %1,%2; ld.w %0,alr\\t# mulsi3"
+  [(set_attr "length" "4")
+   (set_attr "type" "other")])
+
+
+;; ----------------------------------------------------------------------
+;; AND INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(and:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
+		(match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
+  ""
+  "@
+  and\\t%0,%2
+  xand\\t%0,%2\\t;%v2
+  xand\\t%0,%2\\t;%v2
+  xand\\t%0,%2\\t;%v2"
+  [(set_attr "length" "2,2,4,6")
+   (set_attr "type" "other")
+   (set_attr "in_delay_slot" "yes,yes,no,no")])
+
+
+;; ----------------------------------------------------------------------
+;; OR INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(ior:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
+		(match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
+  ""
+  "@
+  or\\t%0,%2
+  xoor\\t%0,%2\\t;%v2
+  xoor\\t%0,%2\\t;%v2
+  xoor\\t%0,%2\\t;%v2"
+  [(set_attr "length" "2,2,4,6")
+   (set_attr "type" "other")
+   (set_attr "in_delay_slot" "yes,yes,no,no")])
+
+
+;; ----------------------------------------------------------------------
+;; XOR INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(xor:SI (match_operand:SI 1 "register_operand" "0,0,0,0")
+		(match_operand:SI 2 "nonmemory_operand" "r,K,L,n")))]
+  ""
+  "@
+  xor\\t%0,%2
+  xxor\\t%0,%2\\t;%v2
+  xxor\\t%0,%2\\t;%v2
+  xxor\\t%0,%2\\t;%v2"
+  [(set_attr "length" "2,2,4,6")
+   (set_attr "type" "other")
+   (set_attr "in_delay_slot" "yes,yes,no,no")])
+
+
+;; ----------------------------------------------------------------------
+;; NOT INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(not:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "not %0,%1"
+  [(set_attr "length" "2")
+   (set_attr "in_delay_slot" "yes")])
+
+   /* C33: Do not define logic negative of the immediate,
+           because it is solved at the time of compiling.  */
+   
+
+;; -----------------------------------------------------------------
+;; BIT FIELDS
+;; -----------------------------------------------------------------
+
+/* C33: Unnecessary in C33. */
+
+;; -----------------------------------------------------------------
+;; Scc INSTRUCTIONS
+;; -----------------------------------------------------------------
+
+/* C33: Do not define "Scc" in C33 because C33 do not have the instruction
+        which sets the value accroding to the condition judgment.           */
+
+;; -----------------------------------------------------------------
+;; C33: BIT OPERATION INSTRUCTIONS
+;; -----------------------------------------------------------------
+
+(define_peephole
+  [(set (match_operand:QI 0 "register_operand" "=r") 
+		(match_operand:QI 1 "memory_operand" "m"))
+   (set (match_operand:SI 2 "register_operand" "=r") 
+        (and:SI (match_operand:SI 3 "register_operand" "r")
+			    (match_operand:SI 4 "const_int_operand" "n")))
+   (set (cc0) (match_operand:SI 5 "register_operand" "r"))]
+
+  "/* C33: The registers must not be used in the future. */
+   dead_or_set_p (insn, operands[0])
+   && dead_or_set_p (insn, operands[2])
+   /* C33: The registers for the process must be the same. */
+   && (REGNO(operands[0]) == REGNO(operands[2]))
+   && (REGNO(operands[0]) == REGNO(operands[5]))
+   /* C33: Operation object must be 1bit. */
+   && (GET_CODE(operands[4]) == CONST_INT)
+   && ((INTVAL(operands[4]) == 0x01) || (INTVAL(operands[4]) == 0x02)
+	|| (INTVAL(operands[4]) == 0x04) || (INTVAL(operands[4]) == 0x08)
+	|| (INTVAL(operands[4]) == 0x10) || (INTVAL(operands[4]) == 0x20)
+	|| (INTVAL(operands[4]) == 0x40) || (INTVAL(operands[4]) == 0x80)
+	|| (INTVAL(operands[4]) == 0xffffff80))
+   /* C33: The memory reference must not be %sp indirect. */
+   && !((GET_CODE(XEXP(operands[1], 0)) == PLUS)
+    && (REGNO(XEXP(XEXP(operands[1], 0), 0)) == STACK_POINTER_REGNUM))
+   && !((GET_CODE(XEXP(operands[1], 0)) == REG)
+    && (REGNO(XEXP(operands[1], 0)) == STACK_POINTER_REGNUM))
+   /* C33: The reference destination must not be defaut data area in the case of Advanced mode. */
+   && !(TARGET_C33ADV
+    && (GET_CODE(XEXP(operands[1], 0)) == SYMBOL_REF)
+    && (!ENCODED_NAME_P(XSTR(XEXP(operands[1], 0), 0))))
+   && !(TARGET_C33ADV
+    && (GET_CODE(XEXP(operands[1], 0)) == CONST)
+    && (!ENCODED_NAME_P(XSTR(XEXP(XEXP(XEXP(operands[1], 0), 0), 0), 0))))"
+  "* return output_btst (operands);")
+
+
+(define_peephole
+  [(set (match_operand:QI 0 "register_operand" "=r")
+		(match_operand:QI 1 "memory_operand" "m"))
+   (set (match_operand:SI 2 "register_operand" "=r") 
+        (and:SI (match_operand:SI 3 "register_operand" "r")
+			    (match_operand:SI 4 "const_int_operand" "n")))
+   (set (match_dup 1) 
+		(match_operand:QI 5 "register_operand" "r"))]
+
+  "/* C33: The registers must not be used in the future. */
+   dead_or_set_p (insn, operands[0])
+   && dead_or_set_p (insn, operands[2])
+   /* C33: The registers for the process must be the same. */
+   && (REGNO(operands[0]) == REGNO(operands[2]))
+   && (REGNO(operands[0]) == REGNO(operands[5]))
+   /* C33: Operation object must be 1bit. */
+   && (GET_CODE(operands[4]) == CONST_INT)
+   && (((INTVAL(operands[4]) & 0xff) == 0xfe)
+       || ((INTVAL(operands[4]) & 0xff) == 0xfd)
+       || ((INTVAL(operands[4]) & 0xff) == 0xfb)
+       || ((INTVAL(operands[4]) & 0xff) == 0xf7)
+       || ((INTVAL(operands[4]) & 0xff) == 0xef)
+       || ((INTVAL(operands[4]) & 0xff) == 0xdf)
+       || ((INTVAL(operands[4]) & 0xff) == 0xbf)
+       || ((INTVAL(operands[4]) & 0xff) == 0x7f))
+   /* C33: The memory reference must not be %sp indirect. */
+   && !((GET_CODE(XEXP(operands[1], 0)) == PLUS)
+    && (REGNO(XEXP(XEXP(operands[1], 0), 0)) == STACK_POINTER_REGNUM))
+   && !((GET_CODE(XEXP(operands[1], 0)) == REG)
+    && (REGNO(XEXP(operands[1], 0)) == STACK_POINTER_REGNUM))
+   /* C33: The reference destination must not be defaut data area in the case of Advanced mode. */
+   && !(TARGET_C33ADV
+    && (GET_CODE(XEXP(operands[1], 0)) == SYMBOL_REF)
+    && (!ENCODED_NAME_P(XSTR(XEXP(operands[1], 0), 0))))
+   && !(TARGET_C33ADV
+    && (GET_CODE(XEXP(operands[1], 0)) == CONST)
+    && (!ENCODED_NAME_P(XSTR(XEXP(XEXP(XEXP(operands[1], 0), 0), 0), 0))))"
+  "* return output_bclr (operands);")
+
+
+(define_peephole
+  [(set (match_operand:QI 0 "register_operand" "=r")
+		(match_operand:QI 1 "memory_operand" "m"))
+   (set (match_operand:SI 2 "register_operand" "=r") 
+        (ior:SI (match_operand:SI 3 "register_operand" "r")
+		(match_operand:SI 4 "const_int_operand" "n")))
+   (set (match_dup 1)
+		(match_operand:QI 5 "register_operand" "r"))]
+
+  "/* C33: The registers must not be used in the future. */
+   dead_or_set_p (insn, operands[0])
+   && dead_or_set_p (insn, operands[2])
+   /* C33: The registers for the process must be the same. */
+   && (REGNO(operands[0]) == REGNO(operands[2]))
+   && (REGNO(operands[0]) == REGNO(operands[5]))
+   /* C33: Operation object must be 1bit. */
+   && (GET_CODE(operands[4]) == CONST_INT)
+   && (((INTVAL(operands[4]) & 0xff) == 0x01)
+       || ((INTVAL(operands[4]) & 0xff) == 0x02)
+	   || ((INTVAL(operands[4]) & 0xff) == 0x04)
+	   || ((INTVAL(operands[4]) & 0xff) == 0x08)
+	   || ((INTVAL(operands[4]) & 0xff) == 0x10)
+	   || ((INTVAL(operands[4]) & 0xff) == 0x20)
+	   || ((INTVAL(operands[4]) & 0xff) == 0x40)
+ 	   || ((INTVAL(operands[4]) & 0xff) == 0x80))
+   /* C33: The memory reference must not be %sp indirect. */
+   && !((GET_CODE(XEXP(operands[1], 0)) == PLUS)
+    && (REGNO(XEXP(XEXP(operands[1], 0), 0)) == STACK_POINTER_REGNUM))
+   && !((GET_CODE(XEXP(operands[1], 0)) == REG)
+    && (REGNO(XEXP(operands[1], 0)) == STACK_POINTER_REGNUM))
+   /* C33: The reference destination must not be defaut data area in the case of Advanced mode. */
+   && !(TARGET_C33ADV
+    && (GET_CODE(XEXP(operands[1], 0)) == SYMBOL_REF)
+    && (!ENCODED_NAME_P(XSTR(XEXP(operands[1], 0), 0))))
+   && !(TARGET_C33ADV
+    && (GET_CODE(XEXP(operands[1], 0)) == CONST)
+    && (!ENCODED_NAME_P(XSTR(XEXP(XEXP(XEXP(operands[1], 0), 0), 0), 0))))"
+  "* return output_bset (operands);")
+
+
+;; ----------------------------------------------------------------------
+;; JUMP INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; Conditional jump instructions
+
+(define_expand "ble"
+  [(set (pc)
+	(if_then_else (le (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bleu"
+  [(set (pc)
+	(if_then_else (leu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bge"
+  [(set (pc)
+	(if_then_else (ge (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bgeu"
+  [(set (pc)
+	(if_then_else (geu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "blt"
+  [(set (pc)
+	(if_then_else (lt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bltu"
+  [(set (pc)
+	(if_then_else (ltu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bgt"
+  [(set (pc)
+	(if_then_else (gt (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bgtu"
+  [(set (pc)
+	(if_then_else (gtu (cc0)
+			   (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "beq"
+  [(set (pc)
+	(if_then_else (eq (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+(define_expand "bne"
+  [(set (pc)
+	(if_then_else (ne (cc0)
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "")
+
+/* C33: The conditional branch is the same to V850 so far. */
+
+(define_insn "*branch_normal"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+				      [(cc0) (const_int 0)])
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+  "*
+{
+  if (get_attr_length (insn) == 2)
+    return \"jr%b1%#\\t%l0\";
+  else if (get_attr_length (insn) == 4)
+    /* return \"ext %l0@rm\; jr%b1%# %l0@rl\"; */
+    return \"sjr%b1%#\\t%l0\";
+  else
+    /* return \"ext %l0@rh\; ext %l0@rm\; jr%b1%# %l0@rl\"; */
+    return \"xjr%b1%#\\t%l0\";
+}"
+ [(set_attr "type" "branch")
+  (set_attr "needs_delay_slot" "yes")])
+
+
+(define_insn "*branch_invert"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+				      [(cc0) (const_int 0)])
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+  "*
+{
+  if (get_attr_length (insn) == 2)
+    return \"jr%B1%#\\t%l0\";
+  else if (get_attr_length (insn) == 4)
+    /* return \"ext %l0@rm\; jr%B1%# %l0@rl\"; */
+    return \"sjr%B1%#\\t%l0\";
+  else
+    /* return \"ext %l0@rh\; ext %l0@rm\; jr%B1%# %l0@rl\"; */
+    return \"xjr%B1%#\\t%l0\";
+}"
+ [(set_attr "type" "branch")
+  (set_attr "needs_delay_slot" "yes")])
+
+
+;; Unconditional and other jump instructions.
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "*
+{
+  if (get_attr_length (insn) == 2)
+    return \"jp%#\\t%l0\";
+  else if (get_attr_length (insn) == 4)
+    /* return \"ext %l0@rm\; jp%# %l0@rl\"; */
+    return \"sjp%#\\t%l0\";
+  else
+    /* return \"ext %l0@rh\; ext %l0@rm\; jp%# %l0@rl\"; */
+    return \"xjp%#\\t%l0\";
+}"
+  [(set_attr "type" "branch")
+   (set_attr "needs_delay_slot" "yes")])
+
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "jp%#\\t%0"
+  [(set_attr "length" "2")
+   (set_attr "needs_delay_slot" "yes")])
+
+
+(define_insn "tablejump"
+  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  "jp%#\\t%0"
+  [(set_attr "length" "2")
+   (set_attr "needs_delay_slot" "yes")])
+
+
+;; Call subroutine with no return value.
+
+(define_expand "call"
+  [(call (match_operand:QI 0 "general_operand" "")
+	 (match_operand:SI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* CHG K.Watanabe V1.7 >>>>>>> */
+/*  if (! call_address_operand (XEXP (operands[0], 0))) */
+  if (! call_address_operand (XEXP (operands[0], 0),QImode))
+  /* CHG K.Watanabe V1.7 <<<<<<< */ 
+  
+  XEXP (operands[0], 0) = force_reg (SImode, XEXP (operands[0], 0));
+  if (TARGET_LONG_CALLS)
+    emit_call_insn (gen_call_internal_long (XEXP (operands[0], 0), operands[1]));
+  else
+    emit_call_insn (gen_call_internal_short (XEXP (operands[0], 0), operands[1]));
+  DONE;
+}")
+
+
+;; C33: Define the follwing lines in c33.c.
+;; call_address_operand()
+;; {
+;;	return (GET_CODE(op) == SYMBOL_REF || GET_CODE(op) == REG);
+;; }
+
+(define_insn "call_internal_short"
+  [(call (mem:QI (match_operand:SI 0 "call_address_operand" "S,r"))
+	 (match_operand:SI 1 "general_operand" "g,g"))]
+  "! TARGET_LONG_CALLS"
+  "@
+  scall%#\\t%0
+  call%#\\t%0"
+  [(set_attr "length" "4,2")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn "call_internal_long"
+  [(call (mem:QI (match_operand:SI 0 "call_address_operand" "S,r"))
+	 (match_operand:SI 1 "general_operand" "g,g"))]
+  "TARGET_LONG_CALLS"
+  "@
+  xcall%#\\t%0
+  call%#\\t%0"
+  [(set_attr "length" "6,2")
+   (set_attr "needs_delay_slot" "yes")])
+
+
+;; Call subroutine, returning value in operand 0
+;; (which must be a hard register).
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+	(call (match_operand:QI 1 "general_operand" "")
+	      (match_operand:SI 2 "general_operand" "")))]
+  ""
+  "
+{
+  /* CHG K.Watanabe V1.7 >>>>>>> */ 
+/*  if (! call_address_operand (XEXP (operands[1], 0))) */
+  if (! call_address_operand (XEXP (operands[1], 0),QImode))
+  /* CHG K.Watanabe V1.7 <<<<<<< */ 
+  
+    XEXP (operands[1], 0) = force_reg (SImode, XEXP (operands[1], 0));
+  if (TARGET_LONG_CALLS)
+    emit_call_insn (gen_call_value_internal_long (operands[0],
+	 				          XEXP (operands[1], 0),
+					          operands[2]));
+  else
+    emit_call_insn (gen_call_value_internal_short (operands[0],
+	 				           XEXP (operands[1], 0),
+					           operands[2]));
+  DONE;
+}")
+
+(define_insn "call_value_internal_short"
+  [(set (match_operand 0 "" "=r,r")
+	(call (mem:QI (match_operand:SI 1 "call_address_operand" "S,r"))
+	      (match_operand:SI 2 "general_operand" "g,g")))]
+  "! TARGET_LONG_CALLS"
+  "@
+  scall%#\\t%1
+  call%#\\t%1"
+  [(set_attr "length" "4,2")
+   (set_attr "needs_delay_slot" "yes")])
+
+(define_insn "call_value_internal_long"
+  [(set (match_operand 0 "" "=r,r")
+	(call (mem:QI (match_operand:SI 1 "call_address_operand" "S,r"))
+	      (match_operand:SI 2 "general_operand" "g,g")))]
+  "TARGET_LONG_CALLS"
+  "@
+  xcall%#\\t%1
+  call%#\\t%1"
+  [(set_attr "length" "6,2")
+   (set_attr "needs_delay_slot" "yes")])
+
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "length" "2")
+   (set_attr "in_delay_slot" "yes")])
+
+;; ----------------------------------------------------------------------
+;; EXTEND INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI
+	 (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "* return output_move_single (operands, TRUE);"
+  [(set_attr "length" "2,6")
+   (set_attr "type" "other,load")
+   (set_attr "in_delay_slot" "yes,no")])
+
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI
+	 (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "* return output_move_single (operands, TRUE);"
+  [(set_attr "length" "2,6")
+   (set_attr "type" "other,load")
+   (set_attr "in_delay_slot" "yes,no")])
+
+
+;;- sign extension instructions
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(sign_extend:SI
+	 (match_operand:HI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "* return output_move_single (operands, FALSE);"
+  [(set_attr "length" "2,6")
+   (set_attr "type" "other,load")
+   (set_attr "in_delay_slot" "yes,no")])
+
+
+(define_insn "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(sign_extend:SI
+	 (match_operand:QI 1 "nonimmediate_operand" "r,m")))]
+  ""
+  "* return output_move_single (operands, FALSE);"
+  [(set_attr "length" "2,6")
+   (set_attr "type" "other,load")
+   (set_attr "in_delay_slot" "yes,no")])
+
+
+;; ----------------------------------------------------------------------
+;; SHIFTS
+;; ----------------------------------------------------------------------
+
+(define_expand "rotlsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+        (rotate:SI (match_operand:SI 1 "register_operand" "")
+                   (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "if (expand_a_shift (SImode, ROTATE, operands)) DONE;else FAIL;")
+
+(define_insn "rotlsi3_c33"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
+	(rotate:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0")
+	           (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,n")))
+   (clobber (match_scratch:QI 3 "=&r,X,X,X,X"))]
+  "!TARGET_C33ADV && !TARGET_C33PE"
+  "* return emit_a_shift (ROTATE, operands);"
+  [(set_attr "length" "16,2,4,4,2")
+   (set_attr "in_delay_slot" "no,yes,no,no,yes")])
+
+(define_insn "rotlsi3_c33adv"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(rotate:SI (match_operand:SI 1 "register_operand" "0,0")
+	           (match_operand:QI 2 "nonmemory_operand" "r,n")))]
+  "TARGET_C33ADV || TARGET_C33PE"
+  "@
+   rl %0,%2
+   rl %0,%2"
+  [(set_attr "length" "2,2")
+   (set_attr "in_delay_slot" "yes,yes")])
+
+
+(define_expand "rotrsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+        (rotatert:SI (match_operand:SI 1 "register_operand" "")
+                     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "if (expand_a_shift (SImode, ROTATERT, operands)) DONE;else FAIL;")
+
+(define_insn "rotrsi3_c33"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
+	(rotatert:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0")
+	             (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,n")))
+   (clobber (match_scratch:QI 3 "=&r,X,X,X,X"))]
+  "!TARGET_C33ADV && !TARGET_C33PE"
+  "* return emit_a_shift (ROTATERT, operands);"
+  [(set_attr "length" "16,2,4,4,2")
+   (set_attr "in_delay_slot" "no,yes,no,no,yes")])
+
+(define_insn "rotrsi3_c33adv"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(rotatert:SI (match_operand:SI 1 "register_operand" "0,0")
+	             (match_operand:QI 2 "nonmemory_operand" "r,n")))]
+  "TARGET_C33ADV || TARGET_C33PE"
+  "@
+   rr %0,%2
+   rr %0,%2"
+  [(set_attr "length" "2,2")
+   (set_attr "in_delay_slot" "yes,yes")])
+
+
+/* C33: Arithmetical shift to left.
+        ( The instruction output actually is logical shift instruction "sll" ) */
+(define_expand "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+        (ashift:SI (match_operand:SI 1 "register_operand" "")
+                   (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "if (expand_a_shift (SImode, ASHIFT, operands)) DONE;else FAIL;")
+
+(define_insn "ashlsi3_c33"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r")
+        (ashift:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0,0")
+                   (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,P,n")))
+   (clobber (match_scratch:QI 3 "=&r,X,X,X,X,X"))]
+  "!TARGET_C33ADV && !TARGET_C33PE"
+  "* return emit_a_shift (ASHIFT, operands);"
+  [(set_attr "length" "16,2,4,6,8,4")
+   (set_attr "in_delay_slot" "no,yes,no,no,no,no")])
+
+(define_insn "ashlsi3_c33adv"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+        (ashift:SI (match_operand:SI 1 "register_operand" "0,0")
+                   (match_operand:QI 2 "nonmemory_operand" "r,n")))]
+  "TARGET_C33ADV || TARGET_C33PE"
+  "@
+   sll %0,%2
+   sll %0,%2"
+  [(set_attr "length" "2,2")
+   (set_attr "in_delay_slot" "yes,yes")])
+
+
+/* C33: Logical shift to right.
+        ( The instruction output actually is logical shift instruction "srl" ) */
+(define_expand "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+        (lshiftrt:SI (match_operand:SI 1 "register_operand" "")
+                     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "if (expand_a_shift (SImode, LSHIFTRT, operands)) DONE;else FAIL;")
+
+(define_insn "lshrsi3_c33"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r,r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0,0")
+		     (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,P,n")))
+   (clobber (match_scratch:QI 3 "=&r,X,X,X,X,X"))]
+  "!TARGET_C33ADV && !TARGET_C33PE"
+  "* return emit_a_shift (LSHIFTRT, operands);"
+  [(set_attr "length" "16,2,4,6,8,4")
+   (set_attr "in_delay_slot" "no,yes,no,no,no,no")])
+
+(define_insn "lshrsi3_c33adv"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
+		     (match_operand:QI 2 "nonmemory_operand" "r,n")))]
+  "TARGET_C33ADV || TARGET_C33PE"
+  "@
+   srl %0,%2
+   srl %0,%2"
+  [(set_attr "length" "2,2")
+   (set_attr "in_delay_slot" "yes,yes")])
+
+
+/* C33: Arithmetical shift to right.
+        ( The instruction output actually is arithmetical shift instruction "sra" ) */
+(define_expand "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+        (ashiftrt:SI (match_operand:SI 1 "register_operand" "")
+                     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  "if (expand_a_shift (SImode, ASHIFTRT, operands)) DONE;else FAIL;")
+
+(define_insn "ashrsi3_c33"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r,r")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0,0,0,0")
+		     (match_operand:QI 2 "nonmemory_operand" "r,M,N,O,n")))
+   (clobber (match_scratch:QI 3 "=&r,X,X,X,X"))]
+  "!TARGET_C33ADV && !TARGET_C33PE"
+  "* return emit_a_shift (ASHIFTRT, operands);"
+  [(set_attr "length" "16,2,4,6,8")
+   (set_attr "in_delay_slot" "no,yes,no,no,no")])
+
+(define_insn "ashrsi3_c33adv"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0,0")
+		     (match_operand:QI 2 "nonmemory_operand" "r,n")))]
+  "TARGET_C33ADV || TARGET_C33PE"
+  "@
+   sra %0,%2
+   sra %0,%2"
+  [(set_attr "length" "2,2")
+   (set_attr "in_delay_slot" "yes,yes")])
+
+
+
+;; Block moves, see c33.c for more details.
+;; Argument 0 is the destination
+;; Argument 1 is the source
+;; Argument 2 is the length
+;; Argument 3 is the alignment
+
+;; C33: Besed on mips.
+
+(define_expand "movstrsi"
+  [(parallel [(set (match_operand:BLK 0 "general_operand" "")
+		   (match_operand:BLK 1 "general_operand" ""))
+	      (use (match_operand:SI 2 "const_int_operand" ""))
+	      (use (match_operand:SI 3 "const_int_operand" ""))])]
+  ""
+  "
+{
+  if (operands[0])		/* avoid unused code messages */
+    {
+      expand_block_move (operands);
+      DONE;
+    }
+}")
+
+;; Insn generated by block moves
+
+;;; CHG K.Watanabe V1.7 >>>>>>>
+;;;; C33: "register_operand" shall not be "r" but be "+r".
+;;;;      Because the value of "destination/ source" is rewritten in "output_block_move()".
+
+;;(define_insn "movstrsi_internal"
+;;  [(set (mem:BLK (match_operand:SI 0 "register_operand" "r"))	;; destination
+;;	(mem:BLK (match_operand:SI 1 "register_operand" "r")))	;; source
+;;   (clobber (match_dup 0))					;; destination
+;;   (clobber (match_dup 1))					;; source
+;;   (clobber (match_scratch:SI 4 "=&r"))				;; temp 1
+;;   (clobber (match_scratch:SI 5 "=&r"))				;; temp 2
+;;   (clobber (match_scratch:SI 6 "=&r"))				;; temp 3
+;;   (clobber (match_scratch:SI 7 "=&r"))				;; temp 4
+;;   (use (match_operand:SI 2 "const_int_operand" ""))		;; # bytes to move
+;;   (use (match_operand:SI 3 "const_int_operand" ""))		;; alignment
+;;   (use (const_int 0))]						;; normal block move
+;;  ""
+;;  "* return output_block_move (insn, operands, 4);"
+;;  [(set_attr "length"	"20")])
+
+(define_insn "movstrsi_internal"
+  [(set (mem:BLK (match_operand:SI 0 "register_operand" "+r"))	;; destination
+	(mem:BLK (match_operand:SI 1 "register_operand" "+r")))	;; source
+   (clobber (match_dup 0))					;; destination
+   (clobber (match_dup 1))					;; source
+   (clobber (match_scratch:SI 4 "=&r"))				;; temp 1
+   (clobber (match_scratch:SI 5 "=&r"))				;; temp 2
+   (clobber (match_scratch:SI 6 "=&r"))				;; temp 3
+   (clobber (match_scratch:SI 7 "=&r"))				;; temp 4
+   (use (match_operand:SI 2 "const_int_operand" ""))		;; # bytes to move
+   (use (match_operand:SI 3 "const_int_operand" ""))		;; alignment
+   (use (const_int 0))]						;; normal block move
+  ""
+  "* return output_block_move (insn, operands, 4);"
+  [(set_attr "length"	"20")])
+;;; CHG K.Watanabe V1.7 <<<<<<<
+  
+  
+  
+;; ide 2000.10.4 Added
+;; C33: "peephole" for reducing ext by replacing "shift/and".
+;;      watanabe 2001.12.28 
+;;          The following definition is for ASHIFT( shift to left ).
+;;          Another definiton is necessary for shift to right.
+
+(define_peephole
+  [(parallel [
+	(set (match_operand:SI 0 "register_operand" "")
+	(match_operator:SI 3 "nshift_operator" 
+	 [(match_operand:SI 1 "register_operand" "0")
+	 (match_operand:QI 2 "const_int_operand" "n")]))
+   (clobber (scratch:QI))])
+   (set (match_operand:SI 4 "register_operand" "r")
+	(and:SI (match_operand:SI 5 "register_operand" "%0")
+		(match_operand:SI 6 "nonmemory_operand" "n")))
+]
+
+   "
+   /* C33: The registers for the process must be the same. */
+   (REGNO(operands[0]) == REGNO(operands[4]))
+	/* C33: Shift to left. */
+	&& (GET_CODE(operands[3]) == ASHIFT)
+	/* C33: The bit position before shifting is less than sign19 
+	        and the bit position after shifting is sign19 or more.
+	        Or the bit position before shifting is less than sign6 
+	        and the bit position after shifting is sign6 or more.        */
+	&& (
+		(((unsigned) (INTVAL(operands[6]) >> INTVAL(operands[2])) + 0x40000 < 0x80000)
+		&& ((unsigned) (INTVAL(operands[6])) + 0x40000 >= 0x80000))
+	  ||(((unsigned) (INTVAL(operands[6]) >> INTVAL(operands[2])) + 0x20 < 0x40)
+		&& ((unsigned) (INTVAL(operands[6])) + 0x20 >= 0x40))
+	)
+"
+  "*
+{
+	int shift_cnt = INTVAL(operands[2]);
+	int i = INTVAL(operands[6]);
+
+	i >>= shift_cnt;
+	operands[6] = GEN_INT(i);
+        
+	output_asm_insn(\"xand\\t%0,%6\\t;%v6\\t;peephole\",operands);
+
+//	emit_a_shift (insn, operands);
+	emit_a_shift (ASHIFT, operands);
+	return \"\";
+}")
+
+
diff --git a/gcc/config/c33/lib1funcs.s b/gcc/config/c33/lib1funcs.s
new file mode 100644
index 0000000..7157c19
--- /dev/null
+++ b/gcc/config/c33/lib1funcs.s
@@ -0,0 +1,315 @@
+/* libgcc1 routines for EPSON C33.
+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with files
+   compiled with GCC to produce an executable, this does not cause
+   the resulting executable to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+/*
+	Copyright (C) SEIKO EPSON CORP. 1996
+
+	Filename : divsi3.c
+	Function :
+	  This module defines the functions
+		that emulate signed and unsigned integer division.
+	Revision :
+	  10/18/1996	ESD T.Katahira		start			    */
+
+#ifdef L_divsi3
+
+//	Function :	___divsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- quotient
+//	Function :	calculate signed integer division
+
+	.section .text
+	.align 1
+	.global	___divsi3
+___divsi3:
+	ld.w	alr,r6	# set dividend to accumlator (alr)
+	div0s	r7		# initializer of signed division
+#ifdef	FAST
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	div1	r7		# execute division #9
+	div1	r7		# execute division #10
+	div1	r7		# execute division #11
+	div1	r7		# execute division #12
+	div1	r7		# execute division #13
+	div1	r7		# execute division #14
+	div1	r7		# execute division #15
+	div1	r7		# execute division #16
+	div1	r7		# execute division #17
+	div1	r7		# execute division #18
+	div1	r7		# execute division #19
+	div1	r7		# execute division #20
+	div1	r7		# execute division #21
+	div1	r7		# execute division #22
+	div1	r7		# execute division #23
+	div1	r7		# execute division #24
+	div1	r7		# execute division #25
+	div1	r7		# execute division #26
+	div1	r7		# execute division #27
+	div1	r7		# execute division #28
+	div1	r7		# execute division #29
+	div1	r7		# execute division #30
+	div1	r7		# execute division #31
+	div1	r7		# execute division #32
+#else
+	ld.w	r8,0x4		# set loop counter (N = 4)
+	ld.w	r9,psr	# save flag register
+___divsi3_loop_start:	
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	sub	r8,0x1		# decrement loop counter
+	jrne.d	___divsi3_loop_start	# if (loop counter != 0) goto loop top
+	ld.w	psr,r9	# restore flag register (delayed slot)
+#endif
+	div2s	r7		# post divistion process #1
+	div3s			# post divistion process #2
+	ret.d			# return to the caller (use delayed return)
+	ld.w	r4,alr	# set quotient to return reg (delayed slot)
+#endif /* L_divsi3 */
+
+#ifdef L_udivsi3
+
+//	Function :	___udivsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- quotient
+//	Function :	calculate unsigned integer division
+
+	.section .text
+	.align 1
+	.global	___udivsi3
+___udivsi3:
+	ld.w	alr,r6	# set dividend to accumlator (alr)
+	div0u	r7		# initializer of signed division
+#ifdef	FAST
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	div1	r7		# execute division #9
+	div1	r7		# execute division #10
+	div1	r7		# execute division #11
+	div1	r7		# execute division #12
+	div1	r7		# execute division #13
+	div1	r7		# execute division #14
+	div1	r7		# execute division #15
+	div1	r7		# execute division #16
+	div1	r7		# execute division #17
+	div1	r7		# execute division #18
+	div1	r7		# execute division #19
+	div1	r7		# execute division #20
+	div1	r7		# execute division #21
+	div1	r7		# execute division #22
+	div1	r7		# execute division #23
+	div1	r7		# execute division #24
+	div1	r7		# execute division #25
+	div1	r7		# execute division #26
+	div1	r7		# execute division #27
+	div1	r7		# execute division #28
+	div1	r7		# execute division #29
+	div1	r7		# execute division #30
+	div1	r7		# execute division #31
+	div1	r7		# execute division #32
+#else
+	ld.w	r8,0x4		# set loop counter (N = 4)
+___udivsi3_loop_start:	
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	sub	r8,0x1		# decrement loop counter
+	jrne	___udivsi3_loop_start	# if (loop counter != 0) goto loop top
+#endif
+	ret.d			# return to the caller (use delayed return)
+	ld.w	r4,alr	# set quotient to return reg (delayed slot)
+
+#endif /* L_udivsi3 */
+
+
+#ifdef L_modsi3
+
+//	Function :	___modsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- remainder
+//	Function :	calculate signed integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	___modsi3
+___modsi3:
+	ld.w	alr,r6	# set dividend to accumlator (alr)
+	div0s	r7		# initializer of signed division
+#ifdef	FAST
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	div1	r7		# execute division #9
+	div1	r7		# execute division #10
+	div1	r7		# execute division #11
+	div1	r7		# execute division #12
+	div1	r7		# execute division #13
+	div1	r7		# execute division #14
+	div1	r7		# execute division #15
+	div1	r7		# execute division #16
+	div1	r7		# execute division #17
+	div1	r7		# execute division #18
+	div1	r7		# execute division #19
+	div1	r7		# execute division #20
+	div1	r7		# execute division #21
+	div1	r7		# execute division #22
+	div1	r7		# execute division #23
+	div1	r7		# execute division #24
+	div1	r7		# execute division #25
+	div1	r7		# execute division #26
+	div1	r7		# execute division #27
+	div1	r7		# execute division #28
+	div1	r7		# execute division #29
+	div1	r7		# execute division #30
+	div1	r7		# execute division #31
+	div1	r7		# execute division #32
+#else
+	ld.w	r8,0x4		# set loop counter (N = 4)
+	ld.w	r9,psr	# save flag register
+___modsi3_loop_start:	
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	sub	r8,0x1		# decrement loop counter
+	jrne.d	___modsi3_loop_start	# if (loop counter != 0) goto loop top
+	ld.w	psr,r9	# restore flag register (delayed slot)
+#endif
+	div2s	r7		# post divistion process #1
+	div3s			# post divistion process #2
+	ret.d			# return to the caller (use delayed return)
+	ld.w	r4,ahr	# set remainder to return reg (delayed slot)
+
+#endif /* L_modsi3 */
+
+#ifdef L_umodsi3
+
+//	Function :	___umodsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- remainder
+//	Function :	calculate unsigned integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	___umodsi3
+___umodsi3:
+	ld.w	alr,r6	# set dividend to accumlator (alr)
+	div0u	r7		# initializer of signed division
+#ifdef	FAST
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	div1	r7		# execute division #9
+	div1	r7		# execute division #10
+	div1	r7		# execute division #11
+	div1	r7		# execute division #12
+	div1	r7		# execute division #13
+	div1	r7		# execute division #14
+	div1	r7		# execute division #15
+	div1	r7		# execute division #16
+	div1	r7		# execute division #17
+	div1	r7		# execute division #18
+	div1	r7		# execute division #19
+	div1	r7		# execute division #20
+	div1	r7		# execute division #21
+	div1	r7		# execute division #22
+	div1	r7		# execute division #23
+	div1	r7		# execute division #24
+	div1	r7		# execute division #25
+	div1	r7		# execute division #26
+	div1	r7		# execute division #27
+	div1	r7		# execute division #28
+	div1	r7		# execute division #29
+	div1	r7		# execute division #30
+	div1	r7		# execute division #31
+	div1	r7		# execute division #32
+#else
+	ld.w	r8,0x4		# set loop counter (N = 4)
+___umodsi3_loop_start:	
+	div1	r7		# execute division #1
+	div1	r7		# execute division #2
+	div1	r7		# execute division #3
+	div1	r7		# execute division #4
+	div1	r7		# execute division #5
+	div1	r7		# execute division #6
+	div1	r7		# execute division #7
+	div1	r7		# execute division #8
+	sub	r8,0x1		# decrement loop counter
+	jrne	___umodsi3_loop_start	# if (loop counter != 0) goto loop top
+#endif
+	ret.d			# return to the caller (use delayed return)
+	ld.w	r4,ahr	# set remainder to return reg (delayed slot)
+
+#endif /* L_umodsi3 */
diff --git a/gcc/config/c33/libgcc/Makefile b/gcc/config/c33/libgcc/Makefile
new file mode 100644
index 0000000..dbf9238
--- /dev/null
+++ b/gcc/config/c33/libgcc/Makefile
@@ -0,0 +1,45 @@
+# 011016 watanabe
+# 020612 fcmpd, fcmpsは使用しないことになった。
+
+FP_LIB = adddf3 \
+	 addsf3 \
+	 divdf3 \
+	 divsf3 \
+	 extsfdf \
+	 fcmpd \
+	 fcmps \
+	 fixdfi \
+	 fixdfui \
+	 fixsfi \
+	 fixsfui \
+	 flosidf \
+	 flosisf \
+	 muldf3 \
+	 mulsf3 \
+ 	 negdf2 \
+	 negsf2 \
+	 scan64 \
+	 trncdfsf
+
+EMU_LIB = divsi3 \
+	  modsi3 \
+	  divhi3 \
+	  modhi3
+
+LIB1ASMFUNCS = $(FP_LIB) $(EMU_LIB)
+#LIB1ASMFUNCS = $(FP_LIB)
+
+GAS_FOR_TARGET = /gnu33/as
+AR_FOR_TARGET = ar
+AR_FLAGS_FOR_TARGET = rc
+
+libgcc.a: 
+	for name in $(LIB1ASMFUNCS); \
+	do \
+	  echo $${name}; \
+	  $(GAS_FOR_TARGET) -alh $${name}.s -o $${name}.o >$${name}.lst; \
+	  $(AR_FOR_TARGET) $(AR_FLAGS_FOR_TARGET) tmplibgcc1.a $${name}.o; \
+	  rm -f $${name}.o; \
+	done
+	mv tmplibgcc1.a libgcc.a
+
diff --git a/gcc/config/c33/libgcc/adddf3.lst b/gcc/config/c33/libgcc/adddf3.lst
new file mode 100644
index 0000000..3965930
--- /dev/null
+++ b/gcc/config/c33/libgcc/adddf3.lst
@@ -0,0 +1,847 @@
+GAS LISTING adddf3.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : adddf3.s
+   6              	;*
+   7              	;*	Double floating point addition function
+   8              	;*						& subtract function
+   9              	;*		input: (%r7, %r6) & (%r9, %r8)
+  10              	;*		output: (%r5, %r4)
+  11              	;*
+  12              	;*	Begin				1996/09/12	V. Chan
+  13              	;*  Fixed sign bug		1997/02/17	V. Chan
+  14              	;*  ﾊﾑｹｹ				2001/01/18  O.Hinokuchi
+  15              	;*  			 		 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+  16              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  17              	;*
+  18              	;*****************************************
+  19              	
+  20              	.section .text
+  21              	.align 1
+  22              	.global	__adddf3
+  23              	.global __subdf3
+  24              	
+  25              	;==============================================
+  26              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  27              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+  28              	;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+  29              	;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/count
+  30              	;	%r3:ｻﾘｿﾉ｣ｲ(8bit)
+  31              	;	%r4:ﾌ皃ﾃﾍ[L]
+  32              	;	%r5:ﾌ皃ﾃﾍ[H]
+  33              	;	%r6:ｰｿ｣ｱ[L](double)/ｲｾｿﾉ｣ｱ[L]/shift counter
+  34              	;	%r7:ｰｿ｣ｱ[H](double)/ｲｾｿﾉ｣ｱ[H]
+  35              	;	%r8:ｰｿ｣ｲ[L](double)/ｲｾｿﾉ｣ｲ[L]
+  36              	;	%r9:ｰｿ｣ｲ[H](double)/ｲｾｿﾉ｣ｲ[H]
+  37              	;	%r10:temp/difference/implied
+  38              	;	%r11:xflag
+  39              	;	%r13:count/shift
+  40              	;	-------------------------------------------
+  41              	;	%r0:ｶｦﾍｭ･･ｸ･ｹ･ｿ
+  42              	;		bit31:ｻﾘｿﾉ｣ｱ
+  43              	;		bit30:ｻﾘｿﾉ｣ｲ
+  44              	;		bit29-22:TEMP(1byte)
+  45              	;		bit21-11:ｻﾘｿﾉ｣ｱ
+  46              	;		bit10-0 :ｻﾘｿﾉ｣ｲ
+  47              	;==============================================
+  48              	
+  49              	
+  50              	;;macro	VARSHIFT $1, $2, $3
+  51              		; used in 32-bit variable shifting
+  52              		; $1 = input register
+  53              		; $2 = shift amount
+  54              		; $3 = shift instruction
+  55              	
+  56              	;$$1:
+  57              	;	cmp		$2, 8		; if temp <= 8 then goto $$2
+GAS LISTING adddf3.s 			page 2
+
+
+  58              	;	jrle	$$2
+  59              	
+  60              	;	$3		$1, 8		; shift input register 8 bits
+  61              	;	jp.d	$$1
+  62              	;	sub		$2, 8		; temp = temp - 8
+  63              	
+  64              	;$$2:
+  65              	;	$3		$1, $2		; last shift
+  66              	;;endm
+  67              	
+  68              	;;macro	SHFTROTSHFT $1, $2, $3, $4, $5, $6, $7
+  69              		; used in 64-bit variable shifting
+  70              		; $1 = shift amount
+  71              		; $2 = 1st input register (shifted)
+  72              		; $3 = 2nd input register (rotated)
+  73              		; $4 = 3rd input register (mask --> shifted)
+  74              		; $5 = shift instruction
+  75              		; $6 = rotate instruction
+  76              		; $7 = temp register
+  77              	;	ld.w	$7, $1		; temp = shift amount
+  78              	
+  79              	;$$1:
+  80              	;	cmp		$7, 8		; if temp <= 8 then goto $$2
+  81              	;	jrle	$$2
+  82              	
+  83              	;	$5		$2, 8		; shift 1st register
+  84              	;	$6		$3, 8		; rotate 2nd register
+  85              	;	$5		$4, 8		; shift 3rd register
+  86              	;	jp.d	$$1
+  87              	;	sub		$7, 8		; temp = temp - 8
+  88              	
+  89              	;$$2:
+  90              	;	$5		$2, $7		; last shift
+  91              	;	$6		$3, $7		; last rotate
+  92              	;	$5		$4, $7		; last shift
+  93              	;;endm
+  94              	
+  95              	__subdf3:
+  96 0000 00D000C0 		xxor	%r9, 0x80000000			; ｰｿ｣ｲ[H}(%r9)= ｰｿ｣ｲ[H](%r9) & 0x80000000 
+  96      0978
+  97              	
+  98              	__adddf3:
+  99 0006 0302     		pushn	%r3				; save register values
+ 100              	
+ 101              		;@@@ 01/01/23 add start hinokuchi
+ 102              		;sub		%sp, 4
+ 103              		;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+ 104              		;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+ 105              		;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+ 106              		;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+ 107              		;@@@ 01/01/23 add end
+ 108              		
+ 109              		;@@@ 01/02/14 del start
+ 110              		;ld.w	%r0, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ[H](%r7) 
+ 111              		;rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+ 112              		;and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+ 113              		;@@@ 01/01/23 del end
+GAS LISTING adddf3.s 			page 3
+
+
+ 114 0008 006C     		ld.w	%r0, 0			; ｶｦﾍｭ･･ｸ･ｹ･ｿ･ｯ･･｢(%r0) @@@ 01/02/14 add
+ 115              	
+ 116              		;@@@ 01/02/14 add start
+ 117 000a 712E     		ld.w	%r1, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7) 
+ 118 000c 119C     		rl		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) rotate left 1 bit
+ 119 000e 1170     		and		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) & 1 
+ 120              		; 	SET_SIGN1 %r0, %r1		; ｶｦﾍｭ･･ｸ･ｹ･ｿ､ﾋﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱﾊﾝﾂｸ 
+ 121              	__L0001:
+ 122 0010 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 122      F073
+ 123 0016 1170     		and		%r1,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 124 0018 1198     		rr		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 125 001a 1036     		or		%r0,%r1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 126 001c 119C     		rl		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 127              		;@@@ 01/01/23 add end
+ 128              	
+ 129              	
+ 130              	
+ 131              		;@@@ 01/02/14 del start
+ 132              		;ld.w	%r2, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ[H](%r9)
+ 133              		;rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+ 134              		;and	%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1 
+ 135              		;@@@ 01/01/23 del end
+ 136              	
+ 137              		;@@@ 01/02/14 add start
+ 138 001e 922E     		ld.w	%r2, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r1) <- ｰｿ｣ｲ[H](%r9)
+ 139 0020 129C     		rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r1) rotate left 1 bit
+ 140 0022 1270     		and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r1) & 1 
+ 141              		; 	SET_SIGN2 %r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ､ﾋﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲﾊﾝﾂｸ 
+ 142              	__L0002:
+ 143 0024 FFD7FFDF 		xand	%r0,0xbfffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｯ･･｢
+ 143      F073
+ 144 002a 1270     		and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 145 002c 2298     		rr		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 146 002e 2036     		or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｻ･ﾃ･ﾈ
+ 147 0030 229C     		rl		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 148              	
+ 149              		;@@@ 01/01/23 add end
+ 150              	
+ 151              	
+ 152 0032 712E     		ld.w	%r1, %r7		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7)
+ 153 0034 118C     		sll		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) << 1
+ 154 0036 81888188 		xsrl 	%r1, 21			; ｻﾘｿﾉ｣ｱ(%r1) >> 21
+ 154      5188
+ 155              	
+ 156              		; 	SET_EXP1 %r0, %r1		; @@@ 01/02/14 add start
+ 157              	__L0003:
+ 158 003c E0DF0070 		xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+ 159 0040 1FC0F173 		xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 160 0044 1036     		or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+ 161              	
+ 162              	
+ 163 0046 1FC0F16B 		xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(0x7ff) 
+ 164 004a 00C001C0 		xjrge	overflow		; then jump to overflow
+ 164      380A
+ 165              	
+ 166 0050 932E     		ld.w	%r3, %r9		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ[H](%r9)
+GAS LISTING adddf3.s 			page 4
+
+
+ 167 0052 138C     		sll 	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) << 1
+ 168 0054 83888388 		xsrl	%r3, 21			; ｻﾘｿﾉ｣ｲ(%r3) >> 21
+ 168      5388
+ 169              	
+ 170              		; 	SET_EXP2 %r0, %r3		; @@@ 01/02/14 add start
+ 171              	__L0004:
+ 172 005a F8DF1FC0 		xand	%r0,0xffc007ff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｲ･ｯ･･｢
+ 172      F073
+ 173 0060 1FC0F373 		xand	%r3,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 174 0064 838C     		sll		%r3,8			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 175 0066 338C     		sll		%r3,3			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 176 0068 3036     		or		%r0,%r3			; ｻﾘｿﾉ｣ｲ･ｻ･ﾃ･ﾈ
+ 177 006a 8388     		srl		%r3,8			; ｻﾘｿﾉﾉｵ｢
+ 178 006c 3388     		srl		%r3,3			; ｻﾘｿﾉﾉｵ｢
+ 179              	
+ 180              		; 	GET_SIGN1	%r0, %r4
+ 181              	__L0005:
+ 182 006e 042E     		ld.w	%r4,%r0			; 
+ 183 0070 149C     		rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 184 0072 1470     		and		%r4,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+ 185              	
+ 186              	
+ 187              		;@@@ del 01/02/15 ld.w	%r10, %r0		; temp(%r10) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+ 188              		;@@@ del 01/02/15 ld.w	%r10, %r0		; temp(%r10) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+ 189              	
+ 190              		; 	SET_SIGN1 %r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 191              	__L0006:
+ 192 0074 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 192      F073
+ 193 007a 1270     		and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 194 007c 1298     		rr		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 195 007e 2036     		or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 196 0080 129C     		rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 197 0082 1FC0F36B 		xcmp	%r3, 0x7ff		; if ｻﾘｿﾉ｣ｲ(%r3) >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(0x7ff) 
+ 198              		;@@@ del 01/02/15 ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 199 0086 00C001C0 		xjrge	overflow		; then jump to overflow
+ 199      1A0A
+ 200              		; 	SET_SIGN1 %r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 201              	__L0007:
+ 202 008c FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 202      F073
+ 203 0092 1470     		and		%r4,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 204 0094 1498     		rr		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 205 0096 4036     		or		%r0,%r4			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 206 0098 149C     		rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 207              	
+ 208 009a 312A     		cmp		%r1, %r3		; if ｻﾘｿﾉ｣ｱ(%r1) < ｻﾘｿﾉ｣ｲ(%r3)
+ 209 009c 0B0C     		jrlt	ex1ltex2		; then jump to ex1ltex2
+ 210              		;@@@ del 01/02/15 ld.w	%r0, %r10		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- temp(%r10)
+ 211              	
+ 212              		; case: exp1 >= exp2
+ 213 009e 752E     		ld.w	%r5, %r7		; ﾌ皃ﾃﾍ[H](%r5) <- ｰｿ｣ｱ[H](%r7)
+ 214              		;@@@ del 01/02/15 ld.w	%r10, %r1		; difference(%r10) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 215 00a0 142E     		ld.w	%r4, %r1		; difference(%r4) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 216 00a2 3426     		sub		%r4, %r3
+ 217              		;@@@ del 01/02/15 sub		%r10, %r3
+ 218              	
+GAS LISTING adddf3.s 			page 5
+
+
+ 219              		;@@@ del 01/02/15 xcmp	%r10, 0x35		; if difference(%r10) >= 0x35 (53-bits) then
+ 220 00a4 00C0546B 		xcmp	%r4, 0x35		; if difference(%r4) >= 0x35 (53-bits) then
+ 221              	
+ 222 00a8 642E     		ld.w	%r4, %r6		; ﾌ皃ﾃﾍ[L](%r4) <- ｰｿ｣ｱ[L](%r6)
+ 223 00aa 00C001C0 		xjrge	end				; return first input
+ 223      130A
+ 224 00b0 121E     		jp		continue
+ 225              		
+ 226              	ex1ltex2:
+ 227 00b2 952E     		ld.w	%r5, %r9		; ﾌ皃ﾃﾍ[H](%r5) <- ｰｿ｣ｲ[H](%r9)
+ 228              		;@@@ del 01/02/15 ld.w	%r10, %r3		; difference(%r10) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 229 00b4 342E     		ld.w	%r4, %r3		; difference(%r4) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 230              	
+ 231 00b6 1426     		sub		%r4, %r1
+ 232              		;@@@ del 01/02/15 sub		%r10, %r1
+ 233              		
+ 234              		;@@@ del 01/02/15 xcmp	%r10, 0x35		; if difference(%r10) >= 0x35 (53-bits) then
+ 235 00b8 00C0546B 		xcmp	%r4, 0x35		; if difference(%r4) >= 0x35 (53-bits) then
+ 236              	
+ 237 00bc 842E     		ld.w	%r4, %r8		; ﾌ皃ﾃﾍ[L](%r4) <- ｰｿ｣ｲ[L](%r8)
+ 238 00be 0B0C     		jrlt	continue
+ 239              		;@@@ del 01/02/15 ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 240              		; 	SET_SIGN1 %r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)@@@ add 01/02/15
+ 241              	__L0008:
+ 242 00c0 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 242      F073
+ 243 00c6 1270     		and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 244 00c8 1298     		rr		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 245 00ca 2036     		or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 246 00cc 129C     		rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 247 00ce 00C001C0 		xjp		end				; return 2nd input
+ 247      011E
+ 248              	
+ 249              	continue:
+ 250              		;@@@ del 01/02/15 xld.w	%r10, 0x100000	; implied bit(%r10) <- 0x100000
+ 251 00d4 02C000C0 		xld.w	%r2, 0x100000	; implied bit(%r2) <- 0x100000
+ 251      026C
+ 252              	
+ 253              		;@@@ del 01/02/15 xld.w	%r13, 0xfffff	; mask(%r13) <- 0xfffff 
+ 254 00da 01C0FFDF 		xld.w	%r4, 0xfffff	; mask(%r4) <- 0xfffff 
+ 254      F46F
+ 255              	
+ 256              		; isolate mantissa1
+ 257 00e0 0168     		cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 then goto getman2
+ 258 00e2 0319     		jreq.d	getman2
+ 259              		;@@@ del 01/02/15 and		%r7, %r13		; ｰｿ｣ｱ[H](%r7) & mask(%r13) clear first 12 bits of %r7
+ 260 00e4 4732     		and		%r7, %r4		; ｰｿ｣ｱ[H](%r7) & mask(%r4) clear first 12 bits of %r7
+ 261              	
+ 262              		;@@@ del 01/02/15 or		%r7, %r10		; ｰｿ｣ｱ[H](%r7) | mplied bit(%r10)  else normal input --> add im
+ 263 00e6 2736     		or		%r7, %r2		; ｰｿ｣ｱ[H](%r7) | mplied bit(%r2)  else normal input --> add implied bit
+ 264              		
+ 265              	getman2:
+ 266 00e8 0368     		cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r3) = 0 then goto signs
+ 267 00ea 0319     		jreq.d	cmpexp
+ 268              		;@@@ del 01/02/15 and		%r9, %r13		; ｰｿ｣ｲ[H](%r9) & mask(%r13) clear first 12 bits of %r9
+ 269 00ec 4932     		and		%r9, %r4		; ｰｿ｣ｲ[H](%r9) & mask(%r4) clear first 12 bits of %r9
+ 270              	
+GAS LISTING adddf3.s 			page 6
+
+
+ 271              		;@@@ del 01/02/15 or		%r9, %r10		; ｰｿ｣ｲ[H](%r9) | mplied bit(%r10) else normal input --> add imp
+ 272 00ee 2936     		or		%r9, %r2		; ｰｿ｣ｲ[H](%r9) | mplied bit(%r2) else normal input --> add implied bit
+ 273              	
+ 274              	cmpexp:
+ 275              		; compare exponents -- %r1 will be result exponent
+ 276              		; if exp1 > exp2 then mantissa2 is shifted to the right
+ 277              		; if exp2 > exp1 then mantissa1 is shifted to the right
+ 278              	
+ 279              		;@@@ del 01/02/15 ld.w	%r11, 0			; xflag(%r11) = 0
+ 280 00f0 046C     		ld.w 	%r4, 0
+ 281              		; 	SET_TEMP %r0, %r4			; ｶｦﾍｭ･･ｸ･ｹ･ｿ[temp](%r0) <- xflag = 0 
+ 282              	__L0009:
+ 283 00f2 07D8FFDF 		xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+ 283      F073
+ 284 00f8 03C0F473 		xand	%r4,0xff			; 1･ﾐ･､･ﾈ mask
+ 285 00fc 8498     		rr		%r4,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 286 00fe 2498     		rr		%r4,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 287 0100 4036     		or		%r0,%r4			; TEMP･ｻ･ﾃ･ﾈ
+ 288 0102 849C     		rl		%r4,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 289 0104 249C     		rl		%r4,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 290              	
+ 291              	
+ 292 0106 312A     		cmp		%r1, %r3
+ 293 0108 6318     		jreq	negation		; if ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｲ(%r3) then jump to negation
+ 294 010a 3508     		jrgt	man2			; if ｻﾘｿﾉ｣ｱ(%r1) > ｻﾘｿﾉ｣ｲ(%r3) then jump to man2
+ 295              	
+ 296              		; case: exp1 < exp2
+ 297              		;@@@ del 01/02/15 ld.w	%r11, 2			; xflag(%r11) = 2
+ 298 010c 246C     		ld.w 	%r4, 2
+ 299              		; 	SET_TEMP %r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[temp](%r0) <- xflag = 2 
+ 300              	__L0010:
+ 301 010e 07D8FFDF 		xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+ 301      F073
+ 302 0114 03C0F473 		xand	%r4,0xff			; 1･ﾐ･､･ﾈ mask
+ 303 0118 8498     		rr		%r4,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 304 011a 2498     		rr		%r4,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 305 011c 4036     		or		%r0,%r4			; TEMP･ｻ･ﾃ･ﾈ
+ 306 011e 849C     		rl		%r4,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 307 0120 249C     		rl		%r4,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 308              	
+ 309              	
+ 310              		;@@@ del 01/02/15 ld.w	%r10, %r1		; temp(%r10) = ｻﾘｿﾉ｣ｱ(%r1)
+ 311 0122 142E     		ld.w	%r4, %r1		; temp(%r4) = ｻﾘｿﾉ｣ｱ(%r1)
+ 312              	
+ 313 0124 312E     		ld.w	%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｲ(%r3)
+ 314              		; 	SET_EXP1 %r0, %r1		; @@@ 01/02/26 add start
+ 315              	__L0011:
+ 316 0126 E0DF0070 		xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+ 317 012a 1FC0F173 		xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 318 012e 1036     		or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+ 319              	
+ 320              	
+ 321              		;@@@ del 01/02/15 sub		%r3, %r10		; shift (%r3) = ｻﾘｿﾉ｣ｲ(%r3) - ｻﾘｿﾉ｣ｱ(%r1)
+ 322 0130 4326     		sub		%r3, %r4		; shift (%r3) = ｻﾘｿﾉ｣ｲ(%r3) - ｻﾘｿﾉ｣ｱ(%r4)
+ 323              	
+ 324              		;@@@ del 01/02/15 cmp		%r10, 0			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 then goto shftm1 (normal)
+ 325 0132 0468     		cmp		%r4, 0			; if ｻﾘｿﾉ｣ｱ(%r4) != 0 then goto shftm1 (normal)
+GAS LISTING adddf3.s 			page 7
+
+
+ 326              	
+ 327 0134 021A     		jrne	shftm1
+ 328 0136 1364     		sub		%r3, 1			; shift(%r3) = shift (%r3) - 1  else denormal --> decrement shift
+ 329              	
+ 330              	shftm1:
+ 331 0138 00C0036A 		xcmp	%r3, 32			; if shift(%r3) < 32 then 64-bit shift
+ 332 013c 0B0C     		jrlt	shift1
+ 333              	
+ 334              		; case: shift >=32
+ 335 013e 762E     		ld.w	%r6, %r7		; ｲｾｿﾉ｣ｱ[L] <- ｲｾｿﾉ｣ｱ[H] (32-bit shift)
+ 336 0140 076C     		ld.w	%r7, 0			; ｲｾｿﾉ｣ｱ[H] <- 0
+ 337 0142 0366     		sub		%r3, 32			; shift(%r3) = shift(%r3) - 32
+ 338              		;xsrl	%r6, %r3		; man1_2 >> shift
+ 339              		; used in 32-bit variable shifting	; 	VARSHIFT %r6, %r3, srl
+ 340              		; $1 = input register
+ 341              		; $2 = shift amount
+ 342              		; $3 = shift instruction
+ 343              	
+ 344              	__L0012:
+ 345 0144 8368     		cmp		%r3, 8		; if temp <= 8 then goto $$2
+ 346 0146 040E     		jrle	__L0013
+ 347              	
+ 348 0148 8688     		srl		%r6, 8		; shift input register 8 bits
+ 349 014a FD1F     		jp.d	__L0012
+ 350 014c 8364     		sub		%r3, 8		; temp = temp - 8
+ 351              	
+ 352              	__L0013:
+ 353 014e 3689     		srl		%r6, %r3		; last shift
+ 354 0150 3F1E     		jp		negation
+ 355              	
+ 356              	shift1:
+ 357              		; shift {man1, man1_2} right
+ 358              		;xsrl	%r6, %r3		; shift low 32-bits to the right x bits (shift amount = x)
+ 359              		;xrr	%r7, %r3		; rotate high 32-bits to the right x bits
+ 360              		;xsrl	%r10, %r3		; make a mask for last 32-x bits --> %r10 = 000...111
+ 361              	
+ 362              		;@@@ del 01/02/15 ld.w	%r10, -1		; mask(%r10) <- 0xffff ffff
+ 363 0152 F46F     		ld.w	%r4, -1		; mask(%r4) <- 0xffff ffff
+ 364              	
+ 365              		;@@@ del 01/02/15 SHFTROTSHFT %r3, %r6, %r7, %r10, srl, rr, %r3
+ 366              		; used in 64-bit variable shifting	; 	SHFTROTSHFT %r3, %r6, %r7, %r4, srl, rr, %r3
+ 367              		; $1 = shift amount
+ 368              		; $2 = 1st input register (shifted)
+ 369              		; $3 = 2nd input register (rotated)
+ 370              		; $4 = 3rd input register (mask --> shifted)
+ 371              		; $5 = shift instruction
+ 372              		; $6 = rotate instruction
+ 373              		; $7 = temp register
+ 374 0154 332E     		ld.w	%r3, %r3		; temp = shift amount
+ 375              	
+ 376              	__L0014:
+ 377 0156 8368     		cmp		%r3, 8		; if temp <= 8 then goto $$2
+ 378 0158 060E     		jrle	__L0015
+ 379              	
+ 380 015a 8688     		srl		%r6, 8		; shift 1st register
+ 381 015c 8798     		rr		%r7, 8		; rotate 2nd register
+ 382 015e 8488     		srl		%r4, 8		; shift 3rd register
+GAS LISTING adddf3.s 			page 8
+
+
+ 383 0160 FB1F     		jp.d	__L0014
+ 384 0162 8364     		sub		%r3, 8		; temp = temp - 8
+ 385              	
+ 386              	__L0015:
+ 387 0164 3689     		srl		%r6, %r3		; last shift
+ 388 0166 3799     		rr		%r7, %r3		; last rotate
+ 389 0168 3489     		srl		%r4, %r3		; last shift
+ 390              	
+ 391              		;@@@ del 01/02/15 not		%r3, %r10		; shift(%r3) = ~mask(%r10)   flip mask for first x bits --> %r3 
+ 392 016a 433E     		not		%r3, %r4		; shift(%r3) = ~mask(%r4)   flip mask for first x bits --> %r3 = 111...000 (mask)
+ 393              	
+ 394 016c 7332     		and		%r3, %r7		; isolate first x bits of %r7
+ 395 016e 3636     		or		%r6, %r3		; add first x bits of %r7 to %r6
+ 396 0170 2F1F     		jp.d	negation
+ 397              		;@@@ del 01/02/15 and		%r7, %r10		; keep the low 32-x bits of %r7
+ 398 0172 4732     		and		%r7, %r4		; keep the low 32-x bits of %r7
+ 399              	
+ 400              	
+ 401              	man2:						; case: ｻﾘｿﾉ｣ｱ(%r1) > ｻﾘｿﾉ｣ｲ(%r3)
+ 402              		;@@@ del 01/02/15 ld.w	%r11, 1			; xflag(%r11) = 1
+ 403 0174 146C     		ld.w 	%r4, 1
+ 404              		; 	SET_TEMP %r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[temp](%r0) <- xflag = 1 
+ 405              	__L0016:
+ 406 0176 07D8FFDF 		xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+ 406      F073
+ 407 017c 03C0F473 		xand	%r4,0xff			; 1･ﾐ･､･ﾈ mask
+ 408 0180 8498     		rr		%r4,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 409 0182 2498     		rr		%r4,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 410 0184 4036     		or		%r0,%r4			; TEMP･ｻ･ﾃ･ﾈ
+ 411 0186 849C     		rl		%r4,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 412 0188 249C     		rl		%r4,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 413              	
+ 414              	
+ 415              		;@@@ del 01/02/15 ld.w	%r10, %r1		; temp(%r10) <- ｻﾘｿﾉ｣ｱ(%r1)
+ 416 018a 142E     		ld.w	%r4, %r1		; temp(%r4) <- ｻﾘｿﾉ｣ｱ(%r1)
+ 417              	
+ 418              		;@@@ del 01/02/15 sub		%r10, %r3		; shift(%r10) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 419 018c 3426     		sub		%r4, %r3		; shift(%r4) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 420              	
+ 421 018e 0368     		cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r1) != 0 then goto shftm2 (normal)
+ 422 0190 021A     		jrne	shftm2
+ 423              		;@@@ del 01/02/15 sub		%r10, 1			; else denormal --> shift(%r10) = shift(%r10) - 1
+ 424 0192 1464     		sub		%r4, 1			; else denormal --> shift(%r4) = shift(%r4) - 1
+ 425              		
+ 426              	shftm2:
+ 427              		;@@@ del 01/02/15 xcmp	%r10, 32		; if shift(%r10) < 32 then 64-bit shift
+ 428 0194 00C0046A 		xcmp	%r4, 32		; if shift(%r4) < 32 then 64-bit shift
+ 429              	
+ 430 0198 0B0C     		jrlt	shift2
+ 431              	
+ 432              		; case: shift >=32
+ 433 019a 982E     		ld.w	%r8, %r9		; ｲｾｿﾉ｣ｲ[L] <- ｲｾｿﾉ｣ｲ[H] 
+ 434 019c 096C     		ld.w	%r9, 0			; ｲｾｿﾉ｣ｲ[H] <- 0
+ 435              		;@@@ del 01/02/15 sub		%r10, 32		; shift(%r10) = shift(%r10) - 32
+ 436 019e 0466     		sub		%r4, 32			; shift(%r4) = shift(%r4) - 32
+ 437              	
+ 438              		;xsrl	%r8, %r10		; man2_2 >> shift
+GAS LISTING adddf3.s 			page 9
+
+
+ 439              		;@@@ del 01/02/15 VARSHIFT %r8, %r10, srl
+ 440              		; used in 32-bit variable shifting	; 	VARSHIFT %r8, %r4, srl
+ 441              		; $1 = input register
+ 442              		; $2 = shift amount
+ 443              		; $3 = shift instruction
+ 444              	
+ 445              	__L0017:
+ 446 01a0 8468     		cmp		%r4, 8		; if temp <= 8 then goto $$2
+ 447 01a2 040E     		jrle	__L0018
+ 448              	
+ 449 01a4 8888     		srl		%r8, 8		; shift input register 8 bits
+ 450 01a6 FD1F     		jp.d	__L0017
+ 451 01a8 8464     		sub		%r4, 8		; temp = temp - 8
+ 452              	
+ 453              	__L0018:
+ 454 01aa 4889     		srl		%r8, %r4		; last shift
+ 455              	
+ 456 01ac 111E     		jp		negation
+ 457              	
+ 458              	shift2:
+ 459              		; shift {man2, man2_2} right
+ 460              		;xsrl	%r8, %r10		; shift low 32-bits to the right x bits (shift amount = x)
+ 461              		;xrr	%r9, %r10		; rotate high 32-bits to the right x bits
+ 462              		;xsrl	%r3, %r10		; make a mask for last 32-x bits --> %r3 = 000...111
+ 463              	
+ 464 01ae F36F     		ld.w	%r3, -1			; %r3 = 0xffff ffff
+ 465              		;@@@ del 01/02/15 SHFTROTSHFT %r10, %r8, %r9, %r3, srl, rr, %r13		; %r13 = temp
+ 466              		; used in 64-bit variable shifting	; 	SHFTROTSHFT %r4, %r8, %r9, %r3, srl, rr, %r4		; %r4 = temp
+ 467              		; $1 = shift amount
+ 468              		; $2 = 1st input register (shifted)
+ 469              		; $3 = 2nd input register (rotated)
+ 470              		; $4 = 3rd input register (mask --> shifted)
+ 471              		; $5 = shift instruction
+ 472              		; $6 = rotate instruction
+ 473              		; $7 = temp register
+ 474 01b0 442E     		ld.w	%r4, %r4		; temp = shift amount
+ 475              	
+ 476              	__L0019:
+ 477 01b2 8468     		cmp		%r4, 8		; if temp <= 8 then goto $$2
+ 478 01b4 060E     		jrle	__L0020
+ 479              	
+ 480 01b6 8888     		srl		%r8, 8		; shift 1st register
+ 481 01b8 8998     		rr		%r9, 8		; rotate 2nd register
+ 482 01ba 8388     		srl		%r3, 8		; shift 3rd register
+ 483 01bc FB1F     		jp.d	__L0019
+ 484 01be 8464     		sub		%r4, 8		; temp = temp - 8
+ 485              	
+ 486              	__L0020:
+ 487 01c0 4889     		srl		%r8, %r4		; last shift
+ 488 01c2 4999     		rr		%r9, %r4		; last rotate
+ 489 01c4 4389     		srl		%r3, %r4		; last shift
+ 490              	
+ 491              		;@@@ del 01/02/15 not		%r10, %r3		; flip mask for first x bits --> %r10 = 111...000 (mask)
+ 492 01c6 343E     		not		%r4, %r3		; flip mask for first x bits --> %r4 = 111...000 (mask)
+ 493              	
+ 494              		;@@@ del 01/02/15 and		%r10, %r9		; isolate first x bits of %r9
+ 495 01c8 9432     		and		%r4, %r9		; isolate first x bits of %r9
+GAS LISTING adddf3.s 			page 10
+
+
+ 496              	
+ 497              		;@@@ del 01/02/15 or		%r8, %r10		; add first x bits of %r9 to %r8
+ 498 01ca 4836     		or		%r8, %r4		; add first x bits of %r9 to %r8
+ 499              	
+ 500 01cc 3932     		and		%r9, %r3		; keep the low 32-x bits of %r9
+ 501              	
+ 502              	negation:
+ 503              		; xflag = 0 if exp1 = exp2
+ 504              		;		  1 if exp1 > exp2
+ 505              		;		  2 if exp1 < exp2
+ 506              		; %r0 will now be result sign bit
+ 507              	
+ 508              		; if exp1 = exp2 then this is the case
+ 509              		; sign1	(%r0)  sign2 (%r2)	result sign (%r0)
+ 510              		;	0			  0				0	<== no change
+ 511              		;	1			  0				0	<== change to 1 if result < 0
+ 512              		;	0			  1				0	<== change to 1 if result < 0
+ 513              		;	1			  1				1	<== no change
+ 514              	
+ 515              		; 	GET_TEMP 	%r0, %r1	; xflag(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0)	@@@ 01/02/15 add
+ 516              	__L0021:
+ 517 01ce 012E     		ld.w	%r1,%r0			
+ 518 01d0 819C     		rl		%r1,8
+ 519 01d2 219C     		rl		%r1,2
+ 520 01d4 03C0F173 		xand	%r1,0xff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMPｼ霹ﾀ
+ 521              	
+ 522              		; 	GET_SIGN1	%r0, %r4	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0)	@@@ 01/02/15 add
+ 523              	__L0022:
+ 524 01d8 042E     		ld.w	%r4,%r0			; 
+ 525 01da 149C     		rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 526 01dc 1470     		and		%r4,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+ 527              	
+ 528              		; 	GET_SIGN2	%r0, %r2	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ](%r0)	@@@ 01/02/15 add
+ 529              	__L0023:
+ 530 01de 022E     		ld.w	%r2,%r0			; 
+ 531 01e0 229C     		rl		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 532 01e2 1270     		and		%r2,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲｼ霹ﾀ
+ 533              	
+ 534              	
+ 535              		;@@@ del 01/02/15 cmp		%r0, %r2		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 536 01e4 242A     		cmp		%r4, %r2		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 537              	
+ 538 01e6 1618     		jreq	sign			; then goto sign
+ 539              		;@@@ del 01/02/15 cmp		%r0, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) != 1 
+ 540 01e8 1468     		cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) != 1 
+ 541              	
+ 542 01ea 101A     		jrne	negm2			; then goto negm2
+ 543              	
+ 544              		; case: sign1 = 1
+ 545              		;@@@ del 01/02/15 cmp		%r11, 0			; only change %r0 if xflag(%r11) = 0
+ 546 01ec 0168     		cmp		%r1, 0			; only change %r0 if xflag(%r1) = 0
+ 547              	
+ 548 01ee 091A     		jrne	negm1
+ 549              		;@@@ del 01/02/15 ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- 0
+ 550 01f0 046C     		ld.w	%r4, 0
+ 551              		; 	SET_SIGN1	%r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- 0
+ 552              	__L0024:
+GAS LISTING adddf3.s 			page 11
+
+
+ 553 01f2 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 553      F073
+ 554 01f8 1470     		and		%r4,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 555 01fa 1498     		rr		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 556 01fc 4036     		or		%r0,%r4			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 557 01fe 149C     		rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 558              	
+ 559              	negm1:
+ 560 0200 773E     		not		%r7, %r7		; negate the first input
+ 561 0202 663E     		not		%r6, %r6
+ 562 0204 1660     		add		%r6, 1
+ 563 0206 27B8     		adc		%r7, %r2		; using %r2 (equals 0) to add the carry-over
+ 564 0208 051E     		jp		sign
+ 565              	
+ 566              	negm2:
+ 567              		; case: sign2 = 1
+ 568 020a 993E     		not		%r9, %r9		; negate the second input
+ 569 020c 883E     		not		%r8, %r8
+ 570 020e 1860     		add		%r8, 1
+ 571              		;@@@ del 01/02/15 adc		%r9, %r0		; using %r0 (equals 0) to add carry-over
+ 572 0210 49B8     		adc		%r9, %r4		; using %r4 (equals 0) to add carry-over
+ 573              	
+ 574              	sign:
+ 575              		; fix sign
+ 576              		; if xflag = 2 then result sign = sign2 (%r0 = %r2)
+ 577              		; if xflag = 1 then result sign = sign1	(%r0 = %r0)
+ 578              		; if xflag = 0 then result sign = 0 or 1
+ 579              	
+ 580 0212 2168     		cmp		%r1, 2			; if xflag(%r1) != 2
+ 581 0214 081A     		jrne	addition		; then goto  addition
+ 582              	
+ 583              		; case: xflag = 2
+ 584              		;@@@ del 01/02/15 ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 585              		; 	SET_SIGN1	%r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+ 586              	__L0025:
+ 587 0216 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 587      F073
+ 588 021c 1270     		and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 589 021e 1298     		rr		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 590 0220 2036     		or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 591 0222 129C     		rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 592              	
+ 593              	
+ 594              	addition:
+ 595              		; %r0 = result sign, %r1 = result exponent
+ 596              		; {%r7, %r6} = mantissa1, {%r9, %r8} = mantiss2
+ 597              		; {%r5, %r5} = result
+ 598              	
+ 599 0224 642E     		ld.w	%r4, %r6		; ﾌ皃ﾃﾍ[L](%r4) = ｲｾｿﾉ｣ｱ[L](6) + ｲｾｿﾉ｣ｲ[L](%r8)
+ 600 0226 8422     		add		%r4, %r8
+ 601              	
+ 602 0228 752E     		ld.w	%r5, %r7		; ﾌ皃ﾃﾍ[H](%r5) = ｲｾｿﾉ｣ｱ[H](%r7) + ｲｾｿﾉ｣ｲ[H](%r9) (with carry)
+ 603 022a 95B8     		adc		%r5, %r9
+ 604              	
+ 605 022c 0568     		cmp		%r5, 0
+ 606 022e 1408     		jrgt	count			; if ﾌ皃ﾃﾍ[H](%r5)  > 0 then normalize
+ 607 0230 040C     		jrlt	negative		; if ﾌ皃ﾃﾍ[H](%r5)  < 0 then negate result first
+GAS LISTING adddf3.s 			page 12
+
+
+ 608              	
+ 609              		; case: result1 = 0
+ 610 0232 0468     		cmp		%r4, 0
+ 611 0234 5018     		jreq	end				; if ﾌ皃ﾃﾍ[L](%r4) = 0 then end
+ 612 0236 1008     		jrgt	count			; if ﾌ皃ﾃﾍ[L](%r4) > 0 then normalize
+ 613              	
+ 614              	negative:					; result is negative
+ 615 0238 553E     		not		%r5, %r5		; negate the 64-bit result
+ 616 023a 443E     		not		%r4, %r4
+ 617 023c 1460     		add		%r4, 1			; ﾌ皃ﾃﾍ[L](%r4) = ~ﾌ皃ﾃﾍ[L](%r4) + 1
+ 618 023e 026C     		ld.w	%r2, 0			; %r2 = 0 (temp variable for carry-over add)
+ 619 0240 25B8     		adc		%r5, %r2		; ﾌ皃ﾃﾍ[H](%r5) = ~ﾌ皃ﾃﾍ[H](%r5) + carry over
+ 620              	
+ 621              		;@@@ 01/02/15 del cmp		%r11, 0			; if xflag(%r11) != 0 then goto count
+ 622 0242 0168     		cmp		%r1, 0			; if xflag(%r1) != 0 then goto count
+ 623              	
+ 624 0244 091A     		jrne	count
+ 625              		;@@@ 01/02/15 del ld.w	%r0, 1			; sign was 0 now sign = 1
+ 626 0246 166C     		ld.w	%r6, 1
+ 627              		; 	SET_SIGN1	%r0, %r6		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- 1
+ 628              	__L0026:
+ 629 0248 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+ 629      F073
+ 630 024e 1670     		and		%r6,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 631 0250 1698     		rr		%r6,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 632 0252 6036     		or		%r0,%r6			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+ 633 0254 169C     		rl		%r6,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 634              	
+ 635              	count:
+ 636              		; %r0 = result sign, %r1 = result exponent
+ 637              		; {%r5, %r4} = result, %r13 = count
+ 638              	
+ 639 0256 162E     		ld.w	%r6, %r1		; xflag(%r6) <- xflag(%r1) @@@ 01/02/15 add
+ 640              	
+ 641              		;@@@ 01/02/15 del ld.w	%r12, %r5		; copy result to input register of subroutine
+ 642 0258 582E     		ld.w	%r8, %r5		; copy result to input register of subroutine
+ 643              	
+ 644              		;@@@ 01/02/15 del ld.w	%r13, %r4
+ 645 025a 492E     		ld.w	%r9, %r4
+ 646 025c 00C000C0 		xcall	__scan64		; call 64-bit scan subroutine
+ 646      001C
+ 647              			
+ 648              		; check result exponent for normalizing	
+ 649              	
+ 650              		; 	GET_EXP1 	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0)
+ 651              	__L0027:
+ 652 0262 012E     		ld.w	%r1,%r0			; 
+ 653 0264 1FC0F173 		xand	%r1,0x7ff		; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱｼ霹ﾀ
+ 654              	
+ 655 0268 0168     		cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 then goto normalize
+ 656 026a 051A     		jrne	normalize
+ 657              	
+ 658              		; case: exp = 0
+ 659              		;@@@ 01/02/15 del cmp		%r13, 11		; if count(%r13) != 11 then goto end (denormal result)
+ 660 026c B968     		cmp		%r9, 11			; if count(%r9) != 11 then goto end (denormal result)
+ 661              	
+ 662 026e 2D1A     		jrne	finish
+GAS LISTING adddf3.s 			page 13
+
+
+ 663              	
+ 664              		; case: count = 11 & exp = 0 (denormal + denormal with carry-over result)
+ 665 0270 2C1F     		jp.d	finish
+ 666 0272 116C     		ld.w	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) <- 1	
+ 667              	
+ 668              	normalize:
+ 669              		;@@@ 01/02/15 del cmp		%r13, 11
+ 670 0274 B968     		cmp		%r9, 11
+ 671              	
+ 672 0276 2918     		jreq	finish			; if count(%r13) = 11 then goto finish (no shifting needed)
+ 673 0278 190C     		jrlt	rshift			; if count(%r9) < 11 then need to shift right
+ 674              	
+ 675              		; case: count > 11	(need to shift left)
+ 676              		;@@@ 01/02/15 del sub		%r13, 11		; count(%r13) = count(%r13) - 11
+ 677 027a B964     		sub		%r9, 11			; count(%r9) = count(%r9) - 11
+ 678              	
+ 679              		;@@@ 01/02/15 del cmp		%r1, %r13		; if ｻﾘｿﾉ｣ｱ(%r1) > count then normal result
+ 680 027c 912A     		cmp		%r1, %r9		; if ｻﾘｿﾉ｣ｱ(%r1) > count(%r9) then normal result
+ 681 027e 0408     		jrgt	lshift
+ 682              	
+ 683              		; case: exp <= count (denormal result)
+ 684 0280 1164     		sub		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - 1
+ 685 0282 021F     		jp.d	lshift
+ 686              		;@@@ 01/02/15 del ld.w	%r13, %r1		; shift(%r13) = ｻﾘｿﾉ｣ｱ(%r1)
+ 687 0284 192E     		ld.w	%r9, %r1		; shift(%r9) = ｻﾘｿﾉ｣ｱ(%r1)
+ 688              	
+ 689              	
+ 690              	lshift:
+ 691              		; {%r5, %r4} << shift
+ 692              		;xsll	%r5, %r13		; shift high 32-bits to the left x bits (shift amount = x)
+ 693              		;xrl	%r4, %r13		; rotate low 32-bits to the left x bits
+ 694              		;xsll	%r2, %r13		; make a mask for first 32-x bits --> %r2 = 111...000
+ 695              	
+ 696 0286 F26F     		ld.w	%r2, -1			; %r2 = 0xffff ffff
+ 697              		;@@@ 01/02/15 del SHFTROTSHFT %r13, %r5, %r4, %r2, sll, rl, %r11
+ 698              		; used in 64-bit variable shifting	; 	SHFTROTSHFT %r9, %r5, %r4, %r2, sll, rl, %r6
+ 699              		; $1 = shift amount
+ 700              		; $2 = 1st input register (shifted)
+ 701              		; $3 = 2nd input register (rotated)
+ 702              		; $4 = 3rd input register (mask --> shifted)
+ 703              		; $5 = shift instruction
+ 704              		; $6 = rotate instruction
+ 705              		; $7 = temp register
+ 706 0288 962E     		ld.w	%r6, %r9		; temp = shift amount
+ 707              	
+ 708              	__L0028:
+ 709 028a 8668     		cmp		%r6, 8		; if temp <= 8 then goto $$2
+ 710 028c 060E     		jrle	__L0029
+ 711              	
+ 712 028e 858C     		sll		%r5, 8		; shift 1st register
+ 713 0290 849C     		rl		%r4, 8		; rotate 2nd register
+ 714 0292 828C     		sll		%r2, 8		; shift 3rd register
+ 715 0294 FB1F     		jp.d	__L0028
+ 716 0296 8664     		sub		%r6, 8		; temp = temp - 8
+ 717              	
+ 718              	__L0029:
+ 719 0298 658D     		sll		%r5, %r6		; last shift
+GAS LISTING adddf3.s 			page 14
+
+
+ 720 029a 649D     		rl		%r4, %r6		; last rotate
+ 721 029c 628D     		sll		%r2, %r6		; last shift
+ 722              	
+ 723 029e 233E     		not		%r3, %r2		; flip mask for last x bits --> %r3 = 000...111 (mask)
+ 724 02a0 4332     		and		%r3, %r4		; isolate last x bits of %r4
+ 725 02a2 3536     		or		%r5, %r3		; add last x bits of %r4 to %r5
+ 726 02a4 2432     		and		%r4, %r2		; keep the high 32-x bits of %r4
+ 727              	
+ 728 02a6 111F     		jp.d	finish
+ 729              		;@@@ 01/02/15 del sub		%r1, %r13		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - shift(%r13)
+ 730 02a8 9126     		sub		%r1, %r9		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - shift(%r9)
+ 731              	
+ 732              	rshift:
+ 733              		; shift to the right 1 bit
+ 734 02aa 1488     		srl		%r4, 1			; shift low 32-bits to the right 1 bit
+ 735 02ac 136C     		ld.w	%r3, 1			; mask
+ 736 02ae 5332     		and		%r3, %r5		; get LSB of high 32-bits
+ 737 02b0 1398     		rr		%r3, 1			; rotate to MSB position
+ 738 02b2 3436     		or		%r4, %r3		; add to %r4
+ 739 02b4 1588     		srl		%r5, 1			; shift high 32-bits to the right 1 bit
+ 740 02b6 1160     		add		%r1, 1			; exp = exp + 1
+ 741              	
+ 742              		; overflow check	
+ 743 02b8 1FC0F16B 		xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) < 0x7ff then jump to finish
+ 744 02bc 060C     		jrlt	finish
+ 745              	
+ 746              	overflow:
+ 747 02be FECF00C0 		xld.w	%r5, 0x7ff00000	; put infinity into result
+ 747      056C
+ 748 02c4 081F     		jp.d	end				; delayed jump
+ 749 02c6 046C     		ld.w	%r4, 0
+ 750              	
+ 751              	finish:
+ 752              		; %r0 = sign, %r1 = exponent, %r5 = mantissa
+ 753 02c8 01C0FFDF 		xand	%r5, 0xfffff		; isolate mantissa
+ 753      F573
+ 754              	
+ 755 02ce 81984198 		xrr		%r1, 12			; position exponent bits to [30:23]
+ 756 02d2 1536     		or		%r5, %r1
+ 757              	
+ 758              	end:
+ 759              		;@@@ 01/02/15 del rr		%r0, 1			; position sign bit to MSB
+ 760              		; 	GET_SIGN1	%r0, %r6	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r6) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0)
+ 761              	__L0030:
+ 762 02d4 062E     		ld.w	%r6,%r0			; 
+ 763 02d6 169C     		rl		%r6,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 764 02d8 1670     		and		%r6,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+ 765              	
+ 766 02da 1698     		rr		%r6, 1			; position sign bit to MSB	@@@ 01/02/15 add
+ 767              		;@@@ 01/02/15 del or		%r5, %r0		; ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+ 768 02dc 6536     		or		%r5, %r6		; ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+ 769              	
+ 770              		;@@@ 01/01/23 add start hinokuchi
+ 771              		;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+ 772              		;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+ 773              		;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+ 774              		;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+GAS LISTING adddf3.s 			page 15
+
+
+ 775              		;add		%sp, 4
+ 776              		;@@@ 01/01/23 add end
+ 777 02de 4302     		popn	%r3				; restore register values
+ 778 02e0 4006     		ret
diff --git a/gcc/config/c33/libgcc/adddf3.s b/gcc/config/c33/libgcc/adddf3.s
new file mode 100644
index 0000000..38dcd59
--- /dev/null
+++ b/gcc/config/c33/libgcc/adddf3.s
@@ -0,0 +1,778 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : adddf3.s
+;*
+;*	Double floating point addition function
+;*						& subtract function
+;*		input: (%r7, %r6) & (%r9, %r8)
+;*		output: (%r5, %r4)
+;*
+;*	Begin				1996/09/12	V. Chan
+;*  Fixed sign bug		1997/02/17	V. Chan
+;*  ﾊﾑｹｹ				2001/01/18  O.Hinokuchi
+;*  			 		 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global	__adddf3
+.global __subdf3
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/count
+;	%r3:ｻﾘｿﾉ｣ｲ(8bit)
+;	%r4:ﾌ皃ﾃﾍ[L]
+;	%r5:ﾌ皃ﾃﾍ[H]
+;	%r6:ｰｿ｣ｱ[L](double)/ｲｾｿﾉ｣ｱ[L]/shift counter
+;	%r7:ｰｿ｣ｱ[H](double)/ｲｾｿﾉ｣ｱ[H]
+;	%r8:ｰｿ｣ｲ[L](double)/ｲｾｿﾉ｣ｲ[L]
+;	%r9:ｰｿ｣ｲ[H](double)/ｲｾｿﾉ｣ｲ[H]
+;	%r10:temp/difference/implied
+;	%r11:xflag
+;	%r13:count/shift
+;	-------------------------------------------
+;	%r0:ｶｦﾍｭ･･ｸ･ｹ･ｿ
+;		bit31:ｻﾘｿﾉ｣ｱ
+;		bit30:ｻﾘｿﾉ｣ｲ
+;		bit29-22:TEMP(1byte)
+;		bit21-11:ｻﾘｿﾉ｣ｱ
+;		bit10-0 :ｻﾘｿﾉ｣ｲ
+;==============================================
+
+
+;;macro	VARSHIFT $1, $2, $3
+	; used in 32-bit variable shifting
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+;$$1:
+;	cmp		$2, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$3		$1, 8		; shift input register 8 bits
+;	jp.d	$$1
+;	sub		$2, 8		; temp = temp - 8
+
+;$$2:
+;	$3		$1, $2		; last shift
+;;endm
+
+;;macro	SHFTROTSHFT $1, $2, $3, $4, $5, $6, $7
+	; used in 64-bit variable shifting
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+;	ld.w	$7, $1		; temp = shift amount
+
+;$$1:
+;	cmp		$7, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$5		$2, 8		; shift 1st register
+;	$6		$3, 8		; rotate 2nd register
+;	$5		$4, 8		; shift 3rd register
+;	jp.d	$$1
+;	sub		$7, 8		; temp = temp - 8
+
+;$$2:
+;	$5		$2, $7		; last shift
+;	$6		$3, $7		; last rotate
+;	$5		$4, $7		; last shift
+;;endm
+
+__subdf3:
+	xxor	%r9, 0x80000000			; ｰｿ｣ｲ[H}(%r9)= ｰｿ｣ｲ[H](%r9) & 0x80000000 
+
+__adddf3:
+	pushn	%r3				; save register values
+
+	;@@@ 01/01/23 add start hinokuchi
+	;sub		%sp, 4
+	;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+	;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+	;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+	;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+	;@@@ 01/01/23 add end
+	
+	;@@@ 01/02/14 del start
+	;ld.w	%r0, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ[H](%r7) 
+	;rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+	;and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+	;@@@ 01/01/23 del end
+	ld.w	%r0, 0			; ｶｦﾍｭ･･ｸ･ｹ･ｿ･ｯ･･｢(%r0) @@@ 01/02/14 add
+
+	;@@@ 01/02/14 add start
+	ld.w	%r1, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7) 
+	rl		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) rotate left 1 bit
+	and		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) & 1 
+	; 	SET_SIGN1 %r0, %r1		; ｶｦﾍｭ･･ｸ･ｹ･ｿ､ﾋﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱﾊﾝﾂｸ 
+__L0001:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r1,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+	;@@@ 01/01/23 add end
+
+
+
+	;@@@ 01/02/14 del start
+	;ld.w	%r2, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ[H](%r9)
+	;rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+	;and	%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1 
+	;@@@ 01/01/23 del end
+
+	;@@@ 01/02/14 add start
+	ld.w	%r2, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r1) <- ｰｿ｣ｲ[H](%r9)
+	rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r1) rotate left 1 bit
+	and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r1) & 1 
+	; 	SET_SIGN2 %r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ､ﾋﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲﾊﾝﾂｸ 
+__L0002:
+	xand	%r0,0xbfffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｯ･･｢
+	and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｻ･ﾃ･ﾈ
+	rl		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+	;@@@ 01/01/23 add end
+
+
+	ld.w	%r1, %r7		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7)
+	sll		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) << 1
+	xsrl 	%r1, 21			; ｻﾘｿﾉ｣ｱ(%r1) >> 21
+
+	; 	SET_EXP1 %r0, %r1		; @@@ 01/02/14 add start
+__L0003:
+	xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+	xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+
+
+	xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(0x7ff) 
+	xjrge	overflow		; then jump to overflow
+
+	ld.w	%r3, %r9		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ[H](%r9)
+	sll 	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) << 1
+	xsrl	%r3, 21			; ｻﾘｿﾉ｣ｲ(%r3) >> 21
+
+	; 	SET_EXP2 %r0, %r3		; @@@ 01/02/14 add start
+__L0004:
+	xand	%r0,0xffc007ff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｲ･ｯ･･｢
+	xand	%r3,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	sll		%r3,8			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	sll		%r3,3			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r3			; ｻﾘｿﾉ｣ｲ･ｻ･ﾃ･ﾈ
+	srl		%r3,8			; ｻﾘｿﾉﾉｵ｢
+	srl		%r3,3			; ｻﾘｿﾉﾉｵ｢
+
+	; 	GET_SIGN1	%r0, %r4
+__L0005:
+	ld.w	%r4,%r0			; 
+	rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+	and		%r4,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+
+
+	;@@@ del 01/02/15 ld.w	%r10, %r0		; temp(%r10) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+	;@@@ del 01/02/15 ld.w	%r10, %r0		; temp(%r10) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+
+	; 	SET_SIGN1 %r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+__L0006:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+	xcmp	%r3, 0x7ff		; if ｻﾘｿﾉ｣ｲ(%r3) >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(0x7ff) 
+	;@@@ del 01/02/15 ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+	xjrge	overflow		; then jump to overflow
+	; 	SET_SIGN1 %r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+__L0007:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r4,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r4			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+	cmp		%r1, %r3		; if ｻﾘｿﾉ｣ｱ(%r1) < ｻﾘｿﾉ｣ｲ(%r3)
+	jrlt	ex1ltex2		; then jump to ex1ltex2
+	;@@@ del 01/02/15 ld.w	%r0, %r10		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- temp(%r10)
+
+	; case: exp1 >= exp2
+	ld.w	%r5, %r7		; ﾌ皃ﾃﾍ[H](%r5) <- ｰｿ｣ｱ[H](%r7)
+	;@@@ del 01/02/15 ld.w	%r10, %r1		; difference(%r10) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+	ld.w	%r4, %r1		; difference(%r4) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+	sub		%r4, %r3
+	;@@@ del 01/02/15 sub		%r10, %r3
+
+	;@@@ del 01/02/15 xcmp	%r10, 0x35		; if difference(%r10) >= 0x35 (53-bits) then
+	xcmp	%r4, 0x35		; if difference(%r4) >= 0x35 (53-bits) then
+
+	ld.w	%r4, %r6		; ﾌ皃ﾃﾍ[L](%r4) <- ｰｿ｣ｱ[L](%r6)
+	xjrge	end				; return first input
+	jp		continue
+	
+ex1ltex2:
+	ld.w	%r5, %r9		; ﾌ皃ﾃﾍ[H](%r5) <- ｰｿ｣ｲ[H](%r9)
+	;@@@ del 01/02/15 ld.w	%r10, %r3		; difference(%r10) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+	ld.w	%r4, %r3		; difference(%r4) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+
+	sub		%r4, %r1
+	;@@@ del 01/02/15 sub		%r10, %r1
+	
+	;@@@ del 01/02/15 xcmp	%r10, 0x35		; if difference(%r10) >= 0x35 (53-bits) then
+	xcmp	%r4, 0x35		; if difference(%r4) >= 0x35 (53-bits) then
+
+	ld.w	%r4, %r8		; ﾌ皃ﾃﾍ[L](%r4) <- ｰｿ｣ｲ[L](%r8)
+	jrlt	continue
+	;@@@ del 01/02/15 ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+	; 	SET_SIGN1 %r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)@@@ add 01/02/15
+__L0008:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+	xjp		end				; return 2nd input
+
+continue:
+	;@@@ del 01/02/15 xld.w	%r10, 0x100000	; implied bit(%r10) <- 0x100000
+	xld.w	%r2, 0x100000	; implied bit(%r2) <- 0x100000
+
+	;@@@ del 01/02/15 xld.w	%r13, 0xfffff	; mask(%r13) <- 0xfffff 
+	xld.w	%r4, 0xfffff	; mask(%r4) <- 0xfffff 
+
+	; isolate mantissa1
+	cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 then goto getman2
+	jreq.d	getman2
+	;@@@ del 01/02/15 and		%r7, %r13		; ｰｿ｣ｱ[H](%r7) & mask(%r13) clear first 12 bits of %r7
+	and		%r7, %r4		; ｰｿ｣ｱ[H](%r7) & mask(%r4) clear first 12 bits of %r7
+
+	;@@@ del 01/02/15 or		%r7, %r10		; ｰｿ｣ｱ[H](%r7) | mplied bit(%r10)  else normal input --> add implied bit
+	or		%r7, %r2		; ｰｿ｣ｱ[H](%r7) | mplied bit(%r2)  else normal input --> add implied bit
+	
+getman2:
+	cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r3) = 0 then goto signs
+	jreq.d	cmpexp
+	;@@@ del 01/02/15 and		%r9, %r13		; ｰｿ｣ｲ[H](%r9) & mask(%r13) clear first 12 bits of %r9
+	and		%r9, %r4		; ｰｿ｣ｲ[H](%r9) & mask(%r4) clear first 12 bits of %r9
+
+	;@@@ del 01/02/15 or		%r9, %r10		; ｰｿ｣ｲ[H](%r9) | mplied bit(%r10) else normal input --> add implied bit
+	or		%r9, %r2		; ｰｿ｣ｲ[H](%r9) | mplied bit(%r2) else normal input --> add implied bit
+
+cmpexp:
+	; compare exponents -- %r1 will be result exponent
+	; if exp1 > exp2 then mantissa2 is shifted to the right
+	; if exp2 > exp1 then mantissa1 is shifted to the right
+
+	;@@@ del 01/02/15 ld.w	%r11, 0			; xflag(%r11) = 0
+	ld.w 	%r4, 0
+	; 	SET_TEMP %r0, %r4			; ｶｦﾍｭ･･ｸ･ｹ･ｿ[temp](%r0) <- xflag = 0 
+__L0009:
+	xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+	xand	%r4,0xff			; 1･ﾐ･､･ﾈ mask
+	rr		%r4,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	rr		%r4,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r4			; TEMP･ｻ･ﾃ･ﾈ
+	rl		%r4,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+	rl		%r4,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+
+
+	cmp		%r1, %r3
+	jreq	negation		; if ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｲ(%r3) then jump to negation
+	jrgt	man2			; if ｻﾘｿﾉ｣ｱ(%r1) > ｻﾘｿﾉ｣ｲ(%r3) then jump to man2
+
+	; case: exp1 < exp2
+	;@@@ del 01/02/15 ld.w	%r11, 2			; xflag(%r11) = 2
+	ld.w 	%r4, 2
+	; 	SET_TEMP %r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[temp](%r0) <- xflag = 2 
+__L0010:
+	xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+	xand	%r4,0xff			; 1･ﾐ･､･ﾈ mask
+	rr		%r4,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	rr		%r4,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r4			; TEMP･ｻ･ﾃ･ﾈ
+	rl		%r4,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+	rl		%r4,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+
+
+	;@@@ del 01/02/15 ld.w	%r10, %r1		; temp(%r10) = ｻﾘｿﾉ｣ｱ(%r1)
+	ld.w	%r4, %r1		; temp(%r4) = ｻﾘｿﾉ｣ｱ(%r1)
+
+	ld.w	%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｲ(%r3)
+	; 	SET_EXP1 %r0, %r1		; @@@ 01/02/26 add start
+__L0011:
+	xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+	xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+
+
+	;@@@ del 01/02/15 sub		%r3, %r10		; shift (%r3) = ｻﾘｿﾉ｣ｲ(%r3) - ｻﾘｿﾉ｣ｱ(%r1)
+	sub		%r3, %r4		; shift (%r3) = ｻﾘｿﾉ｣ｲ(%r3) - ｻﾘｿﾉ｣ｱ(%r4)
+
+	;@@@ del 01/02/15 cmp		%r10, 0			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 then goto shftm1 (normal)
+	cmp		%r4, 0			; if ｻﾘｿﾉ｣ｱ(%r4) != 0 then goto shftm1 (normal)
+
+	jrne	shftm1
+	sub		%r3, 1			; shift(%r3) = shift (%r3) - 1  else denormal --> decrement shift
+
+shftm1:
+	xcmp	%r3, 32			; if shift(%r3) < 32 then 64-bit shift
+	jrlt	shift1
+
+	; case: shift >=32
+	ld.w	%r6, %r7		; ｲｾｿﾉ｣ｱ[L] <- ｲｾｿﾉ｣ｱ[H] (32-bit shift)
+	ld.w	%r7, 0			; ｲｾｿﾉ｣ｱ[H] <- 0
+	sub		%r3, 32			; shift(%r3) = shift(%r3) - 32
+	;xsrl	%r6, %r3		; man1_2 >> shift
+	; used in 32-bit variable shifting	; 	VARSHIFT %r6, %r3, srl
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+__L0012:
+	cmp		%r3, 8		; if temp <= 8 then goto $$2
+	jrle	__L0013
+
+	srl		%r6, 8		; shift input register 8 bits
+	jp.d	__L0012
+	sub		%r3, 8		; temp = temp - 8
+
+__L0013:
+	srl		%r6, %r3		; last shift
+	jp		negation
+
+shift1:
+	; shift {man1, man1_2} right
+	;xsrl	%r6, %r3		; shift low 32-bits to the right x bits (shift amount = x)
+	;xrr	%r7, %r3		; rotate high 32-bits to the right x bits
+	;xsrl	%r10, %r3		; make a mask for last 32-x bits --> %r10 = 000...111
+
+	;@@@ del 01/02/15 ld.w	%r10, -1		; mask(%r10) <- 0xffff ffff
+	ld.w	%r4, -1		; mask(%r4) <- 0xffff ffff
+
+	;@@@ del 01/02/15 SHFTROTSHFT %r3, %r6, %r7, %r10, srl, rr, %r3
+	; used in 64-bit variable shifting	; 	SHFTROTSHFT %r3, %r6, %r7, %r4, srl, rr, %r3
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r3, %r3		; temp = shift amount
+
+__L0014:
+	cmp		%r3, 8		; if temp <= 8 then goto $$2
+	jrle	__L0015
+
+	srl		%r6, 8		; shift 1st register
+	rr		%r7, 8		; rotate 2nd register
+	srl		%r4, 8		; shift 3rd register
+	jp.d	__L0014
+	sub		%r3, 8		; temp = temp - 8
+
+__L0015:
+	srl		%r6, %r3		; last shift
+	rr		%r7, %r3		; last rotate
+	srl		%r4, %r3		; last shift
+
+	;@@@ del 01/02/15 not		%r3, %r10		; shift(%r3) = ~mask(%r10)   flip mask for first x bits --> %r3 = 111...000 (mask)
+	not		%r3, %r4		; shift(%r3) = ~mask(%r4)   flip mask for first x bits --> %r3 = 111...000 (mask)
+
+	and		%r3, %r7		; isolate first x bits of %r7
+	or		%r6, %r3		; add first x bits of %r7 to %r6
+	jp.d	negation
+	;@@@ del 01/02/15 and		%r7, %r10		; keep the low 32-x bits of %r7
+	and		%r7, %r4		; keep the low 32-x bits of %r7
+
+
+man2:						; case: ｻﾘｿﾉ｣ｱ(%r1) > ｻﾘｿﾉ｣ｲ(%r3)
+	;@@@ del 01/02/15 ld.w	%r11, 1			; xflag(%r11) = 1
+	ld.w 	%r4, 1
+	; 	SET_TEMP %r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[temp](%r0) <- xflag = 1 
+__L0016:
+	xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+	xand	%r4,0xff			; 1･ﾐ･､･ﾈ mask
+	rr		%r4,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	rr		%r4,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r4			; TEMP･ｻ･ﾃ･ﾈ
+	rl		%r4,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+	rl		%r4,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+
+
+	;@@@ del 01/02/15 ld.w	%r10, %r1		; temp(%r10) <- ｻﾘｿﾉ｣ｱ(%r1)
+	ld.w	%r4, %r1		; temp(%r4) <- ｻﾘｿﾉ｣ｱ(%r1)
+
+	;@@@ del 01/02/15 sub		%r10, %r3		; shift(%r10) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+	sub		%r4, %r3		; shift(%r4) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+
+	cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r1) != 0 then goto shftm2 (normal)
+	jrne	shftm2
+	;@@@ del 01/02/15 sub		%r10, 1			; else denormal --> shift(%r10) = shift(%r10) - 1
+	sub		%r4, 1			; else denormal --> shift(%r4) = shift(%r4) - 1
+	
+shftm2:
+	;@@@ del 01/02/15 xcmp	%r10, 32		; if shift(%r10) < 32 then 64-bit shift
+	xcmp	%r4, 32		; if shift(%r4) < 32 then 64-bit shift
+
+	jrlt	shift2
+
+	; case: shift >=32
+	ld.w	%r8, %r9		; ｲｾｿﾉ｣ｲ[L] <- ｲｾｿﾉ｣ｲ[H] 
+	ld.w	%r9, 0			; ｲｾｿﾉ｣ｲ[H] <- 0
+	;@@@ del 01/02/15 sub		%r10, 32		; shift(%r10) = shift(%r10) - 32
+	sub		%r4, 32			; shift(%r4) = shift(%r4) - 32
+
+	;xsrl	%r8, %r10		; man2_2 >> shift
+	;@@@ del 01/02/15 VARSHIFT %r8, %r10, srl
+	; used in 32-bit variable shifting	; 	VARSHIFT %r8, %r4, srl
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+__L0017:
+	cmp		%r4, 8		; if temp <= 8 then goto $$2
+	jrle	__L0018
+
+	srl		%r8, 8		; shift input register 8 bits
+	jp.d	__L0017
+	sub		%r4, 8		; temp = temp - 8
+
+__L0018:
+	srl		%r8, %r4		; last shift
+
+	jp		negation
+
+shift2:
+	; shift {man2, man2_2} right
+	;xsrl	%r8, %r10		; shift low 32-bits to the right x bits (shift amount = x)
+	;xrr	%r9, %r10		; rotate high 32-bits to the right x bits
+	;xsrl	%r3, %r10		; make a mask for last 32-x bits --> %r3 = 000...111
+
+	ld.w	%r3, -1			; %r3 = 0xffff ffff
+	;@@@ del 01/02/15 SHFTROTSHFT %r10, %r8, %r9, %r3, srl, rr, %r13		; %r13 = temp
+	; used in 64-bit variable shifting	; 	SHFTROTSHFT %r4, %r8, %r9, %r3, srl, rr, %r4		; %r4 = temp
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r4, %r4		; temp = shift amount
+
+__L0019:
+	cmp		%r4, 8		; if temp <= 8 then goto $$2
+	jrle	__L0020
+
+	srl		%r8, 8		; shift 1st register
+	rr		%r9, 8		; rotate 2nd register
+	srl		%r3, 8		; shift 3rd register
+	jp.d	__L0019
+	sub		%r4, 8		; temp = temp - 8
+
+__L0020:
+	srl		%r8, %r4		; last shift
+	rr		%r9, %r4		; last rotate
+	srl		%r3, %r4		; last shift
+
+	;@@@ del 01/02/15 not		%r10, %r3		; flip mask for first x bits --> %r10 = 111...000 (mask)
+	not		%r4, %r3		; flip mask for first x bits --> %r4 = 111...000 (mask)
+
+	;@@@ del 01/02/15 and		%r10, %r9		; isolate first x bits of %r9
+	and		%r4, %r9		; isolate first x bits of %r9
+
+	;@@@ del 01/02/15 or		%r8, %r10		; add first x bits of %r9 to %r8
+	or		%r8, %r4		; add first x bits of %r9 to %r8
+
+	and		%r9, %r3		; keep the low 32-x bits of %r9
+
+negation:
+	; xflag = 0 if exp1 = exp2
+	;		  1 if exp1 > exp2
+	;		  2 if exp1 < exp2
+	; %r0 will now be result sign bit
+
+	; if exp1 = exp2 then this is the case
+	; sign1	(%r0)  sign2 (%r2)	result sign (%r0)
+	;	0			  0				0	<== no change
+	;	1			  0				0	<== change to 1 if result < 0
+	;	0			  1				0	<== change to 1 if result < 0
+	;	1			  1				1	<== no change
+
+	; 	GET_TEMP 	%r0, %r1	; xflag(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0)	@@@ 01/02/15 add
+__L0021:
+	ld.w	%r1,%r0			
+	rl		%r1,8
+	rl		%r1,2
+	xand	%r1,0xff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMPｼ霹ﾀ
+
+	; 	GET_SIGN1	%r0, %r4	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0)	@@@ 01/02/15 add
+__L0022:
+	ld.w	%r4,%r0			; 
+	rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+	and		%r4,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+
+	; 	GET_SIGN2	%r0, %r2	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ](%r0)	@@@ 01/02/15 add
+__L0023:
+	ld.w	%r2,%r0			; 
+	rl		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+	and		%r2,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲｼ霹ﾀ
+
+
+	;@@@ del 01/02/15 cmp		%r0, %r2		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+	cmp		%r4, %r2		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+
+	jreq	sign			; then goto sign
+	;@@@ del 01/02/15 cmp		%r0, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) != 1 
+	cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) != 1 
+
+	jrne	negm2			; then goto negm2
+
+	; case: sign1 = 1
+	;@@@ del 01/02/15 cmp		%r11, 0			; only change %r0 if xflag(%r11) = 0
+	cmp		%r1, 0			; only change %r0 if xflag(%r1) = 0
+
+	jrne	negm1
+	;@@@ del 01/02/15 ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- 0
+	ld.w	%r4, 0
+	; 	SET_SIGN1	%r0, %r4		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- 0
+__L0024:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r4,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r4			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r4,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+negm1:
+	not		%r7, %r7		; negate the first input
+	not		%r6, %r6
+	add		%r6, 1
+	adc		%r7, %r2		; using %r2 (equals 0) to add the carry-over
+	jp		sign
+
+negm2:
+	; case: sign2 = 1
+	not		%r9, %r9		; negate the second input
+	not		%r8, %r8
+	add		%r8, 1
+	;@@@ del 01/02/15 adc		%r9, %r0		; using %r0 (equals 0) to add carry-over
+	adc		%r9, %r4		; using %r4 (equals 0) to add carry-over
+
+sign:
+	; fix sign
+	; if xflag = 2 then result sign = sign2 (%r0 = %r2)
+	; if xflag = 1 then result sign = sign1	(%r0 = %r0)
+	; if xflag = 0 then result sign = 0 or 1
+
+	cmp		%r1, 2			; if xflag(%r1) != 2
+	jrne	addition		; then goto  addition
+
+	; case: xflag = 2
+	;@@@ del 01/02/15 ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+	; 	SET_SIGN1	%r0, %r2		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2)
+__L0025:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r2,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+
+addition:
+	; %r0 = result sign, %r1 = result exponent
+	; {%r7, %r6} = mantissa1, {%r9, %r8} = mantiss2
+	; {%r5, %r5} = result
+
+	ld.w	%r4, %r6		; ﾌ皃ﾃﾍ[L](%r4) = ｲｾｿﾉ｣ｱ[L](6) + ｲｾｿﾉ｣ｲ[L](%r8)
+	add		%r4, %r8
+
+	ld.w	%r5, %r7		; ﾌ皃ﾃﾍ[H](%r5) = ｲｾｿﾉ｣ｱ[H](%r7) + ｲｾｿﾉ｣ｲ[H](%r9) (with carry)
+	adc		%r5, %r9
+
+	cmp		%r5, 0
+	jrgt	count			; if ﾌ皃ﾃﾍ[H](%r5)  > 0 then normalize
+	jrlt	negative		; if ﾌ皃ﾃﾍ[H](%r5)  < 0 then negate result first
+
+	; case: result1 = 0
+	cmp		%r4, 0
+	jreq	end				; if ﾌ皃ﾃﾍ[L](%r4) = 0 then end
+	jrgt	count			; if ﾌ皃ﾃﾍ[L](%r4) > 0 then normalize
+
+negative:					; result is negative
+	not		%r5, %r5		; negate the 64-bit result
+	not		%r4, %r4
+	add		%r4, 1			; ﾌ皃ﾃﾍ[L](%r4) = ~ﾌ皃ﾃﾍ[L](%r4) + 1
+	ld.w	%r2, 0			; %r2 = 0 (temp variable for carry-over add)
+	adc		%r5, %r2		; ﾌ皃ﾃﾍ[H](%r5) = ~ﾌ皃ﾃﾍ[H](%r5) + carry over
+
+	;@@@ 01/02/15 del cmp		%r11, 0			; if xflag(%r11) != 0 then goto count
+	cmp		%r1, 0			; if xflag(%r1) != 0 then goto count
+
+	jrne	count
+	;@@@ 01/02/15 del ld.w	%r0, 1			; sign was 0 now sign = 1
+	ld.w	%r6, 1
+	; 	SET_SIGN1	%r0, %r6		; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ] <- 1
+__L0026:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r6,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r6,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r6			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r6,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+count:
+	; %r0 = result sign, %r1 = result exponent
+	; {%r5, %r4} = result, %r13 = count
+
+	ld.w	%r6, %r1		; xflag(%r6) <- xflag(%r1) @@@ 01/02/15 add
+
+	;@@@ 01/02/15 del ld.w	%r12, %r5		; copy result to input register of subroutine
+	ld.w	%r8, %r5		; copy result to input register of subroutine
+
+	;@@@ 01/02/15 del ld.w	%r13, %r4
+	ld.w	%r9, %r4
+	xcall	__scan64		; call 64-bit scan subroutine
+		
+	; check result exponent for normalizing	
+
+	; 	GET_EXP1 	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0)
+__L0027:
+	ld.w	%r1,%r0			; 
+	xand	%r1,0x7ff		; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱｼ霹ﾀ
+
+	cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 then goto normalize
+	jrne	normalize
+
+	; case: exp = 0
+	;@@@ 01/02/15 del cmp		%r13, 11		; if count(%r13) != 11 then goto end (denormal result)
+	cmp		%r9, 11			; if count(%r9) != 11 then goto end (denormal result)
+
+	jrne	finish
+
+	; case: count = 11 & exp = 0 (denormal + denormal with carry-over result)
+	jp.d	finish
+	ld.w	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) <- 1	
+
+normalize:
+	;@@@ 01/02/15 del cmp		%r13, 11
+	cmp		%r9, 11
+
+	jreq	finish			; if count(%r13) = 11 then goto finish (no shifting needed)
+	jrlt	rshift			; if count(%r9) < 11 then need to shift right
+
+	; case: count > 11	(need to shift left)
+	;@@@ 01/02/15 del sub		%r13, 11		; count(%r13) = count(%r13) - 11
+	sub		%r9, 11			; count(%r9) = count(%r9) - 11
+
+	;@@@ 01/02/15 del cmp		%r1, %r13		; if ｻﾘｿﾉ｣ｱ(%r1) > count then normal result
+	cmp		%r1, %r9		; if ｻﾘｿﾉ｣ｱ(%r1) > count(%r9) then normal result
+	jrgt	lshift
+
+	; case: exp <= count (denormal result)
+	sub		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - 1
+	jp.d	lshift
+	;@@@ 01/02/15 del ld.w	%r13, %r1		; shift(%r13) = ｻﾘｿﾉ｣ｱ(%r1)
+	ld.w	%r9, %r1		; shift(%r9) = ｻﾘｿﾉ｣ｱ(%r1)
+
+
+lshift:
+	; {%r5, %r4} << shift
+	;xsll	%r5, %r13		; shift high 32-bits to the left x bits (shift amount = x)
+	;xrl	%r4, %r13		; rotate low 32-bits to the left x bits
+	;xsll	%r2, %r13		; make a mask for first 32-x bits --> %r2 = 111...000
+
+	ld.w	%r2, -1			; %r2 = 0xffff ffff
+	;@@@ 01/02/15 del SHFTROTSHFT %r13, %r5, %r4, %r2, sll, rl, %r11
+	; used in 64-bit variable shifting	; 	SHFTROTSHFT %r9, %r5, %r4, %r2, sll, rl, %r6
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r6, %r9		; temp = shift amount
+
+__L0028:
+	cmp		%r6, 8		; if temp <= 8 then goto $$2
+	jrle	__L0029
+
+	sll		%r5, 8		; shift 1st register
+	rl		%r4, 8		; rotate 2nd register
+	sll		%r2, 8		; shift 3rd register
+	jp.d	__L0028
+	sub		%r6, 8		; temp = temp - 8
+
+__L0029:
+	sll		%r5, %r6		; last shift
+	rl		%r4, %r6		; last rotate
+	sll		%r2, %r6		; last shift
+
+	not		%r3, %r2		; flip mask for last x bits --> %r3 = 000...111 (mask)
+	and		%r3, %r4		; isolate last x bits of %r4
+	or		%r5, %r3		; add last x bits of %r4 to %r5
+	and		%r4, %r2		; keep the high 32-x bits of %r4
+
+	jp.d	finish
+	;@@@ 01/02/15 del sub		%r1, %r13		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - shift(%r13)
+	sub		%r1, %r9		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - shift(%r9)
+
+rshift:
+	; shift to the right 1 bit
+	srl		%r4, 1			; shift low 32-bits to the right 1 bit
+	ld.w	%r3, 1			; mask
+	and		%r3, %r5		; get LSB of high 32-bits
+	rr		%r3, 1			; rotate to MSB position
+	or		%r4, %r3		; add to %r4
+	srl		%r5, 1			; shift high 32-bits to the right 1 bit
+	add		%r1, 1			; exp = exp + 1
+
+	; overflow check	
+	xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) < 0x7ff then jump to finish
+	jrlt	finish
+
+overflow:
+	xld.w	%r5, 0x7ff00000	; put infinity into result
+	jp.d	end				; delayed jump
+	ld.w	%r4, 0
+
+finish:
+	; %r0 = sign, %r1 = exponent, %r5 = mantissa
+	xand	%r5, 0xfffff		; isolate mantissa
+
+	xrr		%r1, 12			; position exponent bits to [30:23]
+	or		%r5, %r1
+
+end:
+	;@@@ 01/02/15 del rr		%r0, 1			; position sign bit to MSB
+	; 	GET_SIGN1	%r0, %r6	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r6) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0)
+__L0030:
+	ld.w	%r6,%r0			; 
+	rl		%r6,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+	and		%r6,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+
+	rr		%r6, 1			; position sign bit to MSB	@@@ 01/02/15 add
+	;@@@ 01/02/15 del or		%r5, %r0		; ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+	or		%r5, %r6		; ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+
+	;@@@ 01/01/23 add start hinokuchi
+	;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+	;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+	;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+	;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+	;add		%sp, 4
+	;@@@ 01/01/23 add end
+	popn	%r3				; restore register values
+	ret
diff --git a/gcc/config/c33/libgcc/addsf3.lst b/gcc/config/c33/libgcc/addsf3.lst
new file mode 100644
index 0000000..06a57f8
--- /dev/null
+++ b/gcc/config/c33/libgcc/addsf3.lst
@@ -0,0 +1,399 @@
+GAS LISTING addsf3.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : addsf3.s
+   6              	;*
+   7              	;*	Single floating point add function
+   8              	;*						  subtract function					
+   9              	;*		input: %r6, %r7
+  10              	;*		output: %r4
+  11              	;*
+  12              	;*	Begin					1996/09/12	V. Chan
+  13              	;*  Fixed sign bug			1997/02/17	V. Chan
+  14              	;*  Fixed a precision bug	1997/02/24	V. Chan
+  15              	;*  ﾊﾑｹｹ					2001/01/15  O.Hinokuchi
+  16              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  17              	;*
+  18              	;*********************************************
+  19              	
+  20              	.section .text
+  21              	.align 1
+  22              	.global __addsf3
+  23              	.global __subsf3
+  24              	
+  25              	;==============================================
+  26              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  27              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+  28              	;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+  29              	;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/count
+  30              	;	%r3:ｻﾘｿﾉ｣ｲ(8bit)
+  31              	;	%r4:ﾌ皃ﾃﾍ
+  32              	;	%r5:ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(8bit)/xflag
+  33              	;	%r6:ｰｿ｣ｱ(float)/ｲｾｿﾉ｣ｱ/shift counter
+  34              	;	%r7:ｰｿ｣ｲ(float)/ｲｾｿﾉ｣ｲ
+  35              	;	%r8:temp/implied bit/shift/loop counter
+  36              	;	%r9:mask
+  37              	;==============================================
+  38              	
+  39              	
+  40              	;;macro	VARSHIFT $1, $2, $3
+  41              		; used in 32-bit variable shifting
+  42              		; $1 = input register
+  43              		; $2 = shift amount
+  44              		; $3 = shift instruction
+  45              	
+  46              	;$$1:
+  47              	;	cmp		$2, 8		; if temp <= 8 then goto $$2
+  48              	;	jrle	$$2
+  49              	
+  50              	;	$3		$1, 8		; shift input register 8 bits
+  51              	;	jp.d	$$1
+  52              	;	sub		$2, 8		; temp = temp - 8
+  53              	
+  54              	;$$2:
+  55              	;	$3		$1, $2		; last shift
+  56              	;;endm
+  57              	
+GAS LISTING addsf3.s 			page 2
+
+
+  58              	__subsf3:
+  59 0000 00D000C0 		xxor	%r7, 0x80000000	; ｰｿ｣ｲ(%r7)= ｰｿ｣ｲ(%r7) & 0x80000000 
+  59      0778
+  60              	
+  61              	__addsf3:
+  62 0006 0302     		pushn	%r3				; save register values
+  63              	
+  64 0008 03C0F56F 		xld.w	%r5, 0xff		; ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ <- 0xff 
+  65              	
+  66 000c 602E     		ld.w	%r0, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ(%r6) 
+  67 000e 109C     		rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+  68 0010 1070     		and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+  69 0012 082E     		ld.w	%r8, %r0		; temp(%r8) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+  70              	
+  71 0014 722E     		ld.w	%r2, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r0) <- ｰｿ｣ｲ(%r7) 
+  72 0016 129C     		rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+  73 0018 1270     		and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1 
+  74              	
+  75 001a 612E     		ld.w	%r1, %r6		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ(%r6) 
+  76 001c 118C     		sll		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) << 1
+  77 001e 81888188 		xsrl 	%r1, 24			; ｻﾘｿﾉ｣ｱ(%r1) >> 24
+  77      8188
+  78              	
+  79 0024 512A     		cmp		%r1, %r5		; if ｻﾘｿﾉ｣ｱ(%r1) >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(%r5) 
+  80 0026 00C000C0 		xjrge	overflow		; then jump to overflow
+  80      920A
+  81              	
+  82 002c 732E     		ld.w	%r3, %r7		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ(%r6)
+  83 002e 138C     		sll 	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) << 1
+  84 0030 83888388 		xsrl	%r3, 24			; ｻﾘｿﾉ｣ｲ(%r3) >> 24
+  84      8388
+  85 0036 202E     		ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r0) 
+  86              	
+  87 0038 532A     		cmp		%r3, %r5		; if ｻﾘｿﾉ｣ｲ(%r3)  >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(%r5)  
+  88 003a 00C000C0 		xjrge	overflow		; then jump to overflow
+  88      880A
+  89              			
+  90 0040 312A     		cmp		%r1, %r3		; if ｻﾘｿﾉ｣ｱ(%r1) < ｻﾘｿﾉ｣ｲ(%r3) 
+  91 0042 0A0D     		jrlt.d	ex1ltex2		; then jump to ex1ltex2
+  92 0044 802E     		ld.w	%r0, %r8		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- temp(%r8) 
+  93              	
+  94              		; case: exp1 >= exp2
+  95 0046 182E     		ld.w	%r8, %r1		; temp(%r8) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) - ｻﾘｿﾉ｣ｲ(%r3) (difference)
+  96 0048 3826     		sub		%r8, %r3		; temp(%r8) = temp(%r8) - ｻﾘｿﾉ｣ｲ(%r3)
+  97 004a 8869     		cmp		%r8, 0x18		; if temp(%r8)difference >= 0x18 (24-bits it too large)
+  98 004c 642E     		ld.w	%r4, %r6		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r6) 
+  99 004e 00C000C0 		xjrge	end				; then jump to end return first input
+  99      860A
+ 100 0054 0A1E     		jp		continue		
+ 101              	
+ 102              	ex1ltex2:
+ 103              		; case: exp2 > exp1
+ 104 0056 382E     		ld.w 	%r8, %r3		; temp(%r8) <- ｻﾘｿﾉ｣ｲ(%r3)
+ 105 0058 1826     		sub		%r8, %r1		; temp(%r8) = ｻﾘｿﾉ｣ｲ(%r3) - ｻﾘｿﾉ｣ｱ(%r1)
+ 106 005a 8869     		xcmp	%r8, 0x18		; if temp(%r8)difference < 0x18
+ 107 005c 742E     		ld.w	%r4, %r7		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｲ 
+ 108 005e 050C     		jrlt 	continue		; then jump to continue
+GAS LISTING addsf3.s 			page 3
+
+
+ 109 0060 202E     		ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) 
+ 110 0062 00C000C0 		xjp		end				; return second input
+ 110      7C1E
+ 111              	
+ 112              	continue:
+ 113 0068 0FC0FFDF 		xld.w	%r9, 0x7fffff	; mask(%r9) <- 0x7fffff 
+ 113      F96F
+ 114 006e 10C000C0 		xld.w	%r8, 0x800000	; implied bit(%r8) <- 0x800000 
+ 114      086C
+ 115              	
+ 116              		; isolate mantissa1
+ 117 0074 0168     		cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) = 0
+ 118 0076 0319     		jreq.d	getman2			; then jump to getman2
+ 119 0078 9632     		and		%r6, %r9		; ｰｿ｣ｱ(%r6) & mask(%r9)  
+ 120 007a 8636     		or		%r6, %r8		; ｰｿ｣ｱ(%r6) & mplied bit(%r8) 
+ 121              	
+ 122              	getman2:
+ 123              		; isolate mantissa2
+ 124 007c 0368     		cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r3) = 0
+ 125 007e 0319     		jreq.d	cmpexp			; then jump to cmpexp
+ 126 0080 9732     		and		%r7, %r9		; ｰｿ｣ｲ(%r7) & mask(%r9)  clear first 9 bits of %r7
+ 127 0082 8736     		or		%r7, %r8		; ｰｿ｣ｲ(%r7) | mplied bit(%r8) if exp2 != 0 then add implied bit (normal)
+ 128              	
+ 129              	cmpexp:
+ 130              		; compare exponents -- %r1 will be result exponent
+ 131              		; if exp1 > exp2 then mantissa2 is shifted to the right
+ 132              		; if exp2 > exp1 then mantissa1 is shifted to the right
+ 133              	
+ 134              		; shift mantissa left for increased precision
+ 135 0084 168C     		sll		%r6, 1			; ｰｿ｣ｱ(%r6) << 1
+ 136 0086 178C     		sll		%r7, 1			; ｰｿ｣ｲ(%r6) << 1
+ 137              	
+ 138              		; xflag indicates which input (1 or 2) is the smaller input
+ 139 0088 056C     		ld.w	%r5, 0			; xflag(%r5) <- 0
+ 140              	
+ 141 008a 312A     		cmp		%r1, %r3		
+ 142 008c 1C18     		jreq	negation		; if ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｲ(%r3) then jump to negation
+ 143 008e 0F08     		jrgt	man2			; if ｻﾘｿﾉ｣ｱ(%r1) > ｻﾘｿﾉ｣ｲ(%r3) then jump to man2
+ 144              	
+ 145              		; case: exp1 < exp2
+ 146 0090 0168     		cmp		%r1, 0			 
+ 147 0092 182E     		ld.w	%r8, %r1		; temp(%r8) <- ｻﾘｿﾉ｣ｱ(%r1)
+ 148 0094 031B     		jrne.d	shftm1			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 then normal
+ 149 0096 312E     		ld.w	%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) <- ｻﾘｿﾉ｣ｲ(%r3) result exp = exp2
+ 150 0098 1364     		sub 	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) = ｻﾘｿﾉ｣ｲ(%r3) - 1 else denormal --> decrement shift
+ 151              	
+ 152              	shftm1:
+ 153 009a 8326     		sub		%r3, %r8		; ｻﾘｿﾉ｣ｲ(%r3) = ｻﾘｿﾉ｣ｲ(%r3) - temp(%r8) shift amount = exp2 - temp (exp1)
+ 154              	
+ 155              		;xsrl		%r6, %r3	; man1 >> shift
+ 156              		; used in 32-bit variable shifting	; 	VARSHIFT %r6, %r3, srl	; ｲｾｿﾉ｣ｱ(%r6) >> shift
+ 157              		; $1 = input register
+ 158              		; $2 = shift amount
+ 159              		; $3 = shift instruction
+ 160              	
+ 161              	__L0001:
+ 162 009c 8368     		cmp		%r3, 8		; if temp <= 8 then goto $$2
+GAS LISTING addsf3.s 			page 4
+
+
+ 163 009e 040E     		jrle	__L0002
+ 164              	
+ 165 00a0 8688     		srl		%r6, 8		; shift input register 8 bits
+ 166 00a2 FD1F     		jp.d	__L0001
+ 167 00a4 8364     		sub		%r3, 8		; temp = temp - 8
+ 168              	
+ 169              	__L0002:
+ 170 00a6 3689     		srl		%r6, %r3		; last shift
+ 171 00a8 0E1F     		jp.d	negation
+ 172 00aa 256C     		ld.w	%r5, 2			; xflag(%r5) = 2
+ 173              	
+ 174              	man2:
+ 175              		; case: ｻﾘｿﾉ｣ｱ > ｻﾘｿﾉ｣ｲ
+ 176 00ac 0368     		cmp		%r3, 0
+ 177 00ae 031B     		jrne.d	shftm2			; if ｻﾘｿﾉ｣ｲ(%r3) != 0 then normal
+ 178 00b0 182E     		ld.w	%r8, %r1		; shift(%r8) <- ｻﾘｿﾉ｣ｱ
+ 179 00b2 1864     		sub		%r8, 1			; shift(%r8) = shift(%r8) - 1 else denormal -- decrement shift
+ 180              	
+ 181              	shftm2:
+ 182 00b4 3826     		sub		%r8, %r3		; shift(%r8) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+ 183              	
+ 184              		;srl	%r7, %r8		; man2 >> shift
+ 185              		; used in 32-bit variable shifting	; 	VARSHIFT %r7, %r8, srl	; ｲｾｿﾉ｣ｱ(%r7) >> shift(%r8)
+ 186              		; $1 = input register
+ 187              		; $2 = shift amount
+ 188              		; $3 = shift instruction
+ 189              	
+ 190              	__L0003:
+ 191 00b6 8868     		cmp		%r8, 8		; if temp <= 8 then goto $$2
+ 192 00b8 040E     		jrle	__L0004
+ 193              	
+ 194 00ba 8788     		srl		%r7, 8		; shift input register 8 bits
+ 195 00bc FD1F     		jp.d	__L0003
+ 196 00be 8864     		sub		%r8, 8		; temp = temp - 8
+ 197              	
+ 198              	__L0004:
+ 199 00c0 8789     		srl		%r7, %r8		; last shift
+ 200              	
+ 201 00c2 156C     		ld.w	%r5, 1			; xflag(%r5) <- 1
+ 202              	
+ 203              	negation:
+ 204              		; xflag = 0 if exp1 = exp2
+ 205              		;		  1 if exp1 > exp2
+ 206              		;		  2 if exp1 < exp2
+ 207              		; %r0 will now be result sign bit
+ 208              	
+ 209              		; if exp1 = exp2 then this is the case
+ 210              		; sign1	(%r0)  sign2 (%r2)	result sign (%r0)
+ 211              		;	0			  0				0	<== no change
+ 212              		;	1			  0				0	<== change to 1 if result < 0
+ 213              		;	0			  1				0	<== change to 1 if result < 0
+ 214              		;	1			  1				1	<== no change
+ 215              	
+ 216 00c4 202A     		cmp		%r0, %r2		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) compare sign bits
+ 217 00c6 0B18     		jreq	sign			; then jump to sign
+ 218 00c8 1068     		cmp		%r0, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) != 1
+ 219 00ca 071A     		jrne	negm2			; then jump to negm2
+GAS LISTING addsf3.s 			page 5
+
+
+ 220              	
+ 221              		; case: sign1 = 1
+ 222 00cc 0568     		cmp		%r5, 0			; if xflag(%r5) != 0 only change %r0 if xflag = 0
+ 223 00ce 021A     		jrne	negm1			; then jump to negm1
+ 224 00d0 006C     		ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- 0 %r0 is now temp result sign (positive)
+ 225              	
+ 226              	negm1:
+ 227 00d2 663E     		not		%r6, %r6		; ｰｿ｣ｱ(%r6) = ~ｰｿ｣ｱ(%r6) negate man1
+ 228 00d4 041F     		jp.d	sign			; delayed jump to sign
+ 229 00d6 1660     		add		%r6, 1			; ｲｾｿﾉ｣ｱ(%r6) = ｲｾｿﾉ｣ｱ(%r6) + 1
+ 230              		
+ 231              	negm2:
+ 232 00d8 773E     		not		%r7, %r7		; ｲｾｿﾉ｣ｲ(%r7) = ~ｲｾｿﾉ｣ｲ(%r7) negate man2
+ 233 00da 1760     		add		%r7, 1			; ｲｾｿﾉ｣ｲ(%r7) = ｲｾｿﾉ｣ｲ(%r7) + 1
+ 234              	
+ 235              	sign:
+ 236              		; fix sign, case where exp2 > exp1 and sign2 = 1
+ 237              		; if xflag = 2 then result sign = sign2 (%r0 = %r2)
+ 238              		; if xflag = 1 then result sign = sign1	(%r0 = %r0)
+ 239              		; if xflag = 0 then result sign = 0 or 1
+ 240 00dc 2568     		cmp		%r5, 2			; if xflag(%r5) != 2
+ 241 00de 021A     		jrne	addition		; then jump to addition begin addition
+ 242              	
+ 243              		; case: xflag = 2
+ 244 00e0 202E     		ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) result sign = sign2
+ 245              	
+ 246              	addition:
+ 247              		; %r0 = result sign, %r1 = result exponent
+ 248              		; %r6 = mantissa1, %r7 = mantissa2
+ 249              		; %r4 = result
+ 250              	
+ 251 00e2 7622     		add		%r6, %r7		; ｲｾｿﾉ｣ｱ= ｲｾｿﾉ｣ｱ+ ｲｾｿﾉ｣ｲ add man1 and man2
+ 252 00e4 642E     		ld.w 	%r4, %r6		; ﾌ皃ﾃﾍ(%r4) <- ｲｾｿﾉ｣ｱ+ ｲｾｿﾉ｣ｲ put result (%r6) in %r4
+ 253              	
+ 254 00e6 0468     		cmp		%r4, 0			; if ﾌ皃ﾃﾍ(%r4) = 0
+ 255 00e8 3B19     		jreq.d	end				; jump to end if result = 0
+ 256 00ea 086C     		ld.w 	%r8, 0			; loop counter(8) <- 0 clear temp register
+ 257 00ec 0608     		jrgt	precount		; if result > 0 then continue with normalize
+ 258              	
+ 259              		; case: result < 0
+ 260 00ee 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4) + 1
+ 261 00f0 1460     		add		%r4, 1
+ 262              	
+ 263 00f2 0568     		cmp		%r5, 0			; if xflag(%r5) != 0 
+ 264 00f4 021A     		jrne	precount		; then goto count
+ 265 00f6 106C     		ld.w 	%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- 1 sign was 0 now sign = 1 
+ 266              	
+ 267              	precount:
+ 268 00f8 1488     		srl		%r4, 1			; ﾌ皃ﾃﾍ(%r4) >> 1 compensate for shifts on 117, 118
+ 269 00fa 462E     		ld.w	%r6, %r4		; shift counter(%r6) <- (ﾌ皃ﾃﾍ(%r4) >> 1) copy new result to %r6 for counting
+ 270              	
+ 271              	count:
+ 272 00fc 628E     		scan1	%r2, %r6		; scan1 count(%r2), shift counter(%r6) count = ; of 0's before leading 1 in result
+ 273 00fe 0412     		jruge	expchk			; if count !=8 then goto expchk
+ 274 0100 8860     		add		%r8, 8			; loop counter(%r8) = loop counter (%r8) + 8 add 8 to loop counter
+ 275 0102 FD1F     		jp.d	count
+ 276 0104 868C     		sll		%r6, 8			; shift counter(%r6) >> 8 shift 8 leading 0's out of %r6
+GAS LISTING addsf3.s 			page 6
+
+
+ 277              	
+ 278              	expchk:
+ 279 0106 8222     		add		%r2, %r8		; count(%r2) = count(%r2) + loop counter(%r8)
+ 280              	
+ 281 0108 0168     		cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 
+ 282 010a 051A     		jrne	normalize		; then jump to normalize
+ 283              	
+ 284              		; case: denormal + denormal (sisu = 0)
+ 285 010c 8268     		cmp		%r2, 8			; if count(%r2) != 8 
+ 286 010e 241A     		jrne	finish			; then jump to finish
+ 287 0110 231F     		jp.d	finish
+ 288 0112 116C     		ld.w 	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) <- 1 if count = 8 then normal result
+ 289              	
+ 290              	normalize:
+ 291 0114 8264     		sub		%r2, 8			; count(%r2) = count(%r2) - 8
+ 292 0116 2018     		jreq	finish			; if count(%r2) = 8 then no normalize needed
+ 293 0118 150C     		jrlt	shftrght		; if count(%r2) <= 8 then normal result with carry-over
+ 294              	
+ 295              		; case: count > 8
+ 296 011a 212A     		cmp		%r1, %r2		; if ｻﾘｿﾉ｣ｱ(%r1) <= count(%r2) 
+ 297 011c 0A0E     		jrle	denormal		; then denormal
+ 298              	
+ 299 011e 282E     		ld.w	%r8, %r2		; temp(%r8) <- count(%r2)
+ 300              		; used in 32-bit variable shifting	; 	VARSHIFT  %r4, %r2, sll	; ﾌ皃ﾃﾍ(%r4) << count(%r2)
+ 301              		; $1 = input register
+ 302              		; $2 = shift amount
+ 303              		; $3 = shift instruction
+ 304              	
+ 305              	__L0005:
+ 306 0120 8268     		cmp		%r2, 8		; if temp <= 8 then goto $$2
+ 307 0122 040E     		jrle	__L0006
+ 308              	
+ 309 0124 848C     		sll		%r4, 8		; shift input register 8 bits
+ 310 0126 FD1F     		jp.d	__L0005
+ 311 0128 8264     		sub		%r2, 8		; temp = temp - 8
+ 312              	
+ 313              	__L0006:
+ 314 012a 248D     		sll		%r4, %r2		; last shift
+ 315              		;xsll	%r4, %r2		; result << count
+ 316              	
+ 317 012c 151F     		jp.d	finish
+ 318 012e 8126     		sub		%r1, %r8		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - count(%r2)
+ 319              	
+ 320              	denormal:
+ 321 0130 1164     		sub 	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - 1 (shift to denormal position)
+ 322              		; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r1, sll	; ﾌ皃ﾃﾍ(%r4) << ｻﾘｿﾉ｣ｱ(%r1)
+ 323              		; $1 = input register
+ 324              		; $2 = shift amount
+ 325              		; $3 = shift instruction
+ 326              	
+ 327              	__L0007:
+ 328 0132 8168     		cmp		%r1, 8		; if temp <= 8 then goto $$2
+ 329 0134 040E     		jrle	__L0008
+ 330              	
+ 331 0136 848C     		sll		%r4, 8		; shift input register 8 bits
+ 332 0138 FD1F     		jp.d	__L0007
+ 333 013a 8164     		sub		%r1, 8		; temp = temp - 8
+GAS LISTING addsf3.s 			page 7
+
+
+ 334              	
+ 335              	__L0008:
+ 336 013c 148D     		sll		%r4, %r1		; last shift
+ 337              		;xsll 	%r4, %r1		; result << exp
+ 338 013e 0C1F     		jp.d	finish
+ 339 0140 016C     		ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 (denormal result)
+ 340              	
+ 341              	shftrght:
+ 342 0142 1488     		srl		%r4, 1			; ﾌ皃ﾃﾍ(%r4) >> 1
+ 343 0144 1160     		add		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + 1
+ 344              	
+ 345              		; overflow check
+ 346 0146 03C0F56F 		xld.w	%r5, 0xff		; ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(%r5) <- 0xff add:01/01/19 Hinokuchi set overflow compari
+ 347 014a 512A     		cmp		%r1, %r5		; if ｻﾘｿﾉ｣ｱ(%r1)  < 0xff
+ 348 014c 050C     		jrlt	finish			; then jump to finish
+ 349              	
+ 350              	overflow:
+ 351 014e F0CF00C0 		xld.w	%r4, 0x7f800000	; ﾌ皃ﾃﾍ(%r4) <- 0x7f800000 put infinity into result
+ 351      046C
+ 352 0154 051E     		jp		end
+ 353              	
+ 354              	finish:
+ 355              		; %r0 = sign, %r1 = exponent, %r4 = mantissa
+ 356              	
+ 357 0156 9432     		and		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) & mask(%r9) isolate mantissa
+ 358              	
+ 359 0158 81981198 		xrr		%r1, 9			; ｻﾘｿﾉ｣ｱ(%r1) bit[30｡ﾁ23]､ﾋ･ｷ･ﾕ･ﾈ  position exponent bits to [30:23]
+ 360 015c 1436     		or		%r4, %r1		; ﾌ皃ﾃﾍ(%r4) = ｻﾘｿﾉ｣ｱ(%r1) | ｲｾｿﾉ(%r4)
+ 361              	
+ 362              	end:
+ 363 015e 1098     		rr		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)bit[31]､ﾋ･ｷ･ﾕ･ﾈ position sign bit to MSB
+ 364 0160 0436     		or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) | ｻﾘｿﾉ｣ｱ(%r1) | ｲｾｿﾉ(%r4) add sign bit
+ 365              	
+ 366 0162 4302     		popn	%r3				; restore register values
+ 367              	
+ 368 0164 4006     		ret
diff --git a/gcc/config/c33/libgcc/addsf3.s b/gcc/config/c33/libgcc/addsf3.s
new file mode 100644
index 0000000..9f01ece
--- /dev/null
+++ b/gcc/config/c33/libgcc/addsf3.s
@@ -0,0 +1,368 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : addsf3.s
+;*
+;*	Single floating point add function
+;*						  subtract function					
+;*		input: %r6, %r7
+;*		output: %r4
+;*
+;*	Begin					1996/09/12	V. Chan
+;*  Fixed sign bug			1997/02/17	V. Chan
+;*  Fixed a precision bug	1997/02/24	V. Chan
+;*  ﾊﾑｹｹ					2001/01/15  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __addsf3
+.global __subsf3
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/count
+;	%r3:ｻﾘｿﾉ｣ｲ(8bit)
+;	%r4:ﾌ皃ﾃﾍ
+;	%r5:ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(8bit)/xflag
+;	%r6:ｰｿ｣ｱ(float)/ｲｾｿﾉ｣ｱ/shift counter
+;	%r7:ｰｿ｣ｲ(float)/ｲｾｿﾉ｣ｲ
+;	%r8:temp/implied bit/shift/loop counter
+;	%r9:mask
+;==============================================
+
+
+;;macro	VARSHIFT $1, $2, $3
+	; used in 32-bit variable shifting
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+;$$1:
+;	cmp		$2, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$3		$1, 8		; shift input register 8 bits
+;	jp.d	$$1
+;	sub		$2, 8		; temp = temp - 8
+
+;$$2:
+;	$3		$1, $2		; last shift
+;;endm
+
+__subsf3:
+	xxor	%r7, 0x80000000	; ｰｿ｣ｲ(%r7)= ｰｿ｣ｲ(%r7) & 0x80000000 
+
+__addsf3:
+	pushn	%r3				; save register values
+
+	xld.w	%r5, 0xff		; ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ <- 0xff 
+
+	ld.w	%r0, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ(%r6) 
+	rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+	and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+	ld.w	%r8, %r0		; temp(%r8) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+
+	ld.w	%r2, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r0) <- ｰｿ｣ｲ(%r7) 
+	rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+	and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1 
+
+	ld.w	%r1, %r6		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ(%r6) 
+	sll		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) << 1
+	xsrl 	%r1, 24			; ｻﾘｿﾉ｣ｱ(%r1) >> 24
+
+	cmp		%r1, %r5		; if ｻﾘｿﾉ｣ｱ(%r1) >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(%r5) 
+	xjrge	overflow		; then jump to overflow
+
+	ld.w	%r3, %r7		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ(%r6)
+	sll 	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) << 1
+	xsrl	%r3, 24			; ｻﾘｿﾉ｣ｲ(%r3) >> 24
+	ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r0) 
+
+	cmp		%r3, %r5		; if ｻﾘｿﾉ｣ｲ(%r3)  >= ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(%r5)  
+	xjrge	overflow		; then jump to overflow
+		
+	cmp		%r1, %r3		; if ｻﾘｿﾉ｣ｱ(%r1) < ｻﾘｿﾉ｣ｲ(%r3) 
+	jrlt.d	ex1ltex2		; then jump to ex1ltex2
+	ld.w	%r0, %r8		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- temp(%r8) 
+
+	; case: exp1 >= exp2
+	ld.w	%r8, %r1		; temp(%r8) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) - ｻﾘｿﾉ｣ｲ(%r3) (difference)
+	sub		%r8, %r3		; temp(%r8) = temp(%r8) - ｻﾘｿﾉ｣ｲ(%r3)
+	cmp		%r8, 0x18		; if temp(%r8)difference >= 0x18 (24-bits it too large)
+	ld.w	%r4, %r6		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r6) 
+	xjrge	end				; then jump to end return first input
+	jp		continue		
+
+ex1ltex2:
+	; case: exp2 > exp1
+	ld.w 	%r8, %r3		; temp(%r8) <- ｻﾘｿﾉ｣ｲ(%r3)
+	sub		%r8, %r1		; temp(%r8) = ｻﾘｿﾉ｣ｲ(%r3) - ｻﾘｿﾉ｣ｱ(%r1)
+	xcmp	%r8, 0x18		; if temp(%r8)difference < 0x18
+	ld.w	%r4, %r7		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｲ 
+	jrlt 	continue		; then jump to continue
+	ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) 
+	xjp		end				; return second input
+
+continue:
+	xld.w	%r9, 0x7fffff	; mask(%r9) <- 0x7fffff 
+	xld.w	%r8, 0x800000	; implied bit(%r8) <- 0x800000 
+
+	; isolate mantissa1
+	cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) = 0
+	jreq.d	getman2			; then jump to getman2
+	and		%r6, %r9		; ｰｿ｣ｱ(%r6) & mask(%r9)  
+	or		%r6, %r8		; ｰｿ｣ｱ(%r6) & mplied bit(%r8) 
+
+getman2:
+	; isolate mantissa2
+	cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r3) = 0
+	jreq.d	cmpexp			; then jump to cmpexp
+	and		%r7, %r9		; ｰｿ｣ｲ(%r7) & mask(%r9)  clear first 9 bits of %r7
+	or		%r7, %r8		; ｰｿ｣ｲ(%r7) | mplied bit(%r8) if exp2 != 0 then add implied bit (normal)
+
+cmpexp:
+	; compare exponents -- %r1 will be result exponent
+	; if exp1 > exp2 then mantissa2 is shifted to the right
+	; if exp2 > exp1 then mantissa1 is shifted to the right
+
+	; shift mantissa left for increased precision
+	sll		%r6, 1			; ｰｿ｣ｱ(%r6) << 1
+	sll		%r7, 1			; ｰｿ｣ｲ(%r6) << 1
+
+	; xflag indicates which input (1 or 2) is the smaller input
+	ld.w	%r5, 0			; xflag(%r5) <- 0
+
+	cmp		%r1, %r3		
+	jreq	negation		; if ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｲ(%r3) then jump to negation
+	jrgt	man2			; if ｻﾘｿﾉ｣ｱ(%r1) > ｻﾘｿﾉ｣ｲ(%r3) then jump to man2
+
+	; case: exp1 < exp2
+	cmp		%r1, 0			 
+	ld.w	%r8, %r1		; temp(%r8) <- ｻﾘｿﾉ｣ｱ(%r1)
+	jrne.d	shftm1			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 then normal
+	ld.w	%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) <- ｻﾘｿﾉ｣ｲ(%r3) result exp = exp2
+	sub 	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) = ｻﾘｿﾉ｣ｲ(%r3) - 1 else denormal --> decrement shift
+
+shftm1:
+	sub		%r3, %r8		; ｻﾘｿﾉ｣ｲ(%r3) = ｻﾘｿﾉ｣ｲ(%r3) - temp(%r8) shift amount = exp2 - temp (exp1)
+
+	;xsrl		%r6, %r3	; man1 >> shift
+	; used in 32-bit variable shifting	; 	VARSHIFT %r6, %r3, srl	; ｲｾｿﾉ｣ｱ(%r6) >> shift
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+__L0001:
+	cmp		%r3, 8		; if temp <= 8 then goto $$2
+	jrle	__L0002
+
+	srl		%r6, 8		; shift input register 8 bits
+	jp.d	__L0001
+	sub		%r3, 8		; temp = temp - 8
+
+__L0002:
+	srl		%r6, %r3		; last shift
+	jp.d	negation
+	ld.w	%r5, 2			; xflag(%r5) = 2
+
+man2:
+	; case: ｻﾘｿﾉ｣ｱ > ｻﾘｿﾉ｣ｲ
+	cmp		%r3, 0
+	jrne.d	shftm2			; if ｻﾘｿﾉ｣ｲ(%r3) != 0 then normal
+	ld.w	%r8, %r1		; shift(%r8) <- ｻﾘｿﾉ｣ｱ
+	sub		%r8, 1			; shift(%r8) = shift(%r8) - 1 else denormal -- decrement shift
+
+shftm2:
+	sub		%r8, %r3		; shift(%r8) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)
+
+	;srl	%r7, %r8		; man2 >> shift
+	; used in 32-bit variable shifting	; 	VARSHIFT %r7, %r8, srl	; ｲｾｿﾉ｣ｱ(%r7) >> shift(%r8)
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+__L0003:
+	cmp		%r8, 8		; if temp <= 8 then goto $$2
+	jrle	__L0004
+
+	srl		%r7, 8		; shift input register 8 bits
+	jp.d	__L0003
+	sub		%r8, 8		; temp = temp - 8
+
+__L0004:
+	srl		%r7, %r8		; last shift
+
+	ld.w	%r5, 1			; xflag(%r5) <- 1
+
+negation:
+	; xflag = 0 if exp1 = exp2
+	;		  1 if exp1 > exp2
+	;		  2 if exp1 < exp2
+	; %r0 will now be result sign bit
+
+	; if exp1 = exp2 then this is the case
+	; sign1	(%r0)  sign2 (%r2)	result sign (%r0)
+	;	0			  0				0	<== no change
+	;	1			  0				0	<== change to 1 if result < 0
+	;	0			  1				0	<== change to 1 if result < 0
+	;	1			  1				1	<== no change
+
+	cmp		%r0, %r2		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) compare sign bits
+	jreq	sign			; then jump to sign
+	cmp		%r0, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) != 1
+	jrne	negm2			; then jump to negm2
+
+	; case: sign1 = 1
+	cmp		%r5, 0			; if xflag(%r5) != 0 only change %r0 if xflag = 0
+	jrne	negm1			; then jump to negm1
+	ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- 0 %r0 is now temp result sign (positive)
+
+negm1:
+	not		%r6, %r6		; ｰｿ｣ｱ(%r6) = ~ｰｿ｣ｱ(%r6) negate man1
+	jp.d	sign			; delayed jump to sign
+	add		%r6, 1			; ｲｾｿﾉ｣ｱ(%r6) = ｲｾｿﾉ｣ｱ(%r6) + 1
+	
+negm2:
+	not		%r7, %r7		; ｲｾｿﾉ｣ｲ(%r7) = ~ｲｾｿﾉ｣ｲ(%r7) negate man2
+	add		%r7, 1			; ｲｾｿﾉ｣ｲ(%r7) = ｲｾｿﾉ｣ｲ(%r7) + 1
+
+sign:
+	; fix sign, case where exp2 > exp1 and sign2 = 1
+	; if xflag = 2 then result sign = sign2 (%r0 = %r2)
+	; if xflag = 1 then result sign = sign1	(%r0 = %r0)
+	; if xflag = 0 then result sign = 0 or 1
+	cmp		%r5, 2			; if xflag(%r5) != 2
+	jrne	addition		; then jump to addition begin addition
+
+	; case: xflag = 2
+	ld.w	%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) result sign = sign2
+
+addition:
+	; %r0 = result sign, %r1 = result exponent
+	; %r6 = mantissa1, %r7 = mantissa2
+	; %r4 = result
+
+	add		%r6, %r7		; ｲｾｿﾉ｣ｱ= ｲｾｿﾉ｣ｱ+ ｲｾｿﾉ｣ｲ add man1 and man2
+	ld.w 	%r4, %r6		; ﾌ皃ﾃﾍ(%r4) <- ｲｾｿﾉ｣ｱ+ ｲｾｿﾉ｣ｲ put result (%r6) in %r4
+
+	cmp		%r4, 0			; if ﾌ皃ﾃﾍ(%r4) = 0
+	jreq.d	end				; jump to end if result = 0
+	ld.w 	%r8, 0			; loop counter(8) <- 0 clear temp register
+	jrgt	precount		; if result > 0 then continue with normalize
+
+	; case: result < 0
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4) + 1
+	add		%r4, 1
+
+	cmp		%r5, 0			; if xflag(%r5) != 0 
+	jrne	precount		; then goto count
+	ld.w 	%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- 1 sign was 0 now sign = 1 
+
+precount:
+	srl		%r4, 1			; ﾌ皃ﾃﾍ(%r4) >> 1 compensate for shifts on 117, 118
+	ld.w	%r6, %r4		; shift counter(%r6) <- (ﾌ皃ﾃﾍ(%r4) >> 1) copy new result to %r6 for counting
+
+count:
+	scan1	%r2, %r6		; scan1 count(%r2), shift counter(%r6) count = ; of 0's before leading 1 in result
+	jruge	expchk			; if count !=8 then goto expchk
+	add		%r8, 8			; loop counter(%r8) = loop counter (%r8) + 8 add 8 to loop counter
+	jp.d	count
+	sll		%r6, 8			; shift counter(%r6) >> 8 shift 8 leading 0's out of %r6
+
+expchk:
+	add		%r2, %r8		; count(%r2) = count(%r2) + loop counter(%r8)
+
+	cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) != 0 
+	jrne	normalize		; then jump to normalize
+
+	; case: denormal + denormal (sisu = 0)
+	cmp		%r2, 8			; if count(%r2) != 8 
+	jrne	finish			; then jump to finish
+	jp.d	finish
+	ld.w 	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) <- 1 if count = 8 then normal result
+
+normalize:
+	sub		%r2, 8			; count(%r2) = count(%r2) - 8
+	jreq	finish			; if count(%r2) = 8 then no normalize needed
+	jrlt	shftrght		; if count(%r2) <= 8 then normal result with carry-over
+
+	; case: count > 8
+	cmp		%r1, %r2		; if ｻﾘｿﾉ｣ｱ(%r1) <= count(%r2) 
+	jrle	denormal		; then denormal
+
+	ld.w	%r8, %r2		; temp(%r8) <- count(%r2)
+	; used in 32-bit variable shifting	; 	VARSHIFT  %r4, %r2, sll	; ﾌ皃ﾃﾍ(%r4) << count(%r2)
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+__L0005:
+	cmp		%r2, 8		; if temp <= 8 then goto $$2
+	jrle	__L0006
+
+	sll		%r4, 8		; shift input register 8 bits
+	jp.d	__L0005
+	sub		%r2, 8		; temp = temp - 8
+
+__L0006:
+	sll		%r4, %r2		; last shift
+	;xsll	%r4, %r2		; result << count
+
+	jp.d	finish
+	sub		%r1, %r8		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - count(%r2)
+
+denormal:
+	sub 	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - 1 (shift to denormal position)
+	; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r1, sll	; ﾌ皃ﾃﾍ(%r4) << ｻﾘｿﾉ｣ｱ(%r1)
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+
+__L0007:
+	cmp		%r1, 8		; if temp <= 8 then goto $$2
+	jrle	__L0008
+
+	sll		%r4, 8		; shift input register 8 bits
+	jp.d	__L0007
+	sub		%r1, 8		; temp = temp - 8
+
+__L0008:
+	sll		%r4, %r1		; last shift
+	;xsll 	%r4, %r1		; result << exp
+	jp.d	finish
+	ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 (denormal result)
+
+shftrght:
+	srl		%r4, 1			; ﾌ皃ﾃﾍ(%r4) >> 1
+	add		%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + 1
+
+	; overflow check
+	xld.w	%r5, 0xff		; ｻﾘｿﾉ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼﾃﾍ(%r5) <- 0xff add:01/01/19 Hinokuchi set overflow comparison value
+	cmp		%r1, %r5		; if ｻﾘｿﾉ｣ｱ(%r1)  < 0xff
+	jrlt	finish			; then jump to finish
+
+overflow:
+	xld.w	%r4, 0x7f800000	; ﾌ皃ﾃﾍ(%r4) <- 0x7f800000 put infinity into result
+	jp		end
+
+finish:
+	; %r0 = sign, %r1 = exponent, %r4 = mantissa
+
+	and		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) & mask(%r9) isolate mantissa
+
+	xrr		%r1, 9			; ｻﾘｿﾉ｣ｱ(%r1) bit[30｡ﾁ23]､ﾋ･ｷ･ﾕ･ﾈ  position exponent bits to [30:23]
+	or		%r4, %r1		; ﾌ皃ﾃﾍ(%r4) = ｻﾘｿﾉ｣ｱ(%r1) | ｲｾｿﾉ(%r4)
+
+end:
+	rr		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)bit[31]､ﾋ･ｷ･ﾕ･ﾈ position sign bit to MSB
+	or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) | ｻﾘｿﾉ｣ｱ(%r1) | ｲｾｿﾉ(%r4) add sign bit
+
+	popn	%r3				; restore register values
+
+	ret
diff --git a/gcc/config/c33/libgcc/divdf3.lst b/gcc/config/c33/libgcc/divdf3.lst
new file mode 100644
index 0000000..59aa746
--- /dev/null
+++ b/gcc/config/c33/libgcc/divdf3.lst
@@ -0,0 +1,719 @@
+GAS LISTING divdf3.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : divdf3.s
+   6              	;*
+   7              	;*	Double floating point division function
+   8              	;*		input: (%r7, %r6) & (%r9, %r8)
+   9              	;*		output: (%r5, %r4)
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/31  O.Hinokuchi
+  13              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  14              	;*
+  15              	;*****************************************
+  16              	
+  17              	.section .text
+  18              	.align 1
+  19              	.global __divdf3
+  20              	
+  21              	;==============================================
+  22              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  23              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+  24              	;	%r1:ｻﾘｿﾉ｣ｱ(11bit)
+  25              	;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/shift/flag
+  26              	;	%r3:ｻﾘｿﾉ｣ｲ(11bit)/count/loop
+  27              	;	%r4:ﾌ皃ﾃﾍ[L]
+  28              	;	%r5:ﾌ皃ﾃﾍ[H]
+  29              	;	%r6:ｰｿ｣ｱ[L](ﾈｽｿ)/ｲｾｿﾉ｣ｱ[L]
+  30              	;	%r7:ｰｿ｣ｱ[H](ﾈｽｿ)/ｲｾｿﾉ｣ｱ[H]
+  31              	;	%r8:ｰｿ｣ｲ[L](ｽｿ)/ｲｾｿﾉ｣ｲ[L]
+  32              	;	%r9:ｰｿ｣ｲ[H](ｽｿ)/ｲｾｿﾉ｣ｲ[H]
+  33              	;	%r10:implied bit/lshift
+  34              	;	%r11:count1/shift/flag/extra
+  35              	;	%r12:scan64 ｰｿ｣ｱ/count2
+  36              	;	%r13:loop counter/scan64 ｰｿ｣ｲ/shift
+  37              	;==============================================
+  38              	
+  39              	;;macro	SHFTROTSHFT $1, $2, $3, $4, $5, $6, $7
+  40              		; used in 64-bit variable shifts
+  41              		; $1 = shift amount
+  42              		; $2 = 1st input register (shifted)
+  43              		; $3 = 2nd input register (rotated)
+  44              		; $4 = 3rd input register (mask --> shifted)
+  45              		; $5 = shift instruction
+  46              		; $6 = rotate instruction
+  47              		; $7 = temp register
+  48              	;	ld.w	$7, $1		; temp = shift amount
+  49              	
+  50              	;$$1:
+  51              	;	cmp		$7, 8		; if temp <= 8 then goto $$2
+  52              	;	jrle	$$2
+  53              	
+  54              	;	$5		$2, 8		; shift 1st register
+  55              	;	$6		$3, 8		; rotate 2nd register
+  56              	;	$5		$4, 8		; shift 3rd register
+  57              	;	jp.d	$$1
+GAS LISTING divdf3.s 			page 2
+
+
+  58              	;	sub		$7, 8		; temp = temp - 8
+  59              	
+  60              	;$$2:
+  61              	;	$5		$2, $7		; last shift
+  62              	;	$6		$3, $7		; last rotate
+  63              	;	$5		$4, $7		; last shift
+  64              	;;endm
+  65              	
+  66              	__divdf3:
+  67 0000 0302     		pushn	%r3				; save register values
+  68              		;@@@ 01/01/30 add start hinokuchi
+  69              		;sub		%sp, 4
+  70              		;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+  71              		;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+  72              		;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+  73              		;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+  74              		;@@@ 01/01/30 add end
+  75 0002 006C     		ld.w	%r0, 0			; ｶｦﾍｭ･･ｸ･ｹ･ｿ･ｯ･･｢ @@@ 01/02/19
+  76              	
+  77 0004 712E     		ld.w	%r1, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7) 
+  78 0006 119C     		rl		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) rotate left 1 bit
+  79 0008 1170     		and		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) & 1 
+  80              	
+  81 000a 922E     		ld.w	%r2, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ[H](%r9)
+  82 000c 129C     		rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+  83 000e 1270     		and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1
+  84              	
+  85 0010 213A     		xor		%r1, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ~ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+  86              		; 	SET_SIGN1	%r0, %r1
+  87              	__L0001:
+  88 0012 FFCFFFDF 		xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+  88      F073
+  89 0018 1170     		and		%r1,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+  90 001a 1198     		rr		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+  91 001c 1036     		or		%r0,%r1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+  92 001e 119C     		rl		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+  93              	
+  94 0020 056C     		ld.w	%r5, 0			; ﾌ皃ﾃﾍ[H](%r5) <- 0
+  95 0022 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ[L](%r4) <- 0
+  96              	
+  97 0024 178C     		sll		%r7, 1			; ｰｿ｣ｱ[H](%r7) << 1
+  98 0026 1788     		srl		%r7, 1			; ｰｿ｣ｱ[H](%r7) >> 1
+  99 0028 0768     		cmp		%r7, 0			; if ｰｿ｣ｱ[H](%r7) != 0 then check input2
+ 100 002a 041A     		jrne	zerochk2
+ 101 002c 0668     		cmp		%r6, 0			; if ｰｿ｣ｱ[L](%r6) = 0 then end
+ 102 002e 01C0     		ext		end@rm
+ 103 0030 6018     		jreq	end@rl
+ 104              	
+ 105              	zerochk2:
+ 106 0032 198C     		sll		%r9, 1			; ｰｿ｣ｲ[H](%r9) << 1
+ 107 0034 1988     		srl		%r9, 1			; ｰｿ｣ｲ[H](%r9) >> 1
+ 108 0036 0968     		cmp		%r9, 0			; if ｰｿ｣ｲ[H](%r9) != 0 then goto getexp
+ 109 0038 041A     		jrne	getexp
+ 110 003a 0868     		cmp		%r8, 0			; if ｰｿ｣ｲ[L](%r8) = 0 then overflow
+ 111 003c 01C0     		ext		overflow@rm
+ 112 003e 4B18     		jreq	overflow@rl
+ 113              	
+GAS LISTING divdf3.s 			page 3
+
+
+ 114              	getexp:
+ 115 0040 712E     		ld.w	%r1, %r7		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7)
+ 116 0042 81888188 		xsrl 	%r1, 20			; ｻﾘｿﾉ｣ｱ(%r1) >> 20
+ 116      4188
+ 117              		; 	SET_EXP1	%r0 ,%r1	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0) <- ｻﾘｿﾉ｣ｱ(%r1) @@@ 01/02/19
+ 118              	__L0002:
+ 119 0048 E0DF0070 		xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+ 120 004c 1FC0F173 		xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 121 0050 1036     		or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+ 122              	
+ 123              	
+ 124 0052 1FC0F16B 		xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+ 125 0056 01C0     		ext		overflow@rm
+ 126 0058 3E0A     		jrge	overflow@rl		; result is overflow
+ 127              	
+ 128 005a 932E     		ld.w	%r3, %r9		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ[H](%r9)
+ 129 005c 83888388 		xsrl	%r3, 20			; ｻﾘｿﾉ｣ｲ(%r3) >> 20
+ 129      4388
+ 130              		; 	SET_EXP2	%r0 ,%r3	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｲ](%r0) <- ｻﾘｿﾉ｣ｲ(%r3) @@@ 01/02/19
+ 131              	__L0003:
+ 132 0062 F8DF1FC0 		xand	%r0,0xffc007ff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｲ･ｯ･･｢
+ 132      F073
+ 133 0068 1FC0F373 		xand	%r3,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 134 006c 838C     		sll		%r3,8			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 135 006e 338C     		sll		%r3,3			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 136 0070 3036     		or		%r0,%r3			; ｻﾘｿﾉ｣ｲ･ｻ･ﾃ･ﾈ
+ 137 0072 8388     		srl		%r3,8			; ｻﾘｿﾉﾉｵ｢
+ 138 0074 3388     		srl		%r3,3			; ｻﾘｿﾉﾉｵ｢
+ 139              	
+ 140              	
+ 141 0076 1FC0F36B 		xcmp	%r3, 0x7ff		; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+ 142 007a 01C0     		ext		end@rm
+ 143 007c 3A18     		jreq	end@rl			; result is 0 (xxx/NaN = 0)
+ 144              	
+ 145              		; del @@@ 01/02/19 del xld.w	%r10, 0x100000	; implied bit(%r10) <- 0x100000
+ 146              	
+ 147              		; isolate mantissa1
+ 148 007e 01C0FFDF 		xand	%r7, 0xfffff	; clear first 12 bits of %r7
+ 148      F773
+ 149              	
+ 150 0084 0168     		cmp		%r1, 0
+ 151 0086 0819     		jreq.d	count1			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 (denormal)
+ 152 0088 126C     		ld.w	%r2, 1			; flag(%r2) = 1
+ 153              	
+ 154              		; case: normal input
+ 155 008a 02C000C0 		xoor	%r7, 0x100000	; else add implied bit(0x100000) to mantissa @@@ 01/02/19
+ 155      0774
+ 156 0090 026C     		ld.w	%r2, 0			; flag(%r2) = 0
+ 157 0092 151F     		jp.d	getman2
+ 158 0094 B56C     		ld.w	%r5, 11			; count1(%r5) = 11
+ 159              		
+ 160              	count1:	
+ 161 0096 742E     		ld.w	%r4, %r7		; scan64 ｰｿ｣ｱ(%r4) <- ｰｿ｣ｱ[H](%r7)
+ 162 0098 652E     		ld.w	%r5, %r6		; scan64 ｰｿ｣ｲ(%r5) <- ｰｿ｣ｱ[L](%r6)
+ 163              		; @@@ del 01/02/19 xcall	__scan64
+ 164              		; 	SCAN64 	%r4, %r5		; @@@ add 01/02/19		
+ 165 009a 0102     		pushn	%r1				; save register values
+GAS LISTING divdf3.s 			page 4
+
+
+ 166              	
+ 167 009c 006C     		ld.w	%r0, 0			; loop counter = 0
+ 168              	
+ 169 009e 0468     		cmp		%r4, 0			; if high 32-bits != 0 then count
+ 170 00a0 041A     		jrne	__L0004
+ 171              	
+ 172              		; case: $1 = 0
+ 173 00a2 542E     		ld.w	%r4, %r5			; count low 32-bits instead
+ 174 00a4 00C0006E 		xld.w	%r0, 32			; loop counter = 32
+ 175              	
+ 176              	__L0004:						; count ; of leading 0's
+ 177 00a8 418E     		scan1	%r1, %r4			; %r1 = count
+ 178 00aa 0612     		jruge	__L0005				; if count != 8 then goto end
+ 179 00ac 8069     		cmp		%r0, 24
+ 180 00ae 0419     		jreq.d	__L0005				; if count = 32 then jump to end
+ 181 00b0 8060     		add		%r0, 8			; increment loop counter
+ 182 00b2 FB1F     		jp.d	__L0004
+ 183 00b4 848C     		sll		%r4, 8			; shift register to the left 8 bits
+ 184              	
+ 185              	__L0005:
+ 186 00b6 0122     		add		%r1, %r0		; count = count + loop counter
+ 187 00b8 152E     		ld.w	%r5, %r1			; put result into output register
+ 188              	
+ 189 00ba 4102     		popn	%r1				; restore register values
+ 190              	
+ 191              	getman2:
+ 192              		; isolate mantissa2
+ 193              	
+ 194 00bc 01C0FFDF 		xand	%r9, 0xfffff		; ｰｿ｣ｲ[H] = ｰｿ｣ｲ[H] & 0xfffff clear first 12 bits of %r9
+ 194      F973
+ 195              	
+ 196 00c2 0368     		cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r3) = 0
+ 197 00c4 0719     		jreq.d	count2			; then jump to count2
+ 198 00c6 532E     		ld.w	%r3, %r5		; %r11 = count1
+ 199              	
+ 200              		; case: normal input
+ 201 00c8 02C000C0 		xoor	%r9, 0x100000	; else add implied bit(0x100000)	@@@ 01/02/19
+ 201      0974
+ 202 00ce 161F     		jp.d	cmpcount
+ 203 00d0 B46C     		ld.w	%r4, 11			; count2(%r12) = 11
+ 204              	
+ 205              	count2:
+ 206 00d2 942E     		ld.w	%r4, %r9		; scan64 ｰｿ｣ｱ(%r4) = ｰｿ｣ｲ[H](%r9)
+ 207 00d4 852E     		ld.w	%r5, %r8		; scan64 ｰｿ｣ｲ(%r5) = ｰｿ｣ｲ[L](%r8)
+ 208              		; @@@ del 01/02/19 xcall	__scan64		; %r13 = count2
+ 209              		; 	SCAN64 	%r4, %r5		; @@@ add 01/02/19		
+ 210 00d6 0102     		pushn	%r1				; save register values
+ 211              	
+ 212 00d8 006C     		ld.w	%r0, 0			; loop counter = 0
+ 213              	
+ 214 00da 0468     		cmp		%r4, 0			; if high 32-bits != 0 then count
+ 215 00dc 041A     		jrne	__L0006
+ 216              	
+ 217              		; case: $1 = 0
+ 218 00de 542E     		ld.w	%r4, %r5			; count low 32-bits instead
+ 219 00e0 00C0006E 		xld.w	%r0, 32			; loop counter = 32
+ 220              	
+GAS LISTING divdf3.s 			page 5
+
+
+ 221              	__L0006:						; count ; of leading 0's
+ 222 00e4 418E     		scan1	%r1, %r4			; %r1 = count
+ 223 00e6 0612     		jruge	__L0007				; if count != 8 then goto end
+ 224 00e8 8069     		cmp		%r0, 24
+ 225 00ea 0419     		jreq.d	__L0007				; if count = 32 then jump to end
+ 226 00ec 8060     		add		%r0, 8			; increment loop counter
+ 227 00ee FB1F     		jp.d	__L0006
+ 228 00f0 848C     		sll		%r4, 8			; shift register to the left 8 bits
+ 229              	
+ 230              	__L0007:
+ 231 00f2 0122     		add		%r1, %r0		; count = count + loop counter
+ 232 00f4 152E     		ld.w	%r5, %r1			; put result into output register
+ 233              	
+ 234 00f6 4102     		popn	%r1				; restore register values
+ 235              	
+ 236              	
+ 237 00f8 1264     		sub		%r2, 1			; flag(%r2) = flag(%r2) - 1 (0 or -1)
+ 238              	
+ 239              	cmpcount:
+ 240              		; 	SET_TEMP 	%r0, %r2	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0) <- flag(%r2)
+ 241              	__L0008:
+ 242 00fa 07D8FFDF 		xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+ 242      F073
+ 243 0100 03C0F273 		xand	%r2,0xff			; 1･ﾐ･､･ﾈ mask
+ 244 0104 8298     		rr		%r2,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 245 0106 2298     		rr		%r2,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 246 0108 2036     		or		%r0,%r2			; TEMP･ｻ･ﾃ･ﾈ
+ 247 010a 829C     		rl		%r2,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 248 010c 229C     		rl		%r2,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 249              	
+ 250 010e 532A     		cmp		%r3, %r5		; if count1(%r11) <= count2(%r13) 
+ 251 0110 160E     		jrle	man2shift		; then goto man2shift
+ 252              	
+ 253              		; case: count1 > count2
+ 254 0112 5326     		sub		%r3, %r5		; shift(%r3) = (count1(%r3) - count2(%r5)) - 1
+ 255 0114 1364     		sub		%r3, 1
+ 256              	
+ 257              		; {%r7, %r6} << shift
+ 258              		;xsll	%r7, %r11		; shift high 32-bits to the left x bits
+ 259              		;xrl	%r6, %r11		; rotate low 32-bits to the left x bits
+ 260              		;xsll	%r10, %r11		; make a mask for first 32-x bits --> %r10 = 111...000
+ 261              	
+ 262 0116 F26F     		ld.w	%r2, -1			; %r2 = 0xffff ffff
+ 263              		; used in 64-bit variable shifts	; 	SHFTROTSHFT %r3, %r7, %r6, %r2, sll, rl, %r5			; %r5 = temp
+ 264              		; $1 = shift amount
+ 265              		; $2 = 1st input register (shifted)
+ 266              		; $3 = 2nd input register (rotated)
+ 267              		; $4 = 3rd input register (mask --> shifted)
+ 268              		; $5 = shift instruction
+ 269              		; $6 = rotate instruction
+ 270              		; $7 = temp register
+ 271 0118 352E     		ld.w	%r5, %r3		; temp = shift amount
+ 272              	
+ 273              	__L0009:
+ 274 011a 8568     		cmp		%r5, 8		; if temp <= 8 then goto $$2
+ 275 011c 060E     		jrle	__L0010
+ 276              	
+GAS LISTING divdf3.s 			page 6
+
+
+ 277 011e 878C     		sll		%r7, 8		; shift 1st register
+ 278 0120 869C     		rl		%r6, 8		; rotate 2nd register
+ 279 0122 828C     		sll		%r2, 8		; shift 3rd register
+ 280 0124 FB1F     		jp.d	__L0009
+ 281 0126 8564     		sub		%r5, 8		; temp = temp - 8
+ 282              	
+ 283              	__L0010:
+ 284 0128 578D     		sll		%r7, %r5		; last shift
+ 285 012a 569D     		rl		%r6, %r5		; last rotate
+ 286 012c 528D     		sll		%r2, %r5		; last shift
+ 287 012e 253E     		not		%r5, %r2		; flip mask for last x bits --> %r5 = 000...111 (mask)
+ 288 0130 6532     		and		%r5, %r6		; isolate last x bits of %r6
+ 289 0132 5736     		or		%r7, %r5		; add last x bits of %r6 to %r7
+ 290 0134 2632     		and		%r6, %r2		; keep the high 32-x bits of %r6
+ 291              	
+ 292 0136 1360     		add		%r3, 1			; shift(%r3) = shift(%r3) + 1
+ 293 0138 161F     		jp.d	divide
+ 294 013a 322E     		ld.w	%r2, %r3		; lshift(%r2) = count1 - count2
+ 295              	
+ 296              	man2shift:
+ 297 013c 3526     		sub		%r5, %r3		; shift(%r5) = count2 - count1 + 1
+ 298 013e 1560     		add		%r5, 1
+ 299              	
+ 300              		; {%r9, %r8} << shift
+ 301              		;xsll	%r9, %r13		; shift high 32-bits to the left x bits
+ 302              		;xrl	%r8, %r13		; rotate low 32-bits to the left x bits
+ 303              		;xsll	%r10, %r13		; make a mask for first 32-x bits --> %r10 = 111...000
+ 304              	
+ 305 0140 F26F     		ld.w	%r2, -1			; %r2 = 0xffff ffff
+ 306              		; used in 64-bit variable shifts	; 	SHFTROTSHFT %r5, %r9, %r8, %r2, sll, rl, %r4		; %r4 = temp
+ 307              		; $1 = shift amount
+ 308              		; $2 = 1st input register (shifted)
+ 309              		; $3 = 2nd input register (rotated)
+ 310              		; $4 = 3rd input register (mask --> shifted)
+ 311              		; $5 = shift instruction
+ 312              		; $6 = rotate instruction
+ 313              		; $7 = temp register
+ 314 0142 542E     		ld.w	%r4, %r5		; temp = shift amount
+ 315              	
+ 316              	__L0011:
+ 317 0144 8468     		cmp		%r4, 8		; if temp <= 8 then goto $$2
+ 318 0146 060E     		jrle	__L0012
+ 319              	
+ 320 0148 898C     		sll		%r9, 8		; shift 1st register
+ 321 014a 889C     		rl		%r8, 8		; rotate 2nd register
+ 322 014c 828C     		sll		%r2, 8		; shift 3rd register
+ 323 014e FB1F     		jp.d	__L0011
+ 324 0150 8464     		sub		%r4, 8		; temp = temp - 8
+ 325              	
+ 326              	__L0012:
+ 327 0152 498D     		sll		%r9, %r4		; last shift
+ 328 0154 489D     		rl		%r8, %r4		; last rotate
+ 329 0156 428D     		sll		%r2, %r4		; last shift
+ 330 0158 243E     		not		%r4, %r2		; flip mask for last x bits --> %r4 = 000...111 (mask)
+ 331 015a 8432     		and		%r4, %r8		; isolate last x bits of %r8
+ 332 015c 4936     		or		%r9, %r4		; add last x bits of %r8 to %r9
+ 333 015e 2832     		and		%r8, %r2		; keep the high 32-x bits of %r8
+GAS LISTING divdf3.s 			page 7
+
+
+ 334              	
+ 335 0160 523E     		not		%r2, %r5		; lshift(%r10) = count1 - count2 (~shift + 1 + 1)
+ 336 0162 2260     		add		%r2, 2
+ 337              	
+ 338              	divide:
+ 339              		; man1 has x leading 0's
+ 340              		; man2 has x-1 leading 0's
+ 341              		; lshift used to normalize result
+ 342              		; %r0 = sign; %r1 = exp1, %r3 = exp2
+ 343              		; %r10 = lshift
+ 344              		; 	GET_EXP2	%r0, %r3	; ｻﾘｿﾉ｣ｲ(%r3) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｲ](%r0)
+ 345              	__L0013:
+ 346 0164 032E     		ld.w	%r3,%r0			
+ 347 0166 8388     		srl		%r3,8
+ 348 0168 3388     		srl		%r3,3
+ 349 016a 1FC0F373 		xand	%r3,0x7ff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｲｼ霹ﾀ
+ 350              	
+ 351              	
+ 352 016e 3126     		sub		%r1, %r3		; new sisu = sisu1 - sisu2 + bias + flag (0,1,-1)
+ 353              	
+ 354 0170 0FC0F163 		xadd	%r1, 0x3ff
+ 355              		; 	GET_TEMP	%r0, %r3	; flag(%r3) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0)	@@@ 01/02/19 add
+ 356              	__L0014:
+ 357 0174 032E     		ld.w	%r3,%r0			
+ 358 0176 839C     		rl		%r3,8
+ 359 0178 239C     		rl		%r3,2
+ 360 017a 03C0F373 		xand	%r3,0xff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMPｼ霹ﾀ
+ 361              	
+ 362 017e 3122     		add		%r1, %r3
+ 363              	
+ 364 0180 1FC0F16B 		xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) >= 0x7ff then goto overflow
+ 365 0184 00C0     		ext		overflow@rm
+ 366 0186 A70A     		jrge	overflow@rl
+ 367 0188 FFDFC168 		xcmp	%r1, -52		; if ｻﾘｿﾉ｣ｱ(%r1) <= -52 then underflow
+ 368 018c 00C0     		ext		end@rm
+ 369 018e B10E     		jrle	end@rl
+ 370              	
+ 371              		; DIVIDE CODE STARTS HERE
+ 372 0190 132E     		ld.w	%r3, %r1	
+ 373 0192 139C     		rl		%r3,1			; ｻﾘｿﾉ｣ｱﾉ荵讌ﾓ･ﾃ･ﾈﾊﾝﾂｸ
+ 374              		; 	SET_SIGN2	%r0, %r3	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ](%r0) <- ｻﾘｿﾉ｣ｱﾉ荵讌ﾓ･ﾃ･ﾈ
+ 375              	__L0015:
+ 376 0194 FFD7FFDF 		xand	%r0,0xbfffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｯ･･｢
+ 376      F073
+ 377 019a 1370     		and		%r3,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 378 019c 2398     		rr		%r3,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 379 019e 3036     		or		%r0,%r3			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｻ･ﾃ･ﾈ
+ 380 01a0 239C     		rl		%r3,2			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+ 381              	
+ 382              		; 	SET_EXP1	%r0, %r1	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0) <- ｻﾘｿﾉ｣ｱ(%r1) @@@ 01/02/19 add
+ 383              	__L0016:
+ 384 01a2 E0DF0070 		xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+ 385 01a6 1FC0F173 		xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 386 01aa 1036     		or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+ 387              	
+ 388              		; 	SET_TEMP	%r0, %r2	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0) <- lshift(%r2) @@@ 01/02/19 add
+ 389              	__L0017:
+GAS LISTING divdf3.s 			page 8
+
+
+ 390 01ac 07D8FFDF 		xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+ 390      F073
+ 391 01b2 03C0F273 		xand	%r2,0xff			; 1･ﾐ･､･ﾈ mask
+ 392 01b6 8298     		rr		%r2,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 393 01b8 2298     		rr		%r2,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+ 394 01ba 2036     		or		%r0,%r2			; TEMP･ｻ･ﾃ･ﾈ
+ 395 01bc 829C     		rl		%r2,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 396 01be 229C     		rl		%r2,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+ 397              	
+ 398              	
+ 399              		; make a mask for first 31 bits --> %r2 = 111...110
+ 400              		; @@@ del 01/02/19 ld.w	%r2, -2			; %r2 = 0xffff fffe
+ 401 01c0 036C     		ld.w	%r3, 0			; loop(%r3) <- 0
+ 402 01c2 016C     		ld.w	%r1, 0			; flag(%r1) = 0
+ 403 01c4 046C     		ld.w	%r4, 0			; @@@ 01/02/26 add
+ 404 01c6 056C     		ld.w	%r5, 0			; @@@ 01/02/26 add
+ 405              	
+ 406              	
+ 407              	loop:
+ 408 01c8 1360     		add		%r3, 1			; loop(%r3) = loop(%r3) + 1
+ 409 01ca 00C0736B 		xcmp	%r3, 55			; if loop(%r3) >= 55 then exit divide loop
+ 410 01ce 380A     		jrge	normalize
+ 411              	
+ 412              		; {result1, result2} << 1
+ 413 01d0 158C     		sll		%r5, 1			; shift high 32-bits to the left 1 bit
+ 414 01d2 149C     		rl		%r4, 1			; rotate low 32-bits to the left 1 bit
+ 415 01d4 126C     		ld.w	%r2, 1			; mask for last bit (LSB)
+ 416 01d6 4232     		and		%r2, %r4		; isolate last bit of %r8
+ 417 01d8 2536     		or		%r5, %r2		; add last bit of %r8 to %r9
+ 418 01da E473     		xand	%r4, -2			; keep the high 31 bits of %r8
+ 419              		
+ 420 01dc 718E     		scan1	%r1, %r7		; is there a leading 1? (0 = yes)
+ 421              	
+ 422              		; {ｲｾｿﾉ｣ｱ[H](%r7), ｲｾｿﾉ｣ｱ[L](%r6)} << 1
+ 423 01de 178C     		sll		%r7, 1			; shift high 32-bits to the left 1 bit
+ 424 01e0 169C     		rl		%r6, 1			; rotate low 32-bits to the left 1 bit
+ 425 01e2 126C     		ld.w	%r2, 1			; mask for last bit (LSB)
+ 426 01e4 6232     		and		%r2, %r6		; isolate last bit of %r8
+ 427 01e6 2736     		or		%r7, %r2		; add last bit of %r8 to %r9
+ 428 01e8 E673     		xand	%r6, -2			; keep the high 31 bits of %r8
+ 429 01ea 0168     		cmp		%r1, 0			; if a leading 1 was shifted out then subtract
+ 430 01ec 0618     		jreq	subtract
+ 431              	
+ 432 01ee 972A     		cmp		%r7, %r9
+ 433 01f0 0410     		jrugt	subtract		; if ｲｾｿﾉ｣ｱ[H](%r7) > ｲｾｿﾉ｣ｲ[H](%r9) then subtract
+ 434 01f2 EB14     		jrult	loop			; if ｲｾｿﾉ｣ｱ[H](%r7) < ｲｾｿﾉ｣ｲ[H](%r9) then goto loop
+ 435              	
+ 436              		; case: man1 = man2 (%r7 = %r9)
+ 437 01f4 862A     		cmp		%r6, %r8		; if ｲｾｿﾉ｣ｱ[L](%r6) < ｲｾｿﾉ｣ｲ[L](%r8) then goto loop
+ 438 01f6 E914     		jrult	loop
+ 439              	
+ 440              	subtract:
+ 441 01f8 8626     		sub		%r6, %r8		; ｲｾｿﾉ｣ｱ[L](%r6) = ｲｾｿﾉ｣ｱ[L](%r6) - ｲｾｿﾉ｣ｲ[L](%r8)
+ 442 01fa 97BC     		sbc		%r7, %r9		; ｲｾｿﾉ｣ｱ[H](%r7) = ｲｾｿﾉ｣ｱ[H](%r7) - ｲｾｿﾉ｣ｲ[H](%r9) - carry
+ 443 01fc 1460     		add		%r4, 1			; ﾌ皃ﾃﾍ[L](%r4) = ﾌ皃ﾃﾍ[L](%r4) + 1 
+ 444              	
+ 445 01fe 0768     		cmp		%r7, 0			; if {ｲｾｿﾉ｣ｱ[H](%r7), ｲｾｿﾉ｣ｱ[L](%r6) } = 0 then exit
+GAS LISTING divdf3.s 			page 9
+
+
+ 446 0200 E41A     		jrne	loop
+ 447 0202 0668     		cmp		%r6, 0
+ 448 0204 E21A     		jrne	loop
+ 449              	
+ 450 0206 00C0636B 		xcmp	%r3, 54			; if loop(%r3) >= 54 then exit divide loop
+ 451 020a 1A0A     		jrge	normalize
+ 452              	
+ 453              		; fill in the extra 0's needed in the result
+ 454 020c 00C0616F 		xld.w	%r1, 54
+ 455 0210 3126     		sub		%r1, %r3		; extra(%r1) = 54 - loop(%r3)	
+ 456 0212 00C0016A 		xcmp	%r1, 32			; if extra(%r1) < 32 then goto shift
+ 457 0216 040C     		jrlt	xshift
+ 458              	
+ 459              		; case: extra iterations >= 32
+ 460 0218 452E     		ld.w	%r5, %r4		; ﾌ皃ﾃﾍ[H](%r5) <- ﾌ皃ﾃﾍ[L](%r4)
+ 461 021a 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ[L](%r4) <- 0
+ 462 021c 0166     		sub		%r1, 32			; extra(%r1) = extra(%r1) - 32
+ 463              		
+ 464              	xshift:
+ 465              		; {%r5, %r4} << extra
+ 466              		;xsll	%r5, %r11		; shift high 32-bits to the left x bits
+ 467              		;xrl	%r4, %r11		; rotate low 32-bits to the left x bits
+ 468              		;xsll	%r3, %r11		; make a mask for first 32-x bits --> %r3 = 111...000
+ 469              	
+ 470 021e F36F     		ld.w	%r3, -1			; %r3 = 0xffff ffff
+ 471              		; used in 64-bit variable shifts	; 	SHFTROTSHFT %r1, %r5, %r4, %r3, sll, rl, %r1
+ 472              		; $1 = shift amount
+ 473              		; $2 = 1st input register (shifted)
+ 474              		; $3 = 2nd input register (rotated)
+ 475              		; $4 = 3rd input register (mask --> shifted)
+ 476              		; $5 = shift instruction
+ 477              		; $6 = rotate instruction
+ 478              		; $7 = temp register
+ 479 0220 112E     		ld.w	%r1, %r1		; temp = shift amount
+ 480              	
+ 481              	__L0018:
+ 482 0222 8168     		cmp		%r1, 8		; if temp <= 8 then goto $$2
+ 483 0224 060E     		jrle	__L0019
+ 484              	
+ 485 0226 858C     		sll		%r5, 8		; shift 1st register
+ 486 0228 849C     		rl		%r4, 8		; rotate 2nd register
+ 487 022a 838C     		sll		%r3, 8		; shift 3rd register
+ 488 022c FB1F     		jp.d	__L0018
+ 489 022e 8164     		sub		%r1, 8		; temp = temp - 8
+ 490              	
+ 491              	__L0019:
+ 492 0230 158D     		sll		%r5, %r1		; last shift
+ 493 0232 149D     		rl		%r4, %r1		; last rotate
+ 494 0234 138D     		sll		%r3, %r1		; last shift
+ 495 0236 323E     		not		%r2, %r3		; flip mask for last x bits --> %r2 = 000...111 (mask)
+ 496 0238 4232     		and		%r2, %r4		; isolate last x bits of %r6
+ 497 023a 2536     		or		%r5, %r2		; add last x bits of %r6 to %r7
+ 498 023c 3432     		and		%r4, %r3		; keep the high 32-x bits of %r6
+ 499              	
+ 500              		; DIVIDE CODE ENDS HERE
+ 501              	
+ 502              	normalize:
+GAS LISTING divdf3.s 			page 10
+
+
+ 503              		; %r0 = result sign, %r1 = result exponent
+ 504              		; %r10 = lshift, (%r5, %r4) = result
+ 505              		
+ 506              		;ld.w	%r3, 10			; count = 10
+ 507 023e 036C     		ld.w	%r3, 0			; count(%r3) <- 0
+ 508              	
+ 509 0240 582E     		ld.w	%r8, %r5
+ 510 0242 04C000C0 		xand	%r8, 0x200000	; check 21st bit
+ 510      0870
+ 511              	
+ 512 0248 021A     		jrne	continue2		; if 21st bit = 1 then count = 10
+ 513 024a 1360     		add		%r3, 1			; else count(%r3) = count(%r3) + 1
+ 514              	
+ 515              	continue2:
+ 516              		; 	GET_EXP1	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0)
+ 517              	__L0020:
+ 518 024c 012E     		ld.w	%r1,%r0			; 
+ 519 024e 1FC0F173 		xand	%r1,0x7ff		; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱｼ霹ﾀ
+ 520              	
+ 521              		; 	GET_SIGN2	%r0, %r2	; ｻﾘｿﾉ｣ｱﾉ荵讌ﾓ･ﾃ･ﾈ(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ](%r0)
+ 522              	__L0021:
+ 523 0252 022E     		ld.w	%r2,%r0			; 
+ 524 0254 229C     		rl		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 525 0256 1270     		and		%r2,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲｼ霹ﾀ
+ 526              	
+ 527 0258 1268     		cmp		%r2, 1			; ｻﾘｿﾉ｣ｱ･ﾞ･､･ﾊ･ｹ､ｫ｡ｩ
+ 528 025a 031A     		jrne	exp1_no_sign
+ 529 025c E0DF0174 		xoor	%r1, 0xfffff800	; ｻﾘｿﾉ｣ｱﾉ荵豕ﾈﾄ･
+ 530              	exp1_no_sign:
+ 531              	
+ 532              	
+ 533              		; 	GET_TEMP	%r0, %r2	; lshift(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0)
+ 534              	__L0022:
+ 535 0260 022E     		ld.w	%r2,%r0			
+ 536 0262 829C     		rl		%r2,8
+ 537 0264 229C     		rl		%r2,2
+ 538 0266 03C0F273 		xand	%r2,0xff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMPｼ霹ﾀ
+ 539              	
+ 540              	
+ 541              		;sub		%r3, 10		; count = count - 10
+ 542 026a 3222     		add		%r2, %r3		; lshift(%r2) = lshiftｻﾘｿﾉ｣ｱ + count(%r3)
+ 543 026c 212A     		cmp		%r1, %r2
+ 544 026e 2208     		jrgt	normal			; if ｻﾘｿﾉ｣ｱ(%r1) > lshift(%r10) then normal result
+ 545              	
+ 546              		; case: ｻﾘｿﾉ｣ｱ(%r1) <= lshift(%r2)
+ 547 0270 1260     		add		%r2, 1
+ 548 0272 3226     		sub		%r2, %r3		; lshift(%r2) = lshift(%r2) + (11 - count(%r3))
+ 549 0274 1226     		sub		%r2, %r1
+ 550 0276 1260     		add		%r2, 1			; lshift(%r2) = lshift(%r2) - (ｻﾘｿﾉ｣ｱ(%r1) - 1)
+ 551              	
+ 552 0278 00C0626B 		xcmp	%r2, 54		; if lshift(%r2) >= 54 then underflow
+ 553 027c 040C     		jrlt	notunder
+ 554 027e 056C     		ld.w	%r5, 0			; ﾌ皃ﾃﾍ[H](%r5) <- 0
+ 555 0280 381F     		jp.d	end
+ 556 0282 046C     		ld.w	%r4, 0
+ 557              	
+ 558              	notunder:
+GAS LISTING divdf3.s 			page 11
+
+
+ 559              		; {%r5, %r4} >> %r10
+ 560              		;xsrl	%r4, %r10		; shift low 32-bits to the right x bits (shift amount = x)
+ 561              		;xrr	%r5, %r10		; rotate high 32-bits to the right x bits
+ 562              		;xsrl	%r3, %r10		; make a mask for last 32-x bits --> %r3 = 000...111
+ 563              	
+ 564 0284 F36F     		ld.w	%r3, -1			; %r3 = 0xffff ffff
+ 565              		; used in 64-bit variable shifts	; 	SHFTROTSHFT %r2, %r4, %r5, %r3, srl, rr, %r2
+ 566              		; $1 = shift amount
+ 567              		; $2 = 1st input register (shifted)
+ 568              		; $3 = 2nd input register (rotated)
+ 569              		; $4 = 3rd input register (mask --> shifted)
+ 570              		; $5 = shift instruction
+ 571              		; $6 = rotate instruction
+ 572              		; $7 = temp register
+ 573 0286 222E     		ld.w	%r2, %r2		; temp = shift amount
+ 574              	
+ 575              	__L0023:
+ 576 0288 8268     		cmp		%r2, 8		; if temp <= 8 then goto $$2
+ 577 028a 060E     		jrle	__L0024
+ 578              	
+ 579 028c 8488     		srl		%r4, 8		; shift 1st register
+ 580 028e 8598     		rr		%r5, 8		; rotate 2nd register
+ 581 0290 8388     		srl		%r3, 8		; shift 3rd register
+ 582 0292 FB1F     		jp.d	__L0023
+ 583 0294 8264     		sub		%r2, 8		; temp = temp - 8
+ 584              	
+ 585              	__L0024:
+ 586 0296 2489     		srl		%r4, %r2		; last shift
+ 587 0298 2599     		rr		%r5, %r2		; last rotate
+ 588 029a 2389     		srl		%r3, %r2		; last shift
+ 589 029c 383E     		not		%r8, %r3		; flip mask for first x bits --> %r8 = 111...000 (mask)
+ 590 029e 5832     		and		%r8, %r5		; isolate first x bits of %r5
+ 591 02a0 8436     		or		%r4, %r8		; add first x bits of %r5 to %r4
+ 592 02a2 3532     		and		%r5, %r3		; keep the low 32-x bits of %r5
+ 593              	
+ 594              		
+ 595 02a4 016C     		ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 for denormal result
+ 596              		; 	SET_EXP1	%r0, %r1
+ 597              	__L0025:
+ 598 02a6 E0DF0070 		xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+ 599 02aa 1FC0F173 		xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 600 02ae 1036     		or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+ 601              	
+ 602 02b0 171E     		jp	finish
+ 603              		; @@@ 01/03/02 del ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 for denormal result
+ 604              	
+ 605              	normal:	
+ 606              		; case: exp > lshift
+ 607 02b2 2126     		sub		%r1, %r2		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - lshift(%r2)
+ 608              		; 	SET_EXP1	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0) @@@ 01/02/26 add
+ 609              	__L0026:
+ 610 02b4 E0DF0070 		xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+ 611 02b8 1FC0F173 		xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+ 612 02bc 1036     		or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+ 613              	
+ 614              	
+ 615 02be 1368     		cmp		%r3, 1			; if original count(%r3) = 11 then no shifting needed
+GAS LISTING divdf3.s 			page 12
+
+
+ 616 02c0 0718     		jreq	overchk
+ 617              	
+ 618              		; {ﾌ皃ﾃﾍ[H](%r5), ﾌ皃ﾃﾍ[L](%r4)} >> 1 (shift to the right 1 bit)
+ 619 02c2 1488     		srl		%r4, 1			; shift low 32-bits to the right 1 bit
+ 620 02c4 136C     		ld.w	%r3, 1			; mask
+ 621 02c6 5332     		and		%r3, %r5		; get LSB of high 32-bits
+ 622 02c8 1398     		rr		%r3, 1			; rotate to MSB position
+ 623 02ca 3436     		or		%r4, %r3		; add to %r4
+ 624 02cc 1588     		srl		%r5, 1			; shift high 32-bits to the right 1 bit
+ 625              	
+ 626              	overchk:
+ 627 02ce 1FC0F16B 		xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) < 0x7ff then jump to finish
+ 628 02d2 060C     		jrlt	finish
+ 629              	
+ 630              	overflow:
+ 631 02d4 FECF00C0 		xld.w	%r5, 0x7ff00000	; put infinity into result
+ 631      056C
+ 632 02da 0B1F     		jp.d	end
+ 633 02dc 046C     		ld.w	%r4, 0
+ 634              	
+ 635              	finish:
+ 636              		; %r0 = sign, %r1 = exponent, %r5 = mantissa
+ 637              	
+ 638 02de 01C0FFDF 		xand	%r5, 0xfffff		; ﾌ皃ﾃﾍ[H](%r5) = ﾌ皃ﾃﾍ[H](%r5) & 0xfffff
+ 638      F573
+ 639              	
+ 640              		; 	GET_EXP1	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0)
+ 641              	__L0027:
+ 642 02e4 012E     		ld.w	%r1,%r0			; 
+ 643 02e6 1FC0F173 		xand	%r1,0x7ff		; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱｼ霹ﾀ
+ 644              	
+ 645              	
+ 646 02ea 81984198 		xrr		%r1, 12			; position exponent bits to [30:20]
+ 647 02ee 1536     		or		%r5, %r1
+ 648              	
+ 649              	end:
+ 650              		; 	GET_SIGN1	%r0, %r2	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0)
+ 651              	__L0028:
+ 652 02f0 022E     		ld.w	%r2,%r0			; 
+ 653 02f2 129C     		rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+ 654 02f4 1270     		and		%r2,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+ 655              	
+ 656              	
+ 657 02f6 1298     		rr		%r2, 1			; position sign bit to MSB
+ 658 02f8 2536     		or		%r5, %r2		; ﾌ皃ﾃﾍ[H](%r5) = ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1)
+ 659              	
+ 660              		;@@@ 01/01/23 add start hinokuchi
+ 661              		;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+ 662              		;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+ 663              		;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+ 664              		;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+ 665              		;add		%sp, 4
+ 666              		;@@@ 01/01/23 add end
+ 667              	
+ 668 02fa 4302     		popn	%r3				; restore register values
+ 669 02fc 4006     		ret
diff --git a/gcc/config/c33/libgcc/divdf3.s b/gcc/config/c33/libgcc/divdf3.s
new file mode 100644
index 0000000..79bf88e
--- /dev/null
+++ b/gcc/config/c33/libgcc/divdf3.s
@@ -0,0 +1,669 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : divdf3.s
+;*
+;*	Double floating point division function
+;*		input: (%r7, %r6) & (%r9, %r8)
+;*		output: (%r5, %r4)
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/31  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __divdf3
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ｣ｱ(11bit)
+;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/shift/flag
+;	%r3:ｻﾘｿﾉ｣ｲ(11bit)/count/loop
+;	%r4:ﾌ皃ﾃﾍ[L]
+;	%r5:ﾌ皃ﾃﾍ[H]
+;	%r6:ｰｿ｣ｱ[L](ﾈｽｿ)/ｲｾｿﾉ｣ｱ[L]
+;	%r7:ｰｿ｣ｱ[H](ﾈｽｿ)/ｲｾｿﾉ｣ｱ[H]
+;	%r8:ｰｿ｣ｲ[L](ｽｿ)/ｲｾｿﾉ｣ｲ[L]
+;	%r9:ｰｿ｣ｲ[H](ｽｿ)/ｲｾｿﾉ｣ｲ[H]
+;	%r10:implied bit/lshift
+;	%r11:count1/shift/flag/extra
+;	%r12:scan64 ｰｿ｣ｱ/count2
+;	%r13:loop counter/scan64 ｰｿ｣ｲ/shift
+;==============================================
+
+;;macro	SHFTROTSHFT $1, $2, $3, $4, $5, $6, $7
+	; used in 64-bit variable shifts
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+;	ld.w	$7, $1		; temp = shift amount
+
+;$$1:
+;	cmp		$7, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$5		$2, 8		; shift 1st register
+;	$6		$3, 8		; rotate 2nd register
+;	$5		$4, 8		; shift 3rd register
+;	jp.d	$$1
+;	sub		$7, 8		; temp = temp - 8
+
+;$$2:
+;	$5		$2, $7		; last shift
+;	$6		$3, $7		; last rotate
+;	$5		$4, $7		; last shift
+;;endm
+
+__divdf3:
+	pushn	%r3				; save register values
+	;@@@ 01/01/30 add start hinokuchi
+	;sub		%sp, 4
+	;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+	;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+	;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+	;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+	;@@@ 01/01/30 add end
+	ld.w	%r0, 0			; ｶｦﾍｭ･･ｸ･ｹ･ｿ･ｯ･･｢ @@@ 01/02/19
+
+	ld.w	%r1, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7) 
+	rl		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) rotate left 1 bit
+	and		%r1, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1) & 1 
+
+	ld.w	%r2, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ[H](%r9)
+	rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+	and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1
+
+	xor		%r1, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ~ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+	; 	SET_SIGN1	%r0, %r1
+__L0001:
+	xand	%r0,0x7fffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｯ･･｢
+	and		%r1,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ･ｻ･ﾃ･ﾈ
+	rl		%r1,1			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+	ld.w	%r5, 0			; ﾌ皃ﾃﾍ[H](%r5) <- 0
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ[L](%r4) <- 0
+
+	sll		%r7, 1			; ｰｿ｣ｱ[H](%r7) << 1
+	srl		%r7, 1			; ｰｿ｣ｱ[H](%r7) >> 1
+	cmp		%r7, 0			; if ｰｿ｣ｱ[H](%r7) != 0 then check input2
+	jrne	zerochk2
+	cmp		%r6, 0			; if ｰｿ｣ｱ[L](%r6) = 0 then end
+	ext		end@rm
+	jreq	end@rl
+
+zerochk2:
+	sll		%r9, 1			; ｰｿ｣ｲ[H](%r9) << 1
+	srl		%r9, 1			; ｰｿ｣ｲ[H](%r9) >> 1
+	cmp		%r9, 0			; if ｰｿ｣ｲ[H](%r9) != 0 then goto getexp
+	jrne	getexp
+	cmp		%r8, 0			; if ｰｿ｣ｲ[L](%r8) = 0 then overflow
+	ext		overflow@rm
+	jreq	overflow@rl
+
+getexp:
+	ld.w	%r1, %r7		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ[H](%r7)
+	xsrl 	%r1, 20			; ｻﾘｿﾉ｣ｱ(%r1) >> 20
+	; 	SET_EXP1	%r0 ,%r1	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0) <- ｻﾘｿﾉ｣ｱ(%r1) @@@ 01/02/19
+__L0002:
+	xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+	xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+
+
+	xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+	ext		overflow@rm
+	jrge	overflow@rl		; result is overflow
+
+	ld.w	%r3, %r9		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ[H](%r9)
+	xsrl	%r3, 20			; ｻﾘｿﾉ｣ｲ(%r3) >> 20
+	; 	SET_EXP2	%r0 ,%r3	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｲ](%r0) <- ｻﾘｿﾉ｣ｲ(%r3) @@@ 01/02/19
+__L0003:
+	xand	%r0,0xffc007ff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｲ･ｯ･･｢
+	xand	%r3,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	sll		%r3,8			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	sll		%r3,3			; ｻﾘｿﾉ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r3			; ｻﾘｿﾉ｣ｲ･ｻ･ﾃ･ﾈ
+	srl		%r3,8			; ｻﾘｿﾉﾉｵ｢
+	srl		%r3,3			; ｻﾘｿﾉﾉｵ｢
+
+
+	xcmp	%r3, 0x7ff		; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+	ext		end@rm
+	jreq	end@rl			; result is 0 (xxx/NaN = 0)
+
+	; del @@@ 01/02/19 del xld.w	%r10, 0x100000	; implied bit(%r10) <- 0x100000
+
+	; isolate mantissa1
+	xand	%r7, 0xfffff	; clear first 12 bits of %r7
+
+	cmp		%r1, 0
+	jreq.d	count1			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 (denormal)
+	ld.w	%r2, 1			; flag(%r2) = 1
+
+	; case: normal input
+	xoor	%r7, 0x100000	; else add implied bit(0x100000) to mantissa @@@ 01/02/19
+	ld.w	%r2, 0			; flag(%r2) = 0
+	jp.d	getman2
+	ld.w	%r5, 11			; count1(%r5) = 11
+	
+count1:	
+	ld.w	%r4, %r7		; scan64 ｰｿ｣ｱ(%r4) <- ｰｿ｣ｱ[H](%r7)
+	ld.w	%r5, %r6		; scan64 ｰｿ｣ｲ(%r5) <- ｰｿ｣ｱ[L](%r6)
+	; @@@ del 01/02/19 xcall	__scan64
+	; 	SCAN64 	%r4, %r5		; @@@ add 01/02/19		
+	pushn	%r1				; save register values
+
+	ld.w	%r0, 0			; loop counter = 0
+
+	cmp		%r4, 0			; if high 32-bits != 0 then count
+	jrne	__L0004
+
+	; case: $1 = 0
+	ld.w	%r4, %r5			; count low 32-bits instead
+	xld.w	%r0, 32			; loop counter = 32
+
+__L0004:						; count ; of leading 0's
+	scan1	%r1, %r4			; %r1 = count
+	jruge	__L0005				; if count != 8 then goto end
+	cmp		%r0, 24
+	jreq.d	__L0005				; if count = 32 then jump to end
+	add		%r0, 8			; increment loop counter
+	jp.d	__L0004
+	sll		%r4, 8			; shift register to the left 8 bits
+
+__L0005:
+	add		%r1, %r0		; count = count + loop counter
+	ld.w	%r5, %r1			; put result into output register
+
+	popn	%r1				; restore register values
+
+getman2:
+	; isolate mantissa2
+
+	xand	%r9, 0xfffff		; ｰｿ｣ｲ[H] = ｰｿ｣ｲ[H] & 0xfffff clear first 12 bits of %r9
+
+	cmp		%r3, 0			; if ｻﾘｿﾉ｣ｲ(%r3) = 0
+	jreq.d	count2			; then jump to count2
+	ld.w	%r3, %r5		; %r11 = count1
+
+	; case: normal input
+	xoor	%r9, 0x100000	; else add implied bit(0x100000)	@@@ 01/02/19
+	jp.d	cmpcount
+	ld.w	%r4, 11			; count2(%r12) = 11
+
+count2:
+	ld.w	%r4, %r9		; scan64 ｰｿ｣ｱ(%r4) = ｰｿ｣ｲ[H](%r9)
+	ld.w	%r5, %r8		; scan64 ｰｿ｣ｲ(%r5) = ｰｿ｣ｲ[L](%r8)
+	; @@@ del 01/02/19 xcall	__scan64		; %r13 = count2
+	; 	SCAN64 	%r4, %r5		; @@@ add 01/02/19		
+	pushn	%r1				; save register values
+
+	ld.w	%r0, 0			; loop counter = 0
+
+	cmp		%r4, 0			; if high 32-bits != 0 then count
+	jrne	__L0006
+
+	; case: $1 = 0
+	ld.w	%r4, %r5			; count low 32-bits instead
+	xld.w	%r0, 32			; loop counter = 32
+
+__L0006:						; count ; of leading 0's
+	scan1	%r1, %r4			; %r1 = count
+	jruge	__L0007				; if count != 8 then goto end
+	cmp		%r0, 24
+	jreq.d	__L0007				; if count = 32 then jump to end
+	add		%r0, 8			; increment loop counter
+	jp.d	__L0006
+	sll		%r4, 8			; shift register to the left 8 bits
+
+__L0007:
+	add		%r1, %r0		; count = count + loop counter
+	ld.w	%r5, %r1			; put result into output register
+
+	popn	%r1				; restore register values
+
+
+	sub		%r2, 1			; flag(%r2) = flag(%r2) - 1 (0 or -1)
+
+cmpcount:
+	; 	SET_TEMP 	%r0, %r2	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0) <- flag(%r2)
+__L0008:
+	xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+	xand	%r2,0xff			; 1･ﾐ･､･ﾈ mask
+	rr		%r2,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	rr		%r2,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r2			; TEMP･ｻ･ﾃ･ﾈ
+	rl		%r2,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+	rl		%r2,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+
+	cmp		%r3, %r5		; if count1(%r11) <= count2(%r13) 
+	jrle	man2shift		; then goto man2shift
+
+	; case: count1 > count2
+	sub		%r3, %r5		; shift(%r3) = (count1(%r3) - count2(%r5)) - 1
+	sub		%r3, 1
+
+	; {%r7, %r6} << shift
+	;xsll	%r7, %r11		; shift high 32-bits to the left x bits
+	;xrl	%r6, %r11		; rotate low 32-bits to the left x bits
+	;xsll	%r10, %r11		; make a mask for first 32-x bits --> %r10 = 111...000
+
+	ld.w	%r2, -1			; %r2 = 0xffff ffff
+	; used in 64-bit variable shifts	; 	SHFTROTSHFT %r3, %r7, %r6, %r2, sll, rl, %r5			; %r5 = temp
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r5, %r3		; temp = shift amount
+
+__L0009:
+	cmp		%r5, 8		; if temp <= 8 then goto $$2
+	jrle	__L0010
+
+	sll		%r7, 8		; shift 1st register
+	rl		%r6, 8		; rotate 2nd register
+	sll		%r2, 8		; shift 3rd register
+	jp.d	__L0009
+	sub		%r5, 8		; temp = temp - 8
+
+__L0010:
+	sll		%r7, %r5		; last shift
+	rl		%r6, %r5		; last rotate
+	sll		%r2, %r5		; last shift
+	not		%r5, %r2		; flip mask for last x bits --> %r5 = 000...111 (mask)
+	and		%r5, %r6		; isolate last x bits of %r6
+	or		%r7, %r5		; add last x bits of %r6 to %r7
+	and		%r6, %r2		; keep the high 32-x bits of %r6
+
+	add		%r3, 1			; shift(%r3) = shift(%r3) + 1
+	jp.d	divide
+	ld.w	%r2, %r3		; lshift(%r2) = count1 - count2
+
+man2shift:
+	sub		%r5, %r3		; shift(%r5) = count2 - count1 + 1
+	add		%r5, 1
+
+	; {%r9, %r8} << shift
+	;xsll	%r9, %r13		; shift high 32-bits to the left x bits
+	;xrl	%r8, %r13		; rotate low 32-bits to the left x bits
+	;xsll	%r10, %r13		; make a mask for first 32-x bits --> %r10 = 111...000
+
+	ld.w	%r2, -1			; %r2 = 0xffff ffff
+	; used in 64-bit variable shifts	; 	SHFTROTSHFT %r5, %r9, %r8, %r2, sll, rl, %r4		; %r4 = temp
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r4, %r5		; temp = shift amount
+
+__L0011:
+	cmp		%r4, 8		; if temp <= 8 then goto $$2
+	jrle	__L0012
+
+	sll		%r9, 8		; shift 1st register
+	rl		%r8, 8		; rotate 2nd register
+	sll		%r2, 8		; shift 3rd register
+	jp.d	__L0011
+	sub		%r4, 8		; temp = temp - 8
+
+__L0012:
+	sll		%r9, %r4		; last shift
+	rl		%r8, %r4		; last rotate
+	sll		%r2, %r4		; last shift
+	not		%r4, %r2		; flip mask for last x bits --> %r4 = 000...111 (mask)
+	and		%r4, %r8		; isolate last x bits of %r8
+	or		%r9, %r4		; add last x bits of %r8 to %r9
+	and		%r8, %r2		; keep the high 32-x bits of %r8
+
+	not		%r2, %r5		; lshift(%r10) = count1 - count2 (~shift + 1 + 1)
+	add		%r2, 2
+
+divide:
+	; man1 has x leading 0's
+	; man2 has x-1 leading 0's
+	; lshift used to normalize result
+	; %r0 = sign; %r1 = exp1, %r3 = exp2
+	; %r10 = lshift
+	; 	GET_EXP2	%r0, %r3	; ｻﾘｿﾉ｣ｲ(%r3) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｲ](%r0)
+__L0013:
+	ld.w	%r3,%r0			
+	srl		%r3,8
+	srl		%r3,3
+	xand	%r3,0x7ff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｲｼ霹ﾀ
+
+
+	sub		%r1, %r3		; new sisu = sisu1 - sisu2 + bias + flag (0,1,-1)
+
+	xadd	%r1, 0x3ff
+	; 	GET_TEMP	%r0, %r3	; flag(%r3) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0)	@@@ 01/02/19 add
+__L0014:
+	ld.w	%r3,%r0			
+	rl		%r3,8
+	rl		%r3,2
+	xand	%r3,0xff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMPｼ霹ﾀ
+
+	add		%r1, %r3
+
+	xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) >= 0x7ff then goto overflow
+	ext		overflow@rm
+	jrge	overflow@rl
+	xcmp	%r1, -52		; if ｻﾘｿﾉ｣ｱ(%r1) <= -52 then underflow
+	ext		end@rm
+	jrle	end@rl
+
+	; DIVIDE CODE STARTS HERE
+	ld.w	%r3, %r1	
+	rl		%r3,1			; ｻﾘｿﾉ｣ｱﾉ荵讌ﾓ･ﾃ･ﾈﾊﾝﾂｸ
+	; 	SET_SIGN2	%r0, %r3	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ](%r0) <- ｻﾘｿﾉ｣ｱﾉ荵讌ﾓ･ﾃ･ﾈ
+__L0015:
+	xand	%r0,0xbfffffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｯ･･｢
+	and		%r3,1			; 1･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	rr		%r3,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･｡ｼ･ﾆ｡ｼ･ﾈ
+	or		%r0,%r3			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ･ｻ･ﾃ･ﾈ
+	rl		%r3,2			; ﾉ荵讌ﾓ･ﾃ･ﾈﾉｵ｢
+
+	; 	SET_EXP1	%r0, %r1	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0) <- ｻﾘｿﾉ｣ｱ(%r1) @@@ 01/02/19 add
+__L0016:
+	xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+	xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+
+	; 	SET_TEMP	%r0, %r2	; ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0) <- lshift(%r2) @@@ 01/02/19 add
+__L0017:
+	xand	%r0,0xc03fffff	; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMP･ｯ･･｢
+	xand	%r2,0xff			; 1･ﾐ･､･ﾈ mask
+	rr		%r2,8			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	rr		%r2,2			; TEMP､ﾎ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ､ﾋ･ｷ･ﾕ･ﾈ
+	or		%r0,%r2			; TEMP･ｻ･ﾃ･ﾈ
+	rl		%r2,8			; ﾀﾟﾄﾃﾍﾉｵ｢
+	rl		%r2,2			; ﾀﾟﾄﾃﾍﾉｵ｢
+
+
+	; make a mask for first 31 bits --> %r2 = 111...110
+	; @@@ del 01/02/19 ld.w	%r2, -2			; %r2 = 0xffff fffe
+	ld.w	%r3, 0			; loop(%r3) <- 0
+	ld.w	%r1, 0			; flag(%r1) = 0
+	ld.w	%r4, 0			; @@@ 01/02/26 add
+	ld.w	%r5, 0			; @@@ 01/02/26 add
+
+
+loop:
+	add		%r3, 1			; loop(%r3) = loop(%r3) + 1
+	xcmp	%r3, 55			; if loop(%r3) >= 55 then exit divide loop
+	jrge	normalize
+
+	; {result1, result2} << 1
+	sll		%r5, 1			; shift high 32-bits to the left 1 bit
+	rl		%r4, 1			; rotate low 32-bits to the left 1 bit
+	ld.w	%r2, 1			; mask for last bit (LSB)
+	and		%r2, %r4		; isolate last bit of %r8
+	or		%r5, %r2		; add last bit of %r8 to %r9
+	xand	%r4, -2			; keep the high 31 bits of %r8
+	
+	scan1	%r1, %r7		; is there a leading 1? (0 = yes)
+
+	; {ｲｾｿﾉ｣ｱ[H](%r7), ｲｾｿﾉ｣ｱ[L](%r6)} << 1
+	sll		%r7, 1			; shift high 32-bits to the left 1 bit
+	rl		%r6, 1			; rotate low 32-bits to the left 1 bit
+	ld.w	%r2, 1			; mask for last bit (LSB)
+	and		%r2, %r6		; isolate last bit of %r8
+	or		%r7, %r2		; add last bit of %r8 to %r9
+	xand	%r6, -2			; keep the high 31 bits of %r8
+	cmp		%r1, 0			; if a leading 1 was shifted out then subtract
+	jreq	subtract
+
+	cmp		%r7, %r9
+	jrugt	subtract		; if ｲｾｿﾉ｣ｱ[H](%r7) > ｲｾｿﾉ｣ｲ[H](%r9) then subtract
+	jrult	loop			; if ｲｾｿﾉ｣ｱ[H](%r7) < ｲｾｿﾉ｣ｲ[H](%r9) then goto loop
+
+	; case: man1 = man2 (%r7 = %r9)
+	cmp		%r6, %r8		; if ｲｾｿﾉ｣ｱ[L](%r6) < ｲｾｿﾉ｣ｲ[L](%r8) then goto loop
+	jrult	loop
+
+subtract:
+	sub		%r6, %r8		; ｲｾｿﾉ｣ｱ[L](%r6) = ｲｾｿﾉ｣ｱ[L](%r6) - ｲｾｿﾉ｣ｲ[L](%r8)
+	sbc		%r7, %r9		; ｲｾｿﾉ｣ｱ[H](%r7) = ｲｾｿﾉ｣ｱ[H](%r7) - ｲｾｿﾉ｣ｲ[H](%r9) - carry
+	add		%r4, 1			; ﾌ皃ﾃﾍ[L](%r4) = ﾌ皃ﾃﾍ[L](%r4) + 1 
+
+	cmp		%r7, 0			; if {ｲｾｿﾉ｣ｱ[H](%r7), ｲｾｿﾉ｣ｱ[L](%r6) } = 0 then exit
+	jrne	loop
+	cmp		%r6, 0
+	jrne	loop
+
+	xcmp	%r3, 54			; if loop(%r3) >= 54 then exit divide loop
+	jrge	normalize
+
+	; fill in the extra 0's needed in the result
+	xld.w	%r1, 54
+	sub		%r1, %r3		; extra(%r1) = 54 - loop(%r3)	
+	xcmp	%r1, 32			; if extra(%r1) < 32 then goto shift
+	jrlt	xshift
+
+	; case: extra iterations >= 32
+	ld.w	%r5, %r4		; ﾌ皃ﾃﾍ[H](%r5) <- ﾌ皃ﾃﾍ[L](%r4)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ[L](%r4) <- 0
+	sub		%r1, 32			; extra(%r1) = extra(%r1) - 32
+	
+xshift:
+	; {%r5, %r4} << extra
+	;xsll	%r5, %r11		; shift high 32-bits to the left x bits
+	;xrl	%r4, %r11		; rotate low 32-bits to the left x bits
+	;xsll	%r3, %r11		; make a mask for first 32-x bits --> %r3 = 111...000
+
+	ld.w	%r3, -1			; %r3 = 0xffff ffff
+	; used in 64-bit variable shifts	; 	SHFTROTSHFT %r1, %r5, %r4, %r3, sll, rl, %r1
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r1, %r1		; temp = shift amount
+
+__L0018:
+	cmp		%r1, 8		; if temp <= 8 then goto $$2
+	jrle	__L0019
+
+	sll		%r5, 8		; shift 1st register
+	rl		%r4, 8		; rotate 2nd register
+	sll		%r3, 8		; shift 3rd register
+	jp.d	__L0018
+	sub		%r1, 8		; temp = temp - 8
+
+__L0019:
+	sll		%r5, %r1		; last shift
+	rl		%r4, %r1		; last rotate
+	sll		%r3, %r1		; last shift
+	not		%r2, %r3		; flip mask for last x bits --> %r2 = 000...111 (mask)
+	and		%r2, %r4		; isolate last x bits of %r6
+	or		%r5, %r2		; add last x bits of %r6 to %r7
+	and		%r4, %r3		; keep the high 32-x bits of %r6
+
+	; DIVIDE CODE ENDS HERE
+
+normalize:
+	; %r0 = result sign, %r1 = result exponent
+	; %r10 = lshift, (%r5, %r4) = result
+	
+	;ld.w	%r3, 10			; count = 10
+	ld.w	%r3, 0			; count(%r3) <- 0
+
+	ld.w	%r8, %r5
+	xand	%r8, 0x200000	; check 21st bit
+
+	jrne	continue2		; if 21st bit = 1 then count = 10
+	add		%r3, 1			; else count(%r3) = count(%r3) + 1
+
+continue2:
+	; 	GET_EXP1	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0)
+__L0020:
+	ld.w	%r1,%r0			; 
+	xand	%r1,0x7ff		; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱｼ霹ﾀ
+
+	; 	GET_SIGN2	%r0, %r2	; ｻﾘｿﾉ｣ｱﾉ荵讌ﾓ･ﾃ･ﾈ(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ](%r0)
+__L0021:
+	ld.w	%r2,%r0			; 
+	rl		%r2,2			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+	and		%r2,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲｼ霹ﾀ
+
+	cmp		%r2, 1			; ｻﾘｿﾉ｣ｱ･ﾞ･､･ﾊ･ｹ､ｫ｡ｩ
+	jrne	exp1_no_sign
+	xoor	%r1, 0xfffff800	; ｻﾘｿﾉ｣ｱﾉ荵豕ﾈﾄ･
+exp1_no_sign:
+
+
+	; 	GET_TEMP	%r0, %r2	; lshift(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[TEMP](%r0)
+__L0022:
+	ld.w	%r2,%r0			
+	rl		%r2,8
+	rl		%r2,2
+	xand	%r2,0xff			; ｶｦﾍｭ･･ｸ･ｹ･ｿ TEMPｼ霹ﾀ
+
+
+	;sub		%r3, 10		; count = count - 10
+	add		%r2, %r3		; lshift(%r2) = lshiftｻﾘｿﾉ｣ｱ + count(%r3)
+	cmp		%r1, %r2
+	jrgt	normal			; if ｻﾘｿﾉ｣ｱ(%r1) > lshift(%r10) then normal result
+
+	; case: ｻﾘｿﾉ｣ｱ(%r1) <= lshift(%r2)
+	add		%r2, 1
+	sub		%r2, %r3		; lshift(%r2) = lshift(%r2) + (11 - count(%r3))
+	sub		%r2, %r1
+	add		%r2, 1			; lshift(%r2) = lshift(%r2) - (ｻﾘｿﾉ｣ｱ(%r1) - 1)
+
+	xcmp	%r2, 54		; if lshift(%r2) >= 54 then underflow
+	jrlt	notunder
+	ld.w	%r5, 0			; ﾌ皃ﾃﾍ[H](%r5) <- 0
+	jp.d	end
+	ld.w	%r4, 0
+
+notunder:
+	; {%r5, %r4} >> %r10
+	;xsrl	%r4, %r10		; shift low 32-bits to the right x bits (shift amount = x)
+	;xrr	%r5, %r10		; rotate high 32-bits to the right x bits
+	;xsrl	%r3, %r10		; make a mask for last 32-x bits --> %r3 = 000...111
+
+	ld.w	%r3, -1			; %r3 = 0xffff ffff
+	; used in 64-bit variable shifts	; 	SHFTROTSHFT %r2, %r4, %r5, %r3, srl, rr, %r2
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r2, %r2		; temp = shift amount
+
+__L0023:
+	cmp		%r2, 8		; if temp <= 8 then goto $$2
+	jrle	__L0024
+
+	srl		%r4, 8		; shift 1st register
+	rr		%r5, 8		; rotate 2nd register
+	srl		%r3, 8		; shift 3rd register
+	jp.d	__L0023
+	sub		%r2, 8		; temp = temp - 8
+
+__L0024:
+	srl		%r4, %r2		; last shift
+	rr		%r5, %r2		; last rotate
+	srl		%r3, %r2		; last shift
+	not		%r8, %r3		; flip mask for first x bits --> %r8 = 111...000 (mask)
+	and		%r8, %r5		; isolate first x bits of %r5
+	or		%r4, %r8		; add first x bits of %r5 to %r4
+	and		%r5, %r3		; keep the low 32-x bits of %r5
+
+	
+	ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 for denormal result
+	; 	SET_EXP1	%r0, %r1
+__L0025:
+	xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+	xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+
+	jp	finish
+	; @@@ 01/03/02 del ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 for denormal result
+
+normal:	
+	; case: exp > lshift
+	sub		%r1, %r2		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - lshift(%r2)
+	; 	SET_EXP1	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0) @@@ 01/02/26 add
+__L0026:
+	xand	%r0,0xfffff800	; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱ･ｯ･･｢
+	xand	%r1,0x7ff		; ｣ｱ｣ｱ･ﾓ･ﾃ･ﾈ･ﾞ･ｹ･ｯ
+	or		%r0,%r1			; ｻﾘｿﾉ｣ｱ･ｻ･ﾃ･ﾈ
+
+
+	cmp		%r3, 1			; if original count(%r3) = 11 then no shifting needed
+	jreq	overchk
+
+	; {ﾌ皃ﾃﾍ[H](%r5), ﾌ皃ﾃﾍ[L](%r4)} >> 1 (shift to the right 1 bit)
+	srl		%r4, 1			; shift low 32-bits to the right 1 bit
+	ld.w	%r3, 1			; mask
+	and		%r3, %r5		; get LSB of high 32-bits
+	rr		%r3, 1			; rotate to MSB position
+	or		%r4, %r3		; add to %r4
+	srl		%r5, 1			; shift high 32-bits to the right 1 bit
+
+overchk:
+	xcmp	%r1, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r1) < 0x7ff then jump to finish
+	jrlt	finish
+
+overflow:
+	xld.w	%r5, 0x7ff00000	; put infinity into result
+	jp.d	end
+	ld.w	%r4, 0
+
+finish:
+	; %r0 = sign, %r1 = exponent, %r5 = mantissa
+
+	xand	%r5, 0xfffff		; ﾌ皃ﾃﾍ[H](%r5) = ﾌ皃ﾃﾍ[H](%r5) & 0xfffff
+
+	; 	GET_EXP1	%r0, %r1	; ｻﾘｿﾉ｣ｱ(%r1) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ｻﾘｿﾉ｣ｱ](%r0)
+__L0027:
+	ld.w	%r1,%r0			; 
+	xand	%r1,0x7ff		; ｶｦﾍｭ･･ｸ･ｹ･ｿ ｻﾘｿﾉ｣ｱｼ霹ﾀ
+
+
+	xrr		%r1, 12			; position exponent bits to [30:20]
+	or		%r5, %r1
+
+end:
+	; 	GET_SIGN1	%r0, %r2	; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r2) <- ｶｦﾍｭ･･ｸ･ｹ･ｿ[ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ](%r0)
+__L0028:
+	ld.w	%r2,%r0			; 
+	rl		%r2,1			; ﾉ荵讌ﾓ･ﾃ･ﾈ･｡ｼ･ﾆ｡ｼ･ﾈ
+	and		%r2,1			; ｶｦﾍｭ･･ｸ･ｹ･ｿ ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱｼ霹ﾀ
+
+
+	rr		%r2, 1			; position sign bit to MSB
+	or		%r5, %r2		; ﾌ皃ﾃﾍ[H](%r5) = ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r1)
+
+	;@@@ 01/01/23 add start hinokuchi
+	;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+	;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+	;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+	;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+	;add		%sp, 4
+	;@@@ 01/01/23 add end
+
+	popn	%r3				; restore register values
+	ret
diff --git a/gcc/config/c33/libgcc/divhi3.lst b/gcc/config/c33/libgcc/divhi3.lst
new file mode 100644
index 0000000..eb17ef0
--- /dev/null
+++ b/gcc/config/c33/libgcc/divhi3.lst
@@ -0,0 +1,118 @@
+GAS LISTING divhi3.s 			page 1
+
+
+   1              	;
+   2              	;	Copyright (C) SEIKO EPSON CORP. 1996
+   3              	;
+   4              	;	Filename : divhi3.s
+   5              	;	Function :
+   6              	;	  This module defines the functions
+   7              	;		that emulate signed and unsigned integer division.
+   8              	;	Revision :
+   9              	;	  10/18/1996	ESD T.Katahira		start			    */
+  10              	;	  06/11/2002	watanabe		for divhi3
+  11              	;
+  12              	;
+  13              	;	Function :	__divhi3
+  14              	;	Input :		%r6	--- dividend
+  15              	;			%r7	--- divisor
+  16              	;	Output :	%r4	--- quotient
+  17              	;	Function :	calculate signed integer division
+  18              	
+  19              	
+  20              		.section .text
+  21              		.align 1
+  22              		.global	__divhi3
+  23              	__divhi3:
+  24 0000 868C868C 		xsll	%r6, 16
+  25 0004 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  26 0006 708B     		div0s	%r7		; initializer of signed division
+  27              	;ifdef	FAST
+  28 0008 7093     		div1	%r7		; execute division ;1
+  29 000a 7093     		div1	%r7		; execute division ;2
+  30 000c 7093     		div1	%r7		; execute division ;3
+  31 000e 7093     		div1	%r7		; execute division ;4
+  32 0010 7093     		div1	%r7		; execute division ;5
+  33 0012 7093     		div1	%r7		; execute division ;6
+  34 0014 7093     		div1	%r7		; execute division ;7
+  35 0016 7093     		div1	%r7		; execute division ;8
+  36 0018 7093     		div1	%r7		; execute division ;9
+  37 001a 7093     		div1	%r7		; execute division ;10
+  38 001c 7093     		div1	%r7		; execute division ;11
+  39 001e 7093     		div1	%r7		; execute division ;12
+  40 0020 7093     		div1	%r7		; execute division ;13
+  41 0022 7093     		div1	%r7		; execute division ;14
+  42 0024 7093     		div1	%r7		; execute division ;15
+  43 0026 7093     		div1	%r7		; execute division ;16
+  44              	;else
+  45              	;	ld.w	%r8,0x2		; set loop counter (N = 2)
+  46              	;	ld.w	%r9,%psr	; save flag register
+  47              	;__divhi3_loop_start:	
+  48              	;	div1	%r7		; execute division ;1
+  49              	;	div1	%r7		; execute division ;2
+  50              	;	div1	%r7		; execute division ;3
+  51              	;	div1	%r7		; execute division ;4
+  52              	;	div1	%r7		; execute division ;5
+  53              	;	div1	%r7		; execute division ;6
+  54              	;	div1	%r7		; execute division ;7
+  55              	;	div1	%r7		; execute division ;8
+  56              	;	sub	%r8,0x1		; decrement loop counter
+  57              	;	jrne.d	__divhi3_loop_start	; if (loop counter != 0) goto loop top
+GAS LISTING divhi3.s 			page 2
+
+
+  58              	;	ld.w	%psr,%r9	; restore flag register (delayed slot)
+  59              	;endif
+  60 0028 7097     		div2s	%r7		; post divistion process ;1
+  61 002a 009B     		div3s			; post divistion process ;2
+  62 002c 4007     		ret.d			; return to the caller (use delayed return)
+  63 002e 24A4     		ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+  64              	
+  65              	
+  66              	;	Function :	__udivhi3
+  67              	;	Input :		%r6	--- dividend
+  68              	;			%r7	--- divisor
+  69              	;	Output :	%r4	--- quotient
+  70              	;	Function :	calculate unsigned integer division
+  71              	
+  72              		.section .text
+  73              		.align 1
+  74              		.global	__udivhi3
+  75              	__udivhi3:
+  76 0030 868C868C 		xsll	%r6, 16
+  77 0034 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  78 0036 708F     		div0u	%r7		; initializer of signed division
+  79              	;ifdef	FAST
+  80 0038 7093     		div1	%r7		; execute division ;1
+  81 003a 7093     		div1	%r7		; execute division ;2
+  82 003c 7093     		div1	%r7		; execute division ;3
+  83 003e 7093     		div1	%r7		; execute division ;4
+  84 0040 7093     		div1	%r7		; execute division ;5
+  85 0042 7093     		div1	%r7		; execute division ;6
+  86 0044 7093     		div1	%r7		; execute division ;7
+  87 0046 7093     		div1	%r7		; execute division ;8
+  88 0048 7093     		div1	%r7		; execute division ;9
+  89 004a 7093     		div1	%r7		; execute division ;10
+  90 004c 7093     		div1	%r7		; execute division ;11
+  91 004e 7093     		div1	%r7		; execute division ;12
+  92 0050 7093     		div1	%r7		; execute division ;13
+  93 0052 7093     		div1	%r7		; execute division ;14
+  94 0054 7093     		div1	%r7		; execute division ;15
+  95 0056 7093     		div1	%r7		; execute division ;16
+  96              	;else
+  97              	;	ld.w	%r8,0x2		; set loop counter (N = 2)
+  98              	;__udivhi3_loop_start:	
+  99              	;	div1	%r7		; execute division ;1
+ 100              	;	div1	%r7		; execute division ;2
+ 101              	;	div1	%r7		; execute division ;3
+ 102              	;	div1	%r7		; execute division ;4
+ 103              	;	div1	%r7		; execute division ;5
+ 104              	;	div1	%r7		; execute division ;6
+ 105              	;	div1	%r7		; execute division ;7
+ 106              	;	div1	%r7		; execute division ;8
+ 107              	;	sub	%r8,0x1		; decrement loop counter
+ 108              	;	jrne	__udivhi3_loop_start	; if (loop counter != 0) goto loop top
+ 109              	;endif
+ 110 0058 4007     		ret.d			; return to the caller (use delayed return)
+ 111 005a 24A4     		ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+ 112              	
diff --git a/gcc/config/c33/libgcc/divhi3.s b/gcc/config/c33/libgcc/divhi3.s
new file mode 100644
index 0000000..6928db9
--- /dev/null
+++ b/gcc/config/c33/libgcc/divhi3.s
@@ -0,0 +1,112 @@
+;
+;	Copyright (C) SEIKO EPSON CORP. 1996
+;
+;	Filename : divhi3.s
+;	Function :
+;	  This module defines the functions
+;		that emulate signed and unsigned integer division.
+;	Revision :
+;	  10/18/1996	ESD T.Katahira		start			    */
+;	  06/11/2002	watanabe		for divhi3
+;
+;
+;	Function :	__divhi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- quotient
+;	Function :	calculate signed integer division
+
+
+	.section .text
+	.align 1
+	.global	__divhi3
+__divhi3:
+	xsll	%r6, 16
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0s	%r7		; initializer of signed division
+;ifdef	FAST
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	div1	%r7		; execute division ;9
+	div1	%r7		; execute division ;10
+	div1	%r7		; execute division ;11
+	div1	%r7		; execute division ;12
+	div1	%r7		; execute division ;13
+	div1	%r7		; execute division ;14
+	div1	%r7		; execute division ;15
+	div1	%r7		; execute division ;16
+;else
+;	ld.w	%r8,0x2		; set loop counter (N = 2)
+;	ld.w	%r9,%psr	; save flag register
+;__divhi3_loop_start:	
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	sub	%r8,0x1		; decrement loop counter
+;	jrne.d	__divhi3_loop_start	; if (loop counter != 0) goto loop top
+;	ld.w	%psr,%r9	; restore flag register (delayed slot)
+;endif
+	div2s	%r7		; post divistion process ;1
+	div3s			; post divistion process ;2
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+
+
+;	Function :	__udivhi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- quotient
+;	Function :	calculate unsigned integer division
+
+	.section .text
+	.align 1
+	.global	__udivhi3
+__udivhi3:
+	xsll	%r6, 16
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0u	%r7		; initializer of signed division
+;ifdef	FAST
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	div1	%r7		; execute division ;9
+	div1	%r7		; execute division ;10
+	div1	%r7		; execute division ;11
+	div1	%r7		; execute division ;12
+	div1	%r7		; execute division ;13
+	div1	%r7		; execute division ;14
+	div1	%r7		; execute division ;15
+	div1	%r7		; execute division ;16
+;else
+;	ld.w	%r8,0x2		; set loop counter (N = 2)
+;__udivhi3_loop_start:	
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	sub	%r8,0x1		; decrement loop counter
+;	jrne	__udivhi3_loop_start	; if (loop counter != 0) goto loop top
+;endif
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+
diff --git a/gcc/config/c33/libgcc/divsf3.lst b/gcc/config/c33/libgcc/divsf3.lst
new file mode 100644
index 0000000..86112e5
--- /dev/null
+++ b/gcc/config/c33/libgcc/divsf3.lst
@@ -0,0 +1,413 @@
+GAS LISTING divsf3.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : divsf3.s
+   6              	;*
+   7              	;*	Single floating point division function
+   8              	;*		input: %r6, %r7
+   9              	;*		output: %r4
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/18  O.Hinokuchi
+  13              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  14              	;*
+  15              	;*****************************************
+  16              	
+  17              	.section .text
+  18              	.align 1
+  19              	.global __divsf3
+  20              	
+  21              	;==============================================
+  22              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  23              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+  24              	;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+  25              	;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/shift/flag
+  26              	;	%r3:ｻﾘｿﾉ｣ｲ(8bit)/count
+  27              	;	%r4:ﾌ皃ﾃﾍ(float)
+  28              	;	%r5:temp
+  29              	;	%r6:ｰｿ｣ｱ(ﾈｽｿ)
+  30              	;	%r7:ｰｿ｣ｲ(ｽｿ)
+  31              	;	%r8:mask
+  32              	;	%r9:overflow value
+  33              	;	%r10:implied bit/lshift
+  34              	;	%r11:count1/shift
+  35              	;	%r12:temp/count2
+  36              	;	%r13:loop counter/temp/shift
+  37              	;==============================================
+  38              	
+  39              	
+  40              	;;macro	VARSHIFT $1, $2, $3
+  41              		; used in 32-bit variable shifting
+  42              		; $1 = input register
+  43              		; $2 = shift amount
+  44              		; $3 = shift instruction
+  45              	;$$1:
+  46              	;	cmp		$2, 8		; if temp <= 8 then goto $$2
+  47              	;	jrle	$$2
+  48              	
+  49              	;	$3		$1, 8		; shift input register 8 bits
+  50              	;	jp.d	$$1
+  51              	;	sub		$2, 8		; temp = temp - 8
+  52              	
+  53              	;$$2:
+  54              	;	$3		$1, $2		; last shift
+  55              	;;endm
+  56              	
+  57              	__divsf3:
+GAS LISTING divsf3.s 			page 2
+
+
+  58 0000 0302     		pushn	%r3				; save register values
+  59              		;@@@ 01/01/30 add start hinokuchi
+  60              		;sub		%sp, 4
+  61              		;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+  62              		;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+  63              		;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+  64              		;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+  65              		;@@@ 01/01/30 add end
+  66              	
+  67              		;@@@ 01/02/15 del xld.w	%r9, 0xff		; set overflow comparison value
+  68              	
+  69 0002 602E     		ld.w	%r0, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ(%r6) 
+  70 0004 109C     		rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+  71 0006 1070     		and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+  72              	
+  73 0008 722E     		ld.w	%r2, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ(%r7)
+  74 000a 129C     		rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+  75 000c 1270     		and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1
+  76              	
+  77 000e 203A     		xor		%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ~ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+  78 0010 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+  79              	
+  80 0012 168C     		sll		%r6, 1			; ｰｿ｣ｱ(%r6) << 1  clear MSB
+  81 0014 1688     		srl		%r6, 1 			; ｰｿ｣ｱ(%r6) >> 1
+  82 0016 0668     		cmp		%r6, 0
+  83 0018 00C0     		ext		end@rm
+  84 001a 9A18     		jreq	end@rl			; if ｰｿ｣ｱ(%r6) = 0 then end
+  85              	
+  86 001c 0768     		cmp		%r7, 0
+  87 001e 178C     		sll		%r7, 1			; ｰｿ｣ｲ(%r7) << 1 clear
+  88 0020 1788     		srl		%r7, 1			; ｰｿ｣ｲ(%r7) >> 1
+  89 0022 00C0     		ext		overflow@rm
+  90 0024 8B18     		jreq	overflow@rl		; if ｰｿ｣ｲ(%r7) = 0 then overflow
+  91              	
+  92 0026 612E     		ld.w	%r1, %r6		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ(%r6)
+  93 0028 81888188 		xsrl 	%r1, 23			; ｻﾘｿﾉ｣ｱ(%r1) >> 23
+  93      7188
+  94              	
+  95              		;@@@ 01/02/15 del cmp		%r1, %r9		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+  96 002e 03C0F16B 		xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+  97 0032 00C0     		ext		overflow@rm
+  98 0034 830A     		jrge	overflow@rl		; result is overflow
+  99              	
+ 100 0036 732E     		ld.w	%r3, %r7		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ(%r7)
+ 101 0038 83888388 		xsrl	%r3, 23			; ｻﾘｿﾉ｣ｲ(%r3) >> 23
+ 101      7388
+ 102              	
+ 103              		;@@@ 01/02/15 del cmp		%r3, %r9		; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+ 104 003e 03C0F36B 		xcmp		%r3, 0xff	; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+ 105              	
+ 106 0042 00C0     		ext		end@rm
+ 107 0044 8518     		jreq	end@rl			; result is 0 (xxx/NaN = 0)
+ 108              	
+ 109              		;@@@ 01/02/15 del xld.w	%r8, 0x7fffff	; mask(%r8) <- 0x7fffff  set mask for isolating mantissa
+ 110              		;@@@ 01/02/15 del xld.w	%r10, 0x800000	; implied bit(%r10)
+ 111 0046 0FC0FFDF 		xld.w	%r5, 0x7fffff	; mask(%r8) <- 0x7fffff @@@ 01/02/16 add
+ 111      F56F
+GAS LISTING divsf3.s 			page 3
+
+
+ 112 004c 126C     		ld.w	%r2, 1			; flag(%r2) = 1
+ 113              		;@@@ 01/02/15 del ld.w	%r13, 0			; loop counter(%r13)  <- 0
+ 114 004e 086C     		ld.w	%r8, 0			; loop counter(%r8)  <- 0
+ 115              	
+ 116              		; isolate mantissa1
+ 117              		;and		%r6, %r8	; line 62
+ 118 0050 0168     		cmp		%r1, 0			; 
+ 119 0052 0819     		jreq.d	count1			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 (denormal)
+ 120              		;@@@ 01/02/15 del and		%r6, %r8		; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & mask(%r8)  clear first 9 bits of %r
+ 121 0054 5632     		and		%r6, %r5 		; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & 0x7fffff  clear first 9 bits of %r6
+ 122              	
+ 123              		; case: normal input
+ 124              		;@@@ 01/02/15 del or		%r6, %r10		; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & implied bit(%r10)   else add implie
+ 125 0056 10C000C0 		xoor	%r6, 0x800000	; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & implied bit(0x800000)   else add implied bit to m
+ 125      0674
+ 126 005c 026C     		ld.w	%r2, 0			; flag(%r2) <- 0
+ 127 005e 081F     		jp.d	getman2
+ 128              		;@@@ 01/02/15 del ld.w	%r11, 8			; count1(%r11) <- 8
+ 129 0060 896C     		ld.w	%r9, 8			; count1(%r9) <- 8
+ 130              		
+ 131              	count1:	
+ 132              		;@@@ 01/02/15 del ld.w	%r12, %r6		; temp(%r12) <- ｰｿ｣ｱ(%r6)
+ 133 0062 642E     		ld.w	%r4, %r6		; temp(%r4) <- ｰｿ｣ｱ(%r6)
+ 134              	
+ 135              	loop1:
+ 136              		;@@@ 01/02/15 del scan1	%r11, %r12		; %r11 = count1
+ 137 0064 498E     		scan1	%r9, %r4		; %r9 = count1
+ 138 0066 0412     		jruge	getman2			; if count1 !=8 then goto getman2
+ 139              		;@@@ 01/02/15 del add		%r13, 8			; loop counter(%r13) = loop counter(%r13) + 8
+ 140 0068 8860     		add		%r8, 8			; loop counter(%r8) = loop counter(%r8) + 8
+ 141 006a FD1F     		jp.d	loop1
+ 142              		;@@@ 01/02/15 del sll		%r12, 8			; temp(%r12) << 8  shift register to the left 8 bits
+ 143 006c 848C     		sll		%r4, 8			; temp(%r4) << 8  shift register to the left 8 bits
+ 144              			
+ 145              	getman2:
+ 146              		;@@@ 01/02/15 del add		%r11, %r13		; count1(%r11) = count1(%r11) + loop counter(%r13)
+ 147 006e 8922     		add		%r9, %r8		; count1(%r9) = count1(%r8) + loop counter(%r13)
+ 148              		;@@@ 01/02/15 del ld.w	%r13, 0			; loop counter(%r13) = 0
+ 149 0070 086C     		ld.w	%r8, 0			; loop counter(%r8) = 0
+ 150              	
+ 151              		; isolate mantissa2
+ 152              		;and	%r7, %r8		; line 85
+ 153 0072 0368     		cmp		%r3, 0
+ 154 0074 0719     		jreq.d	count2			; if ｻﾘｿﾉ｣ｲ(%r3) = 0 then jump to count2
+ 155              		;@@@ 01/02/15 del and		%r7, %r8		; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) & mask(%r8) clear first 9 bits of %r7
+ 156 0076 5732     		and		%r7, %r5		; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) & mask(0x7fffff) clear first 9 bits of %r7
+ 157              		;@@@ 01/02/15 del or		%r7, %r10		; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) | implied bit(%r10)  else add implied
+ 158 0078 10C000C0 		xoor	%r7, 0x800000	; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) | implied bit(0x800000)  else add implied bit
+ 158      0774
+ 159 007e 091F     		jp.d	cmpcount
+ 160              		;@@@ 01/02/15 del ld.w	%r12, 8			; count2(%r12) <- 8
+ 161 0080 846C     		ld.w	%r4, 8			; count2(%r12) <- 8
+ 162              	
+ 163              	count2:
+ 164 0082 752E     		ld.w	%r5, %r7		; temp(%r5) <- ｲｾｿ｣ｲ(%r7) man2
+ 165 0084 1264     		sub		%r2, 1			; flag(%r2) = flag(%r2) - 1 (0 or -1)
+ 166              	
+GAS LISTING divsf3.s 			page 4
+
+
+ 167              	loop2:
+ 168              		;@@@ 01/02/15 del scan1	%r12, %r5		; %r12 = count2
+ 169 0086 548E     		scan1	%r4, %r5		; %r4 = count2
+ 170              	
+ 171 0088 0412     		jruge	cmpcount		; if count2 !=8 then goto cmpcount
+ 172 008a 8860     		add		%r8, 8			; loop counter(%r8) = loop counter(%r8) + 8
+ 173 008c FD1F     		jp.d	loop2
+ 174 008e 858C     		sll		%r5, 8			; temp(%r5) << 8 shift register to the left 8 bits	
+ 175              	
+ 176              	cmpcount:
+ 177 0090 8422     		add		%r4, %r8		; count2(%r4) = count2(%r4) + loop counter(%r8)
+ 178              	
+ 179 0092 492A     		cmp		%r9, %r4		; if count1(%r9) <= count2(%r4) then goto man2 shift
+ 180 0094 0D0E     		jrle	man2shift
+ 181              	
+ 182              		; case: count1 > count2
+ 183 0096 4926     		sub		%r9, %r4		; shift(%r9) = count1(%r9) - count2(%r4)
+ 184 0098 1964     		sub		%r9, 1			; shift(%r9) = shift(%r9) - 1
+ 185              	
+ 186              		;xsll	%r6, %r11		; shift man1
+ 187 009a 982E     		ld.w	%r8, %r9		; temp(%r8) <- shift(%r9)
+ 188              		; used in 32-bit variable shifting	; 	VARSHIFT %r6, %r9, sll
+ 189              		; $1 = input register
+ 190              		; $2 = shift amount
+ 191              		; $3 = shift instruction
+ 192              	__L0001:
+ 193 009c 8968     		cmp		%r9, 8		; if temp <= 8 then goto $$2
+ 194 009e 040E     		jrle	__L0002
+ 195              	
+ 196 00a0 868C     		sll		%r6, 8		; shift input register 8 bits
+ 197 00a2 FD1F     		jp.d	__L0001
+ 198 00a4 8964     		sub		%r9, 8		; temp = temp - 8
+ 199              	
+ 200              	__L0002:
+ 201 00a6 968D     		sll		%r6, %r9		; last shift
+ 202              	
+ 203 00a8 1860     		add		%r8, 1			; shift(%r8) = shift(%r8) + 1
+ 204 00aa 0D1F     		jp.d	divide
+ 205 00ac 852E     		ld.w	%r5, %r8		; lshift(%r5) <- shift(%r8)
+ 206              	
+ 207              	man2shift:
+ 208 00ae 9426     		sub		%r4, %r9		; shift(%r4) = count2(%r4) - count1(%r9)
+ 209 00b0 1460     		add		%r4, 1			; shift(%r4) = shift(%r4) + 1
+ 210              	
+ 211              		;xsll	%r7, %r12		; shift man2 to the left
+ 212 00b2 482E     		ld.w	%r8, %r4		; temp(%r8) = shift(%r4)
+ 213              		; used in 32-bit variable shifting	; 	VARSHIFT %r7, %r4, sll
+ 214              		; $1 = input register
+ 215              		; $2 = shift amount
+ 216              		; $3 = shift instruction
+ 217              	__L0003:
+ 218 00b4 8468     		cmp		%r4, 8		; if temp <= 8 then goto $$2
+ 219 00b6 040E     		jrle	__L0004
+ 220              	
+ 221 00b8 878C     		sll		%r7, 8		; shift input register 8 bits
+ 222 00ba FD1F     		jp.d	__L0003
+ 223 00bc 8464     		sub		%r4, 8		; temp = temp - 8
+GAS LISTING divsf3.s 			page 5
+
+
+ 224              	
+ 225              	__L0004:
+ 226 00be 478D     		sll		%r7, %r4		; last shift
+ 227              	
+ 228 00c0 853E     		not		%r5, %r8		; lshift(%r5) = ~temp(%r8)
+ 229 00c2 2560     		add		%r5, 2			; lshift(%r5) = lshift(%r5) + 2
+ 230              	
+ 231              	divide:
+ 232              		; man1 has 8 leading 0's
+ 233              		; man2 has 0 leading 0's
+ 234              		; lshift used to normalize result
+ 235              		
+ 236 00c4 3126     		sub		%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)  new sisu = sisu1 - sisu2 + bias + 
+ 237              	
+ 238 00c6 01C0F163 		xadd	%r1, 0x7f		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + 0x7f
+ 239              	
+ 240 00ca 2122     		add		%r1, %r2		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + flag(%r2)
+ 241              	
+ 242 00cc 03C0F16B 		xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= 0xff then goto overflow
+ 243 00d0 350A     		jrge	overflow
+ 244 00d2 916A     		xcmp	%r1, -23		; if ｻﾘｿﾉ｣ｱ(%r1) <= -23 then underflow
+ 245 00d4 3D0F     		jrle.d	end
+ 246 00d6 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ <- 0
+ 247              	
+ 248 00d8 42A0     		ld.w	%alr, %r4		; extra 32-bits for accuracy
+ 249 00da 708F     		div0u	%r7
+ 250 00dc 63A0     		ld.w	%ahr, %r6		; dividend
+ 251              		
+ 252              	;;ifdef FAST
+ 253              	;	div1	%r7			; 25 division instructions
+ 254              	;	div1	%r7
+ 255              	;	div1	%r7
+ 256              	;	div1	%r7
+ 257              	;	div1	%r7
+ 258              	;	div1	%r7
+ 259              	;	div1	%r7
+ 260              	;	div1	%r7
+ 261              	;	div1	%r7
+ 262              	;	div1	%r7
+ 263              	;	div1	%r7
+ 264              	;	div1	%r7
+ 265              	;	div1	%r7
+ 266              	;	div1	%r7
+ 267              	;	div1	%r7
+ 268              	;	div1	%r7
+ 269              	;	div1	%r7
+ 270              	;	div1	%r7
+ 271              	;	div1	%r7
+ 272              	;	div1	%r7
+ 273              	;	div1	%r7
+ 274              	;	div1	%r7
+ 275              	;	div1	%r7
+ 276              	;	div1	%r7
+ 277              	;	div1	%r7
+ 278              	;
+ 279              	;;else
+ 280              	
+GAS LISTING divsf3.s 			page 6
+
+
+ 281 00de 386C     		ld.w	%r8, 3		; loop counter(%r8) <- 3
+ 282 00e0 7093     		div1	%r7			; first division step (25 in total)
+ 283              	
+ 284              	divloop:
+ 285 00e2 7093     		div1	%r7			; 8 division steps
+ 286 00e4 7093     		div1	%r7
+ 287 00e6 7093     		div1	%r7
+ 288 00e8 7093     		div1	%r7
+ 289 00ea 7093     		div1	%r7
+ 290 00ec 7093     		div1	%r7
+ 291 00ee 7093     		div1	%r7
+ 292 00f0 7093     		div1	%r7
+ 293              	
+ 294 00f2 1864     		sub		%r8, 1			; loop counter(%r8) = loop counter(%r8) - 1
+ 295 00f4 F71A     		jrne	divloop			; exit when zero flag is set
+ 296              	
+ 297              	;;endif
+ 298              	
+ 299 00f6 24A4     		ld.w	%r4, %alr		; ﾌ皃ﾃﾍ(%r4) <- ｾｦ(%alr)
+ 300              	
+ 301              		; normalize
+ 302              		; %r0 = result sign, %r1 = result exponent
+ 303              		; %r10 = lshift, %r4 = result
+ 304              	
+ 305              		;ld.w	%r3, 7			; count = 7
+ 306 00f8 036C     		ld.w	%r3, 0			; count(%r3) <- 0
+ 307 00fa 482E     		ld.w	%r8, %r4
+ 308 00fc 20C000C0 		xand	%r8, 0x1000000	; check 24th bit
+ 308      0870
+ 309              	
+ 310 0102 021A     		jrne	continue2		; if 24th bit = 1 then count = 7
+ 311 0104 1360     		add		%r3, 1			; else count(%r3) = count(%r3) + 1
+ 312              	
+ 313              	continue2:
+ 314              		;sub		%r3, 7		; count = count - 7
+ 315 0106 3522     		add		%r5, %r3		; lshift(%r5) = lshift(%r5) + count(%r3)
+ 316 0108 512A     		cmp		%r1, %r5
+ 317 010a 1108     		jrgt	normal			; if ｻﾘｿﾉ｣ｱ(%r1) > lshift(%r5) then normal result
+ 318              	
+ 319              		; case: exp <= lshift
+ 320 010c 1560     		add		%r5, 1
+ 321 010e 3526     		sub		%r5, %r3		; lshift(%r5) = lshift(%r5) + (8 - (count(%r3)+7) )
+ 322 0110 1526     		sub		%r5, %r1
+ 323 0112 1560     		add		%r5, 1			; lshift(%r5) = lshift(%r5) - (ｻﾘｿﾉ｣ｱ(%r1) - 1)
+ 324              	
+ 325 0114 9569     		cmp		%r5, 25		; if lshift(%r5) amount >= 25 then underflow
+ 326 0116 030C     		jrlt	notunder
+ 327 0118 1B1F     		jp.d	end
+ 328 011a 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+ 329              	
+ 330              	notunder:
+ 331              		;xsrl	%r4, %r10		; %r4 >> lshift (shift amount)
+ 332              		; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r5, srl
+ 333              		; $1 = input register
+ 334              		; $2 = shift amount
+ 335              		; $3 = shift instruction
+ 336              	__L0005:
+GAS LISTING divsf3.s 			page 7
+
+
+ 337 011c 8568     		cmp		%r5, 8		; if temp <= 8 then goto $$2
+ 338 011e 040E     		jrle	__L0006
+ 339              	
+ 340 0120 8488     		srl		%r4, 8		; shift input register 8 bits
+ 341 0122 FD1F     		jp.d	__L0005
+ 342 0124 8564     		sub		%r5, 8		; temp = temp - 8
+ 343              	
+ 344              	__L0006:
+ 345 0126 5489     		srl		%r4, %r5		; last shift
+ 346 0128 0D1F     		jp.d	finish
+ 347 012a 016C     		ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 for denormal result
+ 348              	
+ 349              	normal:	
+ 350              		; case: exp > lshift
+ 351 012c 126C     		ld.w	%r2, 1			; shift(%r2) <- 1
+ 352 012e 3226     		sub		%r2, %r3		; shift(%r2) = shift(%r2) - count(%r3)
+ 353              	
+ 354 0130 2489     		srl		%r4, %r2		; ﾌ皃ﾃﾍ(%r4) >> shift(%r2) <-- [1 or 0]
+ 355 0132 5126     		sub		%r1, %r5		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - lshift(%r5)
+ 356              		
+ 357 0134 03C0F16B 		xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) < 0xff then jump to finish
+ 358 0138 050C     		jrlt	finish
+ 359              	
+ 360              	overflow:
+ 361 013a F0CF00C0 		xld.w	%r4, 0x7f800000	; put infinity into result
+ 361      046C
+ 362 0140 071E     		jp		end
+ 363              	
+ 364              	finish:
+ 365              		; %r0 = sign, %r1 = exponent, %r4 = mantissa
+ 366 0142 0FC0FFDF 		xand	%r4, 0x7fffff	; isolate mantissa
+ 366      F473
+ 367              	
+ 368 0148 81981198 		xrr		%r1, 9			; position exponent bits to [30:23]
+ 369 014c 1436     		or		%r4, %r1
+ 370              	
+ 371              	end:
+ 372 014e 1098     		rr		%r0, 1			; position sign bit to MSB
+ 373 0150 0436     		or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) =  ﾌ皃ﾃﾍ(%r4) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)t
+ 374              	
+ 375              		;@@@ 01/01/23 add start hinokuchi
+ 376              		;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+ 377              		;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+ 378              		;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+ 379              		;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+ 380              		;add		%sp, 4
+ 381              		;@@@ 01/01/23 add end
+ 382 0152 4302     		popn	%r3				; restore register values
+ 383              	
+ 384 0154 4006     		ret
diff --git a/gcc/config/c33/libgcc/divsf3.s b/gcc/config/c33/libgcc/divsf3.s
new file mode 100644
index 0000000..79f3add
--- /dev/null
+++ b/gcc/config/c33/libgcc/divsf3.s
@@ -0,0 +1,384 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : divsf3.s
+;*
+;*	Single floating point division function
+;*		input: %r6, %r7
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/18  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __divsf3
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/shift/flag
+;	%r3:ｻﾘｿﾉ｣ｲ(8bit)/count
+;	%r4:ﾌ皃ﾃﾍ(float)
+;	%r5:temp
+;	%r6:ｰｿ｣ｱ(ﾈｽｿ)
+;	%r7:ｰｿ｣ｲ(ｽｿ)
+;	%r8:mask
+;	%r9:overflow value
+;	%r10:implied bit/lshift
+;	%r11:count1/shift
+;	%r12:temp/count2
+;	%r13:loop counter/temp/shift
+;==============================================
+
+
+;;macro	VARSHIFT $1, $2, $3
+	; used in 32-bit variable shifting
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+;$$1:
+;	cmp		$2, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$3		$1, 8		; shift input register 8 bits
+;	jp.d	$$1
+;	sub		$2, 8		; temp = temp - 8
+
+;$$2:
+;	$3		$1, $2		; last shift
+;;endm
+
+__divsf3:
+	pushn	%r3				; save register values
+	;@@@ 01/01/30 add start hinokuchi
+	;sub		%sp, 4
+	;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+	;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+	;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+	;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+	;@@@ 01/01/30 add end
+
+	;@@@ 01/02/15 del xld.w	%r9, 0xff		; set overflow comparison value
+
+	ld.w	%r0, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ(%r6) 
+	rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+	and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+
+	ld.w	%r2, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ(%r7)
+	rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+	and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1
+
+	xor		%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ~ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+
+	sll		%r6, 1			; ｰｿ｣ｱ(%r6) << 1  clear MSB
+	srl		%r6, 1 			; ｰｿ｣ｱ(%r6) >> 1
+	cmp		%r6, 0
+	ext		end@rm
+	jreq	end@rl			; if ｰｿ｣ｱ(%r6) = 0 then end
+
+	cmp		%r7, 0
+	sll		%r7, 1			; ｰｿ｣ｲ(%r7) << 1 clear
+	srl		%r7, 1			; ｰｿ｣ｲ(%r7) >> 1
+	ext		overflow@rm
+	jreq	overflow@rl		; if ｰｿ｣ｲ(%r7) = 0 then overflow
+
+	ld.w	%r1, %r6		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ(%r6)
+	xsrl 	%r1, 23			; ｻﾘｿﾉ｣ｱ(%r1) >> 23
+
+	;@@@ 01/02/15 del cmp		%r1, %r9		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+	xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+	ext		overflow@rm
+	jrge	overflow@rl		; result is overflow
+
+	ld.w	%r3, %r7		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ(%r7)
+	xsrl	%r3, 23			; ｻﾘｿﾉ｣ｲ(%r3) >> 23
+
+	;@@@ 01/02/15 del cmp		%r3, %r9		; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+	xcmp		%r3, 0xff	; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+
+	ext		end@rm
+	jreq	end@rl			; result is 0 (xxx/NaN = 0)
+
+	;@@@ 01/02/15 del xld.w	%r8, 0x7fffff	; mask(%r8) <- 0x7fffff  set mask for isolating mantissa
+	;@@@ 01/02/15 del xld.w	%r10, 0x800000	; implied bit(%r10)
+	xld.w	%r5, 0x7fffff	; mask(%r8) <- 0x7fffff @@@ 01/02/16 add
+	ld.w	%r2, 1			; flag(%r2) = 1
+	;@@@ 01/02/15 del ld.w	%r13, 0			; loop counter(%r13)  <- 0
+	ld.w	%r8, 0			; loop counter(%r8)  <- 0
+
+	; isolate mantissa1
+	;and		%r6, %r8	; line 62
+	cmp		%r1, 0			; 
+	jreq.d	count1			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 (denormal)
+	;@@@ 01/02/15 del and		%r6, %r8		; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & mask(%r8)  clear first 9 bits of %r6
+	and		%r6, %r5 		; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & 0x7fffff  clear first 9 bits of %r6
+
+	; case: normal input
+	;@@@ 01/02/15 del or		%r6, %r10		; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & implied bit(%r10)   else add implied bit to mantissa
+	xoor	%r6, 0x800000	; ｰｿ｣ｱ(%r6) = ｰｿ｣ｱ(%r6) & implied bit(0x800000)   else add implied bit to mantissa
+	ld.w	%r2, 0			; flag(%r2) <- 0
+	jp.d	getman2
+	;@@@ 01/02/15 del ld.w	%r11, 8			; count1(%r11) <- 8
+	ld.w	%r9, 8			; count1(%r9) <- 8
+	
+count1:	
+	;@@@ 01/02/15 del ld.w	%r12, %r6		; temp(%r12) <- ｰｿ｣ｱ(%r6)
+	ld.w	%r4, %r6		; temp(%r4) <- ｰｿ｣ｱ(%r6)
+
+loop1:
+	;@@@ 01/02/15 del scan1	%r11, %r12		; %r11 = count1
+	scan1	%r9, %r4		; %r9 = count1
+	jruge	getman2			; if count1 !=8 then goto getman2
+	;@@@ 01/02/15 del add		%r13, 8			; loop counter(%r13) = loop counter(%r13) + 8
+	add		%r8, 8			; loop counter(%r8) = loop counter(%r8) + 8
+	jp.d	loop1
+	;@@@ 01/02/15 del sll		%r12, 8			; temp(%r12) << 8  shift register to the left 8 bits
+	sll		%r4, 8			; temp(%r4) << 8  shift register to the left 8 bits
+		
+getman2:
+	;@@@ 01/02/15 del add		%r11, %r13		; count1(%r11) = count1(%r11) + loop counter(%r13)
+	add		%r9, %r8		; count1(%r9) = count1(%r8) + loop counter(%r13)
+	;@@@ 01/02/15 del ld.w	%r13, 0			; loop counter(%r13) = 0
+	ld.w	%r8, 0			; loop counter(%r8) = 0
+
+	; isolate mantissa2
+	;and	%r7, %r8		; line 85
+	cmp		%r3, 0
+	jreq.d	count2			; if ｻﾘｿﾉ｣ｲ(%r3) = 0 then jump to count2
+	;@@@ 01/02/15 del and		%r7, %r8		; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) & mask(%r8) clear first 9 bits of %r7
+	and		%r7, %r5		; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) & mask(0x7fffff) clear first 9 bits of %r7
+	;@@@ 01/02/15 del or		%r7, %r10		; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) | implied bit(%r10)  else add implied bit
+	xoor	%r7, 0x800000	; ｰｿ｣ｲ(%r7) = ｰｿ｣ｲ(%r7) | implied bit(0x800000)  else add implied bit
+	jp.d	cmpcount
+	;@@@ 01/02/15 del ld.w	%r12, 8			; count2(%r12) <- 8
+	ld.w	%r4, 8			; count2(%r12) <- 8
+
+count2:
+	ld.w	%r5, %r7		; temp(%r5) <- ｲｾｿ｣ｲ(%r7) man2
+	sub		%r2, 1			; flag(%r2) = flag(%r2) - 1 (0 or -1)
+
+loop2:
+	;@@@ 01/02/15 del scan1	%r12, %r5		; %r12 = count2
+	scan1	%r4, %r5		; %r4 = count2
+
+	jruge	cmpcount		; if count2 !=8 then goto cmpcount
+	add		%r8, 8			; loop counter(%r8) = loop counter(%r8) + 8
+	jp.d	loop2
+	sll		%r5, 8			; temp(%r5) << 8 shift register to the left 8 bits	
+
+cmpcount:
+	add		%r4, %r8		; count2(%r4) = count2(%r4) + loop counter(%r8)
+
+	cmp		%r9, %r4		; if count1(%r9) <= count2(%r4) then goto man2 shift
+	jrle	man2shift
+
+	; case: count1 > count2
+	sub		%r9, %r4		; shift(%r9) = count1(%r9) - count2(%r4)
+	sub		%r9, 1			; shift(%r9) = shift(%r9) - 1
+
+	;xsll	%r6, %r11		; shift man1
+	ld.w	%r8, %r9		; temp(%r8) <- shift(%r9)
+	; used in 32-bit variable shifting	; 	VARSHIFT %r6, %r9, sll
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+__L0001:
+	cmp		%r9, 8		; if temp <= 8 then goto $$2
+	jrle	__L0002
+
+	sll		%r6, 8		; shift input register 8 bits
+	jp.d	__L0001
+	sub		%r9, 8		; temp = temp - 8
+
+__L0002:
+	sll		%r6, %r9		; last shift
+
+	add		%r8, 1			; shift(%r8) = shift(%r8) + 1
+	jp.d	divide
+	ld.w	%r5, %r8		; lshift(%r5) <- shift(%r8)
+
+man2shift:
+	sub		%r4, %r9		; shift(%r4) = count2(%r4) - count1(%r9)
+	add		%r4, 1			; shift(%r4) = shift(%r4) + 1
+
+	;xsll	%r7, %r12		; shift man2 to the left
+	ld.w	%r8, %r4		; temp(%r8) = shift(%r4)
+	; used in 32-bit variable shifting	; 	VARSHIFT %r7, %r4, sll
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+__L0003:
+	cmp		%r4, 8		; if temp <= 8 then goto $$2
+	jrle	__L0004
+
+	sll		%r7, 8		; shift input register 8 bits
+	jp.d	__L0003
+	sub		%r4, 8		; temp = temp - 8
+
+__L0004:
+	sll		%r7, %r4		; last shift
+
+	not		%r5, %r8		; lshift(%r5) = ~temp(%r8)
+	add		%r5, 2			; lshift(%r5) = lshift(%r5) + 2
+
+divide:
+	; man1 has 8 leading 0's
+	; man2 has 0 leading 0's
+	; lshift used to normalize result
+	
+	sub		%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - ｻﾘｿﾉ｣ｲ(%r3)  new sisu = sisu1 - sisu2 + bias + flag (0,1,-1)
+
+	xadd	%r1, 0x7f		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + 0x7f
+
+	add		%r1, %r2		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + flag(%r2)
+
+	xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= 0xff then goto overflow
+	jrge	overflow
+	xcmp	%r1, -23		; if ｻﾘｿﾉ｣ｱ(%r1) <= -23 then underflow
+	jrle.d	end
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ <- 0
+
+	ld.w	%alr, %r4		; extra 32-bits for accuracy
+	div0u	%r7
+	ld.w	%ahr, %r6		; dividend
+	
+;;ifdef FAST
+;	div1	%r7			; 25 division instructions
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;	div1	%r7
+;
+;;else
+
+	ld.w	%r8, 3		; loop counter(%r8) <- 3
+	div1	%r7			; first division step (25 in total)
+
+divloop:
+	div1	%r7			; 8 division steps
+	div1	%r7
+	div1	%r7
+	div1	%r7
+	div1	%r7
+	div1	%r7
+	div1	%r7
+	div1	%r7
+
+	sub		%r8, 1			; loop counter(%r8) = loop counter(%r8) - 1
+	jrne	divloop			; exit when zero flag is set
+
+;;endif
+
+	ld.w	%r4, %alr		; ﾌ皃ﾃﾍ(%r4) <- ｾｦ(%alr)
+
+	; normalize
+	; %r0 = result sign, %r1 = result exponent
+	; %r10 = lshift, %r4 = result
+
+	;ld.w	%r3, 7			; count = 7
+	ld.w	%r3, 0			; count(%r3) <- 0
+	ld.w	%r8, %r4
+	xand	%r8, 0x1000000	; check 24th bit
+
+	jrne	continue2		; if 24th bit = 1 then count = 7
+	add		%r3, 1			; else count(%r3) = count(%r3) + 1
+
+continue2:
+	;sub		%r3, 7		; count = count - 7
+	add		%r5, %r3		; lshift(%r5) = lshift(%r5) + count(%r3)
+	cmp		%r1, %r5
+	jrgt	normal			; if ｻﾘｿﾉ｣ｱ(%r1) > lshift(%r5) then normal result
+
+	; case: exp <= lshift
+	add		%r5, 1
+	sub		%r5, %r3		; lshift(%r5) = lshift(%r5) + (8 - (count(%r3)+7) )
+	sub		%r5, %r1
+	add		%r5, 1			; lshift(%r5) = lshift(%r5) - (ｻﾘｿﾉ｣ｱ(%r1) - 1)
+
+	cmp		%r5, 25		; if lshift(%r5) amount >= 25 then underflow
+	jrlt	notunder
+	jp.d	end
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+
+notunder:
+	;xsrl	%r4, %r10		; %r4 >> lshift (shift amount)
+	; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r5, srl
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+__L0005:
+	cmp		%r5, 8		; if temp <= 8 then goto $$2
+	jrle	__L0006
+
+	srl		%r4, 8		; shift input register 8 bits
+	jp.d	__L0005
+	sub		%r5, 8		; temp = temp - 8
+
+__L0006:
+	srl		%r4, %r5		; last shift
+	jp.d	finish
+	ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0 for denormal result
+
+normal:	
+	; case: exp > lshift
+	ld.w	%r2, 1			; shift(%r2) <- 1
+	sub		%r2, %r3		; shift(%r2) = shift(%r2) - count(%r3)
+
+	srl		%r4, %r2		; ﾌ皃ﾃﾍ(%r4) >> shift(%r2) <-- [1 or 0]
+	sub		%r1, %r5		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - lshift(%r5)
+	
+	xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) < 0xff then jump to finish
+	jrlt	finish
+
+overflow:
+	xld.w	%r4, 0x7f800000	; put infinity into result
+	jp		end
+
+finish:
+	; %r0 = sign, %r1 = exponent, %r4 = mantissa
+	xand	%r4, 0x7fffff	; isolate mantissa
+
+	xrr		%r1, 9			; position exponent bits to [30:23]
+	or		%r4, %r1
+
+end:
+	rr		%r0, 1			; position sign bit to MSB
+	or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) =  ﾌ皃ﾃﾍ(%r4) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)t
+
+	;@@@ 01/01/23 add start hinokuchi
+	;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+	;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+	;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+	;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+	;add		%sp, 4
+	;@@@ 01/01/23 add end
+	popn	%r3				; restore register values
+
+	ret
diff --git a/gcc/config/c33/libgcc/divsi3.lst b/gcc/config/c33/libgcc/divsi3.lst
new file mode 100644
index 0000000..66501e7
--- /dev/null
+++ b/gcc/config/c33/libgcc/divsi3.lst
@@ -0,0 +1,150 @@
+GAS LISTING divsi3.s 			page 1
+
+
+   1              	;
+   2              	;	Copyright (C) SEIKO EPSON CORP. 1996
+   3              	;
+   4              	;	Filename : divsi3.c
+   5              	;	Function :
+   6              	;	  This module defines the functions
+   7              	;		that emulate signed and unsigned integer division.
+   8              	;	Revision :
+   9              	;	  10/18/1996	ESD T.Katahira		start			    */
+  10              	;
+  11              	;
+  12              	;	Function :	__divsi3
+  13              	;	Input :		%r6	--- dividend
+  14              	;			%r7	--- divisor
+  15              	;	Output :	%r4	--- quotient
+  16              	;	Function :	calculate signed integer division
+  17              	
+  18              	
+  19              		.section .text
+  20              		.align 1
+  21              		.global	__divsi3
+  22              	__divsi3:
+  23 0000 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  24 0002 708B     		div0s	%r7		; initializer of signed division
+  25              	;ifdef	FAST
+  26              	;	div1	%r7		; execute division ;1
+  27              	;	div1	%r7		; execute division ;2
+  28              	;	div1	%r7		; execute division ;3
+  29              	;	div1	%r7		; execute division ;4
+  30              	;	div1	%r7		; execute division ;5
+  31              	;	div1	%r7		; execute division ;6
+  32              	;	div1	%r7		; execute division ;7
+  33              	;	div1	%r7		; execute division ;8
+  34              	;	div1	%r7		; execute division ;9
+  35              	;	div1	%r7		; execute division ;10
+  36              	;	div1	%r7		; execute division ;11
+  37              	;	div1	%r7		; execute division ;12
+  38              	;	div1	%r7		; execute division ;13
+  39              	;	div1	%r7		; execute division ;14
+  40              	;	div1	%r7		; execute division ;15
+  41              	;	div1	%r7		; execute division ;16
+  42              	;	div1	%r7		; execute division ;17
+  43              	;	div1	%r7		; execute division ;18
+  44              	;	div1	%r7		; execute division ;19
+  45              	;	div1	%r7		; execute division ;20
+  46              	;	div1	%r7		; execute division ;21
+  47              	;	div1	%r7		; execute division ;22
+  48              	;	div1	%r7		; execute division ;23
+  49              	;	div1	%r7		; execute division ;24
+  50              	;	div1	%r7		; execute division ;25
+  51              	;	div1	%r7		; execute division ;26
+  52              	;	div1	%r7		; execute division ;27
+  53              	;	div1	%r7		; execute division ;28
+  54              	;	div1	%r7		; execute division ;29
+  55              	;	div1	%r7		; execute division ;30
+  56              	;	div1	%r7		; execute division ;31
+  57              	;	div1	%r7		; execute division ;32
+GAS LISTING divsi3.s 			page 2
+
+
+  58              	;else
+  59 0004 486C     		ld.w	%r8,0x4		; set loop counter (N = 4)
+  60 0006 09A4     		ld.w	%r9,%psr	; save flag register
+  61              	__divsi3_loop_start:	
+  62 0008 7093     		div1	%r7		; execute division ;1
+  63 000a 7093     		div1	%r7		; execute division ;2
+  64 000c 7093     		div1	%r7		; execute division ;3
+  65 000e 7093     		div1	%r7		; execute division ;4
+  66 0010 7093     		div1	%r7		; execute division ;5
+  67 0012 7093     		div1	%r7		; execute division ;6
+  68 0014 7093     		div1	%r7		; execute division ;7
+  69 0016 7093     		div1	%r7		; execute division ;8
+  70 0018 1864     		sub	%r8,0x1		; decrement loop counter
+  71 001a F71B     		jrne.d	__divsi3_loop_start	; if (loop counter != 0) goto loop top
+  72 001c 90A0     		ld.w	%psr,%r9	; restore flag register (delayed slot)
+  73              	;endif
+  74 001e 7097     		div2s	%r7		; post divistion process ;1
+  75 0020 009B     		div3s			; post divistion process ;2
+  76 0022 4007     		ret.d			; return to the caller (use delayed return)
+  77 0024 24A4     		ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+  78              	
+  79              	
+  80              	;	Function :	__udivsi3
+  81              	;	Input :		%r6	--- dividend
+  82              	;			%r7	--- divisor
+  83              	;	Output :	%r4	--- quotient
+  84              	;	Function :	calculate unsigned integer division
+  85              	
+  86              		.section .text
+  87              		.align 1
+  88              		.global	__udivsi3
+  89              	__udivsi3:
+  90 0026 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  91 0028 708F     		div0u	%r7		; initializer of signed division
+  92              	;ifdef	FAST
+  93              	;	div1	%r7		; execute division ;1
+  94              	;	div1	%r7		; execute division ;2
+  95              	;	div1	%r7		; execute division ;3
+  96              	;	div1	%r7		; execute division ;4
+  97              	;	div1	%r7		; execute division ;5
+  98              	;	div1	%r7		; execute division ;6
+  99              	;	div1	%r7		; execute division ;7
+ 100              	;	div1	%r7		; execute division ;8
+ 101              	;	div1	%r7		; execute division ;9
+ 102              	;	div1	%r7		; execute division ;10
+ 103              	;	div1	%r7		; execute division ;11
+ 104              	;	div1	%r7		; execute division ;12
+ 105              	;	div1	%r7		; execute division ;13
+ 106              	;	div1	%r7		; execute division ;14
+ 107              	;	div1	%r7		; execute division ;15
+ 108              	;	div1	%r7		; execute division ;16
+ 109              	;	div1	%r7		; execute division ;17
+ 110              	;	div1	%r7		; execute division ;18
+ 111              	;	div1	%r7		; execute division ;19
+ 112              	;	div1	%r7		; execute division ;20
+ 113              	;	div1	%r7		; execute division ;21
+ 114              	;	div1	%r7		; execute division ;22
+GAS LISTING divsi3.s 			page 3
+
+
+ 115              	;	div1	%r7		; execute division ;23
+ 116              	;	div1	%r7		; execute division ;24
+ 117              	;	div1	%r7		; execute division ;25
+ 118              	;	div1	%r7		; execute division ;26
+ 119              	;	div1	%r7		; execute division ;27
+ 120              	;	div1	%r7		; execute division ;28
+ 121              	;	div1	%r7		; execute division ;29
+ 122              	;	div1	%r7		; execute division ;30
+ 123              	;	div1	%r7		; execute division ;31
+ 124              	;	div1	%r7		; execute division ;32
+ 125              	;else
+ 126 002a 486C     		ld.w	%r8,0x4		; set loop counter (N = 4)
+ 127              	__udivsi3_loop_start:	
+ 128 002c 7093     		div1	%r7		; execute division ;1
+ 129 002e 7093     		div1	%r7		; execute division ;2
+ 130 0030 7093     		div1	%r7		; execute division ;3
+ 131 0032 7093     		div1	%r7		; execute division ;4
+ 132 0034 7093     		div1	%r7		; execute division ;5
+ 133 0036 7093     		div1	%r7		; execute division ;6
+ 134 0038 7093     		div1	%r7		; execute division ;7
+ 135 003a 7093     		div1	%r7		; execute division ;8
+ 136 003c 1864     		sub	%r8,0x1		; decrement loop counter
+ 137 003e F71A     		jrne	__udivsi3_loop_start	; if (loop counter != 0) goto loop top
+ 138              	;endif
+ 139 0040 4007     		ret.d			; return to the caller (use delayed return)
+ 140 0042 24A4     		ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+ 141              	
diff --git a/gcc/config/c33/libgcc/divsi3.s b/gcc/config/c33/libgcc/divsi3.s
new file mode 100644
index 0000000..f8c44bf
--- /dev/null
+++ b/gcc/config/c33/libgcc/divsi3.s
@@ -0,0 +1,141 @@
+;
+;	Copyright (C) SEIKO EPSON CORP. 1996
+;
+;	Filename : divsi3.c
+;	Function :
+;	  This module defines the functions
+;		that emulate signed and unsigned integer division.
+;	Revision :
+;	  10/18/1996	ESD T.Katahira		start			    */
+;
+;
+;	Function :	__divsi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- quotient
+;	Function :	calculate signed integer division
+
+
+	.section .text
+	.align 1
+	.global	__divsi3
+__divsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0s	%r7		; initializer of signed division
+;ifdef	FAST
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	div1	%r7		; execute division ;9
+;	div1	%r7		; execute division ;10
+;	div1	%r7		; execute division ;11
+;	div1	%r7		; execute division ;12
+;	div1	%r7		; execute division ;13
+;	div1	%r7		; execute division ;14
+;	div1	%r7		; execute division ;15
+;	div1	%r7		; execute division ;16
+;	div1	%r7		; execute division ;17
+;	div1	%r7		; execute division ;18
+;	div1	%r7		; execute division ;19
+;	div1	%r7		; execute division ;20
+;	div1	%r7		; execute division ;21
+;	div1	%r7		; execute division ;22
+;	div1	%r7		; execute division ;23
+;	div1	%r7		; execute division ;24
+;	div1	%r7		; execute division ;25
+;	div1	%r7		; execute division ;26
+;	div1	%r7		; execute division ;27
+;	div1	%r7		; execute division ;28
+;	div1	%r7		; execute division ;29
+;	div1	%r7		; execute division ;30
+;	div1	%r7		; execute division ;31
+;	div1	%r7		; execute division ;32
+;else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+	ld.w	%r9,%psr	; save flag register
+__divsi3_loop_start:	
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	sub	%r8,0x1		; decrement loop counter
+	jrne.d	__divsi3_loop_start	; if (loop counter != 0) goto loop top
+	ld.w	%psr,%r9	; restore flag register (delayed slot)
+;endif
+	div2s	%r7		; post divistion process ;1
+	div3s			; post divistion process ;2
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+
+
+;	Function :	__udivsi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- quotient
+;	Function :	calculate unsigned integer division
+
+	.section .text
+	.align 1
+	.global	__udivsi3
+__udivsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0u	%r7		; initializer of signed division
+;ifdef	FAST
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	div1	%r7		; execute division ;9
+;	div1	%r7		; execute division ;10
+;	div1	%r7		; execute division ;11
+;	div1	%r7		; execute division ;12
+;	div1	%r7		; execute division ;13
+;	div1	%r7		; execute division ;14
+;	div1	%r7		; execute division ;15
+;	div1	%r7		; execute division ;16
+;	div1	%r7		; execute division ;17
+;	div1	%r7		; execute division ;18
+;	div1	%r7		; execute division ;19
+;	div1	%r7		; execute division ;20
+;	div1	%r7		; execute division ;21
+;	div1	%r7		; execute division ;22
+;	div1	%r7		; execute division ;23
+;	div1	%r7		; execute division ;24
+;	div1	%r7		; execute division ;25
+;	div1	%r7		; execute division ;26
+;	div1	%r7		; execute division ;27
+;	div1	%r7		; execute division ;28
+;	div1	%r7		; execute division ;29
+;	div1	%r7		; execute division ;30
+;	div1	%r7		; execute division ;31
+;	div1	%r7		; execute division ;32
+;else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+__udivsi3_loop_start:	
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	sub	%r8,0x1		; decrement loop counter
+	jrne	__udivsi3_loop_start	; if (loop counter != 0) goto loop top
+;endif
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+
diff --git a/gcc/config/c33/libgcc/extsfdf.lst b/gcc/config/c33/libgcc/extsfdf.lst
new file mode 100644
index 0000000..0bd5395
--- /dev/null
+++ b/gcc/config/c33/libgcc/extsfdf.lst
@@ -0,0 +1,174 @@
+GAS LISTING extsfdf.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : extsfdf.s
+   6              	;*
+   7              	;*	Change type: Single float --> Double float
+   8              	;*		input: %r6
+   9              	;*		output: (%r5, %r4)
+  10              	;*
+  11              	;*	Begin					1996/09/12	V. Chan
+  12              	;*	Fixed bug with variable shift (ln. 108)
+  13              	;*							1997/02/18	V. Chan
+  14              	;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+  15              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  16              	;*
+  17              	;*****************************************
+  18              	
+  19              	.section .text
+  20              	.align 1
+  21              	.global __extendsfdf2
+  22              	
+  23              	__extendsfdf2:
+  24              	
+  25 0000 0302     		pushn	%r3				; save register values
+  26              	
+  27 0002 602E     		ld.w	%r0, %r6		; put sign of input (%r6) into %r0
+  28 0004 109C     		rl		%r0, 1
+  29 0006 1070     		and		%r0, 1
+  30              	
+  31 0008 056C     		ld.w	%r5, 0			; clear output registers
+  32 000a 168C     		sll		%r6, 1			; remove MSB
+  33 000c 1688     		srl		%r6, 1
+  34              	
+  35 000e 0668     		cmp		%r6, 0			; if input = 0 then exit
+  36 0010 4F19     		jreq.d	end
+  37 0012 046C     		ld.w	%r4, 0
+  38              	
+  39 0014 612E     		ld.w	%r1, %r6		; put exponent into %r1
+  40 0016 118C     		sll		%r1, 1
+  41 0018 81888188 		xsrl 	%r1, 24
+  41      8188
+  42              	
+  43 001e 03C0F16B 		xcmp	%r1, 0xff		; if NaN or Inf input then return Inf
+  44 0022 FECF00C0 		xld.w	%r5, 0x7ff00000
+  44      056C
+  45 0028 430B     		jrge.d	end
+  46 002a 046C     		ld.w	%r4, 0
+  47              	
+  48              	
+  49              		; isolate mantissa
+  50 002c 0FC0FFDF 		xand	%r6,0x7fffff		; clear first 9 bits of %r6
+  50      F673
+  51              		
+  52 0032 0168     		cmp		%r1, 0
+  53 0034 2C1B     		jrne.d	expnez			; if exp != 0 then goto expnez
+  54 0036 652E     		ld.w	%r5, %r6		; result1 = input
+GAS LISTING extsfdf.s 			page 2
+
+
+  55              	
+  56              		; case: exp = 0
+  57 0038 592E     		ld.w	%r9, %r5		; copy new result to %r9 for counting
+  58 003a 086C     		ld.w	%r8, 0			; initialize loop counter
+  59              	
+  60              	count:
+  61 003c 978E     		scan1	%r7, %r9		; count = ; of 0's before leading 1 in result
+  62 003e 0412     		jruge	continue		; if count !=8 then goto continue
+  63 0040 8860     		add		%r8, 8			; add 8 to loop counter
+  64 0042 FD1F     		jp.d	count
+  65 0044 898C     		sll		%r9, 8			; shift 8 leading 0's out of %r9
+  66              	
+  67              	continue:
+  68 0046 8722     		add		%r7, %r8		; count = count + loop counter
+  69 0048 0EC0016C 		xld.w	%r1, 0x380		; exp = 0x380
+  70 004c 7126     		sub		%r1, %r7		; exp = exp - count
+  71              		;add	%r1, 9			; moved to line 55
+  72              	
+  73 004e B768     		cmp		%r7, 11
+  74 0050 140B     		jrge.d	shftleft		; if count >= 11 then goto shftleft
+  75 0052 9160     		add		%r1, 9			; exp = exp + 9
+  76              	
+  77              		; case: count < 11
+  78 0054 B26C     		ld.w	%r2, 11
+  79 0056 7226     		sub		%r2, %r7		; %r2 = shift = 11 - count
+  80              	
+  81              		; {result1, result2} >> 11 - count
+  82              		;xsrl	%r4_p, %r2		; shift low 32-bits to the right 11-count bits
+  83              		;xrr	%r5_p, %r2		; rotate high 32-bits to the right 11-count bits
+  84              		;xsrl	%r3, %r2		; make a mask for last 20-count bits --> %r3 = 000...111
+  85              	
+  86 0058 F36F     		ld.w	%r3, -1			; %r3 = 0xffff ffff
+  87              		; 64-bit variable shift and rotate routine
+  88              	L1:
+  89 005a 8268     		cmp		%r2, 8			; if shift amount <= 8 then goto L2
+  90 005c 060E     		jrle	L2
+  91              	
+  92 005e 8488     		srl		%r4, 8			; result1 >> 8
+  93 0060 8598     		rr		%r5, 8			; result2 rotate >> 8
+  94 0062 8388     		srl		%r3, 8			; mask >> 8
+  95 0064 FB1F     		jp.d	L1
+  96 0066 8264     		sub		%r2, 8			; shift amount -= 8 
+  97              	
+  98              	L2:
+  99 0068 2489     		srl		%r4, %r2		; result1 >> %r2
+ 100 006a 2599     		rr		%r5, %r2		; result2 rotate >> %r2
+ 101 006c 2389     		srl		%r3, %r2		; mask >> %r2
+ 102              	
+ 103 006e 383E     		not		%r8, %r3		; flip mask for first 12-count bits --> %r8 = 111...000 (mask)
+ 104 0070 5832     		and		%r8, %r5		; isolate first 12-count bits of %r5
+ 105 0072 8436     		or		%r4, %r8		; add first 12-count bits of %r5 to %r4
+ 106 0074 171F     		jp.d	finish
+ 107 0076 3532     		and		%r5, %r3		; keep the low 20-count bits of %r5
+ 108              	
+ 109              	shftleft:
+ 110 0078 722E     		ld.w	%r2, %r7
+ 111 007a B264     		sub		%r2, 11			; %r2 = shift = count - 11
+GAS LISTING extsfdf.s 			page 3
+
+
+ 112              	
+ 113              		; 	MXSLL	%r5, %r2		; result1 << count - 11
+ 114              	__L0001:
+ 115              		
+ 116              	;	sub		%sp, 1			
+ 117              	;	ld.w	[%sp+0], $2		; rs･ｹ･ｿ･ﾃ･ｯﾂﾔﾈ
+ 118              		
+ 119 007c F271     		and		%r2,0x1f			; ｺﾇﾂ逾ｷ･ﾕ･ﾈｿ=｣ｳ｣ｱ
+ 120              	__L0002:
+ 121 007e 8268     		cmp		%r2,0x8			; if rs <= 8
+ 122 0080 040E     		jrle	__L0003				; then $$3
+ 123 0082 858C     		sll		%r5,0x8			; rd << 8
+ 124 0084 FD1F     		jp.d	__L0002
+ 125 0086 8264     		sub		%r2,0x8			; ｻﾄ･ｷ･ﾕ･ﾈｲｿｷﾗｻｻ
+ 126              	__L0003:
+ 127 0088 258D     		sll		%r5,%r2
+ 128              	
+ 129              	;	ld.w	$2, [%sp+0]		; rs･ｹ･ｿ･ﾃ･ｯﾉｵ｢
+ 130              	;	add		%sp, 1
+ 131              	
+ 132 008a 0C1E     		jp		finish
+ 133              	
+ 134              	expnez:
+ 135 008c 0EC00160 		xadd	%r1, 0x380		; exp = exp + 0x380 (0011 1000 0000 in binary)
+ 136              	
+ 137              		; {result1, result2} >> 3
+ 138 0090 3488     		srl		%r4, 3			; shift low 32-bits to the right 3 bits
+ 139 0092 3598     		rr		%r5, 3			; rotate high 32-bits to the right 3 bits
+ 140 0094 F36F     		ld.w	%r3, -1			; %r3 = 0xffff ffff
+ 141 0096 3388     		srl		%r3, 3			; make a mask for last 29 bits --> %r3 = 0001...111
+ 142 0098 383E     		not		%r8, %r3		; flip mask for first 3 bits --> %r8 = 1110...000
+ 143 009a 5832     		and		%r8, %r5		; isolate first 3 bits of %r5
+ 144 009c 8436     		or		%r4, %r8		; add first 3 bits of %r5 to %r4
+ 145 009e 021F     		jp.d	finish
+ 146 00a0 3532     		and		%r5, %r3		; keep the low 29 bits of %r5
+ 147              	
+ 148              	finish:
+ 149 00a2 01C0FFDF 		xand	%r5, 0xfffff	; remove implied bit
+ 149      F573
+ 150              	
+ 151 00a8 81984198 		xrr		%r1, 12			; position exponent bits
+ 152 00ac 1536     		or		%r5, %r1		; add exponent
+ 153              	
+ 154              	end:
+ 155 00ae 1098     		rr		%r0, 1			; position sign bit
+ 156 00b0 0536     		or		%r5, %r0		; add sign bit
+ 157              	
+ 158 00b2 4302     		popn	%r3				; restore register values
+ 159              	
+ 160              	
+ 161 00b4 4006     		ret
diff --git a/gcc/config/c33/libgcc/extsfdf.s b/gcc/config/c33/libgcc/extsfdf.s
new file mode 100644
index 0000000..7f9b1c2
--- /dev/null
+++ b/gcc/config/c33/libgcc/extsfdf.s
@@ -0,0 +1,161 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : extsfdf.s
+;*
+;*	Change type: Single float --> Double float
+;*		input: %r6
+;*		output: (%r5, %r4)
+;*
+;*	Begin					1996/09/12	V. Chan
+;*	Fixed bug with variable shift (ln. 108)
+;*							1997/02/18	V. Chan
+;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __extendsfdf2
+
+__extendsfdf2:
+
+	pushn	%r3				; save register values
+
+	ld.w	%r0, %r6		; put sign of input (%r6) into %r0
+	rl		%r0, 1
+	and		%r0, 1
+
+	ld.w	%r5, 0			; clear output registers
+	sll		%r6, 1			; remove MSB
+	srl		%r6, 1
+
+	cmp		%r6, 0			; if input = 0 then exit
+	jreq.d	end
+	ld.w	%r4, 0
+
+	ld.w	%r1, %r6		; put exponent into %r1
+	sll		%r1, 1
+	xsrl 	%r1, 24
+
+	xcmp	%r1, 0xff		; if NaN or Inf input then return Inf
+	xld.w	%r5, 0x7ff00000
+	jrge.d	end
+	ld.w	%r4, 0
+
+
+	; isolate mantissa
+	xand	%r6,0x7fffff		; clear first 9 bits of %r6
+	
+	cmp		%r1, 0
+	jrne.d	expnez			; if exp != 0 then goto expnez
+	ld.w	%r5, %r6		; result1 = input
+
+	; case: exp = 0
+	ld.w	%r9, %r5		; copy new result to %r9 for counting
+	ld.w	%r8, 0			; initialize loop counter
+
+count:
+	scan1	%r7, %r9		; count = ; of 0's before leading 1 in result
+	jruge	continue		; if count !=8 then goto continue
+	add		%r8, 8			; add 8 to loop counter
+	jp.d	count
+	sll		%r9, 8			; shift 8 leading 0's out of %r9
+
+continue:
+	add		%r7, %r8		; count = count + loop counter
+	xld.w	%r1, 0x380		; exp = 0x380
+	sub		%r1, %r7		; exp = exp - count
+	;add	%r1, 9			; moved to line 55
+
+	cmp		%r7, 11
+	jrge.d	shftleft		; if count >= 11 then goto shftleft
+	add		%r1, 9			; exp = exp + 9
+
+	; case: count < 11
+	ld.w	%r2, 11
+	sub		%r2, %r7		; %r2 = shift = 11 - count
+
+	; {result1, result2} >> 11 - count
+	;xsrl	%r4_p, %r2		; shift low 32-bits to the right 11-count bits
+	;xrr	%r5_p, %r2		; rotate high 32-bits to the right 11-count bits
+	;xsrl	%r3, %r2		; make a mask for last 20-count bits --> %r3 = 000...111
+
+	ld.w	%r3, -1			; %r3 = 0xffff ffff
+	; 64-bit variable shift and rotate routine
+L1:
+	cmp		%r2, 8			; if shift amount <= 8 then goto L2
+	jrle	L2
+
+	srl		%r4, 8			; result1 >> 8
+	rr		%r5, 8			; result2 rotate >> 8
+	srl		%r3, 8			; mask >> 8
+	jp.d	L1
+	sub		%r2, 8			; shift amount -= 8 
+
+L2:
+	srl		%r4, %r2		; result1 >> %r2
+	rr		%r5, %r2		; result2 rotate >> %r2
+	srl		%r3, %r2		; mask >> %r2
+
+	not		%r8, %r3		; flip mask for first 12-count bits --> %r8 = 111...000 (mask)
+	and		%r8, %r5		; isolate first 12-count bits of %r5
+	or		%r4, %r8		; add first 12-count bits of %r5 to %r4
+	jp.d	finish
+	and		%r5, %r3		; keep the low 20-count bits of %r5
+
+shftleft:
+	ld.w	%r2, %r7
+	sub		%r2, 11			; %r2 = shift = count - 11
+
+	; 	MXSLL	%r5, %r2		; result1 << count - 11
+__L0001:
+	
+;	sub		%sp, 1			
+;	ld.w	[%sp+0], $2		; rs･ｹ･ｿ･ﾃ･ｯﾂﾔﾈ
+	
+	and		%r2,0x1f			; ｺﾇﾂ逾ｷ･ﾕ･ﾈｿ=｣ｳ｣ｱ
+__L0002:
+	cmp		%r2,0x8			; if rs <= 8
+	jrle	__L0003				; then $$3
+	sll		%r5,0x8			; rd << 8
+	jp.d	__L0002
+	sub		%r2,0x8			; ｻﾄ･ｷ･ﾕ･ﾈｲｿｷﾗｻｻ
+__L0003:
+	sll		%r5,%r2
+
+;	ld.w	$2, [%sp+0]		; rs･ｹ･ｿ･ﾃ･ｯﾉｵ｢
+;	add		%sp, 1
+
+	jp		finish
+
+expnez:
+	xadd	%r1, 0x380		; exp = exp + 0x380 (0011 1000 0000 in binary)
+
+	; {result1, result2} >> 3
+	srl		%r4, 3			; shift low 32-bits to the right 3 bits
+	rr		%r5, 3			; rotate high 32-bits to the right 3 bits
+	ld.w	%r3, -1			; %r3 = 0xffff ffff
+	srl		%r3, 3			; make a mask for last 29 bits --> %r3 = 0001...111
+	not		%r8, %r3		; flip mask for first 3 bits --> %r8 = 1110...000
+	and		%r8, %r5		; isolate first 3 bits of %r5
+	or		%r4, %r8		; add first 3 bits of %r5 to %r4
+	jp.d	finish
+	and		%r5, %r3		; keep the low 29 bits of %r5
+
+finish:
+	xand	%r5, 0xfffff	; remove implied bit
+
+	xrr		%r1, 12			; position exponent bits
+	or		%r5, %r1		; add exponent
+
+end:
+	rr		%r0, 1			; position sign bit
+	or		%r5, %r0		; add sign bit
+
+	popn	%r3				; restore register values
+
+
+	ret
diff --git a/gcc/config/c33/libgcc/fcmpd.lst b/gcc/config/c33/libgcc/fcmpd.lst
new file mode 100644
index 0000000..5d6b224
--- /dev/null
+++ b/gcc/config/c33/libgcc/fcmpd.lst
@@ -0,0 +1,108 @@
+GAS LISTING fcmpd.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : fcmpd.s
+   6              	;*
+   7              	;*	Double floating point compare
+   8              	;*		input: (%r7, %r6) & (%r9, %r8)
+   9              	;*		output: %psr
+  10              	;*
+  11              	;*	Begin		1996/10/30	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*********************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __fcmpd
+  21              	
+  22              	;==============================================
+  23              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  24              	;	%r2:ｻﾘｿﾉ｣ｲ
+  25              	;	%r4:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ[0(+) or 1(-)]
+  26              	;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ[0(+) or 1(-)]/ｻﾘｿﾉ｣ｱ/mask
+  27              	;	%r6:ｰｿ｣ｱ[L](double)/ｲｾｿﾉ｣ｱ[L]
+  28              	;	%r7:ｰｿ｣ｱ[H](double)/ｲｾｿﾉ｣ｱ[H]
+  29              	;	%r8:ｰｿ｣ｲ[L](double)/ｲｾｿﾉ｣ｲ[L]
+  30              	;	%r9:ｰｿ｣ｲ[H](double)/ｲｾｿﾉ｣ｲ[H]
+  31              	;==============================================
+  32              	
+  33              	__fcmpd:
+  34 0000 0202     		pushn	%r2				; %r0｡ﾁ%r2 ﾂﾔﾈ
+  35              	
+  36 0002 742E     		ld.w	%r4, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) <- ｰｿ｣ｱ[H](%r7)
+  37 0004 149C     		rl		%r4, 1			; rotate left 1 bit
+  38 0006 1470     		and		%r4, 1			; use mask to keep LSB
+  39              	
+  40 0008 952E     		ld.w	%r5, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r4) <- ｰｿ｣ｲ[H](%r9)
+  41 000a 159C     		rl		%r5, 1			; rotate left 1 bit
+  42 000c 1570     		and		%r5, 1			; use mask to keep LSB
+  43              	
+  44              		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 0 then CVZN = 1001 (lt)
+  45              		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 0 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 1 then CVZN = 0000 (gt)
+  46 000e 452A     		cmp		%r5, %r4		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) != ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) 
+  47 0010 231A     		jrne	end				; %psr is changed
+  48              	
+  49              		; case: ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) 
+  50 0012 752E     		ld.w	%r5, %r7		; ｻﾘｿﾉ｣ｱ(%r5) <- ｰｿ｣ｱ[H](%r7)
+  51 0014 158C     		sll		%r5, 1			; ｻﾘｿﾉ｣ｱ(%r5) << 1
+  52 0016 85888588 		xsrl 	%r5, 21			; ｻﾘｿﾉ｣ｱ(%r5) >> 21
+  52      5588
+  53              	
+  54 001c 922E     		ld.w	%r2, %r9		; ｻﾘｿﾉ｣ｲ(%r2) <- ｰｿ｣ｲ[H](%r9)
+  55 001e 128C     		sll		%r2, 1			; ｻﾘｿﾉ｣ｲ(%r2) << 1
+  56 0020 82888288 		xsrl 	%r2, 21			; ｻﾘｿﾉ｣ｲ(%r2) >> 21
+GAS LISTING fcmpd.s 			page 2
+
+
+  56      5288
+  57              	
+  58 0026 1468     		cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+  59 0028 0418     		jreq	negexp			; then goto negexp
+  60              	
+  61              		; max. ｻﾘｿﾉ = 0x7ff
+  62              		; min. ｻﾘｿﾉ = 0x00
+  63 002a 252A     		cmp		%r5, %r2		; if ｻﾘｿﾉ｣ｱ(%r5) != ｻﾘｿﾉ｣ｲ(%r2) 
+  64 002c 151A     		jrne	end				; then goto end
+  65 002e 031E     		jp		mancmp
+  66              	
+  67              	negexp:
+  68 0030 522A     		cmp		%r2, %r5		; if ｻﾘｿﾉ｣ｲ(%r2) !=  ｻﾘｿﾉ｣ｱ(%r5)
+  69 0032 121A     		jrne	end				; then goto end
+  70              	
+  71              	mancmp:
+  72 0034 1FC0F56B 		xcmp	%r5, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2) = ﾆﾃｼｿ(0xff) 
+  73 0038 0F18     		jreq	end				; then goto end
+  74              	
+  75              		; case: ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2)
+  76 003a 01C0FFDF 		xld.w	%r5, 0xfffff	; mask(%r5) <- 0x7fffff
+  76      F56F
+  77              	
+  78 0040 5732     		and		%r7, %r5		; ｲｾｿﾉ｣ｱ(%r7) = ｲｾｿﾉ｣ｱ(%r7) & mask(%r5)
+  79 0042 5932     		and		%r9, %r5		; ｲｾｿﾉ｣ｲ(%r9) = ｲｾｿﾉ｣ｲ(%r9) & mask(%r5)
+  80              	
+  81 0044 1468     		cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+  82 0046 0518     		jreq	negman
+  83              	
+  84 0048 972A     		cmp		%r7, %r9		; compare ｲｾｿﾉ｣ｱ[H](%r7) : ｲｾｿﾉ｣ｲ[H](%r9) 
+  85 004a 061A     		jrne	end
+  86              	
+  87              		; case: man1 = man2
+  88 004c 862A     		cmp		%r6, %r8		; compare ｲｾｿﾉ｣ｱ[L](%r6) : ｲｾｿﾉ｣ｲ[L](%r8) 
+  89 004e 041E     		jp		end
+  90              	
+  91              	negman:
+  92 0050 792A     		cmp		%r9, %r7		; compare ｲｾｿﾉ｣ｲ[H](%r9) : ｲｾｿﾉ｣ｱ[H](%r7) 
+  93 0052 021A     		jrne	end
+  94              	
+  95 0054 682A     		cmp		%r8, %r6		; compare ｲｾｿﾉ｣ｱ[L](%r6) : ｲｾｿﾉ｣ｲ[L](%r8) 
+  96              		
+  97              	end:
+  98 0056 4202     		popn	%r2				; %r0｡ﾁ%r2 ﾉｵ｢
+  99 0058 4006     		ret
diff --git a/gcc/config/c33/libgcc/fcmpd.s b/gcc/config/c33/libgcc/fcmpd.s
new file mode 100644
index 0000000..076e672
--- /dev/null
+++ b/gcc/config/c33/libgcc/fcmpd.s
@@ -0,0 +1,99 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : fcmpd.s
+;*
+;*	Double floating point compare
+;*		input: (%r7, %r6) & (%r9, %r8)
+;*		output: %psr
+;*
+;*	Begin		1996/10/30	V. Chan
+;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __fcmpd
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r2:ｻﾘｿﾉ｣ｲ
+;	%r4:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ[0(+) or 1(-)]
+;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ[0(+) or 1(-)]/ｻﾘｿﾉ｣ｱ/mask
+;	%r6:ｰｿ｣ｱ[L](double)/ｲｾｿﾉ｣ｱ[L]
+;	%r7:ｰｿ｣ｱ[H](double)/ｲｾｿﾉ｣ｱ[H]
+;	%r8:ｰｿ｣ｲ[L](double)/ｲｾｿﾉ｣ｲ[L]
+;	%r9:ｰｿ｣ｲ[H](double)/ｲｾｿﾉ｣ｲ[H]
+;==============================================
+
+__fcmpd:
+	pushn	%r2				; %r0｡ﾁ%r2 ﾂﾔﾈ
+
+	ld.w	%r4, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) <- ｰｿ｣ｱ[H](%r7)
+	rl		%r4, 1			; rotate left 1 bit
+	and		%r4, 1			; use mask to keep LSB
+
+	ld.w	%r5, %r9		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r4) <- ｰｿ｣ｲ[H](%r9)
+	rl		%r5, 1			; rotate left 1 bit
+	and		%r5, 1			; use mask to keep LSB
+
+	; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 0 then CVZN = 1001 (lt)
+	; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 0 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 1 then CVZN = 0000 (gt)
+	cmp		%r5, %r4		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) != ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) 
+	jrne	end				; %psr is changed
+
+	; case: ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) 
+	ld.w	%r5, %r7		; ｻﾘｿﾉ｣ｱ(%r5) <- ｰｿ｣ｱ[H](%r7)
+	sll		%r5, 1			; ｻﾘｿﾉ｣ｱ(%r5) << 1
+	xsrl 	%r5, 21			; ｻﾘｿﾉ｣ｱ(%r5) >> 21
+
+	ld.w	%r2, %r9		; ｻﾘｿﾉ｣ｲ(%r2) <- ｰｿ｣ｲ[H](%r9)
+	sll		%r2, 1			; ｻﾘｿﾉ｣ｲ(%r2) << 1
+	xsrl 	%r2, 21			; ｻﾘｿﾉ｣ｲ(%r2) >> 21
+
+	cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+	jreq	negexp			; then goto negexp
+
+	; max. ｻﾘｿﾉ = 0x7ff
+	; min. ｻﾘｿﾉ = 0x00
+	cmp		%r5, %r2		; if ｻﾘｿﾉ｣ｱ(%r5) != ｻﾘｿﾉ｣ｲ(%r2) 
+	jrne	end				; then goto end
+	jp		mancmp
+
+negexp:
+	cmp		%r2, %r5		; if ｻﾘｿﾉ｣ｲ(%r2) !=  ｻﾘｿﾉ｣ｱ(%r5)
+	jrne	end				; then goto end
+
+mancmp:
+	xcmp	%r5, 0x7ff		; if ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2) = ﾆﾃｼｿ(0xff) 
+	jreq	end				; then goto end
+
+	; case: ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2)
+	xld.w	%r5, 0xfffff	; mask(%r5) <- 0x7fffff
+
+	and		%r7, %r5		; ｲｾｿﾉ｣ｱ(%r7) = ｲｾｿﾉ｣ｱ(%r7) & mask(%r5)
+	and		%r9, %r5		; ｲｾｿﾉ｣ｲ(%r9) = ｲｾｿﾉ｣ｲ(%r9) & mask(%r5)
+
+	cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+	jreq	negman
+
+	cmp		%r7, %r9		; compare ｲｾｿﾉ｣ｱ[H](%r7) : ｲｾｿﾉ｣ｲ[H](%r9) 
+	jrne	end
+
+	; case: man1 = man2
+	cmp		%r6, %r8		; compare ｲｾｿﾉ｣ｱ[L](%r6) : ｲｾｿﾉ｣ｲ[L](%r8) 
+	jp		end
+
+negman:
+	cmp		%r9, %r7		; compare ｲｾｿﾉ｣ｲ[H](%r9) : ｲｾｿﾉ｣ｱ[H](%r7) 
+	jrne	end
+
+	cmp		%r8, %r6		; compare ｲｾｿﾉ｣ｱ[L](%r6) : ｲｾｿﾉ｣ｲ[L](%r8) 
+	
+end:
+	popn	%r2				; %r0｡ﾁ%r2 ﾉｵ｢
+	ret
diff --git a/gcc/config/c33/libgcc/fcmps.lst b/gcc/config/c33/libgcc/fcmps.lst
new file mode 100644
index 0000000..f9ec7b0
--- /dev/null
+++ b/gcc/config/c33/libgcc/fcmps.lst
@@ -0,0 +1,101 @@
+GAS LISTING fcmps.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : fcmps.s
+   6              	;*
+   7              	;*	Single floating point compare
+   8              	;*		input: %r6 & %r7
+   9              	;*		output: %psr
+  10              	;*
+  11              	;*	Begin		1996/10/30	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*********************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __fcmps
+  21              	
+  22              	;==============================================
+  23              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  24              	;	%r2:ｻﾘｿﾉ｣ｲ
+  25              	;	%r4:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ[0(+) or 1(-)]
+  26              	;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ[0(+) or 1(-)]/ｻﾘｿﾉ｣ｱ/mask
+  27              	;	%r6:ｰｿ｣ｱ(float)/ｲｾｿﾉ｣ｱ
+  28              	;	%r7:ｰｿ｣ｲ(float)/ｲｾｿﾉ｣ｲ
+  29              	;==============================================
+  30              	
+  31              	
+  32              	__fcmps:
+  33 0000 0202     		pushn	%r2				; %r0｡ﾁ%r2 ﾂﾔﾈ
+  34              	
+  35 0002 642E     		ld.w	%r4, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) <- ｰｿ｣ｱ(%r6)
+  36 0004 149C     		rl		%r4, 1			; rotate left 1 bit
+  37 0006 1470     		and		%r4, 1			; keep LSB
+  38              	
+  39 0008 752E     		ld.w	%r5, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) <- ｰｿ｣ｲ(%r7)
+  40 000a 159C     		rl		%r5, 1			; rotate left 1 bit
+  41 000c 1570     		and		%r5, 1			; keep LSB
+  42              	
+  43              		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 0 then CVZN = 1001 (lt)
+  44              		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 0 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 1 then CVZN = 0000 (gt)
+  45 000e 452A     		cmp		%r5, %r4		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) != ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) 
+  46 0010 1F1A     		jrne	end				; then goto end
+  47              	
+  48              		; case: ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) 
+  49 0012 652E     		ld.w	%r5, %r6		; ｻﾘｿﾉ｣ｱ(%r5) <- ｰｿ｣ｱ(%r6)
+  50 0014 158C     		sll		%r5, 1			; ｻﾘｿﾉ｣ｱ(%r5) << 1
+  51 0016 85888588 		xsrl 	%r5, 24			; ｻﾘｿﾉ｣ｱ(%r5) >> 24
+  51      8588
+  52              	
+  53 001c 722E     		ld.w	%r2, %r7		; ｻﾘｿﾉ｣ｲ(%r2) <- ｰｿ｣ｲ(%r7)
+  54 001e 128C     		sll		%r2, 1			; ｻﾘｿﾉ｣ｲ(%r2) << 1
+  55 0020 82888288 		xsrl 	%r2, 24			; ｻﾘｿﾉ｣ｲ(%r2) >> 24
+  55      8288
+GAS LISTING fcmps.s 			page 2
+
+
+  56              	
+  57 0026 1468     		cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+  58 0028 0418     		jreq	negexp			; then goto negexp
+  59              	
+  60              		; max. ｻﾘｿﾉ = 0xff
+  61              		; min. ｻﾘｿﾉ = 0x00
+  62 002a 252A     		cmp		%r5, %r2		; if ｻﾘｿﾉ｣ｱ(%r5) != ｻﾘｿﾉ｣ｲ(%r2) 
+  63 002c 111A     		jrne	end				; then goto end
+  64 002e 031E     		jp		mancmp
+  65              	
+  66              	negexp:
+  67 0030 522A     		cmp		%r2, %r5		; if ｻﾘｿﾉ｣ｲ(%r2) !=  ｻﾘｿﾉ｣ｱ(%r5)
+  68 0032 0E1A     		jrne	end				; then goto end
+  69              	
+  70              	mancmp:
+  71              		; check if Inf or NaN values
+  72 0034 03C0F56B 		xcmp	%r5, 0xff		; if ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2) = ﾆﾃｼｿ(0xff) 
+  73 0038 0B18     		jreq	end				; then goto end
+  74              	
+  75              		; case: ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2)
+  76 003a 0FC0FFDF 		xld.w	%r5, 0x7fffff	; mask(%r5) <- 0x7fffff
+  76      F56F
+  77              	
+  78 0040 5632     		and		%r6, %r5		; ｲｾｿﾉ｣ｱ(%r6) = ｲｾｿﾉ｣ｱ(%r6) & mask(%r5)
+  79 0042 5732     		and		%r7, %r5		; ｲｾｿﾉ｣ｲ(%r7) = ｲｾｿﾉ｣ｲ(%r7) & mask(%r5)
+  80              	
+  81 0044 1468     		cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+  82 0046 0318     		jreq	negman			; then goto negman
+  83              	
+  84 0048 762A     		cmp		%r6, %r7		; compare ｲｾｿﾉ｣ｱ(%r6) : ｲｾｿﾉ｣ｲ(%r7) 
+  85 004a 021E     		jp		end
+  86              	
+  87              	negman:
+  88 004c 672A     		cmp		%r7, %r6		; compare ｲｾｿﾉ｣ｲ(%r7) : ｲｾｿﾉ｣ｱ(%r6) 
+  89              	
+  90              	end:
+  91 004e 4202     		popn	%r2				; %r0｡ﾁ%r2 ﾉｵ｢
+  92 0050 4006     		ret
diff --git a/gcc/config/c33/libgcc/fcmps.s b/gcc/config/c33/libgcc/fcmps.s
new file mode 100644
index 0000000..e31c159
--- /dev/null
+++ b/gcc/config/c33/libgcc/fcmps.s
@@ -0,0 +1,92 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : fcmps.s
+;*
+;*	Single floating point compare
+;*		input: %r6 & %r7
+;*		output: %psr
+;*
+;*	Begin		1996/10/30	V. Chan
+;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __fcmps
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r2:ｻﾘｿﾉ｣ｲ
+;	%r4:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ[0(+) or 1(-)]
+;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ[0(+) or 1(-)]/ｻﾘｿﾉ｣ｱ/mask
+;	%r6:ｰｿ｣ｱ(float)/ｲｾｿﾉ｣ｱ
+;	%r7:ｰｿ｣ｲ(float)/ｲｾｿﾉ｣ｲ
+;==============================================
+
+
+__fcmps:
+	pushn	%r2				; %r0｡ﾁ%r2 ﾂﾔﾈ
+
+	ld.w	%r4, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) <- ｰｿ｣ｱ(%r6)
+	rl		%r4, 1			; rotate left 1 bit
+	and		%r4, 1			; keep LSB
+
+	ld.w	%r5, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) <- ｰｿ｣ｲ(%r7)
+	rl		%r5, 1			; rotate left 1 bit
+	and		%r5, 1			; keep LSB
+
+	; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 0 then CVZN = 1001 (lt)
+	; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 0 and ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) = 1 then CVZN = 0000 (gt)
+	cmp		%r5, %r4		; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) != ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) 
+	jrne	end				; then goto end
+
+	; case: ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r5) 
+	ld.w	%r5, %r6		; ｻﾘｿﾉ｣ｱ(%r5) <- ｰｿ｣ｱ(%r6)
+	sll		%r5, 1			; ｻﾘｿﾉ｣ｱ(%r5) << 1
+	xsrl 	%r5, 24			; ｻﾘｿﾉ｣ｱ(%r5) >> 24
+
+	ld.w	%r2, %r7		; ｻﾘｿﾉ｣ｲ(%r2) <- ｰｿ｣ｲ(%r7)
+	sll		%r2, 1			; ｻﾘｿﾉ｣ｲ(%r2) << 1
+	xsrl 	%r2, 24			; ｻﾘｿﾉ｣ｲ(%r2) >> 24
+
+	cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+	jreq	negexp			; then goto negexp
+
+	; max. ｻﾘｿﾉ = 0xff
+	; min. ｻﾘｿﾉ = 0x00
+	cmp		%r5, %r2		; if ｻﾘｿﾉ｣ｱ(%r5) != ｻﾘｿﾉ｣ｲ(%r2) 
+	jrne	end				; then goto end
+	jp		mancmp
+
+negexp:
+	cmp		%r2, %r5		; if ｻﾘｿﾉ｣ｲ(%r2) !=  ｻﾘｿﾉ｣ｱ(%r5)
+	jrne	end				; then goto end
+
+mancmp:
+	; check if Inf or NaN values
+	xcmp	%r5, 0xff		; if ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2) = ﾆﾃｼｿ(0xff) 
+	jreq	end				; then goto end
+
+	; case: ｻﾘｿﾉ｣ｱ(%r5) = ｻﾘｿﾉ｣ｲ(%r2)
+	xld.w	%r5, 0x7fffff	; mask(%r5) <- 0x7fffff
+
+	and		%r6, %r5		; ｲｾｿﾉ｣ｱ(%r6) = ｲｾｿﾉ｣ｱ(%r6) & mask(%r5)
+	and		%r7, %r5		; ｲｾｿﾉ｣ｲ(%r7) = ｲｾｿﾉ｣ｲ(%r7) & mask(%r5)
+
+	cmp		%r4, 1			; if ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r4) = 1 
+	jreq	negman			; then goto negman
+
+	cmp		%r6, %r7		; compare ｲｾｿﾉ｣ｱ(%r6) : ｲｾｿﾉ｣ｲ(%r7) 
+	jp		end
+
+negman:
+	cmp		%r7, %r6		; compare ｲｾｿﾉ｣ｲ(%r7) : ｲｾｿﾉ｣ｱ(%r6) 
+
+end:
+	popn	%r2				; %r0｡ﾁ%r2 ﾉｵ｢
+	ret
diff --git a/gcc/config/c33/libgcc/fixdfi.lst b/gcc/config/c33/libgcc/fixdfi.lst
new file mode 100644
index 0000000..2f72dcd
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixdfi.lst
@@ -0,0 +1,140 @@
+GAS LISTING fixdfi.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : fixdfui.s
+   6              	;*
+   7              	;*	Change type: Double float --> Unsigned integer
+   8              	;*							  --> Signed integer
+   9              	;*		input: (%r7, %r6)
+  10              	;*		output: %r4
+  11              	;*
+  12              	;*	Begin		1996/09/12	V. Chan
+  13              	;*  ﾊﾑｹｹ		2001/01/18  O.Hinokuchi
+  14              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+  15              	;*				 ｡ｦ__fixunsdfsi ･ﾕ･｡･､･ﾊｬｳ荀ﾎ､ｿ､蘯ｽ 
+  16              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  17              	;*
+  18              	;*****************************************
+  19              	
+  20              	.section .text
+  21              	.align 1
+  22              	.global __fixdfsi
+  23              	
+  24              	;==============================================
+  25              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  26              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+  27              	;	%r4:ﾌ皃ﾃﾍ(int or uint)
+  28              	;	%r5:ｻﾘｿﾉ(11bit)
+  29              	;	%r6:ｰｿ｣ｲ(Doubleｲｼｰﾌ32bit)
+  30              	;	%r7:ｰｿ｣ｱ(Doubleｾ蟆ﾌ32bit)
+  31              	;	%r8:mask
+  32              	;	%r9:shift
+  33              	;==============================================
+  34              	
+  35              	__fixdfsi:
+  36              	
+  37 0000 0002     		pushn	%r0				; %r0 ﾂﾔﾈ
+  38              	
+  39 0002 702E     		ld.w	%r0, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- ｰｿ｣ｲ(%r7) put sign of input (%r7) into %r0
+  40 0004 109C     		rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) >> 31 ､ﾈﾆｱ､ｸ
+  41 0006 1070     		and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) & 1 moved to line 33
+  42              	
+  43 0008 752E     		ld.w	%r5, %r7		; ｻﾘｿﾉ(%r5) <- ｰｿ｣ｱ(%r7)  put exponent into %r5
+  44 000a 158C     		sll		%r5, 1			; ｻﾘｿﾉ(%r7) << 1
+  45 000c 85888588 		xsrl 	%r5, 21			; ｻﾘｿﾉ(%r7) >> 24	
+  45      5588
+  46              	
+  47 0012 0FC0F56B 		xcmp	%r5, 0x3ff		; if ｻﾘｿﾉ(%r7) < 0x3ff then goto end
+  48 0016 320D     		jrlt.d	end				; case: round to zero (underflow)
+  49 0018 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 clear output register
+  50              	
+  51 001a 10C0F569 		xcmp	%r5, 0x41f		; if ﾌ皃ﾃﾍ(%r4) >= 0x41f then integer overflow
+  52 001e 146C     		ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+  53 0020 2A0B     		jrge.d	overflow
+  54 0022 1498     		rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = 0x8000 0000
+  55              	
+  56              		; isolate mantissa
+GAS LISTING fixdfi.s 			page 2
+
+
+  57 0024 742E     		ld.w	%r4, %r7		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r7) 
+  58 0026 01C0FFDF 		xand	%r4, 0xfffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0xfffff) clear first 12 bits of %r7
+  58      F473
+  59 002c 02C000C0 		xoor	%r4, 0x100000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x100000) add implied bit
+  59      0474
+  60 0032 10C0396D 		xld.w	%r9, 0x413		;shift(%r9) <- 0x413
+  61              	
+  62 0036 952A     		cmp		%r5, %r9		; 0x3ff + 31 - 11 = 0x413
+  63 0038 0908     		jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x413 then shift left
+  64              	
+  65              		; case: exp <= 0x413
+  66 003a 5926     		sub		%r9, %r5		; %r9 = 0x413 - exp (max = 20)
+  67              	
+  68              		;xsrl		%r4, %r3		; final shift of result
+  69              		; 32-bit variable shift routine
+  70              	L1:
+  71 003c 8968     		cmp		%r9, 8			; if shift(%r9)  <= 8 then goto L2
+  72 003e 040E     		jrle	L2
+  73              	
+  74 0040 8488     		srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+  75 0042 FD1F     		jp.d	L1
+  76 0044 8964     		sub		%r9, 8			; shift(%r9)  = shift(%r9)  - 8
+  77              	
+  78              	L2:
+  79 0046 121F     		jp.d	finish
+  80 0048 9489     		srl		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) >> shift(%r9) last shift
+  81              	
+  82              	shftleft:
+  83 004a 9526     		sub		%r5, %r9		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - shift(%r9=0x413) (max = 11)
+  84              		
+  85              		; {result, man1_2} << 0x413-exp
+  86              		;xsll	%r4, %r1		; shift high 32-bits to the left x bits (shift amount = x)
+  87              		;xrl	%r6, %r1		; rotate low 32-bits to the left x bits
+  88              		;xsll	%r2, %r1		; make a mask for first 32-x bits --> %r2 = 111...000
+  89              	
+  90 004c F86F     		ld.w	%r8, -1			; mask(%r8) = 0xffff ffff
+  91              		; 64-bit variable shift and rotate routine
+  92              	L3:
+  93 004e 8568     		cmp		%r5, 8			; if ｻﾘｿﾉ(%r5) <= 8 then goto L2
+  94 0050 060E     		jrle	L4
+  95              	
+  96 0052 848C     		sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+  97 0054 869C     		rl		%r6, 8			; ｰｿ｣ｲ(%r6) rotate << 8
+  98 0056 888C     		sll		%r8, 8			; mask(%r8) << 8
+  99 0058 FB1F     		jp.d	L3
+ 100 005a 8564     		sub		%r5, 8			; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - 8 
+ 101              	
+ 102              	L4:
+ 103 005c 548D     		sll		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) << ｻﾘｿﾉ(%r5)
+ 104 005e 569D     		rl		%r6, %r5		; ｰｿ｣ｲ(%r6) rotate << ｻﾘｿﾉ(%r5)
+ 105 0060 588D     		sll		%r8, %r5		; mask(%r8) << ｻﾘｿﾉ(%r5)
+ 106              	
+ 107 0062 853E     		not		%r5, %r8		; ｻﾘｿﾉ(%r5) = ~mask(%r8) flip mask for last x bits --> %r9 = 000...111 (mask)
+ 108 0064 6532     		and		%r5, %r6		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) & ｰｿ｣ｲ(%r6) isolate last x bits of %r6
+ 109 0066 5436     		or		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) & ｻﾘｿﾉ(%r5) add last x bits of %r6 to %r4
+ 110 0068 8632     		and		%r6, %r8		; ｰｿ(%r6) = ｰｿ｣ｲ(%r6) & mask(%r8) keep the high 32-x bits of %r6
+ 111              	
+GAS LISTING fixdfi.s 			page 3
+
+
+ 112              	finish:
+ 113 006a 0068     		cmp		%r0, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 0 then goto end
+ 114 006c 0718     		jreq	end
+ 115              		
+ 116              		; case: sign = 1
+ 117 006e 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+ 118 0070 051F     		jp.d	end
+ 119 0072 1460     		add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+ 120              	
+ 121              	overflow:
+ 122 0074 0068     		cmp		%r0, 0			; check sign
+ 123 0076 021A     		jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 1 then goto end
+ 124 0078 443E     		not		%r4, %r4		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0xffffffff
+ 125              	
+ 126              	end:
+ 127 007a 4002     		popn	%r0				; %r0 ﾉｵ｢
+ 128 007c 4006     		ret
diff --git a/gcc/config/c33/libgcc/fixdfi.s b/gcc/config/c33/libgcc/fixdfi.s
new file mode 100644
index 0000000..ad49802
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixdfi.s
@@ -0,0 +1,128 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : fixdfui.s
+;*
+;*	Change type: Double float --> Unsigned integer
+;*							  --> Signed integer
+;*		input: (%r7, %r6)
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/18  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+;*				 ｡ｦ__fixunsdfsi ･ﾕ･｡･､･ﾊｬｳ荀ﾎ､ｿ､蘯ｽ 
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __fixdfsi
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+;	%r4:ﾌ皃ﾃﾍ(int or uint)
+;	%r5:ｻﾘｿﾉ(11bit)
+;	%r6:ｰｿ｣ｲ(Doubleｲｼｰﾌ32bit)
+;	%r7:ｰｿ｣ｱ(Doubleｾ蟆ﾌ32bit)
+;	%r8:mask
+;	%r9:shift
+;==============================================
+
+__fixdfsi:
+
+	pushn	%r0				; %r0 ﾂﾔﾈ
+
+	ld.w	%r0, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- ｰｿ｣ｲ(%r7) put sign of input (%r7) into %r0
+	rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) >> 31 ､ﾈﾆｱ､ｸ
+	and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) & 1 moved to line 33
+
+	ld.w	%r5, %r7		; ｻﾘｿﾉ(%r5) <- ｰｿ｣ｱ(%r7)  put exponent into %r5
+	sll		%r5, 1			; ｻﾘｿﾉ(%r7) << 1
+	xsrl 	%r5, 21			; ｻﾘｿﾉ(%r7) >> 24	
+
+	xcmp	%r5, 0x3ff		; if ｻﾘｿﾉ(%r7) < 0x3ff then goto end
+	jrlt.d	end				; case: round to zero (underflow)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 clear output register
+
+	xcmp	%r5, 0x41f		; if ﾌ皃ﾃﾍ(%r4) >= 0x41f then integer overflow
+	ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+	jrge.d	overflow
+	rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = 0x8000 0000
+
+	; isolate mantissa
+	ld.w	%r4, %r7		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r7) 
+	xand	%r4, 0xfffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0xfffff) clear first 12 bits of %r7
+	xoor	%r4, 0x100000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x100000) add implied bit
+	xld.w	%r9, 0x413		;shift(%r9) <- 0x413
+
+	cmp		%r5, %r9		; 0x3ff + 31 - 11 = 0x413
+	jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x413 then shift left
+
+	; case: exp <= 0x413
+	sub		%r9, %r5		; %r9 = 0x413 - exp (max = 20)
+
+	;xsrl		%r4, %r3		; final shift of result
+	; 32-bit variable shift routine
+L1:
+	cmp		%r9, 8			; if shift(%r9)  <= 8 then goto L2
+	jrle	L2
+
+	srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+	jp.d	L1
+	sub		%r9, 8			; shift(%r9)  = shift(%r9)  - 8
+
+L2:
+	jp.d	finish
+	srl		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) >> shift(%r9) last shift
+
+shftleft:
+	sub		%r5, %r9		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - shift(%r9=0x413) (max = 11)
+	
+	; {result, man1_2} << 0x413-exp
+	;xsll	%r4, %r1		; shift high 32-bits to the left x bits (shift amount = x)
+	;xrl	%r6, %r1		; rotate low 32-bits to the left x bits
+	;xsll	%r2, %r1		; make a mask for first 32-x bits --> %r2 = 111...000
+
+	ld.w	%r8, -1			; mask(%r8) = 0xffff ffff
+	; 64-bit variable shift and rotate routine
+L3:
+	cmp		%r5, 8			; if ｻﾘｿﾉ(%r5) <= 8 then goto L2
+	jrle	L4
+
+	sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+	rl		%r6, 8			; ｰｿ｣ｲ(%r6) rotate << 8
+	sll		%r8, 8			; mask(%r8) << 8
+	jp.d	L3
+	sub		%r5, 8			; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - 8 
+
+L4:
+	sll		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) << ｻﾘｿﾉ(%r5)
+	rl		%r6, %r5		; ｰｿ｣ｲ(%r6) rotate << ｻﾘｿﾉ(%r5)
+	sll		%r8, %r5		; mask(%r8) << ｻﾘｿﾉ(%r5)
+
+	not		%r5, %r8		; ｻﾘｿﾉ(%r5) = ~mask(%r8) flip mask for last x bits --> %r9 = 000...111 (mask)
+	and		%r5, %r6		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) & ｰｿ｣ｲ(%r6) isolate last x bits of %r6
+	or		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) & ｻﾘｿﾉ(%r5) add last x bits of %r6 to %r4
+	and		%r6, %r8		; ｰｿ(%r6) = ｰｿ｣ｲ(%r6) & mask(%r8) keep the high 32-x bits of %r6
+
+finish:
+	cmp		%r0, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 0 then goto end
+	jreq	end
+	
+	; case: sign = 1
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+	jp.d	end
+	add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+
+overflow:
+	cmp		%r0, 0			; check sign
+	jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 1 then goto end
+	not		%r4, %r4		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0xffffffff
+
+end:
+	popn	%r0				; %r0 ﾉｵ｢
+	ret
diff --git a/gcc/config/c33/libgcc/fixdfui.lst b/gcc/config/c33/libgcc/fixdfui.lst
new file mode 100644
index 0000000..9f496ff
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixdfui.lst
@@ -0,0 +1,154 @@
+GAS LISTING fixdfui.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : fixdfui.s
+   6              	;*
+   7              	;*	Change type: Double float --> Unsigned integer
+   8              	;*							  --> Signed integer
+   9              	;*		input: (%r7, %r6)
+  10              	;*		output: %r4
+  11              	;*
+  12              	;*	Begin		1996/09/12	V. Chan
+  13              	;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+  14              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+  15              	;*				 ｡ｦ__fixdfsi ･ﾕ･｡･､･ﾊｬｳ荀ﾎ､ｿ､蘯ｽ 
+  16              	;*				 ｡ｦ･ﾞ･､･ﾊ･ｹ､ﾎﾃﾍ､ﾎ･ｭ･罕ｹ･ﾈ､ﾏ ｣ｰ  ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢
+  17              	;*                0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣(gcc､ﾎｽ靉､ﾈﾆｱｰ)
+  18              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  19              	;*
+  20              	;*****************************************
+  21              	
+  22              	.section .text
+  23              	.align 1
+  24              	.global __fixunsdfsi
+  25              	
+  26              	;==============================================
+  27              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  28              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+  29              	;	%r4:ﾌ皃ﾃﾍ(int or uint)
+  30              	;	%r5:ｻﾘｿﾉ(11bit)
+  31              	;	%r6:ｰｿ｣ｲ(Doubleｲｼｰﾌ32bit)
+  32              	;	%r7:ｰｿ｣ｱ(Doubleｾ蟆ﾌ32bit)
+  33              	;	%r8:mask
+  34              	;	%r9:shift
+  35              	;==============================================
+  36              	
+  37              	__fixunsdfsi:
+  38              	
+  39 0000 742E     		ld.w	%r4, %r7
+  40 0002 00D000C0 		xand	%r4, 0x80000000		; if( sign_bit == 0 )
+  40      0470
+  41              	
+  42 0008 00C000C0 		xjreq	start						;    goto __fixdfsi
+  42      0318
+  43              											; else
+  44 000e 046C     		xld.w	%r4, 0x0					;	return(0)
+  45 0010 4006     		ret
+  46              	start:
+  47              	
+  48 0012 0002     		pushn	%r0				; %r0 ﾂﾔﾈ
+  49              	
+  50 0014 702E     		ld.w	%r0, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- ｰｿ｣ｲ(%r7) put sign of input (%r7) into %r0
+  51 0016 109C     		rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) >> 31 ､ﾈﾆｱ､ｸ
+  52 0018 1070     		and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) & 1 moved to line 33
+  53              	
+  54 001a 752E     		ld.w	%r5, %r7		; ｻﾘｿﾉ(%r5) <- ｰｿ｣ｱ(%r7)  put exponent into %r5
+  55 001c 158C     		sll		%r5, 1			; ｻﾘｿﾉ(%r7) << 1
+GAS LISTING fixdfui.s 			page 2
+
+
+  56 001e 85888588 		xsrl 	%r5, 21			; ｻﾘｿﾉ(%r7) >> 24	
+  56      5588
+  57              	
+  58 0024 0FC0F56B 		xcmp	%r5, 0x3ff		; if ｻﾘｿﾉ(%r7) < 0x3ff then goto end
+  59 0028 330D     		jrlt.d	end				; case: round to zero (underflow)
+  60 002a 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 clear output register
+  61              	
+  62 002c 10C0F569 		xcmp	%r5, 0x41f		; if ﾌ皃ﾃﾍ(%r4) >= 0x41f then integer overflow
+  63 0030 146C     		ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+  64 0032 2A0B     		jrge.d	overflow
+  65 0034 1498     		rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = 0x8000 0000
+  66              	
+  67              		; isolate mantissa
+  68 0036 742E     		ld.w	%r4, %r7		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r7) 
+  69 0038 01C0FFDF 		xand	%r4, 0xfffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0xfffff) clear first 12 bits of %r7
+  69      F473
+  70 003e 02C000C0 		xoor	%r4, 0x100000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x100000) add implied bit
+  70      0474
+  71 0044 10C0396D 		xld.w	%r9, 0x413		;shift(%r9) <- 0x413
+  72              	
+  73 0048 952A     		cmp		%r5, %r9		; 0x3ff + 31 - 11 = 0x413
+  74 004a 0908     		jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x413 then shift left
+  75              	
+  76              		; case: exp <= 0x413
+  77 004c 5926     		sub		%r9, %r5		; %r9 = 0x413 - exp (max = 20)
+  78              	
+  79              		;xsrl		%r4, %r3		; final shift of result
+  80              		; 32-bit variable shift routine
+  81              	L1:
+  82 004e 8968     		cmp		%r9, 8			; if shift(%r9)  <= 8 then goto L2
+  83 0050 040E     		jrle	L2
+  84              	
+  85 0052 8488     		srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+  86 0054 FD1F     		jp.d	L1
+  87 0056 8964     		sub		%r9, 8			; shift(%r9)  = shift(%r9)  - 8
+  88              	
+  89              	L2:
+  90 0058 121F     		jp.d	finish
+  91 005a 9489     		srl		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) >> shift(%r9) last shift
+  92              	
+  93              	shftleft:
+  94 005c 9526     		sub		%r5, %r9		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - shift(%r9=0x413) (max = 11)
+  95              		
+  96              		; {result, man1_2} << 0x413-exp
+  97              		;xsll	%r4, %r1		; shift high 32-bits to the left x bits (shift amount = x)
+  98              		;xrl	%r6, %r1		; rotate low 32-bits to the left x bits
+  99              		;xsll	%r2, %r1		; make a mask for first 32-x bits --> %r2 = 111...000
+ 100              	
+ 101 005e F86F     		ld.w	%r8, -1			; mask(%r8) = 0xffff ffff
+ 102              		; 64-bit variable shift and rotate routine
+ 103              	L3:
+ 104 0060 8568     		cmp		%r5, 8			; if ｻﾘｿﾉ(%r5) <= 8 then goto L2
+ 105 0062 060E     		jrle	L4
+ 106              	
+ 107 0064 848C     		sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+ 108 0066 869C     		rl		%r6, 8			; ｰｿ｣ｲ(%r6) rotate << 8
+ 109 0068 888C     		sll		%r8, 8			; mask(%r8) << 8
+GAS LISTING fixdfui.s 			page 3
+
+
+ 110 006a FB1F     		jp.d	L3
+ 111 006c 8564     		sub		%r5, 8			; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - 8 
+ 112              	
+ 113              	L4:
+ 114 006e 548D     		sll		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) << ｻﾘｿﾉ(%r5)
+ 115 0070 569D     		rl		%r6, %r5		; ｰｿ｣ｲ(%r6) rotate << ｻﾘｿﾉ(%r5)
+ 116 0072 588D     		sll		%r8, %r5		; mask(%r8) << ｻﾘｿﾉ(%r5)
+ 117              	
+ 118 0074 853E     		not		%r5, %r8		; ｻﾘｿﾉ(%r5) = ~mask(%r8) flip mask for last x bits --> %r9 = 000...111 (mask)
+ 119 0076 6532     		and		%r5, %r6		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) & ｰｿ｣ｲ(%r6) isolate last x bits of %r6
+ 120 0078 5436     		or		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) & ｻﾘｿﾉ(%r5) add last x bits of %r6 to %r4
+ 121 007a 8632     		and		%r6, %r8		; ｰｿ(%r6) = ｰｿ｣ｲ(%r6) & mask(%r8) keep the high 32-x bits of %r6
+ 122              	
+ 123              	finish:
+ 124 007c 0068     		cmp		%r0, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 0 then goto end
+ 125 007e 0818     		jreq	end
+ 126              		
+ 127              		; case: sign = 1
+ 128 0080 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+ 129 0082 061F     		jp.d	end
+ 130 0084 1460     		add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+ 131              	
+ 132              	overflow:
+ 133 0086 0068     		cmp		%r0, 0			; check sign
+ 134 0088 031A     		jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 1 then goto end
+ 135 008a 046C     		ld.w	%r4, 0			; ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣01/01/17  Hinokuchi 
+ 136 008c 443E     		not		%r4, %r4		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0xffffffff
+ 137              	
+ 138              	end:
+ 139 008e 4002     		popn	%r0				; %r0 ﾉｵ｢
+ 140 0090 4006     		ret
diff --git a/gcc/config/c33/libgcc/fixdfui.s b/gcc/config/c33/libgcc/fixdfui.s
new file mode 100644
index 0000000..f472cc0
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixdfui.s
@@ -0,0 +1,140 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : fixdfui.s
+;*
+;*	Change type: Double float --> Unsigned integer
+;*							  --> Signed integer
+;*		input: (%r7, %r6)
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+;*				 ｡ｦ__fixdfsi ･ﾕ･｡･､･ﾊｬｳ荀ﾎ､ｿ､蘯ｽ 
+;*				 ｡ｦ･ﾞ･､･ﾊ･ｹ､ﾎﾃﾍ､ﾎ･ｭ･罕ｹ･ﾈ､ﾏ ｣ｰ  ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢
+;*                0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣(gcc､ﾎｽ靉､ﾈﾆｱｰ)
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __fixunsdfsi
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+;	%r4:ﾌ皃ﾃﾍ(int or uint)
+;	%r5:ｻﾘｿﾉ(11bit)
+;	%r6:ｰｿ｣ｲ(Doubleｲｼｰﾌ32bit)
+;	%r7:ｰｿ｣ｱ(Doubleｾ蟆ﾌ32bit)
+;	%r8:mask
+;	%r9:shift
+;==============================================
+
+__fixunsdfsi:
+
+	ld.w	%r4, %r7
+	xand	%r4, 0x80000000		; if( sign_bit == 0 )
+
+	xjreq	start						;    goto __fixdfsi
+										; else
+	xld.w	%r4, 0x0					;	return(0)
+	ret
+start:
+
+	pushn	%r0				; %r0 ﾂﾔﾈ
+
+	ld.w	%r0, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- ｰｿ｣ｲ(%r7) put sign of input (%r7) into %r0
+	rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) >> 31 ､ﾈﾆｱ､ｸ
+	and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) & 1 moved to line 33
+
+	ld.w	%r5, %r7		; ｻﾘｿﾉ(%r5) <- ｰｿ｣ｱ(%r7)  put exponent into %r5
+	sll		%r5, 1			; ｻﾘｿﾉ(%r7) << 1
+	xsrl 	%r5, 21			; ｻﾘｿﾉ(%r7) >> 24	
+
+	xcmp	%r5, 0x3ff		; if ｻﾘｿﾉ(%r7) < 0x3ff then goto end
+	jrlt.d	end				; case: round to zero (underflow)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 clear output register
+
+	xcmp	%r5, 0x41f		; if ﾌ皃ﾃﾍ(%r4) >= 0x41f then integer overflow
+	ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+	jrge.d	overflow
+	rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = 0x8000 0000
+
+	; isolate mantissa
+	ld.w	%r4, %r7		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r7) 
+	xand	%r4, 0xfffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0xfffff) clear first 12 bits of %r7
+	xoor	%r4, 0x100000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x100000) add implied bit
+	xld.w	%r9, 0x413		;shift(%r9) <- 0x413
+
+	cmp		%r5, %r9		; 0x3ff + 31 - 11 = 0x413
+	jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x413 then shift left
+
+	; case: exp <= 0x413
+	sub		%r9, %r5		; %r9 = 0x413 - exp (max = 20)
+
+	;xsrl		%r4, %r3		; final shift of result
+	; 32-bit variable shift routine
+L1:
+	cmp		%r9, 8			; if shift(%r9)  <= 8 then goto L2
+	jrle	L2
+
+	srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+	jp.d	L1
+	sub		%r9, 8			; shift(%r9)  = shift(%r9)  - 8
+
+L2:
+	jp.d	finish
+	srl		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) >> shift(%r9) last shift
+
+shftleft:
+	sub		%r5, %r9		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - shift(%r9=0x413) (max = 11)
+	
+	; {result, man1_2} << 0x413-exp
+	;xsll	%r4, %r1		; shift high 32-bits to the left x bits (shift amount = x)
+	;xrl	%r6, %r1		; rotate low 32-bits to the left x bits
+	;xsll	%r2, %r1		; make a mask for first 32-x bits --> %r2 = 111...000
+
+	ld.w	%r8, -1			; mask(%r8) = 0xffff ffff
+	; 64-bit variable shift and rotate routine
+L3:
+	cmp		%r5, 8			; if ｻﾘｿﾉ(%r5) <= 8 then goto L2
+	jrle	L4
+
+	sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+	rl		%r6, 8			; ｰｿ｣ｲ(%r6) rotate << 8
+	sll		%r8, 8			; mask(%r8) << 8
+	jp.d	L3
+	sub		%r5, 8			; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) - 8 
+
+L4:
+	sll		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) << ｻﾘｿﾉ(%r5)
+	rl		%r6, %r5		; ｰｿ｣ｲ(%r6) rotate << ｻﾘｿﾉ(%r5)
+	sll		%r8, %r5		; mask(%r8) << ｻﾘｿﾉ(%r5)
+
+	not		%r5, %r8		; ｻﾘｿﾉ(%r5) = ~mask(%r8) flip mask for last x bits --> %r9 = 000...111 (mask)
+	and		%r5, %r6		; ｻﾘｿﾉ(%r5) = ｻﾘｿﾉ(%r5) & ｰｿ｣ｲ(%r6) isolate last x bits of %r6
+	or		%r4, %r5		; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) & ｻﾘｿﾉ(%r5) add last x bits of %r6 to %r4
+	and		%r6, %r8		; ｰｿ(%r6) = ｰｿ｣ｲ(%r6) & mask(%r8) keep the high 32-x bits of %r6
+
+finish:
+	cmp		%r0, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 0 then goto end
+	jreq	end
+	
+	; case: sign = 1
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+	jp.d	end
+	add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+
+overflow:
+	cmp		%r0, 0			; check sign
+	jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) = 1 then goto end
+	ld.w	%r4, 0			; ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣01/01/17  Hinokuchi 
+	not		%r4, %r4		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0xffffffff
+
+end:
+	popn	%r0				; %r0 ﾉｵ｢
+	ret
diff --git a/gcc/config/c33/libgcc/fixsfi.lst b/gcc/config/c33/libgcc/fixsfi.lst
new file mode 100644
index 0000000..01e67e8
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixsfi.lst
@@ -0,0 +1,110 @@
+GAS LISTING fixsfi.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : fixsfui.s
+   6              	;*
+   7              	;*	Change type: Single float --> Unsigned integer
+   8              	;*							  --> Signed integer
+   9              	;*		input: %r6
+  10              	;*		output: %r4
+  11              	;*
+  12              	;*	Begin		1996/09/12	V. Chan
+  13              	;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+  14              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  15              	;*				 ｡ｦ__fixunssfsi ･ﾕ･｡･､･ﾊｬｳ荀ﾎ､ｿ､蘯ｽ 
+  16              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  17              	;*********************************************
+  18              	
+  19              	.section .text
+  20              	.align 1
+  21              	.global __fixsfsi
+  22              	
+  23              	;==============================================
+  24              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  25              	;	%r4:ﾌ皃ﾃﾍ(int or uint)
+  26              	;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+  27              	;	%r6:ｰｿ｣ｱ(float)
+  28              	;	%r7:ｻﾘｿﾉ(8bit)
+  29              	;	%r8:shift
+  30              	;
+  31              	;==============================================
+  32              	
+  33              	__fixsfsi:
+  34              	
+  35 0000 652E     		ld.w	%r5, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) <- ｰｿ｣ｱ(%r6)  
+  36 0002 159C     		rl		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) >> 31 ､ﾈﾆｱ､ｸ
+  37 0004 1570     		and		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) & 1
+  38              	
+  39 0006 672E     		ld.w	%r7, %r6		; ｻﾘｿﾉ(%r7) <- ｰｿ｣ｱ(%r6) 
+  40 0008 178C     		sll		%r7, 1			; ｻﾘｿﾉ(%r7) << 1
+  41 000a 87888788 		xsrl 	%r7, 24			; ｻﾘｿﾉ(%r7) >> 24		
+  41      8788
+  42              								;
+  43              								;
+  44              								;							
+  45 0010 01C0F76B 		xcmp	%r7, 0x7f		; if ｻﾘｿﾉ(%r7) < 0x7f then goto end
+  46 0014 240D     		jrlt.d	end				; round to zero case (integer underflow)
+  47 0016 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 
+  48              	
+  49 0018 02C0F769 		xcmp	%r7, 0x9f		; if ｻﾘｿﾉ(%r7) >= 0x9f then integer overflow
+  50 001c 146C     		ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+  51 001e 1C0B     		jrge.d	overflow
+  52 0020 1498     		rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 0x8000 0000
+  53              	
+  54              		; isolate mantissa
+  55 0022 642E     		ld.w	%r4,%r6			; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r6) 
+  56 0024 0FC0FFDF 		xand	%r4,0x7fffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0x7fffff) clear first 9 bits of %r6
+GAS LISTING fixsfi.s 			page 2
+
+
+  56      F473
+  57 002a 10C000C0 		xoor	%r4,0x800000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x800000) add implied bit
+  57      0474
+  58              	
+  59 0030 02C0686D 		xld.w	%r8, 0x96		;shift(%r8) <- 0x96
+  60              	
+  61 0034 872A     		cmp		%r7, %r8		; 0x7f + 31 - 8 = 0x96
+  62 0036 0908     		jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x96 then goto shftleft
+  63              	
+  64              		; case: exp <= 0x96
+  65 0038 7826     		sub		%r8, %r7		; shift(%r8) = shift(%r8=0x96) - ｻﾘｿﾉ(%r7) (max = 23)
+  66              	
+  67              		; 32-bit variable right shift routine (faster than xsrl)
+  68              	shift:
+  69 003a 8868     		cmp		%r8, 8			; if shift(%r8) <= 8 then goto done
+  70 003c 040E     		jrle	done
+  71              		
+  72              		; case: shift > 8
+  73 003e 8864     		sub		%r8, 8			; shift(%r8) = shift(%r8) - 8
+  74 0040 FD1F     		jp.d	shift
+  75 0042 8488     		srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+  76              	
+  77              	done:						; case: shift(%r8) < 8
+  78 0044 041F     		jp.d	finish
+  79 0046 8489     		srl		%r4, %r8		; ﾌ皃ﾃﾍ(%r4) >> shift(%r8) final shift of result
+  80              		
+  81              	shftleft:
+  82 0048 8726     		sub		%r7, %r8		; ｻﾘｿﾉ(%r7) = ｻﾘｿﾉ(%r7) - shift(%r8=0x96) (max = 8)
+  83              			
+  84 004a 748D     		sll		%r4, %r7		; ﾌ皃ﾃﾍ(%r4) >> ｻﾘｿﾉ(%r7) shift mantissa to the left 8-shift bits
+  85              	
+  86              	finish:
+  87 004c 0568     		cmp		%r5, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 0 then goto end
+  88 004e 0718     		jreq	end
+  89              	
+  90              		; case: sign = 1
+  91 0050 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+  92 0052 051F     		jp.d	end
+  93 0054 1460     		add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+  94              	
+  95              	overflow:
+  96 0056 0568     		cmp		%r5, 0			; check sign
+  97 0058 021A     		jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 1 then goto end
+  98 005a 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) <- 0xffffffff
+  99              	
+ 100              	end:
+ 101 005c 4006     		ret
diff --git a/gcc/config/c33/libgcc/fixsfi.s b/gcc/config/c33/libgcc/fixsfi.s
new file mode 100644
index 0000000..74a29d4
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixsfi.s
@@ -0,0 +1,101 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : fixsfui.s
+;*
+;*	Change type: Single float --> Unsigned integer
+;*							  --> Signed integer
+;*		input: %r6
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*				 ｡ｦ__fixunssfsi ･ﾕ･｡･､･ﾊｬｳ荀ﾎ､ｿ､蘯ｽ 
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*********************************************
+
+.section .text
+.align 1
+.global __fixsfsi
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r4:ﾌ皃ﾃﾍ(int or uint)
+;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+;	%r6:ｰｿ｣ｱ(float)
+;	%r7:ｻﾘｿﾉ(8bit)
+;	%r8:shift
+;
+;==============================================
+
+__fixsfsi:
+
+	ld.w	%r5, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) <- ｰｿ｣ｱ(%r6)  
+	rl		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) >> 31 ､ﾈﾆｱ､ｸ
+	and		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) & 1
+
+	ld.w	%r7, %r6		; ｻﾘｿﾉ(%r7) <- ｰｿ｣ｱ(%r6) 
+	sll		%r7, 1			; ｻﾘｿﾉ(%r7) << 1
+	xsrl 	%r7, 24			; ｻﾘｿﾉ(%r7) >> 24		
+							;
+							;
+							;							
+	xcmp	%r7, 0x7f		; if ｻﾘｿﾉ(%r7) < 0x7f then goto end
+	jrlt.d	end				; round to zero case (integer underflow)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 
+
+	xcmp	%r7, 0x9f		; if ｻﾘｿﾉ(%r7) >= 0x9f then integer overflow
+	ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+	jrge.d	overflow
+	rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 0x8000 0000
+
+	; isolate mantissa
+	ld.w	%r4,%r6			; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r6) 
+	xand	%r4,0x7fffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0x7fffff) clear first 9 bits of %r6
+	xoor	%r4,0x800000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x800000) add implied bit
+
+	xld.w	%r8, 0x96		;shift(%r8) <- 0x96
+
+	cmp		%r7, %r8		; 0x7f + 31 - 8 = 0x96
+	jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x96 then goto shftleft
+
+	; case: exp <= 0x96
+	sub		%r8, %r7		; shift(%r8) = shift(%r8=0x96) - ｻﾘｿﾉ(%r7) (max = 23)
+
+	; 32-bit variable right shift routine (faster than xsrl)
+shift:
+	cmp		%r8, 8			; if shift(%r8) <= 8 then goto done
+	jrle	done
+	
+	; case: shift > 8
+	sub		%r8, 8			; shift(%r8) = shift(%r8) - 8
+	jp.d	shift
+	srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+
+done:						; case: shift(%r8) < 8
+	jp.d	finish
+	srl		%r4, %r8		; ﾌ皃ﾃﾍ(%r4) >> shift(%r8) final shift of result
+	
+shftleft:
+	sub		%r7, %r8		; ｻﾘｿﾉ(%r7) = ｻﾘｿﾉ(%r7) - shift(%r8=0x96) (max = 8)
+		
+	sll		%r4, %r7		; ﾌ皃ﾃﾍ(%r4) >> ｻﾘｿﾉ(%r7) shift mantissa to the left 8-shift bits
+
+finish:
+	cmp		%r5, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 0 then goto end
+	jreq	end
+
+	; case: sign = 1
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+	jp.d	end
+	add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+
+overflow:
+	cmp		%r5, 0			; check sign
+	jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 1 then goto end
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) <- 0xffffffff
+
+end:
+	ret
diff --git a/gcc/config/c33/libgcc/fixsfui.lst b/gcc/config/c33/libgcc/fixsfui.lst
new file mode 100644
index 0000000..e372f06
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixsfui.lst
@@ -0,0 +1,127 @@
+GAS LISTING fixsfui.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : fixsfui.s
+   6              	;*
+   7              	;*	Change type: Single float --> Unsigned integer
+   8              	;*							  --> Signed integer
+   9              	;*		input: %r6
+  10              	;*		output: %r4
+  11              	;*
+  12              	;*	Begin		1996/09/12	V. Chan
+  13              	;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+  14              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+  15              	;*				 ｡ｦ･ﾕ･｡･､･ﾊｬｳ  __fixsfsi -> fixsfis.s ､ﾋｰﾜﾆｰ
+  16              	;*				 ｡ｦ･ﾞ･､･ﾊ･ｹ､ﾎﾃﾍ､ﾎ･ｭ･罕ｹ･ﾈ､ﾏ ｣ｰ  ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢
+  17              	;*                0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣(gcc､ﾎｽ靉､ﾈﾆｱｰ)
+  18              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  19              	;*********************************************
+  20              	
+  21              	.section .text
+  22              	.align 1
+  23              	.global __fixunssfsi
+  24              	
+  25              	;==============================================
+  26              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  27              	;	%r4:ﾌ皃ﾃﾍ(int or uint)
+  28              	;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+  29              	;	%r6:ｰｿ｣ｱ(float)
+  30              	;	%r7:ｻﾘｿﾉ(8bit)
+  31              	;	%r8:shift
+  32              	;
+  33              	;==============================================
+  34              	
+  35              	__fixunssfsi:
+  36              	
+  37 0000 642E     		ld.w	%r4, %r6
+  38 0002 00D000C0 		xand	%r4, 0x80000000				; if( ﾉ荵讌ﾓ･ﾃ･ﾈ == 0 )
+  38      0470
+  39              	
+  40 0008 00C000C0 		xjreq	start						;    goto __start
+  40      0318
+  41              											; else
+  42 000e 046C     		xld.w	%r4, 0x0					;	return 0
+  43 0010 4006     		ret
+  44              	start:
+  45              	
+  46 0012 652E     		ld.w	%r5, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) <- ｰｿ｣ｱ(%r6)  
+  47 0014 159C     		rl		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) >> 31 ､ﾈﾆｱ､ｸ
+  48 0016 1570     		and		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) & 1
+  49              	
+  50 0018 672E     		ld.w	%r7, %r6		; ｻﾘｿﾉ(%r7) <- ｰｿ｣ｱ(%r6) 
+  51 001a 178C     		sll		%r7, 1			; ｻﾘｿﾉ(%r7) << 1
+  52 001c 87888788 		xsrl 	%r7, 24			; ｻﾘｿﾉ(%r7) >> 24		
+  52      8788
+  53              								;
+  54              								;
+GAS LISTING fixsfui.s 			page 2
+
+
+  55              								;							
+  56 0022 01C0F76B 		xcmp	%r7, 0x7f		; if ｻﾘｿﾉ(%r7) < 0x7f then goto end
+  57 0026 250D     		jrlt.d	end				; round to zero case (integer underflow)
+  58 0028 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 
+  59              	
+  60 002a 02C0F769 		xcmp	%r7, 0x9f		; if ｻﾘｿﾉ(%r7) >= 0x9f then integer overflow
+  61 002e 146C     		ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+  62 0030 1C0B     		jrge.d	overflow
+  63 0032 1498     		rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 0x8000 0000
+  64              	
+  65              		; isolate mantissa
+  66 0034 642E     		ld.w	%r4,%r6			; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r6) 
+  67 0036 0FC0FFDF 		xand	%r4,0x7fffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0x7fffff) clear first 9 bits of %r6
+  67      F473
+  68 003c 10C000C0 		xoor	%r4,0x800000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x800000) add implied bit
+  68      0474
+  69              	
+  70 0042 02C0686D 		xld.w	%r8, 0x96		;shift(%r8) <- 0x96
+  71              	
+  72 0046 872A     		cmp		%r7, %r8		; 0x7f + 31 - 8 = 0x96
+  73 0048 0908     		jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x96 then goto shftleft
+  74              	
+  75              		; case: exp <= 0x96
+  76 004a 7826     		sub		%r8, %r7		; shift(%r8) = shift(%r8=0x96) - ｻﾘｿﾉ(%r7) (max = 23)
+  77              	
+  78              		; 32-bit variable right shift routine (faster than xsrl)
+  79              	shift:
+  80 004c 8868     		cmp		%r8, 8			; if shift(%r8) <= 8 then goto done
+  81 004e 040E     		jrle	done
+  82              		
+  83              		; case: shift > 8
+  84 0050 8864     		sub		%r8, 8			; shift(%r8) = shift(%r8) - 8
+  85 0052 FD1F     		jp.d	shift
+  86 0054 8488     		srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+  87              	
+  88              	done:						; case: shift(%r8) < 8
+  89 0056 041F     		jp.d	finish
+  90 0058 8489     		srl		%r4, %r8		; ﾌ皃ﾃﾍ(%r4) >> shift(%r8) final shift of result
+  91              		
+  92              	shftleft:
+  93 005a 8726     		sub		%r7, %r8		; ｻﾘｿﾉ(%r7) = ｻﾘｿﾉ(%r7) - shift(%r8=0x96) (max = 8)
+  94              			
+  95 005c 748D     		sll		%r4, %r7		; ﾌ皃ﾃﾍ(%r4) >> ｻﾘｿﾉ(%r7) shift mantissa to the left 8-shift bits
+  96              	
+  97              	finish:
+  98 005e 0568     		cmp		%r5, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 0 then goto end
+  99 0060 0818     		jreq	end
+ 100              	
+ 101              		; case: sign = 1
+ 102 0062 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+ 103 0064 061F     		jp.d	end
+ 104 0066 1460     		add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+ 105              	
+ 106              	overflow:
+ 107 0068 0568     		cmp		%r5, 0			; check sign
+ 108 006a 031A     		jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 1 then goto end
+ 109 006c 046C     		ld.w	%r4, 0			; ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣01/01/17  Hinokuchi 
+GAS LISTING fixsfui.s 			page 3
+
+
+ 110 006e 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) <- 0xffffffff
+ 111              	
+ 112              	end:
+ 113 0070 4006     		ret
diff --git a/gcc/config/c33/libgcc/fixsfui.s b/gcc/config/c33/libgcc/fixsfui.s
new file mode 100644
index 0000000..f3ecb8c
--- /dev/null
+++ b/gcc/config/c33/libgcc/fixsfui.s
@@ -0,0 +1,113 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : fixsfui.s
+;*
+;*	Change type: Single float --> Unsigned integer
+;*							  --> Signed integer
+;*		input: %r6
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖ､ｭｴｹ､ｨ
+;*				 ｡ｦ･ﾕ･｡･､･ﾊｬｳ  __fixsfsi -> fixsfis.s ､ﾋｰﾜﾆｰ
+;*				 ｡ｦ･ﾞ･､･ﾊ･ｹ､ﾎﾃﾍ､ﾎ･ｭ･罕ｹ･ﾈ､ﾏ ｣ｰ  ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢
+;*                0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣(gcc､ﾎｽ靉､ﾈﾆｱｰ)
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*********************************************
+
+.section .text
+.align 1
+.global __fixunssfsi
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r4:ﾌ皃ﾃﾍ(int or uint)
+;	%r5:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+;	%r6:ｰｿ｣ｱ(float)
+;	%r7:ｻﾘｿﾉ(8bit)
+;	%r8:shift
+;
+;==============================================
+
+__fixunssfsi:
+
+	ld.w	%r4, %r6
+	xand	%r4, 0x80000000				; if( ﾉ荵讌ﾓ･ﾃ･ﾈ == 0 )
+
+	xjreq	start						;    goto __start
+										; else
+	xld.w	%r4, 0x0					;	return 0
+	ret
+start:
+
+	ld.w	%r5, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) <- ｰｿ｣ｱ(%r6)  
+	rl		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) >> 31 ､ﾈﾆｱ､ｸ
+	and		%r5, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) & 1
+
+	ld.w	%r7, %r6		; ｻﾘｿﾉ(%r7) <- ｰｿ｣ｱ(%r6) 
+	sll		%r7, 1			; ｻﾘｿﾉ(%r7) << 1
+	xsrl 	%r7, 24			; ｻﾘｿﾉ(%r7) >> 24		
+							;
+							;
+							;							
+	xcmp	%r7, 0x7f		; if ｻﾘｿﾉ(%r7) < 0x7f then goto end
+	jrlt.d	end				; round to zero case (integer underflow)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0 
+
+	xcmp	%r7, 0x9f		; if ｻﾘｿﾉ(%r7) >= 0x9f then integer overflow
+	ld.w	%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 1
+	jrge.d	overflow
+	rr		%r4, 1			; ﾌ皃ﾃﾍ(%r4) <- 0x8000 0000
+
+	; isolate mantissa
+	ld.w	%r4,%r6			; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(%r6) 
+	xand	%r4,0x7fffff	; ﾌ皃ﾃﾍ(%r4) <- ﾌ皃ﾃﾍ(%r4) & 0x7fffff) clear first 9 bits of %r6
+	xoor	%r4,0x800000	; ﾌ皃ﾃﾍ(%r4) <- (ﾌ皃ﾃﾍ(%r4) | 0x800000) add implied bit
+
+	xld.w	%r8, 0x96		;shift(%r8) <- 0x96
+
+	cmp		%r7, %r8		; 0x7f + 31 - 8 = 0x96
+	jrgt	shftleft		; if ｻﾘｿﾉ(%r7) > 0x96 then goto shftleft
+
+	; case: exp <= 0x96
+	sub		%r8, %r7		; shift(%r8) = shift(%r8=0x96) - ｻﾘｿﾉ(%r7) (max = 23)
+
+	; 32-bit variable right shift routine (faster than xsrl)
+shift:
+	cmp		%r8, 8			; if shift(%r8) <= 8 then goto done
+	jrle	done
+	
+	; case: shift > 8
+	sub		%r8, 8			; shift(%r8) = shift(%r8) - 8
+	jp.d	shift
+	srl		%r4, 8			; ﾌ皃ﾃﾍ(%r4) >> 8
+
+done:						; case: shift(%r8) < 8
+	jp.d	finish
+	srl		%r4, %r8		; ﾌ皃ﾃﾍ(%r4) >> shift(%r8) final shift of result
+	
+shftleft:
+	sub		%r7, %r8		; ｻﾘｿﾉ(%r7) = ｻﾘｿﾉ(%r7) - shift(%r8=0x96) (max = 8)
+		
+	sll		%r4, %r7		; ﾌ皃ﾃﾍ(%r4) >> ｻﾘｿﾉ(%r7) shift mantissa to the left 8-shift bits
+
+finish:
+	cmp		%r5, 0			; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 0 then goto end
+	jreq	end
+
+	; case: sign = 1
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4)
+	jp.d	end
+	add		%r4, 1			; ﾌ皃ﾃﾍ(%r4) = ﾌ皃ﾃﾍ(%r4) + 1 (｣ｲ､ﾎﾊ菫)
+
+overflow:
+	cmp		%r5, 0			; check sign
+	jrne	end				; if ﾉ荵讌ﾓ･ﾃ･ﾈ(%r5) = 1 then goto end
+	ld.w	%r4, 0			; ･ｪ｡ｼ･ﾐ｡ｼ･ﾕ･｡ｼ､ｹ､ｻ､ﾏ｡｢0xffffffff､ﾊﾖ､ｹ､隍ｦ､ﾋｽ､ﾀｵ｡｣01/01/17  Hinokuchi 
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) <- 0xffffffff
+
+end:
+	ret
diff --git a/gcc/config/c33/libgcc/flosidf.lst b/gcc/config/c33/libgcc/flosidf.lst
new file mode 100644
index 0000000..dfe220f
--- /dev/null
+++ b/gcc/config/c33/libgcc/flosidf.lst
@@ -0,0 +1,107 @@
+GAS LISTING flosidf.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : flosidf.s
+   6              	;*
+   7              	;*	Change type: Signed single integer --> Double float
+   8              	;*		input: %r6
+   9              	;*		output: (%r5, %r4)
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*********************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __floatsidf
+  21              	
+  22              	;==============================================
+  23              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  24              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+  25              	;	%r1:ｻﾘｿﾉ(8bit)
+  26              	;	%r4:ﾌ皃ﾃﾍ[L](double)
+  27              	;	%r5:ﾌ皃ﾃﾍ[H](double)
+  28              	;	%r6:ｰｿ｣ｱ(int)/loop counter
+  29              	;	%r8:temp
+  30              	;	%r9:count/shift
+  31              	;==============================================
+  32              	
+  33              	__floatsidf:
+  34 0000 0102     		pushn	%r1				; %r0｡ﾁ%r1 ﾂﾔﾈ
+  35              	
+  36 0002 056C     		ld.w	%r5, 0			; ﾌ皃ﾃﾍ[H](%r5) <- 0
+  37              		
+  38 0004 0668     		cmp		%r6, 0			; if ｰｿ｣ｱ(%r6) = 0 then goto end
+  39 0006 2819     		jreq.d	end
+  40 0008 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ[L](%r4) <- 0
+  41              	
+  42 000a 006C     		ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0
+  43 000c 652E     		ld.w	%r5, %r6		; ﾌ皃ﾃﾍ[H](%r5) <- ｰｿ｣ｱ(%r6)
+  44 000e 582E     		ld.w	%r8, %r5		; temp(%r8) <- ﾌ皃ﾃﾍ[H](%r5)
+  45              		
+  46 0010 0568     		cmp		%r5, 0			; if ﾌ皃ﾃﾍ[H](%r5) >= 0 then goto count
+  47 0012 060B     		jrge.d	count
+  48 0014 066C     		ld.w	%r6, 0			; loop counter(%r6) <- 0 
+  49              	
+  50              		; case: result1 < 0
+  51 0016 553E     		not		%r5, %r5		; ﾌ皃ﾃﾍ[H](%r5) = ~ﾌ皃ﾃﾍ[H](%r5) + 1
+  52 0018 1560     		add		%r5, 1
+  53 001a 106C     		ld.w	%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 1
+  54 001c 582E     		ld.w	%r8, %r5		; temp(%r8) <- ﾌ皃ﾃﾍ(%r4)
+  55              	
+  56              	count:						; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖｸ｡ｺ
+  57 001e 898E     		scan1	%r9, %r8		; count(%r9) <- temp(8)[b31｡ﾁb24]､ﾎｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ   
+GAS LISTING flosidf.s 			page 2
+
+
+  58 0020 0412     		jruge	continue		; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈ､ｬｸｫ､ﾄ､ｫ､ﾃ､ｿ､->continue
+  59 0022 8660     		add		%r6, 8			; loop counter(%r6) = loop counter(%r6) + 8
+  60 0024 FD1F     		jp.d	count
+  61 0026 888C     		sll		%r8, 8			; temp(%r8) << 8 
+  62              	
+  63              	continue:
+  64 0028 6922     		add		%r9, %r6		; count(%r9) = count(%r9) + loop counter(%r6)
+  65 002a F16D     		xld.w	%r1, 31			; ｻﾘｿﾉ(%r1) = 31 - count(%r9) 
+  66 002c 9126     		sub		%r1, %r9
+  67              	
+  68              		; normalize result
+  69 002e 1960     		add		%r9, 1			; shift(%r9) = count(%r9) + 1
+  70              	
+  71              		;xsll	%r5, %r9		; result1 << count + 1 (clear implied bit)
+  72              		; variable shift routine (faster than xsrl)
+  73              	shift:
+  74 0030 8968     		cmp		%r9, 8			; if shift <= 8 then goto done
+  75 0032 040E     		jrle	done
+  76              		
+  77              		; case: shift > 8
+  78 0034 8964     		sub		%r9, 8			; shift(%r9) = shift(%r9) - 8
+  79 0036 FD1F     		jp.d	shift
+  80 0038 858C     		sll		%r5, 8			; ﾌ皃ﾃﾍ[H](%r5) << 8
+  81              	
+  82              	done:						; case: shift(%r9) <= 8
+  83 003a 958D     		sll		%r5, %r9		; ﾌ皃ﾃﾍ[H](%r5) << shift(%r9) 
+  84              	
+  85 003c 542E     		ld.w	%r4, %r5		; ﾌ皃ﾃﾍ[L](%r4) <- ﾌ皃ﾃﾍ[H](%r5)
+  86 003e 85884588 		xsrl	%r5, 12			; ﾌ皃ﾃﾍ[H](%r5) >> 12
+  87 0042 848C848C 		xsll	%r4, 20			; ﾌ皃ﾃﾍ[L](%r4) << 20
+  87      448C
+  88              	
+  89              		; finishing steps
+  90 0048 0FC0F163 		xadd	%r1, 0x3ff		; ｻﾘｿﾉ(%r1) = ｻﾘｿﾉ(%r1) + 0x3ff(bias) (EXT33 Ve%r2)
+  91              	
+  92 004c 81984198 		xrr		%r1, 12			; position exponent bits
+  93 0050 1536     		or		%r5, %r1		; ﾌ皃ﾃﾍ[H](%r5) | ｻﾘｿﾉ(%r1) 
+  94              	
+  95 0052 1098     		rr		%r0, 1			; position sign bit
+  96 0054 0536     		or		%r5, %r0		; ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ
+  97              	
+  98              	end:
+  99 0056 4102     		popn	%r1				; %r0｡ﾁ%r1 ﾉｵ｢
+ 100 0058 4006     		ret
diff --git a/gcc/config/c33/libgcc/flosidf.s b/gcc/config/c33/libgcc/flosidf.s
new file mode 100644
index 0000000..4b7fb78
--- /dev/null
+++ b/gcc/config/c33/libgcc/flosidf.s
@@ -0,0 +1,100 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : flosidf.s
+;*
+;*	Change type: Signed single integer --> Double float
+;*		input: %r6
+;*		output: (%r5, %r4)
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __floatsidf
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ(8bit)
+;	%r4:ﾌ皃ﾃﾍ[L](double)
+;	%r5:ﾌ皃ﾃﾍ[H](double)
+;	%r6:ｰｿ｣ｱ(int)/loop counter
+;	%r8:temp
+;	%r9:count/shift
+;==============================================
+
+__floatsidf:
+	pushn	%r1				; %r0｡ﾁ%r1 ﾂﾔﾈ
+
+	ld.w	%r5, 0			; ﾌ皃ﾃﾍ[H](%r5) <- 0
+	
+	cmp		%r6, 0			; if ｰｿ｣ｱ(%r6) = 0 then goto end
+	jreq.d	end
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ[L](%r4) <- 0
+
+	ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0
+	ld.w	%r5, %r6		; ﾌ皃ﾃﾍ[H](%r5) <- ｰｿ｣ｱ(%r6)
+	ld.w	%r8, %r5		; temp(%r8) <- ﾌ皃ﾃﾍ[H](%r5)
+	
+	cmp		%r5, 0			; if ﾌ皃ﾃﾍ[H](%r5) >= 0 then goto count
+	jrge.d	count
+	ld.w	%r6, 0			; loop counter(%r6) <- 0 
+
+	; case: result1 < 0
+	not		%r5, %r5		; ﾌ皃ﾃﾍ[H](%r5) = ~ﾌ皃ﾃﾍ[H](%r5) + 1
+	add		%r5, 1
+	ld.w	%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 1
+	ld.w	%r8, %r5		; temp(%r8) <- ﾌ皃ﾃﾍ(%r4)
+
+count:						; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖｸ｡ｺ
+	scan1	%r9, %r8		; count(%r9) <- temp(8)[b31｡ﾁb24]､ﾎｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ   
+	jruge	continue		; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈ､ｬｸｫ､ﾄ､ｫ､ﾃ､ｿ､->continue
+	add		%r6, 8			; loop counter(%r6) = loop counter(%r6) + 8
+	jp.d	count
+	sll		%r8, 8			; temp(%r8) << 8 
+
+continue:
+	add		%r9, %r6		; count(%r9) = count(%r9) + loop counter(%r6)
+	xld.w	%r1, 31			; ｻﾘｿﾉ(%r1) = 31 - count(%r9) 
+	sub		%r1, %r9
+
+	; normalize result
+	add		%r9, 1			; shift(%r9) = count(%r9) + 1
+
+	;xsll	%r5, %r9		; result1 << count + 1 (clear implied bit)
+	; variable shift routine (faster than xsrl)
+shift:
+	cmp		%r9, 8			; if shift <= 8 then goto done
+	jrle	done
+	
+	; case: shift > 8
+	sub		%r9, 8			; shift(%r9) = shift(%r9) - 8
+	jp.d	shift
+	sll		%r5, 8			; ﾌ皃ﾃﾍ[H](%r5) << 8
+
+done:						; case: shift(%r9) <= 8
+	sll		%r5, %r9		; ﾌ皃ﾃﾍ[H](%r5) << shift(%r9) 
+
+	ld.w	%r4, %r5		; ﾌ皃ﾃﾍ[L](%r4) <- ﾌ皃ﾃﾍ[H](%r5)
+	xsrl	%r5, 12			; ﾌ皃ﾃﾍ[H](%r5) >> 12
+	xsll	%r4, 20			; ﾌ皃ﾃﾍ[L](%r4) << 20
+
+	; finishing steps
+	xadd	%r1, 0x3ff		; ｻﾘｿﾉ(%r1) = ｻﾘｿﾉ(%r1) + 0x3ff(bias) (EXT33 Ve%r2)
+
+	xrr		%r1, 12			; position exponent bits
+	or		%r5, %r1		; ﾌ皃ﾃﾍ[H](%r5) | ｻﾘｿﾉ(%r1) 
+
+	rr		%r0, 1			; position sign bit
+	or		%r5, %r0		; ﾌ皃ﾃﾍ[H](%r5) | ﾉ荵讌ﾓ･ﾃ･ﾈ
+
+end:
+	popn	%r1				; %r0｡ﾁ%r1 ﾉｵ｢
+	ret
diff --git a/gcc/config/c33/libgcc/flosisf.lst b/gcc/config/c33/libgcc/flosisf.lst
new file mode 100644
index 0000000..de8877b
--- /dev/null
+++ b/gcc/config/c33/libgcc/flosisf.lst
@@ -0,0 +1,102 @@
+GAS LISTING flosisf.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : flosisf.s
+   6              	;*
+   7              	;*	Change type: Signed single integer --> Single float
+   8              	;*		input: %r6
+   9              	;*		output: %r4
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*********************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __floatsisf
+  21              	
+  22              	;==============================================
+  23              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  24              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+  25              	;	%r1:ｻﾘｿﾉ(8bit)
+  26              	;	%r4:ﾌ皃ﾃﾍ(float)
+  27              	;	%r6:ｰｿ｣ｱ(int)/loop counter
+  28              	;	%r8:temp
+  29              	;	%r9:count/shift
+  30              	;==============================================
+  31              	
+  32              	__floatsisf:
+  33              	
+  34 0000 0102     		pushn	%r1				; %r0｡ﾁ%r1 ﾂﾔﾈ
+  35              	
+  36 0002 0668     		cmp		%r6, 0			; if ｰｿ｣ｱ(6) = 0 then goto end
+  37 0004 2419     		jreq.d	end
+  38 0006 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(4) <- 0 
+  39              	
+  40 0008 006C     		ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0
+  41 000a 642E     		ld.w	%r4, %r6		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(6)
+  42 000c 682E     		ld.w	%r8, %r6		; count(%r8) <- ｰｿ｣ｱ(6) 
+  43              	
+  44 000e 0468     		cmp		%r4, 0			; if ﾌ皃ﾃﾍ(%r4) >= 0 then goto count
+  45 0010 060B     		jrge.d	count
+  46 0012 066C     		ld.w	%r6, 0			; loop counter(%r6) <- 0 
+  47              	
+  48              		; case: ﾌ皃ﾃﾍ(%r4) < 0
+  49 0014 443E     		not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4) + 1
+  50 0016 1460     		add		%r4, 1
+  51 0018 106C     		ld.w	%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 1
+  52 001a 482E     		ld.w	%r8, %r4		; temp(%r8) <- ﾌ皃ﾃﾍ(%r4)
+  53              	
+  54              	count:						; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖｸ｡ｺ
+  55 001c 898E     		scan1	%r9, %r8		; count(%r9) <- temp(8)[b31｡ﾁb24]､ﾎｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ   
+  56 001e 0412     		jruge	continue		; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈ､ｬｸｫ､ﾄ､ｫ､ﾃ､ｿ､->continue
+  57 0020 8660     		add		%r6, 8			; loop counter(%r6) = loop counter(%r6) + 8
+GAS LISTING flosisf.s 			page 2
+
+
+  58 0022 FD1F     		jp.d	count
+  59 0024 888C     		sll		%r8, 8			; temp(%r8) << 8 
+  60              	
+  61              	continue:
+  62 0026 6922     		add		%r9, %r6		; count(%r9) = count(%r9) + loop counter(%r6)
+  63 0028 F16D     		ld.w	%r1, 31			; ｻﾘｿﾉ(%r1) = 31 - count(%r9) 
+  64 002a 9126     		sub		%r1, %r9
+  65              	
+  66              		; normalize result
+  67 002c 1960     		add		%r9, 1			; shift(%r9) = count(%r9) + 1
+  68              		
+  69              		;xsll	%r4, %r7		; result << count + 1 (clear implied bit)
+  70              		; variable shift routine (faster than xsrl)
+  71              	shift:
+  72 002e 8968     		cmp		%r9, 8			; if shift(%r9) <= 8 then goto done
+  73 0030 040E     		jrle	done
+  74              		
+  75              		; case: shift(%r9) > 8
+  76 0032 8964     		sub		%r9, 8			; shift(%r9) = shift(%r9) - 8
+  77 0034 FD1F     		jp.d	shift
+  78 0036 848C     		sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+  79              	
+  80              	done:						; case: shift(%r9) < 8
+  81 0038 948D     		sll		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) << shift(%r9) 
+  82              	
+  83 003a 84881488 		xsrl	%r4, 9			; ﾌ皃ﾃﾍ(%r4) >> 9 (normal position)
+  84              	
+  85              		; finishing steps
+  86 003e 01C0F163 		xadd	%r1, 0x7f		; ｻﾘｿﾉ(%r1) = ｻﾘｿﾉ(%r1) + 0x7f(bias) (EXT33 Ve%r2)
+  87              	
+  88 0042 81981198 		xrr		%r1, 9			; position exponent bits
+  89 0046 1436     		or		%r4, %r1		; ﾌ皃ﾃﾍ(%r4) | ｻﾘｿﾉ(%r1) 
+  90              	
+  91 0048 1098     		rr		%r0, 1			; position sign bit
+  92 004a 0436     		or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) | ﾉ荵讌ﾓ･ﾃ･ﾈ
+  93              	
+  94              	end:
+  95 004c 4102     		popn	%r1				; %r0｡ﾁ%r1 ﾉｵ｢
+  96 004e 4006     		ret
diff --git a/gcc/config/c33/libgcc/flosisf.s b/gcc/config/c33/libgcc/flosisf.s
new file mode 100644
index 0000000..580baba
--- /dev/null
+++ b/gcc/config/c33/libgcc/flosisf.s
@@ -0,0 +1,96 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : flosisf.s
+;*
+;*	Change type: Signed single integer --> Single float
+;*		input: %r6
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __floatsisf
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ(8bit)
+;	%r4:ﾌ皃ﾃﾍ(float)
+;	%r6:ｰｿ｣ｱ(int)/loop counter
+;	%r8:temp
+;	%r9:count/shift
+;==============================================
+
+__floatsisf:
+
+	pushn	%r1				; %r0｡ﾁ%r1 ﾂﾔﾈ
+
+	cmp		%r6, 0			; if ｰｿ｣ｱ(6) = 0 then goto end
+	jreq.d	end
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(4) <- 0 
+
+	ld.w	%r0, 0			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 0
+	ld.w	%r4, %r6		; ﾌ皃ﾃﾍ(%r4) <- ｰｿ｣ｱ(6)
+	ld.w	%r8, %r6		; count(%r8) <- ｰｿ｣ｱ(6) 
+
+	cmp		%r4, 0			; if ﾌ皃ﾃﾍ(%r4) >= 0 then goto count
+	jrge.d	count
+	ld.w	%r6, 0			; loop counter(%r6) <- 0 
+
+	; case: ﾌ皃ﾃﾍ(%r4) < 0
+	not		%r4, %r4		; ﾌ皃ﾃﾍ(%r4) = ~ﾌ皃ﾃﾍ(%r4) + 1
+	add		%r4, 1
+	ld.w	%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ(%r0) <- 1
+	ld.w	%r8, %r4		; temp(%r8) <- ﾌ皃ﾃﾍ(%r4)
+
+count:						; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖｸ｡ｺ
+	scan1	%r9, %r8		; count(%r9) <- temp(8)[b31｡ﾁb24]､ﾎｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈｰﾌﾃﾖ   
+	jruge	continue		; ｺﾇｾ蟆ﾌ･ﾓ･ﾃ･ﾈ､ｬｸｫ､ﾄ､ｫ､ﾃ､ｿ､->continue
+	add		%r6, 8			; loop counter(%r6) = loop counter(%r6) + 8
+	jp.d	count
+	sll		%r8, 8			; temp(%r8) << 8 
+
+continue:
+	add		%r9, %r6		; count(%r9) = count(%r9) + loop counter(%r6)
+	ld.w	%r1, 31			; ｻﾘｿﾉ(%r1) = 31 - count(%r9) 
+	sub		%r1, %r9
+
+	; normalize result
+	add		%r9, 1			; shift(%r9) = count(%r9) + 1
+	
+	;xsll	%r4, %r7		; result << count + 1 (clear implied bit)
+	; variable shift routine (faster than xsrl)
+shift:
+	cmp		%r9, 8			; if shift(%r9) <= 8 then goto done
+	jrle	done
+	
+	; case: shift(%r9) > 8
+	sub		%r9, 8			; shift(%r9) = shift(%r9) - 8
+	jp.d	shift
+	sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+
+done:						; case: shift(%r9) < 8
+	sll		%r4, %r9		; ﾌ皃ﾃﾍ(%r4) << shift(%r9) 
+
+	xsrl	%r4, 9			; ﾌ皃ﾃﾍ(%r4) >> 9 (normal position)
+
+	; finishing steps
+	xadd	%r1, 0x7f		; ｻﾘｿﾉ(%r1) = ｻﾘｿﾉ(%r1) + 0x7f(bias) (EXT33 Ve%r2)
+
+	xrr		%r1, 9			; position exponent bits
+	or		%r4, %r1		; ﾌ皃ﾃﾍ(%r4) | ｻﾘｿﾉ(%r1) 
+
+	rr		%r0, 1			; position sign bit
+	or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) | ﾉ荵讌ﾓ･ﾃ･ﾈ
+
+end:
+	popn	%r1				; %r0｡ﾁ%r1 ﾉｵ｢
+	ret
diff --git a/gcc/config/c33/libgcc/libgcc.a b/gcc/config/c33/libgcc/libgcc.a
new file mode 100644
index 0000000000000000000000000000000000000000..ede81a7c5409425fc75ee043f60f721169ab364d
GIT binary patch
literal 21742
zcmeHPe{37qeSiEV(UdGp6eUrzCrY%$I9zg-D2Z0wlyz(;v0E>7Y&Uj_tfH)=Oxb5q
z7AeQcf-aIMiE5}cN$pr^<<0GcbtsA;%eu}Tf`Ti8q9}$o8-lF^g2fBEqU-uc>Lg3D
zuFXE*d-upEnpdB**xiOcfxP#*``)|9yYKh&ecyNAr_S4lCr6So&xbnJmfoI7-{8RD
zZPCGwjvoDx{N2&f--82siF+7hzr&dA75-Uwm@)d)z06qCi;T798Ebbl*6}^YHfI?N
zy}(#F$k?rIjP=AA>%(^7r;L60JB)3I%#I&1w(D1n-Tf)XKK3yG{9X@Z^!db(`Dgzz
z#`Yf@8X8trb+nHS4W*}!@Cx>%#U5T!$4>D>sPH|B)0xCL#MIFUP8}UNF`*jUG;POD
ztE1^LUYi<Emq1$HEr6C9&ZNiGQIhBNG}TW`Y5c0F@T-m|j`9nllGd-B9vL2w_Cq)`
zIW<0l>*#x_n`88wri!%_Db?6jtl?O)D8*|yX6!O*{O%|z@obCFbfBYSpogC4Kz~2J
zdwY7KROuZYh>B<Whj;G1%Vx9T(egsI5@KwhgYWOxH(QvSxfpwi71o`0*qL@xX;^8P
zc<%@Az505(VWMHVKH9MIl;U0SPQ3Szw9h*cT<(YlS0I<4&Q0g;&0TtxO#})*PuEBB
zeVi3+g+b5fmB##RZZ>xy_s*+<!t3ck;f?fczAxVsoz3;-oQiM7XI#TO;YEAi6-emk
zwt4uqeG|Ur?NQ%KZ@8v*O7SWEAyzneTve$3Mvu4stkSRe^nF>Srk0;0+9DZSyS=~)
zcFk6J@6|U`wxpx=?#NA12ex}6H%FaX^$+RSI0|p3v&&t$Qg)>a*BbE;xVtJI^C`Vb
z>6h*dIg|FbMwJyD$7*U%Db<=|bT;X%o6r3+FsnuvKid9gs!y3sR$<S=ayIu1eec$1
z`WJV`(vfKNLxH;^K9lS8ha70zhqj$)ds$hhIY+Z-JBPNj>h8sc_BT?ylq}lL<rbG`
z(KhYf^UTi0{@9tw?&xh1n=-x9x#GYx;dk1u1o8a3!p(kPvcAohT-WB**52g@W23R=
z_)QmG?a#z=F@Jo|#m=O=ZS7rEm27ZIIeXES^tqk2&g4FSz5A1~T`^zWu619eR-27h
zn<tu=<I(1oX63N52Tu%tn`{c{h%M=A`)2aiwp#)X+BcIo`&(<jsXiHYx*Jq`pjEk?
zdRm#s@0!bJS7!3R2+XUACH4G~rOmOOk%4Geq#^KR$d_x>4n!K4`=d>{hB#?lRqd~S
zzzQzS9dPPT`>pi!@*T@f(JBQ!Ku;3Uo%ZcjOi4d<A~Sph+sq{2CPgg+T4Bm$LK{|i
zRUOU@Gv!D+%`L^+_eO}3omCm)WM8k@4S<cPcB1Yq?Pi;*8S4V3^XPm!R*TOq1~$x<
zHH!-NQxP^DK^-K`#9=eJ21y20y}hkeF^Xu9wxX|e=m~V_CG12u83<qRUp=<#@DbNU
zmBsM`;2?@cv{&3wq2eh13VzVBrbTMssY`sT*dZJ9K=k=yTQ=5+`peSs7Q)i;4%B}l
z;Vr1YF5wTM{{3QSZEO%YBjJw#4@!6!@O}w@9Qcfc_X9sG;roHTQvW^;?2)hvT)N>l
z1_#Nyq~oN7_euC6;6Vw`0B0l&r_H`A;m-qqRl;8Yo|o{KfQ8Q1<8FTySQNs4Apo}Y
z+*#^WViFGXL6$h(tHEF*3_h8Sq{cI2<5LNCG?6(mJRV_i&WY0#3_f!>GnN`>`p$H6
zG;^YtrITZ$8QK6vIKpP^=s1aE4}JGCc)>CK)RENGc*bbyRDzACCQl4&V-F|T=-BvJ
zI>{#W_L#;ul?E4v!+rq2yJ{2vL7zsw+Nj4-cN=v+4yoXK;bANK-ag$G!~MoRSM$B!
zHS|LG-fFTY_}*&xUPs}rR9vZFsh@Bwle)(pHhe6+Y?u{T;VDnr@T;@A4&{KpFX!nE
zd)7ay_?5v>ZjAgRE6jU5?SqORIHR~~JM?{zv~PeXd^c5(<8F=o;nR_M-5;KdEJU00
zEqRyL8{XvK;I<|GieqE1(x}dcWS>?S=+@vrH~JO7ifh3mEx;q?)P=<+ts`9HuTNID
zx!}2&HX3sVn&S_~TH@Wn9m=VosyLG$Zgp!_Zt@o-Rj>JScPU36cY1U2Uk2v$GePnV
zGs&*D&F~E~YKOn6wlnOh+oH_iO4<A`12byZQd3|$)Sylqd!|+2Qf<J7mKx%8_wEh5
zYF~#haB8mhGm+`#hGk#0e%Wb}|KAVkSK|E9qV1Q=x)Ul#y9Hl<L6RYD6!0e0WiB_9
zE9Y{OBYz=^Xpgo<Q%C(0z;oD1_TGvQv`@F`axN#%e-6h)5$y?FX?rD?%U7n~&L!?C
zHpaR9zG7pX%Ren0CoWG)$2(AeM8d@7SqT%DzbIki@~=slxSaTp7aQA!%GU+NQy?yX
zMZ)_~|DlAbuYWJ$2T*@a!U@#hk?=U`|0UrJ>Q&P3`vYK~gy(?olQ41l4hf$H?vd~x
z0n6O|6<|?_yFVDN<|J*(&J&XfPSE@tq(728ekDm0*-su#W|*4b1dc$dJmy1egxKpE
zxOZ!><+vwq7@y3&rHF^eIGx-0m{&wTF3qX6<XdvpNoQMC(pHH3Tl1~CbwF;QkNZz5
z6a(E+76aJ|F+@NV|Lm+7|4^)BD{S*qZ1Oh7#O_wFW(O}<XY5*2;4ig|l2B}j#hkd#
zL1ORmJ07p{K04-XeKd~Ie%=;rQtq(R+3%(u$?Dbv3Z1<!(;WD^c1D@AaIRMs@z3S-
z%rZrEGb_QB1L5Yn1EEIsa%w=C!#I2)Kd+C&=hQ<>_nqIr)E!Gi4n;$e#&~leq6~zZ
z;+Ing^+;qfpVK9?>Yk<D=XWf1#j=q-(Jhhvv0&VRJJFY;2(UM_q44t&;FZmYPJn|v
zV*HBdy;uJx$qIj7*QhkE@Hn$^V)JrObn{9n=Bm_Vhi1bQa%qimR!AQo^fcvtD_(6!
zq&xbf^vTCt^36a;5cmBUce%=cF6^xTci(*Y-+c3-b1(Sf)yW^>slL|63M0qcJghLB
z>P19pJLastQ$Z{-`bMfjnKt5)S;QmLYSWVMeB)9iMpx*MIJCox6L;P{fmkrkBOD%U
zd6SN|ORw58c7^V%qi{JL33i5qZf`si@`k+V?UCcoT9-D6nB|RB5I(M|E}NUvqdEAw
z#qMV|FAl~IN3zj@h)pZqgO>KrPzg0AtNn63Bu7Iv#b}84i^oKEeO%#P?!Li3@mG>7
z5Y<i)6;YY+i4jpT2u#pixlc5cEBA>cXT>L;b|S{X#fV4!_yAV)iEap#d`Zb?8{MtA
zvFZ~khU10%#Mi}5!X2u^f$hdox@r^Za=g<H{Iqnu8}%0?d@Jg*&m#W&Pw6=M#M{Nq
zM*DXIs}jBkSd3fg`UikxQvZG*_#H`p6u4bFegb%}gdYT^@is3u-G4tX;m2?wE8#Q1
z|19Az0)Jn^f5IEmzjdGYaAGnA55&U~L?aZ16k`_MNA;G16pAeLScN+;3Q~9!0arAp
zCYY8=A%-ai9GI=lOb(A^*l8{$q8?oA^hEE_cxs48G5QHOFEcf+CMHFkLcJj0I5fl^
z9m57wjMw1rdZRS$XDQaWXgrg({*Ff&Jih4I=G2<=&ABRY?-%^lN%C~8@R)yC_i86|
zm_fpv+$^FF@?~jYnxmWZQzY?L%BxWv;cmSzLNP@Ze3v`0sHw^xV@#jTF9zL+7^+(j
z=@QkMb%CrlrFhkYh6Lt$f_uX2>-L0N)n#Q7qxyM_^B2{pm;CYdfjQ+&$QR!Y|AI&Z
z`?KoZOLMXAcyGuCFVY#L-VJ!3Job?dPHo49iO-E(7}O>{U;gJ;-)`$#b!fYljv`YJ
z1n&(uxSQheVDMpQ#~igA!IpCrRUo37Qx7h#M^xd}BB8FudqZ>`5m!{}QPi85VfxL)
z7NxOaX<Xk4&8J5#=<~BhTjYizU^$PP$(8dc$ywpimtd3IAxk{kh>sbM*5kk<yleWm
z=%2LfimFu}m17IcYO`&{#yO83DYndcl*Z@0*yu$FQw78w-HiH-gu|#mA>lsM=Oug_
z>d#7eC+aUs_+zNQCSjT<l4AjiC2o=WI|95(!Wys~3#5TX(Rq(%Va#}rXsj1=G;7(8
z_D1xHnKhgTR?=y&L~h1_y`0Z<9;0_8m_VhMGDRXQzOOKuGa2mb<uqnt&cturgGxN+
zGWhEgtxind@;4IGI&bkg;hi;3jo9ixF#fw`V?w!Kack!c_F2p?1nUYm?PTb$lD?WJ
z<Iii8p*K?IBe9miKx9&RUcG#hW+dkH8Hw(t+IF-N@6Qb^zme+8@iChnk~BIOGtu?S
zt{Xhw`i4*pY+;sq>BKkPO2HF9<-3dDLe<K7!c4B5CrHi;PxPQeFF}@gq81-Bo}i9?
z6vsso{S&y-)+$fPc1k>vFE(b=`*gd6y{O+MVVd(fE#WTIKP6$hfAX9~82HQ5@!n#c
z#+mq4WVaYSj3*xE23nd*rI1-mjAq#0UbZ(PMiE0p@@r6!{uZ=odGt=uc>il+d(nO)
zWVT>?VjL;kp530&-`|~8npT=7?hJ2kn^KzcbGf<PCv%9R^E0`b-2R*|>GXGpo7x=h
z`@`P0K;f<98}xYht<<5&{SjZ%g=nm*Z9eR5e<*BkONMvYw_A8e^Fhtgm7bTmeLOBb
zC#nklE4L3bxpMm;IV<+@GA=}ZhU|mp0?q70g&hTPTolnifh%pT+6T>Z@nWO5!>mU@
z+y$~(t`D@6&)Myhj<*%-l73@CpN8QWUgNcZKD|FYj$tr=gHPY-Yti7oQU=4-X57DS
z^k%IFtGWh5Z*>h0v?UA;p37lmtZVR$p}`Hh2G_M=e))KfG4j1HatIpi@Sh6X+mGI0
z&81O;C{O^sbmE(yzF_v!sDvLEno+K~W^(14OLA5;_iu3_E1FAhVXl|v-ot+~zO8BQ
zUP=C1H8%}LM#jllNp-Kry<0{2W`TPz89kFVm)R%uH$)}I-2lCetaoblg}26hTDZoy
zoKf_ghqS$bHzAq&!fhwchS$084^ezY@y(*@4V+m#8+s>2b9`CM@#QeLg{TK}e1{QX
zB_ao-^AU!*rCl*sz!ztDTeB;+{f6@MXNph7oS&bUWT<MU<z{l_T269Sw4CNTUV<#~
zGjX9AKhrzd5>J-;hf_?8RepZB*aFw`jD+h@|Cog79f~}jAuYd4I!<xVF$vRnMz$hi
z4T?>8u`wFYh*BKC6yuJ{LzcaLY%irti3}}$J5@5AqTOt*{El_7=Qhjn!kb3tWV^{I
z^p@2*!C(^(zf;>@RoRmIu8SqPVM$fGB{`6JbE9qPDe<tdHS-wXkz}Z9W=m#r<+em}
zR&1#j9l8YBDty-CV`fV~gB;CMiX!?aaHXwPTk;l9w&^)8G*08i#%fTR7Z7*Fhq`PF
zWIM90bO0a5hZjDF@Q8popKK>CVVavAmvCvEWsIHDnc>Nd9wAt_Fp>G_ft95zdM6Vr
zi{574$_hrWWh=ud3gfAxN=tqrM}M}$+sC_LQTD>y@J*ZGn^c9O@i)^nW9ZD-3&|4;
z@J*-nY=WGMIli1TkX>8|WtLn;|3ldVu$dbe9Z-gjC}tKTTNTL)jVvEynaPz~49Qus
zm>=Ro&q0<f#)FTU#pKX&nxPU!^iSYQTdNi$TL47|a<otfyt~-Ajgj}+CSkIeT@ntW
zzE{FG7wb~=aHZ}W^Hr(wVh)h*T=djluJ_mAUABq@9t)$gmyQ0(dXKD|GVfB!61v~F
zB?$lF!dpe%f80P@n3SG}nJxUOBtuo9Yvs0JCRc6?Bxl7IeufJbAX|kGF}0a3d<`AH
z9mhox{S&y-)~YRdizjpMF(F~<lROhd-s4l!ak2$j_csH}wzLJf#6>nn*)5{zBd=fQ
z9ZW0)&OtX4B=Ax0dogsm+6XMV)%uL>3q~hp8?o74T2*oj=4qLhKwhvbSyfY|eKOV*
zug6>TMa;?0BM&T>9}E8c#FL@cI7KUq@CbAHvr7k+x!j$(Y(AUcm8T2>{w|wlRqwFh
zNWV~ecIG3g(&&NT1fgr?wqPb#ZVM!5#TIDR=mKQP7ATv`%oZq9^mlPw6wyC{D{ZaX
zf~>pb7wFA2FMK3L`YbTnLTR*P(=&@@KM@e3*cPJ<{*G3>mf(4#OeH5!T*86n93EY_
z)7PNe1J=hq<a?>C)$OWem#*2Wl0>E>X*T6K*5j?Cxn^hcXO^-#A4W-}(c*pL_0s4{
znTq@PPtm{4xIHV$P*vzlxjvi8mFqLfS<z?8IJf}WtLby{I_k5`&7{wp@Zp8)b4Wnk
z71C!#!fmJzO8EWia~k^0S0ojwx-`RYGLG-<?=uwo>KVzqjR!C5v%{EW;yH00+gwHt
zoNJ>K9L@@tq%1gA_@`nP9M9(Zj$h=y@ijf)@_Y4l8I<Yf^4kkM&rM{n@jdG@_I7W)
zHwbn=+G%8keHmF{f0xv1?b^9#2UfdQ7oOd^nhADa+`Rhqvp21#gIyQ9FY-O}IKpvg
z)s@_^@i21c?BmX)XX9?nh1rpV;MzDyweh5~08cZcdzzb&alB#Og9%&K@j#>282UEe
z_dE949z7Xezrm)}APc!AT($n&nm6cGoyZ3`8JY~*lipgieQcl>ttG2#2NadsRc{SA
zv^%jPX++r)u#W~~-Z-+gkJY(JwyyS|VjtDBm@)fC*<ITLF669z1UU!qO1WQ)Sjoe4
zziwW9Dz-n;6%7T>M&3<rQF2BO+9KxZa_Zbt_Wa_~a%^7N9hpN0cTMY=2!AIzyF%@6
zK0gxa*Vkg1t&F*z?;|Vm%ufVqz#hzaW|KHz*o-)(oM+7B%6W$5tnf@6ljaw2G2)qD
zmk~{`LH@XC&m|s|c3n}m>NkVMGi~}CpG)G$gI8*CO!kwMS@AvTIB}9Ho!^Q2DG5_N
zCBLnV0L$53G%kKclHY;)k0neT=$5W`0Ju%U_X9Uecm#O6glT3mFX5BGQ3*c;d`!aA
zzy~Ev{zA?OUjU}D4lg!F<D(ZP{IocPtv+rT8=sg$h8MkLEzbqhSEOVTCnk`F%s{f4
zu?g)Vre|#F>s$D6qm=xGH&{nA4;#Y{eWFv(EnB<#1dC8cGkp;ZOZW(U&8u4qWO)J@
z=X9OhD`$Y2aeE|UIRk9PxG#d+X{D#bZk7SI;OCjntT3}C1MK9Q{I6pkk^O~?S}FId
zl;`Er9DzeoV)M=*#x_SOf9eySFC9CC`1jPa{i~tX-O8B0CWUP}tJsn?>zWe8zfXaG
z?=5m~6S()OBKO`K+7IqsuXArptt$A`SQXOMPK;|u9#=OwRc6{2td-O=I`Ec*GI(hX
zN$C7$WbhsVzeXb;L~hsrY~5fbzAR<<ujNapq}!_iUBJX!^qA=waRqT6VbGdhO193i
zFcsnfH$GRBE9X^eZ!2#~{}%1hR;KV*0QO;LHTDx{QUB`kDPL)F3l5a{>HYGm_!YPS
zidZ$cMRX2#gvM_^3D*J3GqugYa;#3zg}93s8|y^n2?5a_#ZZ4HVY;7xEnyn_eM7>;
ztN$S3J*dAf;eDvf*<Oc$Uz3i<QNJu<;#vJc>-%hMw0Mm3UTO^nSd$$l*659D!$&#u
zNja{TXwF!9S6s`%X-;1~&lk<7NAxA~Ib6Dm2FEC$#i!b+=TUbXbtDI1eZBSZZU0v5
z@BcNrFpA(nT5&g}&)2z5tIGE4GLu%xrpY!%5q3g4MJg$@ce@ZUwnAOY$3SLs<+e(4
z#0R2?_Gl~mK*zG!LHb8rLUw9qtK@fS&RG=Ep1_s1R>wf%T-|364RMvAL=pUJg&U_C
z#!T+%>!TNpRniRkj*6$!iQ7SUS7=5|+#X{q?tHmsn8}rE2Fd;3)eQP?8=PJ$Xa=aE
z(kk77{yxiZkh8{JmN|pgW4W;&Ygu29H7%{j%3(cLE7oIOADyYBF<p{2m}yMOw{c-J
zjWLre*BFwsqA@h)oPaEGiQtoZ)XV)oz4@hafheMX0$18v<r4Dkyx8<U$n!R`wdq`=
zXF8K}#J{59F3Xdd<p0w}XjgG=+(fsw_VfR+V`T;SPmG?e)h(XYQ~IAO>kHGz`mwH|
z0b^&rqWM-2&6vEMMz(QsquXAfS(NpKe>q;`USIgvR8xpnFU(=Sd?D8oIJAf(M_ZPf
z&%cxMFD=H#BI^U^qBv9CnvbqbX@~W7d^G3S63r;ILi&1XZ)L`t7mo*9GyN@%rNoou
z+j7P;lPlL>lCz?})S>4fOS((CV&)5<gB*W`5JLGN_4hNpNxfAXw~k7<7WMrSrqy7(
zBusp9kAyo=e?-D`|3uOCpH$yS?=R-=RC;$L{ih>ZwKP^~)sl&QMEk6B@2b%`**=b3
zn0Rcrwr;h;+MbP1T$nh=zPP=*YZX$T+kM3fAX@)JN3Z_>U#>m3xDq#)o`tz?pB4|m
z*b3b#*KISoa@{65E4uvxF7zm5Nw?|a#HSKB-wxfrUfDKoT$2~R0;kmPD>KXbAQ&>F
zbzSA_O~(3$h_r|J+t1>E+giJm>nKQF{4XvK{|8)x)1^H5-=Nm^|5~l>|E<>I>Hj~_
zTCRF)6?Cf7PQH({)~I=)$N1N9*0pwE(3l>ykjwIdVOuiS&gbXz#JA;Kdj&RF*O33*
z701g~V%|s&e!%!$v@siBJR!+Y)r^D9<jOgi<VsvtYLD6#eW2@53?0W-@UIyM_v0iV
zonREvKY=T4t&Weyxx}e7#_2J3lsI<nKPZGQ{x8<S{#ENbc;guLw>rp`%CScKX+~qM
PmYV1wS2=?SNgMwg6F6uY

literal 0
HcmV?d00001

diff --git a/gcc/config/c33/libgcc/modhi3.lst b/gcc/config/c33/libgcc/modhi3.lst
new file mode 100644
index 0000000..0045b88
--- /dev/null
+++ b/gcc/config/c33/libgcc/modhi3.lst
@@ -0,0 +1,105 @@
+GAS LISTING modhi3.s 			page 1
+
+
+   1              	;	Function :	__modhi3
+   2              	;	Input :		%r6	--- dividend
+   3              	;			%r7	--- divisor
+   4              	;	Output :	%r4	--- remainder
+   5              	;	Function :	calculate signed integer modulo arithmetic
+   6              	
+   7              		.section .text
+   8              		.align 1
+   9              		.global	__modhi3
+  10              	__modhi3:
+  11 0000 868C868C 		xsll	%r6, 16
+  12 0004 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  13 0006 708B     		div0s	%r7		; initializer of signed division
+  14              	;ifdef	FAST
+  15 0008 7093     		div1	%r7		; execute division ;1
+  16 000a 7093     		div1	%r7		; execute division ;2
+  17 000c 7093     		div1	%r7		; execute division ;3
+  18 000e 7093     		div1	%r7		; execute division ;4
+  19 0010 7093     		div1	%r7		; execute division ;5
+  20 0012 7093     		div1	%r7		; execute division ;6
+  21 0014 7093     		div1	%r7		; execute division ;7
+  22 0016 7093     		div1	%r7		; execute division ;8
+  23 0018 7093     		div1	%r7		; execute division ;9
+  24 001a 7093     		div1	%r7		; execute division ;10
+  25 001c 7093     		div1	%r7		; execute division ;11
+  26 001e 7093     		div1	%r7		; execute division ;12
+  27 0020 7093     		div1	%r7		; execute division ;13
+  28 0022 7093     		div1	%r7		; execute division ;14
+  29 0024 7093     		div1	%r7		; execute division ;15
+  30 0026 7093     		div1	%r7		; execute division ;16
+  31              	;else
+  32              	;	ld.w	%r8,0x2		; set loop counter (N = 2)
+  33              	;	ld.w	%r9,%psr	; save flag register
+  34              	;__modhi3_loop_start:	
+  35              	;	div1	%r7		; execute division ;1
+  36              	;	div1	%r7		; execute division ;2
+  37              	;	div1	%r7		; execute division ;3
+  38              	;	div1	%r7		; execute division ;4
+  39              	;	div1	%r7		; execute division ;5
+  40              	;	div1	%r7		; execute division ;6
+  41              	;	div1	%r7		; execute division ;7
+  42              	;	div1	%r7		; execute division ;8
+  43              	;	sub	%r8,0x1		; decrement loop counter
+  44              	;	jrne.d	__modhi3_loop_start	; if (loop counter != 0) goto loop top
+  45              	;	ld.w	%psr,%r9	; restore flag register (delayed slot)
+  46              	;endif
+  47 0028 7097     		div2s	%r7		; post divistion process ;1
+  48 002a 009B     		div3s			; post divistion process ;2
+  49 002c 4007     		ret.d			; return to the caller (use delayed return)
+  50 002e 34A4     		ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+  51              	
+  52              	
+  53              	;	Function :	__umodhi3
+  54              	;	Input :		%r6	--- dividend
+  55              	;			%r7	--- divisor
+  56              	;	Output :	%r4	--- remainder
+  57              	;	Function :	calculate unsigned integer modulo arithmetic
+GAS LISTING modhi3.s 			page 2
+
+
+  58              	
+  59              		.section .text
+  60              		.align 1
+  61              		.global	__umodhi3
+  62              	__umodhi3:
+  63 0030 868C868C 		xsll	%r6, 16
+  64 0034 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  65 0036 708F     		div0u	%r7		; initializer of signed division
+  66              	;ifdef	FAST
+  67 0038 7093     		div1	%r7		; execute division ;1
+  68 003a 7093     		div1	%r7		; execute division ;2
+  69 003c 7093     		div1	%r7		; execute division ;3
+  70 003e 7093     		div1	%r7		; execute division ;4
+  71 0040 7093     		div1	%r7		; execute division ;5
+  72 0042 7093     		div1	%r7		; execute division ;6
+  73 0044 7093     		div1	%r7		; execute division ;7
+  74 0046 7093     		div1	%r7		; execute division ;8
+  75 0048 7093     		div1	%r7		; execute division ;9
+  76 004a 7093     		div1	%r7		; execute division ;10
+  77 004c 7093     		div1	%r7		; execute division ;11
+  78 004e 7093     		div1	%r7		; execute division ;12
+  79 0050 7093     		div1	%r7		; execute division ;13
+  80 0052 7093     		div1	%r7		; execute division ;14
+  81 0054 7093     		div1	%r7		; execute division ;15
+  82 0056 7093     		div1	%r7		; execute division ;16
+  83              	;else
+  84              	;	ld.w	%r8,0x2		; set loop counter (N = 2)
+  85              	;__umodhi3_loop_start:	
+  86              	;	div1	%r7		; execute division ;1
+  87              	;	div1	%r7		; execute division ;2
+  88              	;	div1	%r7		; execute division ;3
+  89              	;	div1	%r7		; execute division ;4
+  90              	;	div1	%r7		; execute division ;5
+  91              	;	div1	%r7		; execute division ;6
+  92              	;	div1	%r7		; execute division ;7
+  93              	;	div1	%r7		; execute division ;8
+  94              	;	sub	%r8,0x1		; decrement loop counter
+  95              	;	jrne	__umodhi3_loop_start	; if (loop counter != 0) goto loop top
+  96              	;endif
+  97 0058 4007     		ret.d			; return to the caller (use delayed return)
+  98 005a 34A4     		ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+  99              	
diff --git a/gcc/config/c33/libgcc/modhi3.s b/gcc/config/c33/libgcc/modhi3.s
new file mode 100644
index 0000000..11063da
--- /dev/null
+++ b/gcc/config/c33/libgcc/modhi3.s
@@ -0,0 +1,99 @@
+;	Function :	__modhi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- remainder
+;	Function :	calculate signed integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	__modhi3
+__modhi3:
+	xsll	%r6, 16
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0s	%r7		; initializer of signed division
+;ifdef	FAST
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	div1	%r7		; execute division ;9
+	div1	%r7		; execute division ;10
+	div1	%r7		; execute division ;11
+	div1	%r7		; execute division ;12
+	div1	%r7		; execute division ;13
+	div1	%r7		; execute division ;14
+	div1	%r7		; execute division ;15
+	div1	%r7		; execute division ;16
+;else
+;	ld.w	%r8,0x2		; set loop counter (N = 2)
+;	ld.w	%r9,%psr	; save flag register
+;__modhi3_loop_start:	
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	sub	%r8,0x1		; decrement loop counter
+;	jrne.d	__modhi3_loop_start	; if (loop counter != 0) goto loop top
+;	ld.w	%psr,%r9	; restore flag register (delayed slot)
+;endif
+	div2s	%r7		; post divistion process ;1
+	div3s			; post divistion process ;2
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+
+
+;	Function :	__umodhi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- remainder
+;	Function :	calculate unsigned integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	__umodhi3
+__umodhi3:
+	xsll	%r6, 16
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0u	%r7		; initializer of signed division
+;ifdef	FAST
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	div1	%r7		; execute division ;9
+	div1	%r7		; execute division ;10
+	div1	%r7		; execute division ;11
+	div1	%r7		; execute division ;12
+	div1	%r7		; execute division ;13
+	div1	%r7		; execute division ;14
+	div1	%r7		; execute division ;15
+	div1	%r7		; execute division ;16
+;else
+;	ld.w	%r8,0x2		; set loop counter (N = 2)
+;__umodhi3_loop_start:	
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	sub	%r8,0x1		; decrement loop counter
+;	jrne	__umodhi3_loop_start	; if (loop counter != 0) goto loop top
+;endif
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+
diff --git a/gcc/config/c33/libgcc/modsi3.lst b/gcc/config/c33/libgcc/modsi3.lst
new file mode 100644
index 0000000..ca9d2b2
--- /dev/null
+++ b/gcc/config/c33/libgcc/modsi3.lst
@@ -0,0 +1,138 @@
+GAS LISTING modsi3.s 			page 1
+
+
+   1              	;	Function :	__modsi3
+   2              	;	Input :		%r6	--- dividend
+   3              	;			%r7	--- divisor
+   4              	;	Output :	%r4	--- remainder
+   5              	;	Function :	calculate signed integer modulo arithmetic
+   6              	
+   7              		.section .text
+   8              		.align 1
+   9              		.global	__modsi3
+  10              	__modsi3:
+  11 0000 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  12 0002 708B     		div0s	%r7		; initializer of signed division
+  13              	;ifdef	FAST
+  14              	;	div1	%r7		; execute division ;1
+  15              	;	div1	%r7		; execute division ;2
+  16              	;	div1	%r7		; execute division ;3
+  17              	;	div1	%r7		; execute division ;4
+  18              	;	div1	%r7		; execute division ;5
+  19              	;	div1	%r7		; execute division ;6
+  20              	;	div1	%r7		; execute division ;7
+  21              	;	div1	%r7		; execute division ;8
+  22              	;	div1	%r7		; execute division ;9
+  23              	;	div1	%r7		; execute division ;10
+  24              	;	div1	%r7		; execute division ;11
+  25              	;	div1	%r7		; execute division ;12
+  26              	;	div1	%r7		; execute division ;13
+  27              	;	div1	%r7		; execute division ;14
+  28              	;	div1	%r7		; execute division ;15
+  29              	;	div1	%r7		; execute division ;16
+  30              	;	div1	%r7		; execute division ;17
+  31              	;	div1	%r7		; execute division ;18
+  32              	;	div1	%r7		; execute division ;19
+  33              	;	div1	%r7		; execute division ;20
+  34              	;	div1	%r7		; execute division ;21
+  35              	;	div1	%r7		; execute division ;22
+  36              	;	div1	%r7		; execute division ;23
+  37              	;	div1	%r7		; execute division ;24
+  38              	;	div1	%r7		; execute division ;25
+  39              	;	div1	%r7		; execute division ;26
+  40              	;	div1	%r7		; execute division ;27
+  41              	;	div1	%r7		; execute division ;28
+  42              	;	div1	%r7		; execute division ;29
+  43              	;	div1	%r7		; execute division ;30
+  44              	;	div1	%r7		; execute division ;31
+  45              	;	div1	%r7		; execute division ;32
+  46              	;else
+  47 0004 486C     		ld.w	%r8,0x4		; set loop counter (N = 4)
+  48 0006 09A4     		ld.w	%r9,%psr	; save flag register
+  49              	__modsi3_loop_start:	
+  50 0008 7093     		div1	%r7		; execute division ;1
+  51 000a 7093     		div1	%r7		; execute division ;2
+  52 000c 7093     		div1	%r7		; execute division ;3
+  53 000e 7093     		div1	%r7		; execute division ;4
+  54 0010 7093     		div1	%r7		; execute division ;5
+  55 0012 7093     		div1	%r7		; execute division ;6
+  56 0014 7093     		div1	%r7		; execute division ;7
+  57 0016 7093     		div1	%r7		; execute division ;8
+GAS LISTING modsi3.s 			page 2
+
+
+  58 0018 1864     		sub	%r8,0x1		; decrement loop counter
+  59 001a F71B     		jrne.d	__modsi3_loop_start	; if (loop counter != 0) goto loop top
+  60 001c 90A0     		ld.w	%psr,%r9	; restore flag register (delayed slot)
+  61              	;endif
+  62 001e 7097     		div2s	%r7		; post divistion process ;1
+  63 0020 009B     		div3s			; post divistion process ;2
+  64 0022 4007     		ret.d			; return to the caller (use delayed return)
+  65 0024 34A4     		ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+  66              	
+  67              	
+  68              	;	Function :	__umodsi3
+  69              	;	Input :		%r6	--- dividend
+  70              	;			%r7	--- divisor
+  71              	;	Output :	%r4	--- remainder
+  72              	;	Function :	calculate unsigned integer modulo arithmetic
+  73              	
+  74              		.section .text
+  75              		.align 1
+  76              		.global	__umodsi3
+  77              	__umodsi3:
+  78 0026 62A0     		ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+  79 0028 708F     		div0u	%r7		; initializer of signed division
+  80              	;ifdef	FAST
+  81              	;	div1	%r7		; execute division ;1
+  82              	;	div1	%r7		; execute division ;2
+  83              	;	div1	%r7		; execute division ;3
+  84              	;	div1	%r7		; execute division ;4
+  85              	;	div1	%r7		; execute division ;5
+  86              	;	div1	%r7		; execute division ;6
+  87              	;	div1	%r7		; execute division ;7
+  88              	;	div1	%r7		; execute division ;8
+  89              	;	div1	%r7		; execute division ;9
+  90              	;	div1	%r7		; execute division ;10
+  91              	;	div1	%r7		; execute division ;11
+  92              	;	div1	%r7		; execute division ;12
+  93              	;	div1	%r7		; execute division ;13
+  94              	;	div1	%r7		; execute division ;14
+  95              	;	div1	%r7		; execute division ;15
+  96              	;	div1	%r7		; execute division ;16
+  97              	;	div1	%r7		; execute division ;17
+  98              	;	div1	%r7		; execute division ;18
+  99              	;	div1	%r7		; execute division ;19
+ 100              	;	div1	%r7		; execute division ;20
+ 101              	;	div1	%r7		; execute division ;21
+ 102              	;	div1	%r7		; execute division ;22
+ 103              	;	div1	%r7		; execute division ;23
+ 104              	;	div1	%r7		; execute division ;24
+ 105              	;	div1	%r7		; execute division ;25
+ 106              	;	div1	%r7		; execute division ;26
+ 107              	;	div1	%r7		; execute division ;27
+ 108              	;	div1	%r7		; execute division ;28
+ 109              	;	div1	%r7		; execute division ;29
+ 110              	;	div1	%r7		; execute division ;30
+ 111              	;	div1	%r7		; execute division ;31
+ 112              	;	div1	%r7		; execute division ;32
+ 113              	;else
+ 114 002a 486C     		ld.w	%r8,0x4		; set loop counter (N = 4)
+GAS LISTING modsi3.s 			page 3
+
+
+ 115              	__umodsi3_loop_start:	
+ 116 002c 7093     		div1	%r7		; execute division ;1
+ 117 002e 7093     		div1	%r7		; execute division ;2
+ 118 0030 7093     		div1	%r7		; execute division ;3
+ 119 0032 7093     		div1	%r7		; execute division ;4
+ 120 0034 7093     		div1	%r7		; execute division ;5
+ 121 0036 7093     		div1	%r7		; execute division ;6
+ 122 0038 7093     		div1	%r7		; execute division ;7
+ 123 003a 7093     		div1	%r7		; execute division ;8
+ 124 003c 1864     		sub	%r8,0x1		; decrement loop counter
+ 125 003e F71A     		jrne	__umodsi3_loop_start	; if (loop counter != 0) goto loop top
+ 126              	;endif
+ 127 0040 4007     		ret.d			; return to the caller (use delayed return)
+ 128 0042 34A4     		ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+ 129              	
diff --git a/gcc/config/c33/libgcc/modsi3.s b/gcc/config/c33/libgcc/modsi3.s
new file mode 100644
index 0000000..d47fec4
--- /dev/null
+++ b/gcc/config/c33/libgcc/modsi3.s
@@ -0,0 +1,129 @@
+;	Function :	__modsi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- remainder
+;	Function :	calculate signed integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	__modsi3
+__modsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0s	%r7		; initializer of signed division
+;ifdef	FAST
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	div1	%r7		; execute division ;9
+;	div1	%r7		; execute division ;10
+;	div1	%r7		; execute division ;11
+;	div1	%r7		; execute division ;12
+;	div1	%r7		; execute division ;13
+;	div1	%r7		; execute division ;14
+;	div1	%r7		; execute division ;15
+;	div1	%r7		; execute division ;16
+;	div1	%r7		; execute division ;17
+;	div1	%r7		; execute division ;18
+;	div1	%r7		; execute division ;19
+;	div1	%r7		; execute division ;20
+;	div1	%r7		; execute division ;21
+;	div1	%r7		; execute division ;22
+;	div1	%r7		; execute division ;23
+;	div1	%r7		; execute division ;24
+;	div1	%r7		; execute division ;25
+;	div1	%r7		; execute division ;26
+;	div1	%r7		; execute division ;27
+;	div1	%r7		; execute division ;28
+;	div1	%r7		; execute division ;29
+;	div1	%r7		; execute division ;30
+;	div1	%r7		; execute division ;31
+;	div1	%r7		; execute division ;32
+;else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+	ld.w	%r9,%psr	; save flag register
+__modsi3_loop_start:	
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	sub	%r8,0x1		; decrement loop counter
+	jrne.d	__modsi3_loop_start	; if (loop counter != 0) goto loop top
+	ld.w	%psr,%r9	; restore flag register (delayed slot)
+;endif
+	div2s	%r7		; post divistion process ;1
+	div3s			; post divistion process ;2
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+
+
+;	Function :	__umodsi3
+;	Input :		%r6	--- dividend
+;			%r7	--- divisor
+;	Output :	%r4	--- remainder
+;	Function :	calculate unsigned integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	__umodsi3
+__umodsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (%alr)
+	div0u	%r7		; initializer of signed division
+;ifdef	FAST
+;	div1	%r7		; execute division ;1
+;	div1	%r7		; execute division ;2
+;	div1	%r7		; execute division ;3
+;	div1	%r7		; execute division ;4
+;	div1	%r7		; execute division ;5
+;	div1	%r7		; execute division ;6
+;	div1	%r7		; execute division ;7
+;	div1	%r7		; execute division ;8
+;	div1	%r7		; execute division ;9
+;	div1	%r7		; execute division ;10
+;	div1	%r7		; execute division ;11
+;	div1	%r7		; execute division ;12
+;	div1	%r7		; execute division ;13
+;	div1	%r7		; execute division ;14
+;	div1	%r7		; execute division ;15
+;	div1	%r7		; execute division ;16
+;	div1	%r7		; execute division ;17
+;	div1	%r7		; execute division ;18
+;	div1	%r7		; execute division ;19
+;	div1	%r7		; execute division ;20
+;	div1	%r7		; execute division ;21
+;	div1	%r7		; execute division ;22
+;	div1	%r7		; execute division ;23
+;	div1	%r7		; execute division ;24
+;	div1	%r7		; execute division ;25
+;	div1	%r7		; execute division ;26
+;	div1	%r7		; execute division ;27
+;	div1	%r7		; execute division ;28
+;	div1	%r7		; execute division ;29
+;	div1	%r7		; execute division ;30
+;	div1	%r7		; execute division ;31
+;	div1	%r7		; execute division ;32
+;else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+__umodsi3_loop_start:	
+	div1	%r7		; execute division ;1
+	div1	%r7		; execute division ;2
+	div1	%r7		; execute division ;3
+	div1	%r7		; execute division ;4
+	div1	%r7		; execute division ;5
+	div1	%r7		; execute division ;6
+	div1	%r7		; execute division ;7
+	div1	%r7		; execute division ;8
+	sub	%r8,0x1		; decrement loop counter
+	jrne	__umodsi3_loop_start	; if (loop counter != 0) goto loop top
+;endif
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+
diff --git a/gcc/config/c33/libgcc/muldf3.lst b/gcc/config/c33/libgcc/muldf3.lst
new file mode 100644
index 0000000..de6e691
--- /dev/null
+++ b/gcc/config/c33/libgcc/muldf3.lst
@@ -0,0 +1,475 @@
+GAS LISTING muldf3.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : muldf3.s
+   6              	;*
+   7              	;*	Double floating point multiplication function
+   8              	;*		input: (%r7, %r6) & (%r9, %r8)
+   9              	;*		output: (%r5, %r4)
+  10              	;*
+  11              	;*	Begin						1996/09/12	V. Chan
+  12              	;*	Fixed bug at multiply:		1997/02/18	V. Chan
+  13              	;*  ﾊﾑｹｹ						2001/01/30  O.Hinokuchi
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*****************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __muldf3
+  21              	
+  22              	;;macro	SHFTROTSHFT $1, $2, $3, $4, $5, $6, $7
+  23              		; used in 64-bit variable shifting
+  24              		; $1 = shift amount
+  25              		; $2 = 1st input register (shifted)
+  26              		; $3 = 2nd input register (rotated)
+  27              		; $4 = 3rd input register (mask --> shifted)
+  28              		; $5 = shift instruction
+  29              		; $6 = rotate instruction
+  30              		; $7 = temp register
+  31              	;	ld.w	$7, $1		; temp = shift amount
+  32              	
+  33              	;$$1:
+  34              	;	cmp		$7, 8		; if temp <= 8 then goto $$2
+  35              	;	jrle	$$2
+  36              	
+  37              	;	$5		$2, 8		; shift 1st register
+  38              	;	$6		$3, 8		; rotate 2nd register
+  39              	;	$5		$4, 8		; shift 3rd register
+  40              	;	jp.d	$$1
+  41              	;	sub		$7, 8		; temp = temp - 8
+  42              	
+  43              	;$$2:
+  44              	;	$5		$2, $7		; last shift
+  45              	;	$6		$3, $7		; last rotate
+  46              	;	$5		$4, $7		; last shift
+  47              	;;endm
+  48              	
+  49              	__muldf3:
+  50 0000 0302     		pushn	%r3				; save register values
+  51              		;@@@ 01/01/30 add start hinokuchi
+  52              		;sub		%sp, 4
+  53              		;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+  54              		;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+  55              		;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+  56              		;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+  57              		;@@@ 01/01/30 add end
+GAS LISTING muldf3.s 			page 2
+
+
+  58              	
+  59 0002 702E     		ld.w	%r0, %r7		; put sign of input1 (%r7) into %r0
+  60 0004 109C     		rl		%r0, 1
+  61 0006 1070     		and		%r0, 1
+  62              	
+  63 0008 922E     		ld.w	%r2, %r9		; put sign of input2 (%r9) into %r2
+  64 000a 129C     		rl		%r2, 1
+  65 000c 1270     		and		%r2, 1
+  66              	
+  67 000e 203A     		xor		%r0, %r2		; put new sign into register %r0
+  68              	
+  69 0010 056C     		ld.w	%r5, 0			; clear output register
+  70              		;ld.w	%r4, 0			; moved to line 38 for a delayed jump
+  71              		
+  72 0012 178C     		sll		%r7, 1			; clear MSB
+  73 0014 1788     		srl		%r7, 1
+  74 0016 0768     		cmp		%r7, 0			; checking if input1 = 0
+  75 0018 051B     		jrne.d	input2
+  76 001a 046C     		ld.w	%r4, 0
+  77 001c 0668     		cmp		%r6, 0			
+  78 001e 00C0     		ext		end@rm
+  79 0020 E018     		jreq	end@rl			; if {%r7, %r6} = 0 then end
+  80              	
+  81              	input2:
+  82 0022 198C     		sll		%r9, 1			; clear MSB
+  83 0024 1988     		srl		%r9, 1	
+  84 0026 0968     		cmp		%r9, 0			; checking if input2 = 0
+  85 0028 041A     		jrne	getexp
+  86 002a 0868     		cmp		%r8, 0
+  87 002c 00C0     		ext		end@rm
+  88 002e D918     		jreq	end@rl				; if {%r9, %r8} = 0 then end
+  89              	
+  90              	getexp:
+  91 0030 712E     		ld.w	%r1, %r7		; put exponent1 into %r1
+  92 0032 81888188 		xsrl 	%r1, 20
+  92      4188
+  93              	
+  94 0038 1FC0F16B 		xcmp	%r1, 0x7ff		; check exp1 for overflow value
+  95 003c 00C0     		ext		overflow@rm
+  96 003e C618     		jreq	overflow@rl
+  97              	
+  98 0040 932E     		ld.w	%r3, %r9		; put exponent2 into %r3
+  99 0042 83888388 		xsrl	%r3, 20
+  99      4388
+ 100              	
+ 101 0048 1FC0F36B 		xcmp	%r3, 0x7ff		; check exp2 for overflow value
+ 102 004c 00C0     		ext		overflow@rm
+ 103 004e BE18     		jreq	overflow@rl
+ 104              	
+ 105              		; free	%r2, %r11 - %r13
+ 106              		; %r0 = sign, %r1 = sisu1, %r3 = sisu2
+ 107              		; %r10 = implied bit
+ 108              	
+ 109              		;@@@ 01/02/16 del xld.w	%r10, 0x100000	; implied bit
+ 110 0050 126C     		ld.w	%r2, 1			; temp = 1
+ 111              		;@@@ 01/02/16 del xld.w	%r13, 0xfffff
+ 112              	
+GAS LISTING muldf3.s 			page 3
+
+
+ 113              		; isolate mantissa1
+ 114 0052 01C0FFDF 		xand	%r7, 0xfffff	; clear first 12 bits of %r6
+ 114      F773
+ 115 0058 0168     		cmp		%r1, 0
+ 116 005a 0518     		jreq	man2			; if exp1 = 0 (denormal)
+ 117 005c 02C000C0 		xoor	%r7, 0x100000	; else add implied bit to mantissa
+ 117      0774
+ 118              	
+ 119 0062 026C     		ld.w	%r2, 0			; temp = 0
+ 120              	
+ 121              	man2:
+ 122              		; isolate mantissa2
+ 123 0064 01C0FFDF 		xand	%r9, 0xfffff	; clear first 12 bits of %r7
+ 123      F973
+ 124              	
+ 125 006a 0368     		cmp		%r3, 0
+ 126 006c 0518     		jreq	tempadd			; if exp2 = 0 then jump to tempadd
+ 127 006e 02C000C0 		xoor	%r9, 0x100000	; else add implied bit
+ 127      0974
+ 128 0074 021E     		jp	multiply			; delayed jump
+ 129              	
+ 130              	tempadd:
+ 131 0076 1260     		add		%r2, 1			; temp = temp + 1 (2 if den * den : 1 if nor * den)
+ 132              		
+ 133              	multiply:
+ 134              		; %r0 = result sign, %r1 = result exponent
+ 135              	
+ 136              		; calculate and check new exponent
+ 137 0078 3122     		add		%r1, %r3		; sisu = sisu1 + sisu2 - bias + temp
+ 138              	
+ 139 007a 0FC0F167 		xsub	%r1, 0x3ff
+ 140              	
+ 141 007e 2122     		add		%r1, %r2
+ 142              	
+ 143 0080 1FC0F16B 		xcmp	%r1, 0x7ff		; if exp >= 0x7ff then goto overflow
+ 144 0084 00C0     		ext		overflow@rm
+ 145 0086 A20A     		jrge	overflow@rl
+ 146              	
+ 147              		; max. shift from normal to denormal = 52
+ 148              		; min. exp = 1 - max. shift = -51
+ 149 0088 FFDFD168 		xcmp	%r1, -51		; if exp < -51 then goto underflow
+ 150 008c 6C0C     		jrlt	underflow
+ 151              	
+ 152              		; 64-bit * 64-bit = 128-bit
+ 153              		; 1st(128 ~ 97), 2nd(96 ~ 65), 3rd(64 ~ 33), 4th(32 ~ 0)
+ 154              		; (%r7,%r6) * (%r9,%r8)
+ 155              		; %r7 * a15 --> 1st,2nd
+ 156              		; %r7 * a14 --> 2nd,3rd
+ 157              		; %r6 * a15 --> 2nd,3rd
+ 158              		; %r6 * a14 --> 3rd,4th
+ 159              		; %r5 = result1, %r4 = result2, %r10 = result3, %r11 = result4, %r12 = temp
+ 160 008e 026C     		ld.w	%r2, 0			; temp variable for adc and loop counter
+ 161 0090 97AE     		mltu.w	%r7, %r9		; kasu1 * kasu2
+ 162 0092 35A4     		ld.w	%r5, %ahr		; %r5 = result1	
+ 163 0094 24A4     		ld.w	%r4, %alr		; %r4 = result2
+ 164 0096 87AE     		mltu.w	%r7, %r8		; kasu1 * kasu2_2
+ 165 0098 37A4     		ld.w	%r7, %ahr
+GAS LISTING muldf3.s 			page 4
+
+
+ 166 009a 7422     		add		%r4, %r7
+ 167 009c 25B8     		adc		%r5, %r2		; add carry
+ 168 009e 23A4     		ld.w	%r3, %alr		; %r10 = result3
+ 169 00a0 96AE     		mltu.w	%r6, %r9		; kasu1_2 * kasu2
+ 170 00a2 27A4     		ld.w	%r7, %alr
+ 171 00a4 7322     		add		%r3, %r7
+ 172 00a6 24B8     		adc		%r4, %r2		; add carry
+ 173 00a8 25B8     		adc		%r5, %r2		; add carry
+ 174 00aa 37A4     		ld.w	%r7, %ahr
+ 175 00ac 7422     		add		%r4, %r7
+ 176 00ae 25B8     		adc		%r5, %r2		; add carry
+ 177 00b0 86AE     		mltu.w	%r6, %r8		; kasu1_2 * kasu2_2
+ 178 00b2 37A4     		ld.w	%r7, %ahr
+ 179 00b4 7322     		add		%r3, %r7
+ 180 00b6 24B8     		adc		%r4, %r2		; add carry
+ 181 00b8 25B8     		adc		%r5, %r2
+ 182 00ba 26A4     		ld.w	%r6, %alr		; %r11 = result4
+ 183              		
+ 184              		; %r8 will be first result register > 0
+ 185 00bc 0568     		cmp		%r5, 0			; if %r5 !=0 then count it
+ 186 00be 0F1B     		jrne.d	count
+ 187 00c0 582E     		ld.w	%r8, %r5
+ 188              	
+ 189 00c2 00C0026E 		xld.w	%r2, 32			; %r2 = loop counter = 32 
+ 190 00c6 0468     		cmp		%r4, 0			; elsif %r4 != 0 then count it
+ 191 00c8 0A1B     		jrne.d	count
+ 192 00ca 482E     		ld.w	%r8, %r4
+ 193              	
+ 194 00cc 01C0026C 		xld.w	%r2, 64			; %r2 = loop counter = 64
+ 195 00d0 0368     		cmp		%r3, 0			; elsif %r10 != 0 then count it
+ 196 00d2 051B     		jrne.d	count
+ 197 00d4 382E     		ld.w	%r8, %r3
+ 198              	
+ 199 00d6 01C0026E 		xld.w	%r2, 96			; %r2 = loop counter = 96
+ 200 00da 682E     		ld.w	%r8, %r6		; else count 0's leading %r6
+ 201              		
+ 202              	count:
+ 203 00dc 878E     		scan1	%r7, %r8		; %r7 = count
+ 204 00de 0412     		jruge	normalize		; if count !=8 then goto normalize
+ 205 00e0 8260     		add		%r2, 8			; add 8 to loop counter
+ 206 00e2 FD1F     		jp.d	count
+ 207 00e4 888C     		sll		%r8, 8			; shift register to the left 8 bits
+ 208              	
+ 209              	normalize:
+ 210              		; free	%r2 - %r11, %r13
+ 211              		; %r0 = sign, %r1 = exp, %r7 = count
+ 212              		; note: max. count = 127, min. count = 22
+ 213              	
+ 214 00e6 2722     		add		%r7, %r2		; count = count + loopcounter
+ 215              	
+ 216 00e8 0168     		cmp		%r1, 0			; if exp > 0 then jump to expgtz
+ 217 00ea 0F09     		jrgt.d	expgtz
+ 218 00ec 7765     		sub		%r7, 23			; count = count - 23
+ 219              	
+ 220              		; case: exp <= 0
+ 221 00ee 0184     	sub %sp, 1
+ 222 00f0 035C     	ld.w	[%sp+0x0], %r3	; %r3ﾂﾔﾈ
+GAS LISTING muldf3.s 			page 5
+
+
+ 223 00f2 136C     		ld.w	%r3, 1			; %r3 = 1 - exp
+ 224 00f4 1326     		sub		%r3, %r1
+ 225 00f6 C26C     		ld.w	%r2, 12			; %r2 = shift
+ 226 00f8 3226     		sub		%r2, %r3		; shift = 12 - (1 - exp)
+ 227 00fa 0350     	ld.w	%r3, [%sp+0x0]	; %r3ﾉｵ｢
+ 228 00fc 0180     	add %sp, 1
+ 229 00fe 712A     		cmp		%r1, %r7
+ 230 0100 0D0F     		jrle.d	shift			; if exp <= count then jump to shift
+ 231 0102 016C     		ld.w	%r1, 0			; exp = 0
+ 232              	
+ 233              		; case: exp > count - 23
+ 234 0104 0B1F     		jp.d	shift			; delayed jump
+ 235 0106 116C     		ld.w	%r1, 1			; exp = 1
+ 236              		
+ 237              	expgtz:
+ 238 0108 172A     		cmp		%r7, %r1		; if count < exp then goto shftltexp
+ 239 010a 060D     		jrlt.d	shftltexp
+ 240 010c C26C     		ld.w	%r2, 12			; shift = 12
+ 241              	
+ 242              		; case: original count - 23 >= exp
+ 243 010e 1222     		add		%r2, %r1		; shift = shift + exp - 1
+ 244 0110 1264     		sub		%r2, 1			; shift as much as exp allows (until denormal)
+ 245 0112 041F     		jp.d	shift
+ 246 0114 016C     		ld.w	%r1, 0			; exp = 0
+ 247              		
+ 248              	shftltexp:
+ 249 0116 7126     		sub		%r1, %r7		; exp = exp - count
+ 250 0118 7222     		add		%r2, %r7		; shift = shift + count
+ 251              	
+ 252              	shift:
+ 253 011a 0268     		cmp		%r2, 0			;if shift < 0 then shift to the right
+ 254 011c 120C     		jrlt	rshift
+ 255              	
+ 256 011e 00C0026A 		xcmp	%r2, 32			; if 0 =< shift < 32 then goto lshift
+ 257 0122 350C     		jrlt	lshift
+ 258              	
+ 259 0124 01C00268 		xcmp	%r2, 64			; if 32 =< shift < 64 then goto shft32
+ 260 0128 070C     		jrlt	lshft32
+ 261              	
+ 262              		; case:	shift >= 64		(note: max. shift of norm * denormal = 87)
+ 263 012a 352E     		ld.w	%r5, %r3		; result1 = result3
+ 264 012c 642E     		ld.w	%r4, %r6		; result2 = result4
+ 265              	
+ 266 012e 01C00264 		xsub	%r2, 64	; shift = shift - 64
+ 267              	
+ 268 0132 2D1F     		jp.d	lshift
+ 269 0134 036C     		ld.w	%r3, 0			; result3 = 0
+ 270              	
+ 271              	lshft32:
+ 272 0136 452E     		ld.w	%r5, %r4		; result1 = result2
+ 273 0138 342E     		ld.w	%r4, %r3		; result2 = result3
+ 274 013a 632E     		ld.w	%r3, %r6		; result3 = result4
+ 275 013c 281F     		jp.d	lshift
+ 276 013e 0266     		sub		%r2, 32			; shift = shift - 32
+ 277              	
+ 278              	rshift:
+ 279              		; case: shift < 0
+GAS LISTING muldf3.s 			page 6
+
+
+ 280 0140 223E     		not		%r2, %r2		; shift = ~shift + 1
+ 281 0142 1260     		add		%r2, 1
+ 282              	
+ 283 0144 00C0926A 		xcmp	%r2, 41			; if shift > 41 (64-min.count-1) then
+ 284 0148 0E08     		jrgt	underflow
+ 285              	
+ 286 014a 00C0026A 		xcmp	%r2, 32			; if shift < 32 then shift right
+ 287 014e 0E0C     		jrlt	doshift
+ 288              	
+ 289              		; case: 40 => shift >= 32
+ 290 0150 542E     		ld.w	%r4, %r5		; result2 = result1
+ 291 0152 0266     		sub		%r2, 32			; shift = shift - 32
+ 292              	
+ 293              		; xsrl	%r4, %r2		; result2 >> shift
+ 294              		; 32-bit variable shift routine
+ 295              	L1:
+ 296 0154 8268     		cmp		%r2, 8			; if shift <= 8 then goto L2
+ 297 0156 040E     		jrle	L2
+ 298              	
+ 299 0158 8488     		srl		%r4, 8			; result >> %r2
+ 300 015a FD1F     		jp.d	L1
+ 301 015c 8264     		sub		%r2, 8			; shift = shift - 8
+ 302              	
+ 303              	L2:
+ 304 015e 2489     		srl		%r4, %r2		; last shift
+ 305              	
+ 306 0160 3A1F     		jp.d	finish
+ 307 0162 056C     		ld.w	%r5, 0			; result1 = 0
+ 308              	
+ 309              	underflow:
+ 310 0164 056C     		ld.w	%r5, 0			; result1 = 0
+ 311 0166 3D1F     		jp.d	end
+ 312 0168 046C     		ld.w	%r4, 0			; result2 = 0
+ 313              	
+ 314              	doshift:
+ 315              		; {%r5, %r4} >> shift
+ 316              		;xsrl	%r4, %r2		; shift low 32-bits to the right x bits (shift amount = x)
+ 317              		;xrr	%r5, %r2		; rotate high 32-bits to the right x bits
+ 318              		;xsrl	%r3, %r2		; make a mask for last 32-x bits --> %r2 = 000...111
+ 319              	
+ 320 016a F96F     		ld.w	%r9, -1			; %r2 = 0xffff ffff
+ 321              		; used in 64-bit variable shifting	; 	SHFTROTSHFT %r2, %r4, %r5, %r9, srl, rr, %r2
+ 322              		; $1 = shift amount
+ 323              		; $2 = 1st input register (shifted)
+ 324              		; $3 = 2nd input register (rotated)
+ 325              		; $4 = 3rd input register (mask --> shifted)
+ 326              		; $5 = shift instruction
+ 327              		; $6 = rotate instruction
+ 328              		; $7 = temp register
+ 329 016c 222E     		ld.w	%r2, %r2		; temp = shift amount
+ 330              	
+ 331              	__L0001:
+ 332 016e 8268     		cmp		%r2, 8		; if temp <= 8 then goto $$2
+ 333 0170 060E     		jrle	__L0002
+ 334              	
+ 335 0172 8488     		srl		%r4, 8		; shift 1st register
+ 336 0174 8598     		rr		%r5, 8		; rotate 2nd register
+GAS LISTING muldf3.s 			page 7
+
+
+ 337 0176 8988     		srl		%r9, 8		; shift 3rd register
+ 338 0178 FB1F     		jp.d	__L0001
+ 339 017a 8264     		sub		%r2, 8		; temp = temp - 8
+ 340              	
+ 341              	__L0002:
+ 342 017c 2489     		srl		%r4, %r2		; last shift
+ 343 017e 2599     		rr		%r5, %r2		; last rotate
+ 344 0180 2989     		srl		%r9, %r2		; last shift
+ 345 0182 923E     		not		%r2, %r9		; flip mask for first x bits --> %r9 = 111...000 (mask)
+ 346 0184 5232     		and		%r2, %r5		; isolate first x bits of %r5
+ 347 0186 2436     		or		%r4, %r2		; add first x bits of %r5 to %r4
+ 348 0188 261F     		jp.d	finish
+ 349 018a 9532     		and		%r5, %r9		; keep the low 32-x bits of %r5
+ 350              	
+ 351              	lshift:					; case: shift >= 0
+ 352              		; {%r5, %r4, %r10} << shift
+ 353              		;xsll	%r5, %r2		; shift high 32-bits to the left x bits (shift amount = %r3 = x)
+ 354              		;xrl	%r4, %r2		; rotate mid 32-bits to the left x bits
+ 355              		;xsll	%r3, %r2		; make a mask for first 32-x bits --> %r3 = 111...000
+ 356              	
+ 357 018c F96F     		ld.w	%r9, -1			; %r9 = 0xffff ffff
+ 358              		; used in 64-bit variable shifting	; 	SHFTROTSHFT %r2, %r5, %r4, %r9, sll, rl, %r8		; %r8 = temp
+ 359              		; $1 = shift amount
+ 360              		; $2 = 1st input register (shifted)
+ 361              		; $3 = 2nd input register (rotated)
+ 362              		; $4 = 3rd input register (mask --> shifted)
+ 363              		; $5 = shift instruction
+ 364              		; $6 = rotate instruction
+ 365              		; $7 = temp register
+ 366 018e 282E     		ld.w	%r8, %r2		; temp = shift amount
+ 367              	
+ 368              	__L0003:
+ 369 0190 8868     		cmp		%r8, 8		; if temp <= 8 then goto $$2
+ 370 0192 060E     		jrle	__L0004
+ 371              	
+ 372 0194 858C     		sll		%r5, 8		; shift 1st register
+ 373 0196 849C     		rl		%r4, 8		; rotate 2nd register
+ 374 0198 898C     		sll		%r9, 8		; shift 3rd register
+ 375 019a FB1F     		jp.d	__L0003
+ 376 019c 8864     		sub		%r8, 8		; temp = temp - 8
+ 377              	
+ 378              	__L0004:
+ 379 019e 858D     		sll		%r5, %r8		; last shift
+ 380 01a0 849D     		rl		%r4, %r8		; last rotate
+ 381 01a2 898D     		sll		%r9, %r8		; last shift
+ 382 01a4 983E     		not		%r8, %r9		; flip mask for last x bits --> %r8 = 000...111 (mask)
+ 383 01a6 862E     		ld.w	%r6, %r8		; temp = %r8
+ 384 01a8 4832     		and		%r8, %r4		; isolate last x bits of %r4
+ 385 01aa 8536     		or		%r5, %r8		; add last x bits of %r4 to %r5
+ 386              		
+ 387 01ac 0368     		cmp		%r3, 0			; if result3 = 0 then done shifting
+ 388 01ae 0B19     		jreq.d	overchk
+ 389 01b0 9432     		and		%r4 %r9			; keep the high 32-x bits of %r4
+ 390              	
+ 391              		; case: result3 != 0
+ 392              		; 	MXRL	%r3, %r2		; rotate last register to the left
+ 393              	__L0005:
+GAS LISTING muldf3.s 			page 8
+
+
+ 394              		
+ 395              	;	sub		%sp, 1
+ 396              	;	ld.w	[%sp+0], $2		; rs･ｹ･ｿ･ﾃ･ｯﾂﾔﾈ
+ 397              		
+ 398 01b2 F271     		and		%r2,0x1f			; ｺﾇﾂ逾｡ｼ･ﾆ｡ｼ･ﾈｿ=｣ｳ｣ｱ
+ 399              	__L0006:
+ 400 01b4 8268     		cmp		%r2,0x8			; if rs <= 8
+ 401 01b6 040E     		jrle	__L0007				; then $$3
+ 402 01b8 839C     		rl		%r3,0x8			; rd << 8
+ 403 01ba FD1F     		jp.d	__L0006
+ 404 01bc 8264     		sub		%r2,0x8			; ｻﾄ･｡ｼ･ﾆ｡ｼ･ﾈｲｿｷﾗｻｻ
+ 405              	__L0007:
+ 406 01be 239D     		rl		%r3,%r2
+ 407              	;	ld.w	$2, [%sp+0]		; rs･ｹ･ｿ･ﾃ･ｯﾉｵ｢
+ 408              	;	add		%sp, 1
+ 409              	
+ 410 01c0 6332     		and		%r3, %r6		; isolate last x bits of %r3
+ 411 01c2 3436     		or		%r4, %r3		; add last x bits to %r4
+ 412              	
+ 413              	overchk:
+ 414 01c4 1FC0F16B 		xcmp	%r1, 0x7ff
+ 415 01c8 060C     		jrlt	finish			; if exp < 0xff then jump to finish
+ 416              	
+ 417              	overflow:
+ 418 01ca FECF00C0 		xld.w	%r5, 0x7ff00000	; put infinity into result
+ 418      056C
+ 419 01d0 081F     		jp.d	end				; delayed jump
+ 420 01d2 046C     		ld.w	%r4, 0
+ 421              	
+ 422              	finish:
+ 423              		; %r0 = sign, %r1 = exponent, %r5 = mantissa
+ 424              	
+ 425 01d4 01C0FFDF 		xand	%r5, 0xfffff	; isolate mantissa
+ 425      F573
+ 426              	
+ 427 01da 81984198 		xrr		%r1, 12			; position exponent bits to [30:23]
+ 428 01de 1536     		or		%r5, %r1
+ 429              	
+ 430              	end:
+ 431 01e0 1098     		rr		%r0, 1			; position sign bit to MSB
+ 432 01e2 0536     		or		%r5, %r0		; add sign bit
+ 433              	
+ 434              		;@@@ 01/01/23 add start hinokuchi
+ 435              		;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+ 436              		;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+ 437              		;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+ 438              		;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+ 439              		;add		%sp, 4
+ 440              		;@@@ 01/01/23 add end
+ 441 01e4 4302     		popn	%r3				; restore register values
+ 442              	
+ 443 01e6 4006     		ret
diff --git a/gcc/config/c33/libgcc/muldf3.s b/gcc/config/c33/libgcc/muldf3.s
new file mode 100644
index 0000000..f84e65b
--- /dev/null
+++ b/gcc/config/c33/libgcc/muldf3.s
@@ -0,0 +1,443 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : muldf3.s
+;*
+;*	Double floating point multiplication function
+;*		input: (%r7, %r6) & (%r9, %r8)
+;*		output: (%r5, %r4)
+;*
+;*	Begin						1996/09/12	V. Chan
+;*	Fixed bug at multiply:		1997/02/18	V. Chan
+;*  ﾊﾑｹｹ						2001/01/30  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __muldf3
+
+;;macro	SHFTROTSHFT $1, $2, $3, $4, $5, $6, $7
+	; used in 64-bit variable shifting
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+;	ld.w	$7, $1		; temp = shift amount
+
+;$$1:
+;	cmp		$7, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$5		$2, 8		; shift 1st register
+;	$6		$3, 8		; rotate 2nd register
+;	$5		$4, 8		; shift 3rd register
+;	jp.d	$$1
+;	sub		$7, 8		; temp = temp - 8
+
+;$$2:
+;	$5		$2, $7		; last shift
+;	$6		$3, $7		; last rotate
+;	$5		$4, $7		; last shift
+;;endm
+
+__muldf3:
+	pushn	%r3				; save register values
+	;@@@ 01/01/30 add start hinokuchi
+	;sub		%sp, 4
+	;ld.w	[%sp+0], %r10	; %r10ﾂﾔﾈ
+	;ld.w	[%sp+1], %r11	; %r11ﾂﾔﾈ
+	;ld.w	[%sp+2], %r12	; %r12ﾂﾔﾈ
+	;ld.w	[%sp+3], %r13	; %r13ﾂﾔﾈ
+	;@@@ 01/01/30 add end
+
+	ld.w	%r0, %r7		; put sign of input1 (%r7) into %r0
+	rl		%r0, 1
+	and		%r0, 1
+
+	ld.w	%r2, %r9		; put sign of input2 (%r9) into %r2
+	rl		%r2, 1
+	and		%r2, 1
+
+	xor		%r0, %r2		; put new sign into register %r0
+
+	ld.w	%r5, 0			; clear output register
+	;ld.w	%r4, 0			; moved to line 38 for a delayed jump
+	
+	sll		%r7, 1			; clear MSB
+	srl		%r7, 1
+	cmp		%r7, 0			; checking if input1 = 0
+	jrne.d	input2
+	ld.w	%r4, 0
+	cmp		%r6, 0			
+	ext		end@rm
+	jreq	end@rl			; if {%r7, %r6} = 0 then end
+
+input2:
+	sll		%r9, 1			; clear MSB
+	srl		%r9, 1	
+	cmp		%r9, 0			; checking if input2 = 0
+	jrne	getexp
+	cmp		%r8, 0
+	ext		end@rm
+	jreq	end@rl				; if {%r9, %r8} = 0 then end
+
+getexp:
+	ld.w	%r1, %r7		; put exponent1 into %r1
+	xsrl 	%r1, 20
+
+	xcmp	%r1, 0x7ff		; check exp1 for overflow value
+	ext		overflow@rm
+	jreq	overflow@rl
+
+	ld.w	%r3, %r9		; put exponent2 into %r3
+	xsrl	%r3, 20
+
+	xcmp	%r3, 0x7ff		; check exp2 for overflow value
+	ext		overflow@rm
+	jreq	overflow@rl
+
+	; free	%r2, %r11 - %r13
+	; %r0 = sign, %r1 = sisu1, %r3 = sisu2
+	; %r10 = implied bit
+
+	;@@@ 01/02/16 del xld.w	%r10, 0x100000	; implied bit
+	ld.w	%r2, 1			; temp = 1
+	;@@@ 01/02/16 del xld.w	%r13, 0xfffff
+
+	; isolate mantissa1
+	xand	%r7, 0xfffff	; clear first 12 bits of %r6
+	cmp		%r1, 0
+	jreq	man2			; if exp1 = 0 (denormal)
+	xoor	%r7, 0x100000	; else add implied bit to mantissa
+
+	ld.w	%r2, 0			; temp = 0
+
+man2:
+	; isolate mantissa2
+	xand	%r9, 0xfffff	; clear first 12 bits of %r7
+
+	cmp		%r3, 0
+	jreq	tempadd			; if exp2 = 0 then jump to tempadd
+	xoor	%r9, 0x100000	; else add implied bit
+	jp	multiply			; delayed jump
+
+tempadd:
+	add		%r2, 1			; temp = temp + 1 (2 if den * den : 1 if nor * den)
+	
+multiply:
+	; %r0 = result sign, %r1 = result exponent
+
+	; calculate and check new exponent
+	add		%r1, %r3		; sisu = sisu1 + sisu2 - bias + temp
+
+	xsub	%r1, 0x3ff
+
+	add		%r1, %r2
+
+	xcmp	%r1, 0x7ff		; if exp >= 0x7ff then goto overflow
+	ext		overflow@rm
+	jrge	overflow@rl
+
+	; max. shift from normal to denormal = 52
+	; min. exp = 1 - max. shift = -51
+	xcmp	%r1, -51		; if exp < -51 then goto underflow
+	jrlt	underflow
+
+	; 64-bit * 64-bit = 128-bit
+	; 1st(128 ~ 97), 2nd(96 ~ 65), 3rd(64 ~ 33), 4th(32 ~ 0)
+	; (%r7,%r6) * (%r9,%r8)
+	; %r7 * a15 --> 1st,2nd
+	; %r7 * a14 --> 2nd,3rd
+	; %r6 * a15 --> 2nd,3rd
+	; %r6 * a14 --> 3rd,4th
+	; %r5 = result1, %r4 = result2, %r10 = result3, %r11 = result4, %r12 = temp
+	ld.w	%r2, 0			; temp variable for adc and loop counter
+	mltu.w	%r7, %r9		; kasu1 * kasu2
+	ld.w	%r5, %ahr		; %r5 = result1	
+	ld.w	%r4, %alr		; %r4 = result2
+	mltu.w	%r7, %r8		; kasu1 * kasu2_2
+	ld.w	%r7, %ahr
+	add		%r4, %r7
+	adc		%r5, %r2		; add carry
+	ld.w	%r3, %alr		; %r10 = result3
+	mltu.w	%r6, %r9		; kasu1_2 * kasu2
+	ld.w	%r7, %alr
+	add		%r3, %r7
+	adc		%r4, %r2		; add carry
+	adc		%r5, %r2		; add carry
+	ld.w	%r7, %ahr
+	add		%r4, %r7
+	adc		%r5, %r2		; add carry
+	mltu.w	%r6, %r8		; kasu1_2 * kasu2_2
+	ld.w	%r7, %ahr
+	add		%r3, %r7
+	adc		%r4, %r2		; add carry
+	adc		%r5, %r2
+	ld.w	%r6, %alr		; %r11 = result4
+	
+	; %r8 will be first result register > 0
+	cmp		%r5, 0			; if %r5 !=0 then count it
+	jrne.d	count
+	ld.w	%r8, %r5
+
+	xld.w	%r2, 32			; %r2 = loop counter = 32 
+	cmp		%r4, 0			; elsif %r4 != 0 then count it
+	jrne.d	count
+	ld.w	%r8, %r4
+
+	xld.w	%r2, 64			; %r2 = loop counter = 64
+	cmp		%r3, 0			; elsif %r10 != 0 then count it
+	jrne.d	count
+	ld.w	%r8, %r3
+
+	xld.w	%r2, 96			; %r2 = loop counter = 96
+	ld.w	%r8, %r6		; else count 0's leading %r6
+	
+count:
+	scan1	%r7, %r8		; %r7 = count
+	jruge	normalize		; if count !=8 then goto normalize
+	add		%r2, 8			; add 8 to loop counter
+	jp.d	count
+	sll		%r8, 8			; shift register to the left 8 bits
+
+normalize:
+	; free	%r2 - %r11, %r13
+	; %r0 = sign, %r1 = exp, %r7 = count
+	; note: max. count = 127, min. count = 22
+
+	add		%r7, %r2		; count = count + loopcounter
+
+	cmp		%r1, 0			; if exp > 0 then jump to expgtz
+	jrgt.d	expgtz
+	sub		%r7, 23			; count = count - 23
+
+	; case: exp <= 0
+sub %sp, 1
+ld.w	[%sp+0x0], %r3	; %r3ﾂﾔﾈ
+	ld.w	%r3, 1			; %r3 = 1 - exp
+	sub		%r3, %r1
+	ld.w	%r2, 12			; %r2 = shift
+	sub		%r2, %r3		; shift = 12 - (1 - exp)
+ld.w	%r3, [%sp+0x0]	; %r3ﾉｵ｢
+add %sp, 1
+	cmp		%r1, %r7
+	jrle.d	shift			; if exp <= count then jump to shift
+	ld.w	%r1, 0			; exp = 0
+
+	; case: exp > count - 23
+	jp.d	shift			; delayed jump
+	ld.w	%r1, 1			; exp = 1
+	
+expgtz:
+	cmp		%r7, %r1		; if count < exp then goto shftltexp
+	jrlt.d	shftltexp
+	ld.w	%r2, 12			; shift = 12
+
+	; case: original count - 23 >= exp
+	add		%r2, %r1		; shift = shift + exp - 1
+	sub		%r2, 1			; shift as much as exp allows (until denormal)
+	jp.d	shift
+	ld.w	%r1, 0			; exp = 0
+	
+shftltexp:
+	sub		%r1, %r7		; exp = exp - count
+	add		%r2, %r7		; shift = shift + count
+
+shift:
+	cmp		%r2, 0			;if shift < 0 then shift to the right
+	jrlt	rshift
+
+	xcmp	%r2, 32			; if 0 =< shift < 32 then goto lshift
+	jrlt	lshift
+
+	xcmp	%r2, 64			; if 32 =< shift < 64 then goto shft32
+	jrlt	lshft32
+
+	; case:	shift >= 64		(note: max. shift of norm * denormal = 87)
+	ld.w	%r5, %r3		; result1 = result3
+	ld.w	%r4, %r6		; result2 = result4
+
+	xsub	%r2, 64	; shift = shift - 64
+
+	jp.d	lshift
+	ld.w	%r3, 0			; result3 = 0
+
+lshft32:
+	ld.w	%r5, %r4		; result1 = result2
+	ld.w	%r4, %r3		; result2 = result3
+	ld.w	%r3, %r6		; result3 = result4
+	jp.d	lshift
+	sub		%r2, 32			; shift = shift - 32
+
+rshift:
+	; case: shift < 0
+	not		%r2, %r2		; shift = ~shift + 1
+	add		%r2, 1
+
+	xcmp	%r2, 41			; if shift > 41 (64-min.count-1) then
+	jrgt	underflow
+
+	xcmp	%r2, 32			; if shift < 32 then shift right
+	jrlt	doshift
+
+	; case: 40 => shift >= 32
+	ld.w	%r4, %r5		; result2 = result1
+	sub		%r2, 32			; shift = shift - 32
+
+	; xsrl	%r4, %r2		; result2 >> shift
+	; 32-bit variable shift routine
+L1:
+	cmp		%r2, 8			; if shift <= 8 then goto L2
+	jrle	L2
+
+	srl		%r4, 8			; result >> %r2
+	jp.d	L1
+	sub		%r2, 8			; shift = shift - 8
+
+L2:
+	srl		%r4, %r2		; last shift
+
+	jp.d	finish
+	ld.w	%r5, 0			; result1 = 0
+
+underflow:
+	ld.w	%r5, 0			; result1 = 0
+	jp.d	end
+	ld.w	%r4, 0			; result2 = 0
+
+doshift:
+	; {%r5, %r4} >> shift
+	;xsrl	%r4, %r2		; shift low 32-bits to the right x bits (shift amount = x)
+	;xrr	%r5, %r2		; rotate high 32-bits to the right x bits
+	;xsrl	%r3, %r2		; make a mask for last 32-x bits --> %r2 = 000...111
+
+	ld.w	%r9, -1			; %r2 = 0xffff ffff
+	; used in 64-bit variable shifting	; 	SHFTROTSHFT %r2, %r4, %r5, %r9, srl, rr, %r2
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r2, %r2		; temp = shift amount
+
+__L0001:
+	cmp		%r2, 8		; if temp <= 8 then goto $$2
+	jrle	__L0002
+
+	srl		%r4, 8		; shift 1st register
+	rr		%r5, 8		; rotate 2nd register
+	srl		%r9, 8		; shift 3rd register
+	jp.d	__L0001
+	sub		%r2, 8		; temp = temp - 8
+
+__L0002:
+	srl		%r4, %r2		; last shift
+	rr		%r5, %r2		; last rotate
+	srl		%r9, %r2		; last shift
+	not		%r2, %r9		; flip mask for first x bits --> %r9 = 111...000 (mask)
+	and		%r2, %r5		; isolate first x bits of %r5
+	or		%r4, %r2		; add first x bits of %r5 to %r4
+	jp.d	finish
+	and		%r5, %r9		; keep the low 32-x bits of %r5
+
+lshift:					; case: shift >= 0
+	; {%r5, %r4, %r10} << shift
+	;xsll	%r5, %r2		; shift high 32-bits to the left x bits (shift amount = %r3 = x)
+	;xrl	%r4, %r2		; rotate mid 32-bits to the left x bits
+	;xsll	%r3, %r2		; make a mask for first 32-x bits --> %r3 = 111...000
+
+	ld.w	%r9, -1			; %r9 = 0xffff ffff
+	; used in 64-bit variable shifting	; 	SHFTROTSHFT %r2, %r5, %r4, %r9, sll, rl, %r8		; %r8 = temp
+	; $1 = shift amount
+	; $2 = 1st input register (shifted)
+	; $3 = 2nd input register (rotated)
+	; $4 = 3rd input register (mask --> shifted)
+	; $5 = shift instruction
+	; $6 = rotate instruction
+	; $7 = temp register
+	ld.w	%r8, %r2		; temp = shift amount
+
+__L0003:
+	cmp		%r8, 8		; if temp <= 8 then goto $$2
+	jrle	__L0004
+
+	sll		%r5, 8		; shift 1st register
+	rl		%r4, 8		; rotate 2nd register
+	sll		%r9, 8		; shift 3rd register
+	jp.d	__L0003
+	sub		%r8, 8		; temp = temp - 8
+
+__L0004:
+	sll		%r5, %r8		; last shift
+	rl		%r4, %r8		; last rotate
+	sll		%r9, %r8		; last shift
+	not		%r8, %r9		; flip mask for last x bits --> %r8 = 000...111 (mask)
+	ld.w	%r6, %r8		; temp = %r8
+	and		%r8, %r4		; isolate last x bits of %r4
+	or		%r5, %r8		; add last x bits of %r4 to %r5
+	
+	cmp		%r3, 0			; if result3 = 0 then done shifting
+	jreq.d	overchk
+	and		%r4 %r9			; keep the high 32-x bits of %r4
+
+	; case: result3 != 0
+	; 	MXRL	%r3, %r2		; rotate last register to the left
+__L0005:
+	
+;	sub		%sp, 1
+;	ld.w	[%sp+0], $2		; rs･ｹ･ｿ･ﾃ･ｯﾂﾔﾈ
+	
+	and		%r2,0x1f			; ｺﾇﾂ逾｡ｼ･ﾆ｡ｼ･ﾈｿ=｣ｳ｣ｱ
+__L0006:
+	cmp		%r2,0x8			; if rs <= 8
+	jrle	__L0007				; then $$3
+	rl		%r3,0x8			; rd << 8
+	jp.d	__L0006
+	sub		%r2,0x8			; ｻﾄ･｡ｼ･ﾆ｡ｼ･ﾈｲｿｷﾗｻｻ
+__L0007:
+	rl		%r3,%r2
+;	ld.w	$2, [%sp+0]		; rs･ｹ･ｿ･ﾃ･ｯﾉｵ｢
+;	add		%sp, 1
+
+	and		%r3, %r6		; isolate last x bits of %r3
+	or		%r4, %r3		; add last x bits to %r4
+
+overchk:
+	xcmp	%r1, 0x7ff
+	jrlt	finish			; if exp < 0xff then jump to finish
+
+overflow:
+	xld.w	%r5, 0x7ff00000	; put infinity into result
+	jp.d	end				; delayed jump
+	ld.w	%r4, 0
+
+finish:
+	; %r0 = sign, %r1 = exponent, %r5 = mantissa
+
+	xand	%r5, 0xfffff	; isolate mantissa
+
+	xrr		%r1, 12			; position exponent bits to [30:23]
+	or		%r5, %r1
+
+end:
+	rr		%r0, 1			; position sign bit to MSB
+	or		%r5, %r0		; add sign bit
+
+	;@@@ 01/01/23 add start hinokuchi
+	;ld.w	%r13, [%sp+3]	; %r13ﾉｵ｢
+	;ld.w	%r12, [%sp+2]	; %r12ﾉｵ｢
+	;ld.w	%r11, [%sp+1]	; %r11ﾉｵ｢
+	;ld.w	%r10, [%sp+0]	; %r10ﾉｵ｢
+	;add		%sp, 4
+	;@@@ 01/01/23 add end
+	popn	%r3				; restore register values
+
+	ret
diff --git a/gcc/config/c33/libgcc/mulsf3.lst b/gcc/config/c33/libgcc/mulsf3.lst
new file mode 100644
index 0000000..1df33d6
--- /dev/null
+++ b/gcc/config/c33/libgcc/mulsf3.lst
@@ -0,0 +1,327 @@
+GAS LISTING mulsf3.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : mulsf3.s
+   6              	;*
+   7              	;*	Single floating point multiplication function
+   8              	;*		input: %r6, %r7
+   9              	;*		output: %r4
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/26  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*
+  15              	;*****************************************
+  16              	
+  17              	.section .text
+  18              	.align 1
+  19              	.global __mulsf3
+  20              	
+  21              	;==============================================
+  22              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  23              	;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+  24              	;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+  25              	;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/temp/shift
+  26              	;	%r3:ｻﾘｿﾉ｣ｲ(8bit)/mask
+  27              	;	%r4:ﾌ皃ﾃﾍ(float)/ｾ霆ｻｷｲﾌ[H]
+  28              	;	%r5:implied bit/count
+  29              	;	%r6:ｰｿ｣ｱ/ｾ霆ｻｷｲﾌ[L]/ｲｾｿ[L]
+  30              	;	%r7:ｰｿ｣ｲ
+  31              	;	%r8:mask
+  32              	;	%r9:overflow value
+  33              	;	%r12:scan64 ｰｿ｣ｱ
+  34              	;	%r13:scan64 ｰｿ｣ｲ
+  35              	;==============================================
+  36              	
+  37              	
+  38              	;;macro	VARSHIFT $1, $2, $3
+  39              		; used in 32-bit variable shifting
+  40              		; $1 = input register
+  41              		; $2 = shift amount
+  42              		; $3 = shift instruction
+  43              	;$$1:
+  44              	;	cmp		$2, 8		; if temp <= 8 then goto $$2
+  45              	;	jrle	$$2
+  46              	
+  47              	;	$3		$1, 8		; shift input register 8 bits
+  48              	;	jp.d	$$1
+  49              	;	sub		$2, 8		; temp = temp - 8
+  50              	
+  51              	;$$2:
+  52              	;	$3		$1, $2		; last shift
+  53              	;;endm
+  54              	
+  55              	__mulsf3:
+  56              	
+  57 0000 0302     		pushn	%r3				; save register values
+GAS LISTING mulsf3.s 			page 2
+
+
+  58              	
+  59              		;@@@ 01/01/26 add start hinokuchi
+  60              		;sub		%sp, 2
+  61              		;ld.w	[%sp+0], %r12	; %r12ﾂﾔﾈ
+  62              		;ld.w	[%sp+1], %r13	; %r13ﾂﾔﾈ
+  63              		;@@@ 01/01/26 add end
+  64              	
+  65              	
+  66              		;@@@ 01/02/15 del xld.w	%r9, 0xff		; overflow value(%r9) <- 0xff
+  67              	
+  68 0002 602E     		ld.w	%r0, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ(%r6) 
+  69 0004 109C     		rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+  70 0006 1070     		and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+  71              	
+  72 0008 722E     		ld.w	%r2, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ(%r7)
+  73 000a 129C     		rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+  74 000c 1270     		and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1 
+  75              	
+  76 000e 203A     		xor		%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ~ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+  77 0010 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+  78              	
+  79 0012 168C     		sll		%r6, 1			; ｰｿ｣ｱ(%r6) << 1  clear MSB
+  80 0014 1688     		srl		%r6, 1			; ｰｿ｣ｱ(%r6) >> 1
+  81 0016 0668     		cmp		%r6, 0			
+  82 0018 00C0     		ext		end@rm
+  83 001a 8718     		jreq	end@rl			; if ｰｿ｣ｱ(%r6) = 0 then end
+  84              		
+  85 001c 178C     		sll		%r7, 1			; ｰｿ｣ｲ(%r7) << 1 clear MSB
+  86 001e 1788     		srl		%r7, 1			; ｰｿ｣ｲ(%r7) >> 1
+  87 0020 0768     		cmp		%r7, 0		
+  88 0022 00C0     		ext		end@rm
+  89 0024 8218     		jreq	end@rl			; if ｰｿ｣ｲ(%r7) = 0 then end
+  90              	
+  91 0026 612E     		ld.w	%r1, %r6		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ(%r6)
+  92 0028 81888188 		xsrl 	%r1, 23			; ｻﾘｿﾉ｣ｱ(%r1) >> 23
+  92      7188
+  93              	
+  94 002e 03C0F16B 		xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+  95 0032 710A     		jrge	overflow		; then jump to overflow
+  96              	
+  97 0034 732E     		ld.w	%r3, %r7		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ(%r7)
+  98 0036 83888388 		xsrl	%r3, 23			; ｻﾘｿﾉ｣ｲ(%r3) >> 23
+  98      7388
+  99              	
+ 100 003c 03C0F36B 		xcmp	%r3, 0xff		; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+ 101 0040 6A0A     		jrge	overflow		; then jump to overflow
+ 102              	
+ 103              		;@@@ 01/02/15 del xld.w	%r8, 0x7fffff 	; mask(%r8) <- 0x7fffff set mask for isolating mantissa
+ 104              		;@@@ 01/02/15 del xld.w	%r5, 0x800000	; implied bit(%r5) <- 0x800000
+ 105 0042 0FC0FFDF 		xld.w	%r5, 0x7fffff 	; mask(%r5) <- 0x7fffff set mask for isolating mantissa @@@ 01/02/15 add
+ 105      F56F
+ 106              	
+ 107 0048 126C     		ld.w	%r2, 1			; temp(%r2) <- 1
+ 108              	
+ 109              		; isolate mantissa1
+ 110 004a 0168     		cmp		%r1, 0
+ 111 004c 0619     		jreq.d	getman2			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 (denormal)
+GAS LISTING mulsf3.s 			page 3
+
+
+ 112 004e 5632     		and		%r6, %r5		; clear first 9 bits of %r6
+ 113 0050 10C000C0 		xoor	%r6, 0x800000	; else add implied bit(0x800000) to mantissa
+ 113      0674
+ 114              	
+ 115 0056 026C     		ld.w	%r2, 0			; temp(%r2) = 0
+ 116              	
+ 117              	getman2:
+ 118              		; isolate mantissa2
+ 119 0058 0368     		cmp		%r3, 0
+ 120 005a 0719     		jreq.d	flag			; if exp2 = 0 then jump to flag
+ 121 005c 5732     		and		%r7, %r5		; clear first 9 bits of %r7
+ 122 005e 10C000C0 		xld.w	%r5, 0x800000	; implied bit(%r5) <- 0x800000 @@@ 01/02/15 add
+ 122      056C
+ 123 0064 031F     		jp.d	multi			; delayed jump
+ 124 0066 5736     		or	%r7, %r5			; else add implied bit(0x800000)
+ 125              	
+ 126              	flag:
+ 127 0068 1260     		add		%r2, 1			; temp(%r2) = 2 or 1 (2 if den * den : 1 if nor * den)
+ 128              	
+ 129              	multi:
+ 130              		; check result exponent
+ 131 006a 3122     		add		%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + ｻﾘｿﾉ｣ｲ(%r3) + temp(%r2) - bias(0x7f)
+ 132 006c 2122     		add		%r1, %r2
+ 133              	
+ 134 006e 01C0F167 		xsub	%r1, 0x7f		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - 0x7f
+ 135              	
+ 136 0072 03C0F16B 		xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= 0xff then goto overflow
+ 137 0076 4F0A     		jrge	overflow
+ 138              	
+ 139 0078 A16A     		xcmp	%r1, -22		; if ｻﾘｿﾉ｣ｱ(%r1) < -22 then goto end
+ 140 007a 570D     		jrlt.d	end
+ 141 007c 046C     		ld.w	%r4, 0			; underflow value
+ 142              	
+ 143 007e 76AE     		mltu.w	%r6, %r7		; %ahr,%alr <- ｰｿ｣ｱ(%r6) * ｰｿ｣ｲ(%r7)  multiply: 64-bit result is {%r4, %r6}
+ 144 0080 34A4     		ld.w	%r4, %ahr		; ｾ霆ｻｷｲﾌ[H](%r4) <- %ahr
+ 145 0082 26A4     		ld.w	%r6, %alr		; ｾ霆ｻｷｲﾌ[L](%r6) <- %alr
+ 146              	
+ 147 0084 482E     		ld.w	%r8, %r4		; scan64 ｰｿ｣ｱ(%r8) <- ｾ霆ｻｷｲﾌ[H](%r4)
+ 148 0086 692E     		ld.w	%r9, %r6		; scan64 ｰｿ｣ｲ(%r9) <- ｾ霆ｻｷｲﾌ[L](%r6)
+ 149 0088 00C000C0 		xcall	__scan64
+ 149      001C
+ 150 008e 952E     		ld.w	%r5, %r9		; %r5 = count (; of leading 0's in result)
+ 151              	
+ 152              	normalize:
+ 153              		; %r0 = result sign, %r1 = result exponent
+ 154              		; %r5 = count, %r4 = result1, %r6 = result2
+ 155              		; note: max. count = 63, min. count = 16
+ 156              	
+ 157 0090 0168     		cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) > 0 then jump to expgtz
+ 158 0092 0B09     		jrgt.d	expgtz
+ 159 0094 1565     		sub		%r5, 17			; count(%r5) = count(%r5) - 17
+ 160              	
+ 161              		; case: exp <= 0
+ 162 0096 136C     		ld.w	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) = 1 - ｻﾘｿﾉ｣ｱ(%r1)
+ 163 0098 1326     		sub		%r3, %r1
+ 164 009a 926C     		ld.w	%r2, 9			; %r2 = shift
+ 165 009c 3226     		sub		%r2, %r3		; shift(%r2) = 9 - (1 - ｻﾘｿﾉ｣ｱ(%r1))
+GAS LISTING mulsf3.s 			page 4
+
+
+ 166              	
+ 167 009e 512A     		cmp		%r1, %r5
+ 168 00a0 0D0F     		jrle.d	shift			; if ｻﾘｿﾉ｣ｱ(%r1) <= count then jump to shift
+ 169 00a2 016C     		ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0
+ 170              	
+ 171              		; case: exp > count - 17  (only when exp = 0 and original count = 16)
+ 172 00a4 0B1F     		jp.d	shift			; delayed jump
+ 173 00a6 116C     		ld.w	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) <- 1
+ 174              	
+ 175              	expgtz:
+ 176 00a8 152A     		cmp		%r5, %r1		; if count(%r5) < ｻﾘｿﾉ｣ｱ(%r1) then goto shftltexp
+ 177 00aa 060D     		jrlt.d	shftltexp
+ 178 00ac 926C     		ld.w	%r2, 9			; shift(2) <- 9 (for positioning)
+ 179              	
+ 180              		; case: original count - 17 >= exp
+ 181 00ae 1222     		add		%r2, %r1		; shift(%r2) = shift(%r2) + ｻﾘｿﾉ｣ｱ(%r1) - 1
+ 182 00b0 1264     		sub		%r2, 1			; shift(%r2) as much as exp allows (until denormal)
+ 183 00b2 041F     		jp.d	shift
+ 184 00b4 016C     		ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0
+ 185              		
+ 186              	shftltexp:
+ 187 00b6 5126     		sub		%r1, %r5		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - count(%r5)
+ 188 00b8 5222     		add		%r2, %r5		; shift(2) = shift(%r2) + count(%r5)
+ 189              	
+ 190              	shift:
+ 191              		; max. shift < 64
+ 192 00ba 0268     		cmp		%r2, 0			; if shift(%r2) < 0 then shift to the right
+ 193 00bc 0D0C     		jrlt	rshift
+ 194 00be 00C0026A 		xcmp	%r2, 32			; if shift(%r2) < 32 then goto lshift
+ 195 00c2 170C     		jrlt	lshift
+ 196              	
+ 197              		; case: shift >= 32 (at least one is denormal)
+ 198 00c4 642E     		ld.w	%r4, %r6		; result1 = result2
+ 199 00c6 0266     		sub		%r2, 32			; shift(%r2) = shift(%r2) - 32
+ 200              		;xsll	%r4, %r2		; result1 << shift
+ 201              		; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r2, sll
+ 202              		; $1 = input register
+ 203              		; $2 = shift amount
+ 204              		; $3 = shift instruction
+ 205              	__L0001:
+ 206 00c8 8268     		cmp		%r2, 8		; if temp <= 8 then goto $$2
+ 207 00ca 040E     		jrle	__L0002
+ 208              	
+ 209 00cc 848C     		sll		%r4, 8		; shift input register 8 bits
+ 210 00ce FD1F     		jp.d	__L0001
+ 211 00d0 8264     		sub		%r2, 8		; temp = temp - 8
+ 212              	
+ 213              	__L0002:
+ 214 00d2 248D     		sll		%r4, %r2		; last shift
+ 215 00d4 241E     		jp		finish			; no overflow from norm * den
+ 216              	
+ 217              	rshift:
+ 218              		; case: shift < 0
+ 219 00d6 223E     		not		%r2, %r2		; shift(%r2) = ~shift(%r2) + 1
+ 220 00d8 1260     		add		%r2, 1
+ 221              	
+ 222 00da 0269     		cmp		%r2, 16			; if shift(2) < 16 then shift
+GAS LISTING mulsf3.s 			page 5
+
+
+ 223 00dc 030C     		jrlt	denormal
+ 224              	
+ 225              		; case: shift >= 16
+ 226 00de 251F     		jp.d	end
+ 227 00e0 046C     		ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+ 228              	
+ 229              	denormal:
+ 230              		; case: shift < 16
+ 231              		;xsrl	%r4, %r2		; result >> shift
+ 232              		; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r2, srl
+ 233              		; $1 = input register
+ 234              		; $2 = shift amount
+ 235              		; $3 = shift instruction
+ 236              	__L0003:
+ 237 00e2 8268     		cmp		%r2, 8		; if temp <= 8 then goto $$2
+ 238 00e4 040E     		jrle	__L0004
+ 239              	
+ 240 00e6 8488     		srl		%r4, 8		; shift input register 8 bits
+ 241 00e8 FD1F     		jp.d	__L0003
+ 242 00ea 8264     		sub		%r2, 8		; temp = temp - 8
+ 243              	
+ 244              	__L0004:
+ 245 00ec 2489     		srl		%r4, %r2		; last shift
+ 246 00ee 171E     		jp		finish
+ 247              	
+ 248              	lshift:					; case: 32 > shift >= 0
+ 249              		; {%r4, %r6} << shift
+ 250              		;xsll	%r4, %r2		; shift high 32-bits to the left x bits (shift amount = x)
+ 251              		;xrl	%r6, %r2		; rotate low 32-bits to the left x bits
+ 252              		;xsll	%r3, %r2		; make a mask for first 32-x bits --> %r3 = 111...000
+ 253              		
+ 254 00f0 F36F     		ld.w	%r3, -1			; %r3 = 0xffff ffff
+ 255              		; 64-bit variable shift and rotate routine
+ 256              	L1:
+ 257 00f2 8268     		cmp		%r2, 8			; if shift(%r2) amount <= 8 then goto L2
+ 258 00f4 060E     		jrle	L2
+ 259              	
+ 260 00f6 848C     		sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+ 261 00f8 869C     		rl		%r6, 8			; ｲｾｿ[L](%r6) rotate << 8
+ 262 00fa 838C     		sll		%r3, 8			; mask(%r3) << 8
+ 263 00fc FB1F     		jp.d	L1
+ 264 00fe 8264     		sub		%r2, 8			; shift(%r2) = shift(%r2) - 8 
+ 265              	
+ 266              	L2:
+ 267 0100 248D     		sll		%r4, %r2		; ﾌ皃ﾃﾍ(%r4) << shift(%r2)
+ 268 0102 269D     		rl		%r6, %r2		; ｲｾｿ[L] rotate << shift(%r2)
+ 269 0104 238D     		sll		%r3, %r2		; mask(%r3) << shift(%r2)
+ 270              	
+ 271 0106 323E     		not		%r2, %r3		; flip mask for last x bits --> %r2 = 000...111 (mask)
+ 272 0108 6232     		and		%r2, %r6		; isolate last x bits of %r6
+ 273 010a 2436     		or		%r4, %r2		; add last x bits of %r4 to %r4
+ 274 010c 3632     		and		%r6, %r3		; keep the high 32-x bits of %r6 
+ 275              	
+ 276              		; overflow check
+ 277 010e 03C0F16B 		xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) < overflow value(%r9)
+ 278 0112 050C     		jrlt	finish			; then jump to finish
+ 279              	
+GAS LISTING mulsf3.s 			page 6
+
+
+ 280              	overflow:
+ 281 0114 F0CF00C0 		xld.w	%r4, 0x7f800000	; put infinity into result
+ 281      046C
+ 282 011a 071E     		jp		end				; delayed jump
+ 283              	
+ 284              	finish:
+ 285              		; %r0 = sign, %r1 = exponent, %r4 = mantissa
+ 286 011c 0FC0FFDF 		xand	%r4, 0x7fffff		; isolate mantissa
+ 286      F473
+ 287 0122 81981198 		xrr		%r1, 9			; position exponent bits to [30:23]
+ 288 0126 1436     		or		%r4, %r1
+ 289              	
+ 290              	end:
+ 291 0128 1098     		rr		%r0, 1			; position sign bit to MSB
+ 292 012a 0436     		or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+ 293              	
+ 294              		;@@@ 01/01/23 add start hinokuchi
+ 295              		;ld.w	%r13, [%sp+1]	; %r13ﾉｵ｢
+ 296              		;ld.w	%r12, [%sp+0]	; %r12ﾉｵ｢
+ 297              		;add		%sp, 2
+ 298              		;@@@ 01/01/23 add end
+ 299              	
+ 300 012c 4302     		popn	%r3				; restore register values
+ 301 012e 4006     		ret
diff --git a/gcc/config/c33/libgcc/mulsf3.s b/gcc/config/c33/libgcc/mulsf3.s
new file mode 100644
index 0000000..231c219
--- /dev/null
+++ b/gcc/config/c33/libgcc/mulsf3.s
@@ -0,0 +1,301 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : mulsf3.s
+;*
+;*	Single floating point multiplication function
+;*		input: %r6, %r7
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/26  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __mulsf3
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r0:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(0(+) or 1(-))
+;	%r1:ｻﾘｿﾉ｣ｱ(8bit)
+;	%r2:ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(0(+) or 1(-))/temp/shift
+;	%r3:ｻﾘｿﾉ｣ｲ(8bit)/mask
+;	%r4:ﾌ皃ﾃﾍ(float)/ｾ霆ｻｷｲﾌ[H]
+;	%r5:implied bit/count
+;	%r6:ｰｿ｣ｱ/ｾ霆ｻｷｲﾌ[L]/ｲｾｿ[L]
+;	%r7:ｰｿ｣ｲ
+;	%r8:mask
+;	%r9:overflow value
+;	%r12:scan64 ｰｿ｣ｱ
+;	%r13:scan64 ｰｿ｣ｲ
+;==============================================
+
+
+;;macro	VARSHIFT $1, $2, $3
+	; used in 32-bit variable shifting
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+;$$1:
+;	cmp		$2, 8		; if temp <= 8 then goto $$2
+;	jrle	$$2
+
+;	$3		$1, 8		; shift input register 8 bits
+;	jp.d	$$1
+;	sub		$2, 8		; temp = temp - 8
+
+;$$2:
+;	$3		$1, $2		; last shift
+;;endm
+
+__mulsf3:
+
+	pushn	%r3				; save register values
+
+	;@@@ 01/01/26 add start hinokuchi
+	;sub		%sp, 2
+	;ld.w	[%sp+0], %r12	; %r12ﾂﾔﾈ
+	;ld.w	[%sp+1], %r13	; %r13ﾂﾔﾈ
+	;@@@ 01/01/26 add end
+
+
+	;@@@ 01/02/15 del xld.w	%r9, 0xff		; overflow value(%r9) <- 0xff
+
+	ld.w	%r0, %r6		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) <- ｰｿ｣ｱ(%r6) 
+	rl		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) rotate left 1 bit
+	and		%r0, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) & 1 
+
+	ld.w	%r2, %r7		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) <- ｰｿ｣ｲ(%r7)
+	rl		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) rotate left 1 bit
+	and		%r2, 1			; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｲ(%r2) & 1 
+
+	xor		%r0, %r2		; ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0) = ~ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+
+	sll		%r6, 1			; ｰｿ｣ｱ(%r6) << 1  clear MSB
+	srl		%r6, 1			; ｰｿ｣ｱ(%r6) >> 1
+	cmp		%r6, 0			
+	ext		end@rm
+	jreq	end@rl			; if ｰｿ｣ｱ(%r6) = 0 then end
+	
+	sll		%r7, 1			; ｰｿ｣ｲ(%r7) << 1 clear MSB
+	srl		%r7, 1			; ｰｿ｣ｲ(%r7) >> 1
+	cmp		%r7, 0		
+	ext		end@rm
+	jreq	end@rl			; if ｰｿ｣ｲ(%r7) = 0 then end
+
+	ld.w	%r1, %r6		; ｻﾘｿﾉ｣ｱ(%r1) <- ｰｿ｣ｱ(%r6)
+	xsrl 	%r1, 23			; ｻﾘｿﾉ｣ｱ(%r1) >> 23
+
+	xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= overflow value
+	jrge	overflow		; then jump to overflow
+
+	ld.w	%r3, %r7		; ｻﾘｿﾉ｣ｲ(%r3) <- ｰｿ｣ｲ(%r7)
+	xsrl	%r3, 23			; ｻﾘｿﾉ｣ｲ(%r3) >> 23
+
+	xcmp	%r3, 0xff		; if ｻﾘｿﾉ｣ｲ(%r3) >= overflow value
+	jrge	overflow		; then jump to overflow
+
+	;@@@ 01/02/15 del xld.w	%r8, 0x7fffff 	; mask(%r8) <- 0x7fffff set mask for isolating mantissa
+	;@@@ 01/02/15 del xld.w	%r5, 0x800000	; implied bit(%r5) <- 0x800000
+	xld.w	%r5, 0x7fffff 	; mask(%r5) <- 0x7fffff set mask for isolating mantissa @@@ 01/02/15 add
+
+	ld.w	%r2, 1			; temp(%r2) <- 1
+
+	; isolate mantissa1
+	cmp		%r1, 0
+	jreq.d	getman2			; if ｻﾘｿﾉ｣ｱ(%r1) = 0 (denormal)
+	and		%r6, %r5		; clear first 9 bits of %r6
+	xoor	%r6, 0x800000	; else add implied bit(0x800000) to mantissa
+
+	ld.w	%r2, 0			; temp(%r2) = 0
+
+getman2:
+	; isolate mantissa2
+	cmp		%r3, 0
+	jreq.d	flag			; if exp2 = 0 then jump to flag
+	and		%r7, %r5		; clear first 9 bits of %r7
+	xld.w	%r5, 0x800000	; implied bit(%r5) <- 0x800000 @@@ 01/02/15 add
+	jp.d	multi			; delayed jump
+	or	%r7, %r5			; else add implied bit(0x800000)
+
+flag:
+	add		%r2, 1			; temp(%r2) = 2 or 1 (2 if den * den : 1 if nor * den)
+
+multi:
+	; check result exponent
+	add		%r1, %r3		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) + ｻﾘｿﾉ｣ｲ(%r3) + temp(%r2) - bias(0x7f)
+	add		%r1, %r2
+
+	xsub	%r1, 0x7f		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - 0x7f
+
+	xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) >= 0xff then goto overflow
+	jrge	overflow
+
+	xcmp	%r1, -22		; if ｻﾘｿﾉ｣ｱ(%r1) < -22 then goto end
+	jrlt.d	end
+	ld.w	%r4, 0			; underflow value
+
+	mltu.w	%r6, %r7		; %ahr,%alr <- ｰｿ｣ｱ(%r6) * ｰｿ｣ｲ(%r7)  multiply: 64-bit result is {%r4, %r6}
+	ld.w	%r4, %ahr		; ｾ霆ｻｷｲﾌ[H](%r4) <- %ahr
+	ld.w	%r6, %alr		; ｾ霆ｻｷｲﾌ[L](%r6) <- %alr
+
+	ld.w	%r8, %r4		; scan64 ｰｿ｣ｱ(%r8) <- ｾ霆ｻｷｲﾌ[H](%r4)
+	ld.w	%r9, %r6		; scan64 ｰｿ｣ｲ(%r9) <- ｾ霆ｻｷｲﾌ[L](%r6)
+	xcall	__scan64
+	ld.w	%r5, %r9		; %r5 = count (; of leading 0's in result)
+
+normalize:
+	; %r0 = result sign, %r1 = result exponent
+	; %r5 = count, %r4 = result1, %r6 = result2
+	; note: max. count = 63, min. count = 16
+
+	cmp		%r1, 0			; if ｻﾘｿﾉ｣ｱ(%r1) > 0 then jump to expgtz
+	jrgt.d	expgtz
+	sub		%r5, 17			; count(%r5) = count(%r5) - 17
+
+	; case: exp <= 0
+	ld.w	%r3, 1			; ｻﾘｿﾉ｣ｲ(%r3) = 1 - ｻﾘｿﾉ｣ｱ(%r1)
+	sub		%r3, %r1
+	ld.w	%r2, 9			; %r2 = shift
+	sub		%r2, %r3		; shift(%r2) = 9 - (1 - ｻﾘｿﾉ｣ｱ(%r1))
+
+	cmp		%r1, %r5
+	jrle.d	shift			; if ｻﾘｿﾉ｣ｱ(%r1) <= count then jump to shift
+	ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0
+
+	; case: exp > count - 17  (only when exp = 0 and original count = 16)
+	jp.d	shift			; delayed jump
+	ld.w	%r1, 1			; ｻﾘｿﾉ｣ｱ(%r1) <- 1
+
+expgtz:
+	cmp		%r5, %r1		; if count(%r5) < ｻﾘｿﾉ｣ｱ(%r1) then goto shftltexp
+	jrlt.d	shftltexp
+	ld.w	%r2, 9			; shift(2) <- 9 (for positioning)
+
+	; case: original count - 17 >= exp
+	add		%r2, %r1		; shift(%r2) = shift(%r2) + ｻﾘｿﾉ｣ｱ(%r1) - 1
+	sub		%r2, 1			; shift(%r2) as much as exp allows (until denormal)
+	jp.d	shift
+	ld.w	%r1, 0			; ｻﾘｿﾉ｣ｱ(%r1) <- 0
+	
+shftltexp:
+	sub		%r1, %r5		; ｻﾘｿﾉ｣ｱ(%r1) = ｻﾘｿﾉ｣ｱ(%r1) - count(%r5)
+	add		%r2, %r5		; shift(2) = shift(%r2) + count(%r5)
+
+shift:
+	; max. shift < 64
+	cmp		%r2, 0			; if shift(%r2) < 0 then shift to the right
+	jrlt	rshift
+	xcmp	%r2, 32			; if shift(%r2) < 32 then goto lshift
+	jrlt	lshift
+
+	; case: shift >= 32 (at least one is denormal)
+	ld.w	%r4, %r6		; result1 = result2
+	sub		%r2, 32			; shift(%r2) = shift(%r2) - 32
+	;xsll	%r4, %r2		; result1 << shift
+	; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r2, sll
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+__L0001:
+	cmp		%r2, 8		; if temp <= 8 then goto $$2
+	jrle	__L0002
+
+	sll		%r4, 8		; shift input register 8 bits
+	jp.d	__L0001
+	sub		%r2, 8		; temp = temp - 8
+
+__L0002:
+	sll		%r4, %r2		; last shift
+	jp		finish			; no overflow from norm * den
+
+rshift:
+	; case: shift < 0
+	not		%r2, %r2		; shift(%r2) = ~shift(%r2) + 1
+	add		%r2, 1
+
+	cmp		%r2, 16			; if shift(2) < 16 then shift
+	jrlt	denormal
+
+	; case: shift >= 16
+	jp.d	end
+	ld.w	%r4, 0			; ﾌ皃ﾃﾍ(%r4) <- 0
+
+denormal:
+	; case: shift < 16
+	;xsrl	%r4, %r2		; result >> shift
+	; used in 32-bit variable shifting	; 	VARSHIFT %r4, %r2, srl
+	; $1 = input register
+	; $2 = shift amount
+	; $3 = shift instruction
+__L0003:
+	cmp		%r2, 8		; if temp <= 8 then goto $$2
+	jrle	__L0004
+
+	srl		%r4, 8		; shift input register 8 bits
+	jp.d	__L0003
+	sub		%r2, 8		; temp = temp - 8
+
+__L0004:
+	srl		%r4, %r2		; last shift
+	jp		finish
+
+lshift:					; case: 32 > shift >= 0
+	; {%r4, %r6} << shift
+	;xsll	%r4, %r2		; shift high 32-bits to the left x bits (shift amount = x)
+	;xrl	%r6, %r2		; rotate low 32-bits to the left x bits
+	;xsll	%r3, %r2		; make a mask for first 32-x bits --> %r3 = 111...000
+	
+	ld.w	%r3, -1			; %r3 = 0xffff ffff
+	; 64-bit variable shift and rotate routine
+L1:
+	cmp		%r2, 8			; if shift(%r2) amount <= 8 then goto L2
+	jrle	L2
+
+	sll		%r4, 8			; ﾌ皃ﾃﾍ(%r4) << 8
+	rl		%r6, 8			; ｲｾｿ[L](%r6) rotate << 8
+	sll		%r3, 8			; mask(%r3) << 8
+	jp.d	L1
+	sub		%r2, 8			; shift(%r2) = shift(%r2) - 8 
+
+L2:
+	sll		%r4, %r2		; ﾌ皃ﾃﾍ(%r4) << shift(%r2)
+	rl		%r6, %r2		; ｲｾｿ[L] rotate << shift(%r2)
+	sll		%r3, %r2		; mask(%r3) << shift(%r2)
+
+	not		%r2, %r3		; flip mask for last x bits --> %r2 = 000...111 (mask)
+	and		%r2, %r6		; isolate last x bits of %r6
+	or		%r4, %r2		; add last x bits of %r4 to %r4
+	and		%r6, %r3		; keep the high 32-x bits of %r6 
+
+	; overflow check
+	xcmp	%r1, 0xff		; if ｻﾘｿﾉ｣ｱ(%r1) < overflow value(%r9)
+	jrlt	finish			; then jump to finish
+
+overflow:
+	xld.w	%r4, 0x7f800000	; put infinity into result
+	jp		end				; delayed jump
+
+finish:
+	; %r0 = sign, %r1 = exponent, %r4 = mantissa
+	xand	%r4, 0x7fffff		; isolate mantissa
+	xrr		%r1, 9			; position exponent bits to [30:23]
+	or		%r4, %r1
+
+end:
+	rr		%r0, 1			; position sign bit to MSB
+	or		%r4, %r0		; ﾌ皃ﾃﾍ(%r4) | ﾉ荵讌ﾓ･ﾃ･ﾈ｣ｱ(%r0)
+
+	;@@@ 01/01/23 add start hinokuchi
+	;ld.w	%r13, [%sp+1]	; %r13ﾉｵ｢
+	;ld.w	%r12, [%sp+0]	; %r12ﾉｵ｢
+	;add		%sp, 2
+	;@@@ 01/01/23 add end
+
+	popn	%r3				; restore register values
+	ret
diff --git a/gcc/config/c33/libgcc/negdf2.lst b/gcc/config/c33/libgcc/negdf2.lst
new file mode 100644
index 0000000..a41575f
--- /dev/null
+++ b/gcc/config/c33/libgcc/negdf2.lst
@@ -0,0 +1,41 @@
+GAS LISTING negdf2.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : negdfs.s
+   6              	;*
+   7              	;*	Double floating point negative function
+   8              	;*		input: (%r7, %r6)
+   9              	;*		output: (%r5, %r4)
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*********************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __negdf2
+  21              	
+  22              	;==============================================
+  23              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  24              	;	%r4:ﾌ皃ﾃﾍ(L)(double)
+  25              	;	%r5:ﾌ皃ﾃﾍ(H)(double)
+  26              	;	%r6:ｰｿ｣ｱ(L)(double)
+  27              	;	%r7:ｰｿ｣ｱ(H)(double)
+  28              	;==============================================
+  29              	
+  30              	__negdf2:
+  31              	
+  32              		; flip the MSB of %r5 and put result in %r6
+  33 0000 752E     		ld.w	%r5,%r7					;ﾌ皃ﾃﾍ(H)(5) <- ｰｿ｣ｱ(H)(7)
+  34 0002 00D000C0 		xxor	%r5,0x80000000			;ﾌ皃ﾃﾍ(H)(5) <- ﾌ皃ﾃﾍ(H)(5) | 0x80000000
+  34      0578
+  35 0008 642E     		ld.w	%r4, %r6				;ﾌ皃ﾃﾍ(L)(4) <- ｰｿ｣ｱ(L)(6)
+  36              	
+  37 000a 4006     		ret
diff --git a/gcc/config/c33/libgcc/negdf2.s b/gcc/config/c33/libgcc/negdf2.s
new file mode 100644
index 0000000..7d09153
--- /dev/null
+++ b/gcc/config/c33/libgcc/negdf2.s
@@ -0,0 +1,37 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : negdfs.s
+;*
+;*	Double floating point negative function
+;*		input: (%r7, %r6)
+;*		output: (%r5, %r4)
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __negdf2
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r4:ﾌ皃ﾃﾍ(L)(double)
+;	%r5:ﾌ皃ﾃﾍ(H)(double)
+;	%r6:ｰｿ｣ｱ(L)(double)
+;	%r7:ｰｿ｣ｱ(H)(double)
+;==============================================
+
+__negdf2:
+
+	; flip the MSB of %r5 and put result in %r6
+	ld.w	%r5,%r7					;ﾌ皃ﾃﾍ(H)(5) <- ｰｿ｣ｱ(H)(7)
+	xxor	%r5,0x80000000			;ﾌ皃ﾃﾍ(H)(5) <- ﾌ皃ﾃﾍ(H)(5) | 0x80000000
+	ld.w	%r4, %r6				;ﾌ皃ﾃﾍ(L)(4) <- ｰｿ｣ｱ(L)(6)
+
+	ret
diff --git a/gcc/config/c33/libgcc/negsf2.lst b/gcc/config/c33/libgcc/negsf2.lst
new file mode 100644
index 0000000..4a0ed61
--- /dev/null
+++ b/gcc/config/c33/libgcc/negsf2.lst
@@ -0,0 +1,38 @@
+GAS LISTING negsf2.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : negsf2.s
+   6              	;*
+   7              	;*	Single floating point negate function
+   8              	;*		input: %r6
+   9              	;*		output: %r4
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+  13              	;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+  14              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  15              	;*
+  16              	;*********************************************
+  17              	
+  18              	.section .text
+  19              	.align 1
+  20              	.global __negsf2
+  21              	
+  22              	;==============================================
+  23              	;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+  24              	;	%r4:ﾌ皃ﾃﾍ(floart)
+  25              	;	%r6:ｰｿ｣ｱ(floart)
+  26              	;==============================================
+  27              	
+  28              	__negsf2:
+  29              	
+  30              		; flip the MSB of %r6 and put result in %r4
+  31 0000 642E     		ld.w	%r4,%r6					;ﾌ皃ﾃﾍ(4) <- ｰｿ｣ｱ(6)
+  32 0002 00D000C0 		xxor	%r4, 0x80000000			;ﾌ皃ﾃﾍ(4) <- ﾌ皃ﾃﾍ(4) | 0x80000000
+  32      0478
+  33              	
+  34 0008 4006     		ret
diff --git a/gcc/config/c33/libgcc/negsf2.s b/gcc/config/c33/libgcc/negsf2.s
new file mode 100644
index 0000000..859c0b5
--- /dev/null
+++ b/gcc/config/c33/libgcc/negsf2.s
@@ -0,0 +1,34 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : negsf2.s
+;*
+;*	Single floating point negate function
+;*		input: %r6
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/15  O.Hinokuchi
+;*  			 ｡ｦ･･ｸ･ｹ･ｿﾃﾖｴｹ
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*********************************************
+
+.section .text
+.align 1
+.global __negsf2
+
+;==============================================
+;｡罕･ｸ･ｹ･ｿﾀ篶ﾀ｡
+;	%r4:ﾌ皃ﾃﾍ(floart)
+;	%r6:ｰｿ｣ｱ(floart)
+;==============================================
+
+__negsf2:
+
+	; flip the MSB of %r6 and put result in %r4
+	ld.w	%r4,%r6					;ﾌ皃ﾃﾍ(4) <- ｰｿ｣ｱ(6)
+	xxor	%r4, 0x80000000			;ﾌ皃ﾃﾍ(4) <- ﾌ皃ﾃﾍ(4) | 0x80000000
+
+	ret
diff --git a/gcc/config/c33/libgcc/scan64.lst b/gcc/config/c33/libgcc/scan64.lst
new file mode 100644
index 0000000..4b2003f
--- /dev/null
+++ b/gcc/config/c33/libgcc/scan64.lst
@@ -0,0 +1,51 @@
+GAS LISTING scan64.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : scan64.s
+   6              	;*
+   7              	;*	64-bit scan function
+   8              	;*		input: %r8, %r9
+   9              	;*		output: %r9
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/31  O.Hinokuchi
+  13              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  14              	;*
+  15              	;*****************************************
+  16              	
+  17              	.section .text
+  18              	.align 1
+  19              	.global __scan64
+  20              	
+  21              	__scan64:
+  22              	
+  23 0000 0102     		pushn	%r1				; save register values
+  24              	
+  25 0002 006C     		ld.w	%r0, 0			; loop counter = 0
+  26              	
+  27 0004 0868     		cmp		%r8, 0			; if high 32-bits != 0 then count
+  28 0006 041A     		jrne	loop
+  29              	
+  30              		; case: %r8 = 0
+  31 0008 982E     		ld.w	%r8, %r9		; count low 32-bits instead
+  32 000a 00C0006E 		xld.w	%r0, 32			; loop counter = 32
+  33              	
+  34              	loop:						; count ; of leading 0's
+  35 000e 818E     		scan1	%r1, %r8		; %r1 = count
+  36 0010 0612     		jruge	end				; if count != 8 then goto end
+  37 0012 8069     		cmp		%r0, 24
+  38 0014 0419     		jreq.d	end				; if count = 32 then jump to end
+  39 0016 8060     		add		%r0, 8			; increment loop counter
+  40 0018 FB1F     		jp.d	loop
+  41 001a 888C     		sll		%r8, 8			; shift register to the left 8 bits
+  42              	
+  43              	end:
+  44 001c 0122     		add		%r1, %r0		; count = count + loop counter
+  45 001e 192E     		ld.w	%r9, %r1		; put result into output register
+  46              	
+  47 0020 4102     		popn	%r1				; restore register values
+  48 0022 4006     		ret
diff --git a/gcc/config/c33/libgcc/scan64.s b/gcc/config/c33/libgcc/scan64.s
new file mode 100644
index 0000000..02ad4b8
--- /dev/null
+++ b/gcc/config/c33/libgcc/scan64.s
@@ -0,0 +1,48 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : scan64.s
+;*
+;*	64-bit scan function
+;*		input: %r8, %r9
+;*		output: %r9
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/31  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __scan64
+
+__scan64:
+
+	pushn	%r1				; save register values
+
+	ld.w	%r0, 0			; loop counter = 0
+
+	cmp		%r8, 0			; if high 32-bits != 0 then count
+	jrne	loop
+
+	; case: %r8 = 0
+	ld.w	%r8, %r9		; count low 32-bits instead
+	xld.w	%r0, 32			; loop counter = 32
+
+loop:						; count ; of leading 0's
+	scan1	%r1, %r8		; %r1 = count
+	jruge	end				; if count != 8 then goto end
+	cmp		%r0, 24
+	jreq.d	end				; if count = 32 then jump to end
+	add		%r0, 8			; increment loop counter
+	jp.d	loop
+	sll		%r8, 8			; shift register to the left 8 bits
+
+end:
+	add		%r1, %r0		; count = count + loop counter
+	ld.w	%r9, %r1		; put result into output register
+
+	popn	%r1				; restore register values
+	ret
diff --git a/gcc/config/c33/libgcc/sedscr b/gcc/config/c33/libgcc/sedscr
new file mode 100644
index 0000000..913946a
--- /dev/null
+++ b/gcc/config/c33/libgcc/sedscr
@@ -0,0 +1,16 @@
+s/#/;/g
+s/___/__/g
+s/r0/%r0/g
+s/r1/%r1/g
+s/r2/%r2/g
+s/r3/%r3/g
+s/r4/%r4/g
+s/r5/%r5/g
+s/r6/%r6/g
+s/r7/%r7/g
+s/r8/%r8/g
+s/r9/%r9/g
+s/sp/%sp/g
+s/psr/%psr/g
+s/ahr/%ahr/g
+s/alr/%alr/g
diff --git a/gcc/config/c33/libgcc/trncdfsf.lst b/gcc/config/c33/libgcc/trncdfsf.lst
new file mode 100644
index 0000000..a7dc4b2
--- /dev/null
+++ b/gcc/config/c33/libgcc/trncdfsf.lst
@@ -0,0 +1,126 @@
+GAS LISTING trncdfsf.s 			page 1
+
+
+   1              	;*********************************************
+   2              	;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+   3              	;*		ALL RIGHTS RESERVED
+   4              	;*
+   5              	;*	filename : trncdfsf.s
+   6              	;*
+   7              	;*	Change type: Double float --> Single float
+   8              	;*		input: (%r7, %r6)
+   9              	;*		output: %r4
+  10              	;*
+  11              	;*	Begin		1996/09/12	V. Chan
+  12              	;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+  13              	;*	gasﾂﾐｱ		2001/10/15	watanabe
+  14              	;*
+  15              	;*****************************************
+  16              	
+  17              	.section .text
+  18              	.align 1
+  19              	.global __truncdfsf2
+  20              	
+  21              	__truncdfsf2:
+  22              	
+  23 0000 0102     		pushn	%r1				; save register values
+  24              	
+  25 0002 702E     		ld.w	%r0, %r7		; put sign of input (%r7) into %r0
+  26 0004 109C     		rl		%r0, 1
+  27 0006 1070     		and		%r0, 1
+  28              	
+  29 0008 712E     		ld.w	%r1, %r7		; put exponent into %r1
+  30 000a 118C     		sll		%r1, 1
+  31 000c 81888188 		xsrl 	%r1, 21
+  31      5188
+  32              	
+  33              								; 0x368 - 0x3ff(bias) + 0x7f(bias) = -24
+  34 0012 0DC0816A 		xcmp	%r1, 0x368		; if exp < 0x368 then goto end
+  35 0016 340F     		jrle.d	end				; round to zero case (result = 0)
+  36 0018 046C     		ld.w	%r4, 0
+  37              	
+  38              								; 0x47f - 0x3ff(bias) + 0x7f(bias) = 255
+  39 001a 11C0F16B 		xcmp	%r1, 0x47f		; if exp >= 0x47f then overflow
+  40 001e F0CF00C0 		xld.w	%r4, 0x7f800000	; result = infinity
+  40      046C
+  41 0024 2D0A     		jrge	end
+  42              		
+  43              		; isolate mantissa
+  44 0026 01C0FFDF 		xand	%r7,0xfffff		; clear first 12 bits of %r7
+  44      F773
+  45              		
+  46              								; 0x380 - 0x3ff + 0x7f = 0
+  47 002c 0EC00168 		xcmp	%r1, 0x380		; if exp > 0x380 then goto normal
+  48 0030 1B08     		jrgt	normal			; normal result
+  49              	
+  50              		; case: exp <= 0x380 (-127 --> denormal result)
+  51 0032 02C000C0 		xoor	%r7,0x100000	; add implied bit
+  51      0774
+  52              								; 0x37e - 0x3ff + 0x7f = -2 (2 bit shift)
+  53 0038 0DC0E16B 		xcmp	%r1, 0x37e		; if 0x380 > exp > 0x37e then goto shftleft
+GAS LISTING trncdfsf.s 			page 2
+
+
+  54 003c 0B08     		jrgt	shftleft
+  55              	
+  56              		; case: 0x368 =< exp <= 0x37e
+  57 003e 0DC0E56F 		xld.w	%r5, 0x37e		; shift = 0x37e - exp
+  58 0042 1526     		sub		%r5, %r1
+  59              		
+  60              		;xsrl	%r7, %r5		; mantissa >> 0x37e - exp (max. shift = 22)
+  61              		; variable shift routine (faster than xsrl)
+  62              	shift:
+  63 0044 8568     		cmp		%r5, 8			; if shift <= 8 then goto done
+  64 0046 040E     		jrle	done
+  65              		
+  66              		; case: shift > 8
+  67 0048 8564     		sub		%r5, 8			; shift = shift - 8
+  68 004a FD1F     		jp.d	shift
+  69 004c 8788     		srl		%r7, 8			; result >> 8
+  70              	
+  71              	done:						; case: %r5 < 8
+  72 004e 171F     		jp.d	finish
+  73 0050 5789     		srl		%r7, %r5		; final shift of result
+  74              	
+  75              	shftleft:
+  76              		; case: 0x37e < exp <= 0x380
+  77 0052 0DC0E167 		xsub	%r1,0x37e		; shift = exp - 0x37e (max. shift = 2)
+  78              	
+  79              		; {man1, man1_2} << shift
+  80 0056 178D     		sll		%r7, %r1		; shift high 32-bits to the left x bits (x = shift)
+  81 0058 169D     		rl		%r6, %r1		; rotate low 32-bits to the left x bits
+  82 005a F86F     		ld.w	%r8, -1			; %r8 = 0xffff ffff
+  83 005c 188D     		sll		%r8, %r1		; make a mask for first 32-x bits --> %r8 = 111...000
+  84 005e 893E     		not		%r9, %r8		; flip mask for last x bits --> %r9 = 000...111 (mask)
+  85 0060 6932     		and		%r9, %r6		; isolate last x bits of %r6
+  86 0062 0D1F     		jp.d	finish
+  87 0064 9736     		or		%r7, %r9		; add last x bits of %r6 to %r7
+  88              	
+  89              	normal:
+  90              		; case: exp > 0x380 (normal single float result)
+  91 0066 0EC00164 		xsub	%r1,0x380		; exp = exp - 0x3ff + 0x7f
+  92              	
+  93              		; {man1, man1_2} << 3
+  94 006a 378C     		sll		%r7, 3			; shift high 32-bits to the left 3 bits
+  95 006c 369C     		rl		%r6, 3			; rotate low 32-bits to the left 3 bits
+  96 006e 756C     		ld.w	%r5, 0x7		; make a mask for last 3 bits --> %r5 = 000...00111
+  97 0070 583E     		not		%r8, %r5		; flip mask for first 29 bits --> %r8 = 111...11000
+  98 0072 6532     		and		%r5, %r6		; isolate last 3 bits of %r6
+  99 0074 5736     		or		%r7, %r5		; add last 3 bits of %r6 to %r7
+ 100              	
+ 101 0076 81981198 		xrr		%r1, 9			; position exp
+ 102 007a 1736     		or		%r7, %r1		; add exponent
+ 103              	
+ 104              	finish:
+ 105 007c 742E     		ld.w	%r4, %r7		; put result in output register
+ 106              	
+ 107              	end:
+ 108 007e 1098     		rr		%r0, 1			; position sign bit
+ 109 0080 0436     		or		%r4, %r0		; add sign bit
+ 110              	
+GAS LISTING trncdfsf.s 			page 3
+
+
+ 111 0082 4102     		popn	%r1				; restore register values
+ 112              	
+ 113 0084 4006     		ret
diff --git a/gcc/config/c33/libgcc/trncdfsf.s b/gcc/config/c33/libgcc/trncdfsf.s
new file mode 100644
index 0000000..c19cf6b
--- /dev/null
+++ b/gcc/config/c33/libgcc/trncdfsf.s
@@ -0,0 +1,113 @@
+;*********************************************
+;*	Copyright (C), 1996-2001 SEIKO EPSON Corp.
+;*		ALL RIGHTS RESERVED
+;*
+;*	filename : trncdfsf.s
+;*
+;*	Change type: Double float --> Single float
+;*		input: (%r7, %r6)
+;*		output: %r4
+;*
+;*	Begin		1996/09/12	V. Chan
+;*  ﾊﾑｹｹ		2001/01/17  O.Hinokuchi
+;*	gasﾂﾐｱ		2001/10/15	watanabe
+;*
+;*****************************************
+
+.section .text
+.align 1
+.global __truncdfsf2
+
+__truncdfsf2:
+
+	pushn	%r1				; save register values
+
+	ld.w	%r0, %r7		; put sign of input (%r7) into %r0
+	rl		%r0, 1
+	and		%r0, 1
+
+	ld.w	%r1, %r7		; put exponent into %r1
+	sll		%r1, 1
+	xsrl 	%r1, 21
+
+							; 0x368 - 0x3ff(bias) + 0x7f(bias) = -24
+	xcmp	%r1, 0x368		; if exp < 0x368 then goto end
+	jrle.d	end				; round to zero case (result = 0)
+	ld.w	%r4, 0
+
+							; 0x47f - 0x3ff(bias) + 0x7f(bias) = 255
+	xcmp	%r1, 0x47f		; if exp >= 0x47f then overflow
+	xld.w	%r4, 0x7f800000	; result = infinity
+	jrge	end
+	
+	; isolate mantissa
+	xand	%r7,0xfffff		; clear first 12 bits of %r7
+	
+							; 0x380 - 0x3ff + 0x7f = 0
+	xcmp	%r1, 0x380		; if exp > 0x380 then goto normal
+	jrgt	normal			; normal result
+
+	; case: exp <= 0x380 (-127 --> denormal result)
+	xoor	%r7,0x100000	; add implied bit
+							; 0x37e - 0x3ff + 0x7f = -2 (2 bit shift)
+	xcmp	%r1, 0x37e		; if 0x380 > exp > 0x37e then goto shftleft
+	jrgt	shftleft
+
+	; case: 0x368 =< exp <= 0x37e
+	xld.w	%r5, 0x37e		; shift = 0x37e - exp
+	sub		%r5, %r1
+	
+	;xsrl	%r7, %r5		; mantissa >> 0x37e - exp (max. shift = 22)
+	; variable shift routine (faster than xsrl)
+shift:
+	cmp		%r5, 8			; if shift <= 8 then goto done
+	jrle	done
+	
+	; case: shift > 8
+	sub		%r5, 8			; shift = shift - 8
+	jp.d	shift
+	srl		%r7, 8			; result >> 8
+
+done:						; case: %r5 < 8
+	jp.d	finish
+	srl		%r7, %r5		; final shift of result
+
+shftleft:
+	; case: 0x37e < exp <= 0x380
+	xsub	%r1,0x37e		; shift = exp - 0x37e (max. shift = 2)
+
+	; {man1, man1_2} << shift
+	sll		%r7, %r1		; shift high 32-bits to the left x bits (x = shift)
+	rl		%r6, %r1		; rotate low 32-bits to the left x bits
+	ld.w	%r8, -1			; %r8 = 0xffff ffff
+	sll		%r8, %r1		; make a mask for first 32-x bits --> %r8 = 111...000
+	not		%r9, %r8		; flip mask for last x bits --> %r9 = 000...111 (mask)
+	and		%r9, %r6		; isolate last x bits of %r6
+	jp.d	finish
+	or		%r7, %r9		; add last x bits of %r6 to %r7
+
+normal:
+	; case: exp > 0x380 (normal single float result)
+	xsub	%r1,0x380		; exp = exp - 0x3ff + 0x7f
+
+	; {man1, man1_2} << 3
+	sll		%r7, 3			; shift high 32-bits to the left 3 bits
+	rl		%r6, 3			; rotate low 32-bits to the left 3 bits
+	ld.w	%r5, 0x7		; make a mask for last 3 bits --> %r5 = 000...00111
+	not		%r8, %r5		; flip mask for first 29 bits --> %r8 = 111...11000
+	and		%r5, %r6		; isolate last 3 bits of %r6
+	or		%r7, %r5		; add last 3 bits of %r6 to %r7
+
+	xrr		%r1, 9			; position exp
+	or		%r7, %r1		; add exponent
+
+finish:
+	ld.w	%r4, %r7		; put result in output register
+
+end:
+	rr		%r0, 1			; position sign bit
+	or		%r4, %r0		; add sign bit
+
+	popn	%r1				; restore register values
+
+	ret
diff --git a/gcc/config/c33/libgcc1.S b/gcc/config/c33/libgcc1.S
new file mode 100644
index 0000000..b49d189
--- /dev/null
+++ b/gcc/config/c33/libgcc1.S
@@ -0,0 +1,317 @@
+/* libgcc1 routines for EPSON C33.
+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, if you link this library with files
+   compiled with GCC to produce an executable, this does not cause
+   the resulting executable to be covered by the GNU General Public License.
+   This exception does not however invalidate any other reasons why
+   the executable file might be covered by the GNU General Public License.  */
+
+/*
+	Copyright (C) SEIKO EPSON CORP. 1996
+
+	Filename : divsi3.c
+	Function :
+	  This module defines the functions
+		that emulate signed and unsigned integer division.
+	Revision :
+	  10/18/1996	ESD T.Katahira		start			    */
+
+#ifdef L_divsi3
+
+//	Function :	__divsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- quotient
+//	Function :	calculate signed integer division
+
+	.section .text
+	.align 1
+	.global	__divsi3
+__divsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (alr)
+
+	div0s	%r7		; initializer of signed division
+
+#ifdef	FAST
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	div1	%r7		; execute division #9
+	div1	%r7		; execute division #10
+	div1	%r7		; execute division #11
+	div1	%r7		; execute division #12
+	div1	%r7		; execute division #13
+	div1	%r7		; execute division #14
+	div1	%r7		; execute division #15
+	div1	%r7		; execute division #16
+	div1	%r7		; execute division #17
+	div1	%r7		; execute division #18
+	div1	%r7		; execute division #19
+	div1	%r7		; execute division #20
+	div1	%r7		; execute division #21
+	div1	%r7		; execute division #22
+	div1	%r7		; execute division #23
+	div1	%r7		; execute division #24
+	div1	%r7		; execute division #25
+	div1	%r7		; execute division #26
+	div1	%r7		; execute division #27
+	div1	%r7		; execute division #28
+	div1	%r7		; execute division #29
+	div1	%r7		; execute division #30
+	div1	%r7		; execute division #31
+	div1	%r7		; execute division #32
+#else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+	ld.w	%r9,%psr	; save flag register
+___divsi3_loop_start:	
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	sub		%r8,0x1		; decrement loop counter
+	jrne.d	___divsi3_loop_start	; if (loop counter != 0) goto loop top
+	ld.w	%psr,%r9	; restore flag register (delayed slot)
+#endif
+	div2s	%r7		; post divistion process #1
+	div3s			; post divistion process #2
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+#endif /* L_divsi3 */
+
+#ifdef L_udivsi3
+
+//	Function :	__udivsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- quotient
+//	Function :	calculate unsigned integer division
+
+	.section .text
+	.align 1
+	.global	__udivsi3
+__udivsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (alr)
+	div0u	%r7		; initializer of signed division
+#ifdef	FAST
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	div1	%r7		; execute division #9
+	div1	%r7		; execute division #10
+	div1	%r7		; execute division #11
+	div1	%r7		; execute division #12
+	div1	%r7		; execute division #13
+	div1	%r7		; execute division #14
+	div1	%r7		; execute division #15
+	div1	%r7		; execute division #16
+	div1	%r7		; execute division #17
+	div1	%r7		; execute division #18
+	div1	%r7		; execute division #19
+	div1	%r7		; execute division #20
+	div1	%r7		; execute division #21
+	div1	%r7		; execute division #22
+	div1	%r7		; execute division #23
+	div1	%r7		; execute division #24
+	div1	%r7		; execute division #25
+	div1	%r7		; execute division #26
+	div1	%r7		; execute division #27
+	div1	%r7		; execute division #28
+	div1	%r7		; execute division #29
+	div1	%r7		; execute division #30
+	div1	%r7		; execute division #31
+	div1	%r7		; execute division #32
+#else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+___udivsi3_loop_start:	
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	sub		%r8,0x1		; decrement loop counter
+	jrne	___udivsi3_loop_start	; if (loop counter != 0) goto loop top
+#endif
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%alr	; set quotient to return reg (delayed slot)
+
+#endif /* L_udivsi3 */
+
+
+#ifdef L_modsi3
+
+//	Function :	__modsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- remainder
+//	Function :	calculate signed integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	__modsi3
+__modsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (alr)
+	div0s	%r7		; initializer of signed division
+#ifdef	FAST
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	div1	%r7		; execute division #9
+	div1	%r7		; execute division #10
+	div1	%r7		; execute division #11
+	div1	%r7		; execute division #12
+	div1	%r7		; execute division #13
+	div1	%r7		; execute division #14
+	div1	%r7		; execute division #15
+	div1	%r7		; execute division #16
+	div1	%r7		; execute division #17
+	div1	%r7		; execute division #18
+	div1	%r7		; execute division #19
+	div1	%r7		; execute division #20
+	div1	%r7		; execute division #21
+	div1	%r7		; execute division #22
+	div1	%r7		; execute division #23
+	div1	%r7		; execute division #24
+	div1	%r7		; execute division #25
+	div1	%r7		; execute division #26
+	div1	%r7		; execute division #27
+	div1	%r7		; execute division #28
+	div1	%r7		; execute division #29
+	div1	%r7		; execute division #30
+	div1	%r7		; execute division #31
+	div1	%r7		; execute division #32
+#else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+	ld.w	%r9,%psr	; save flag register
+___modsi3_loop_start:	
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	sub		%r8,0x1		; decrement loop counter
+	jrne.d	___modsi3_loop_start	; if (loop counter != 0) goto loop top
+	ld.w	%psr,%r9	; restore flag register (delayed slot)
+#endif
+	div2s	%r7		; post divistion process #1
+	div3s			; post divistion process #2
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+
+#endif /* L_modsi3 */
+
+#ifdef L_umodsi3
+
+//	Function :	__umodsi3
+//	Input :		r6	--- dividend
+//			r7	--- divisor
+//	Output :	r4	--- remainder
+//	Function :	calculate unsigned integer modulo arithmetic
+
+	.section .text
+	.align 1
+	.global	__umodsi3
+__umodsi3:
+	ld.w	%alr,%r6	; set dividend to accumlator (alr)
+	div0u	%r7		; initializer of signed division
+#ifdef	FAST
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	div1	%r7		; execute division #9
+	div1	%r7		; execute division #10
+	div1	%r7		; execute division #11
+	div1	%r7		; execute division #12
+	div1	%r7		; execute division #13
+	div1	%r7		; execute division #14
+	div1	%r7		; execute division #15
+	div1	%r7		; execute division #16
+	div1	%r7		; execute division #17
+	div1	%r7		; execute division #18
+	div1	%r7		; execute division #19
+	div1	%r7		; execute division #20
+	div1	%r7		; execute division #21
+	div1	%r7		; execute division #22
+	div1	%r7		; execute division #23
+	div1	%r7		; execute division #24
+	div1	%r7		; execute division #25
+	div1	%r7		; execute division #26
+	div1	%r7		; execute division #27
+	div1	%r7		; execute division #28
+	div1	%r7		; execute division #29
+	div1	%r7		; execute division #30
+	div1	%r7		; execute division #31
+	div1	%r7		; execute division #32
+#else
+	ld.w	%r8,0x4		; set loop counter (N = 4)
+___umodsi3_loop_start:	
+	div1	%r7		; execute division #1
+	div1	%r7		; execute division #2
+	div1	%r7		; execute division #3
+	div1	%r7		; execute division #4
+	div1	%r7		; execute division #5
+	div1	%r7		; execute division #6
+	div1	%r7		; execute division #7
+	div1	%r7		; execute division #8
+	sub		%r8,0x1		; decrement loop counter
+	jrne	___umodsi3_loop_start	; if (loop counter != 0) goto loop top
+#endif
+	ret.d			; return to the caller (use delayed return)
+	ld.w	%r4,%ahr	; set remainder to return reg (delayed slot)
+
+#endif /* L_umodsi3 */
diff --git a/gcc/config/c33/t-c33 b/gcc/config/c33/t-c33
new file mode 100644
index 0000000..4a7a5d0
--- /dev/null
+++ b/gcc/config/c33/t-c33
@@ -0,0 +1,35 @@
+CROSS_LIBGCC1 = libgcc1-asm.a
+LIB1ASMSRC = c33/libgcc1.S
+LIB1ASMFUNCS	= _divsi3 \
+		  _udivsi3 \
+		  _modsi3 \
+		  _umodsi3
+	
+
+# These are really part of libgcc1, but this will cause them to be
+# built correctly, so...
+
+LIB2FUNCS_EXTRA = fp-bit.c dp-bit.c
+
+dp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#ifdef __LITTLE_ENDIAN__' > dp-bit.c
+	echo '#define FLOAT_BIT_ORDER_MISMATCH' >>dp-bit.c
+	echo '#endif' 		>> dp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> dp-bit.c
+
+fp-bit.c: $(srcdir)/config/fp-bit.c
+	echo '#define FLOAT' > fp-bit.c
+	echo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c
+	echo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c
+	echo '#endif' 		>> fp-bit.c
+	cat $(srcdir)/config/fp-bit.c >> fp-bit.c
+
+#debug_w
+#TCFLAGS = -Wa,-mwarn-signed-overflow -Wa,-mwarn-unsigned-overflow
+TCFLAGS = 
+#debug_w
+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc
+GCC_FOR_TARGET = d:/Epson/gnu33/xgcc -Bd:/Epson/gnu33/
+
+# 2002.2.13 watanabe
+# C33: It is necessary that "LIB2FUNCS_EH = _eh" is changed to "LIB2FUNCS_EH =".
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
index 03b9008..8beb78f 100644
--- a/gcc/cp/decl.c
+++ b/gcc/cp/decl.c
@@ -724,7 +724,19 @@ push_binding_level (newlevel, tag_transparent, keep)
      are active.  */
   memset ((char*) newlevel, 0, sizeof (struct cp_binding_level));
   newlevel->level_chain = current_binding_level;
+  
+  // CHG K.Watanabe V1.8 >>>>>>>
+  #if 0
   current_binding_level = newlevel;
+  #endif
+  
+  if( cfun && cp_function_chain->bindings ){
+	cp_function_chain->bindings = newlevel;
+  } else {
+	scope_chain->bindings = newlevel;
+   }
+  // CHG K.Watanabe V1.8 <<<<<<<
+  
   newlevel->tag_transparent = tag_transparent;
   newlevel->more_cleanups_ok = 1;
 
@@ -780,7 +792,19 @@ pop_binding_level ()
     }
   {
     register struct cp_binding_level *level = current_binding_level;
+    
+    // CHG K.Watanabe V1.8 >>>>>>>
+    #if 0
     current_binding_level = current_binding_level->level_chain;
+    #endif
+    
+    if( cfun && cp_function_chain->bindings ){
+	    cp_function_chain->bindings = current_binding_level->level_chain;
+    } else {
+	    scope_chain->bindings = current_binding_level->level_chain;
+    }
+    // CHG K.Watanabe V1.8 <<<<<<<
+    
     level->level_chain = free_binding_level;
     if (level->parm_flag != 2)
       binding_table_free (level->type_decls);
@@ -797,7 +821,20 @@ static void
 suspend_binding_level ()
 {
   if (class_binding_level)
+    
+    // CHG K.Watanabe V1.8 >>>>>>>
+    #if 0
     current_binding_level = class_binding_level;
+    #endif
+    
+    {
+        if( cfun && cp_function_chain->bindings ){
+	        cp_function_chain->bindings = class_binding_level;
+        } else {
+	        scope_chain->bindings = class_binding_level;
+        }
+    }
+    // CHG K.Watanabe V1.8 <<<<<<<
 
   if (NAMESPACE_LEVEL (global_namespace))
     my_friendly_assert (!global_scope_p (current_binding_level), 20030527);
@@ -816,7 +853,20 @@ suspend_binding_level ()
         }
       is_class_level = 0;
     }
+    
+  // CHG K.Watanabe V1.8 >>>>>>>
+  #if 0
   current_binding_level = current_binding_level->level_chain;
+  #endif
+  
+  if( cfun && cp_function_chain->bindings ){
+      cp_function_chain->bindings = current_binding_level->level_chain;
+  } else {
+      scope_chain->bindings = current_binding_level->level_chain;
+  }
+  // CHG K.Watanabe V1.8 <<<<<<<
+  
+  
   find_class_binding_level ();
 }
 
@@ -829,7 +879,19 @@ resume_binding_level (b)
   my_friendly_assert(!class_binding_level, 386);
   /* Also, resuming a non-directly nested namespace is a no-no.  */
   my_friendly_assert(b->level_chain == current_binding_level, 386);
+  
+  // CHG K.Watanabe V1.8 >>>>>>>
+  #if 0
   current_binding_level = b;
+  #endif
+  
+  if( cfun && cp_function_chain->bindings ){
+      cp_function_chain->bindings = b;
+  } else {
+      scope_chain->bindings = b;
+  }
+  // CHG K.Watanabe V1.8 <<<<<<<
+  
   if (ENABLE_SCOPE_CHECKING)
     {
       b->binding_depth = binding_depth;
@@ -4541,9 +4603,32 @@ pushdecl_with_scope (x, level)
   else
     {
       b = current_binding_level;
+      
+      // CHG K.Watanabe V1.8 >>>>>>>
+      #if 0
       current_binding_level = level;
+      #endif
+      
+      if( cfun && cp_function_chain->bindings ){
+          cp_function_chain->bindings = level;
+      } else {
+          scope_chain->bindings = level;
+      }
+      // CHG K.Watanabe V1.8 <<<<<<<
+      
       x = pushdecl (x);
+      
+      // CHG K.Watanabe V1.8 >>>>>>>
+      #if 0
       current_binding_level = b;
+      #endif
+      
+      if( cfun && cp_function_chain->bindings ){
+          cp_function_chain->bindings = b;
+      } else {
+          scope_chain->bindings = b;
+      }
+      // CHG K.Watanabe V1.8 <<<<<<<
     }
   current_function_decl = function_decl;
   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);
@@ -6942,7 +7027,19 @@ cxx_init_decl_processing ()
   current_lang_name = lang_name_c;
 
   current_function_decl = NULL_TREE;
+  
+  // CHG K.Watanabe V1.8 >>>>>>>
+  #if 0
   current_binding_level = NULL_BINDING_LEVEL;
+  #endif
+  
+  if( cfun && cp_function_chain->bindings ){
+      cp_function_chain->bindings = NULL_BINDING_LEVEL;
+  } else {
+      scope_chain->bindings = NULL_BINDING_LEVEL;
+  }
+  // CHG K.Watanabe V1.8 <<<<<<<
+  
   free_binding_level = NULL_BINDING_LEVEL;
 
   build_common_tree_nodes (flag_signed_char);
@@ -10788,10 +10885,34 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)
   if (decl_context == NORMAL && !toplevel_bindings_p ())
     {
       struct cp_binding_level *b = current_binding_level;
+      
+      // CHG K.Watanabe V1.8 >>>>>>>
+      #if 0
       current_binding_level = b->level_chain;
+      #endif
+      
+      if( cfun && cp_function_chain->bindings ){
+          cp_function_chain->bindings = b->level_chain;
+      } else {
+          scope_chain->bindings = b->level_chain;
+      }
+      // CHG K.Watanabe V1.8 <<<<<<<
+      
       if (current_binding_level != 0 && toplevel_bindings_p ())
 	decl_context = PARM;
+	
+	  // CHG K.Watanabe V1.8 >>>>>>>
+	  #if 0
       current_binding_level = b;
+      #endif
+      
+      if( cfun && cp_function_chain->bindings ){
+          cp_function_chain->bindings = b;
+      } else {
+          scope_chain->bindings = b;
+      }
+      // CHG K.Watanabe V1.8 <<<<<<<
+      
     }
 
   if (name == NULL)
@@ -14431,7 +14552,19 @@ start_function (declspecs, declarator, attrs, flags)
      FIXME factor out the non-RTL stuff.  */
   bl = current_binding_level;
   init_function_start (decl1, input_filename, lineno);
+  
+  // CHG K.Watanabe V1.8 >>>>>>>
+  #if 0
   current_binding_level = bl;
+  #endif
+  
+  if( cfun && cp_function_chain->bindings ){
+      cp_function_chain->bindings = bl;
+  } else {
+      scope_chain->bindings = bl;
+  }
+  // CHG K.Watanabe V1.8 <<<<<<<
+  
 
   /* Even though we're inside a function body, we still don't want to
      call expand_expr to calculate the size of a variable-sized array.
diff --git a/gcc/cppinit.c b/gcc/cppinit.c
index d8e622b..b7f9f40 100644
--- a/gcc/cppinit.c
+++ b/gcc/cppinit.c
@@ -150,6 +150,17 @@ END
 #undef END
 #undef TRIGRAPH_MAP
 
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. 	*/
+/*      This is because gdb can recognize as version 2.95.2.                                           	*/
+int i_Line_Dummy_Output_Flg = 0;			/* 0 -- normal 												*/
+											/* 1 -- dummy output 										*/
+int i_Asm_Adjust_Line_Init_Flg = 0;			/* 0 -- initial value 										*/
+											/* 1 -- Alignment has been done for new line of one line.  	*/
+int i_Asm_CRLF_Line_Init_Flg = 0;			/* 0 -- initial value 										*/
+											/* 1 -- Alignment has been done for new line of one line.  	*/
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
 /* Given a colon-separated list of file names PATH,
    add all the names to the search path for include files.  */
 static void
@@ -1042,6 +1053,8 @@ void
 cpp_finish_options (pfile)
      cpp_reader *pfile;
 {
+	int i_len;		/* ADD K.Watanabe V1.7 */
+	
   /* Mark named operators before handling command line macros.  */
   if (CPP_OPTION (pfile, cplusplus) && CPP_OPTION (pfile, operator_names))
     mark_named_operators (pfile);
@@ -1054,9 +1067,27 @@ cpp_finish_options (pfile)
 
       /* Prevent -Wunused-macros with command-line redefinitions.  */
       pfile->first_unused_line = (unsigned int) -1;
-      _cpp_do_file_change (pfile, LC_RENAME, _("<built-in>"), 1, 0);
+      
+      /* CHG K.Watanabe V1.7 >>>>>>> */
+      /* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+      /* _cpp_do_file_change (pfile, LC_RENAME, _("<built-in>"), 1, 0); */
+      i_len = strlen( pfile->map->to_file );
+      if( ( pfile->map->to_file[ i_len- 1 ] != 's' ) && ( pfile->map->to_file[ i_len- 1 ] != 'S' ) ){
+		  _cpp_do_file_change (pfile, LC_RENAME, _("<built-in>"), 1, 0);
+	  }    
+	  /* CHG K.Watanabe V1.7 <<<<<<< */
+            
       init_builtins (pfile);
-      _cpp_do_file_change (pfile, LC_RENAME, _("<command line>"), 1, 0);
+      
+      /* CHG K.Watanabe V1.7 >>>>>>> */
+      /* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+      /* _cpp_do_file_change (pfile, LC_RENAME, _("<command line>"), 1, 0); */
+      i_len = strlen( pfile->map->to_file );
+      if( ( pfile->map->to_file[ i_len- 1 ] != 's' ) && ( pfile->map->to_file[ i_len- 1 ] != 'S' ) ){
+	  _cpp_do_file_change (pfile, LC_RENAME, _("<command line>"), 1, 0);
+	  }    
+      /* CHG K.Watanabe V1.7 <<<<<<< */      
+      
       for (p = CPP_OPTION (pfile, pending)->directive_head; p; p = p->next)
 	(*p->handler) (pfile, p->arg);
 
@@ -1064,11 +1095,20 @@ cpp_finish_options (pfile)
 	 pfile->next_include_file is NULL, so _cpp_pop_buffer does not
 	 push -include files.  */
       for (p = CPP_OPTION (pfile, pending)->imacros_head; p; p = p->next)
-	if (push_include (pfile, p))
-	  cpp_scan_nooutput (pfile);
-
-      pfile->next_include_file = &CPP_OPTION (pfile, pending)->include_head;
-      _cpp_maybe_push_include_file (pfile);
+	      if (push_include (pfile, p))
+	      cpp_scan_nooutput (pfile);
+	      
+      pfile->next_include_file = &CPP_OPTION (pfile, pending)->include_head; 
+      /* CHG K.Watanabe V1.7 >>>>>>> */
+/*    _cpp_maybe_push_include_file (pfile); */
+      /* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+      i_len = strlen( pfile->map->to_file );
+      if( ( pfile->map->to_file[ i_len- 1 ] == 's' ) || ( pfile->map->to_file[ i_len- 1 ] == 'S' ) ){
+	      i_Line_Dummy_Output_Flg = 1;
+	  }    
+	  _cpp_maybe_push_include_file (pfile); 
+	  i_Line_Dummy_Output_Flg = 0;      
+      /* CHG K.Watanabe V1.7 <<<<<<< */      
     }
 
   pfile->first_unused_line = pfile->line;
@@ -1095,7 +1135,7 @@ _cpp_maybe_push_include_file (pfile)
 	{
 	  /* All done; restore the line map from <command line>.  */
 	  _cpp_do_file_change (pfile, LC_RENAME,
-			       pfile->line_maps.maps[0].to_file, 1, 0);
+			       pfile->line_maps.maps[0].to_file, 1, 0); 
 	  /* Don't come back here again.  */
 	  pfile->next_include_file = NULL;
 	}
diff --git a/gcc/cpplib.c b/gcc/cpplib.c
index e18564e..7f0c3fb 100644
--- a/gcc/cpplib.c
+++ b/gcc/cpplib.c
@@ -26,6 +26,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 #include "cpphash.h"
 #include "obstack.h"
 
+
 /* Chained list of answers to an assertion.  */
 struct answer
 {
@@ -1359,7 +1360,7 @@ do_ifdef (pfile)
      cpp_reader *pfile;
 {
   int skip = 1;
-
+  
   if (! pfile->state.skipping)
     {
       const cpp_hashnode *node = lex_macro_node (pfile);
@@ -1494,7 +1495,7 @@ do_endif (pfile)
 {
   cpp_buffer *buffer = pfile->buffer;
   struct if_stack *ifs = buffer->if_stack;
-
+  
   if (ifs == NULL)
     cpp_error (pfile, DL_ERROR, "#endif without #if");
   else
diff --git a/gcc/cppmain.c b/gcc/cppmain.c
index d49c6f8..23a6128 100644
--- a/gcc/cppmain.c
+++ b/gcc/cppmain.c
@@ -52,6 +52,13 @@ static void cb_ident	  PARAMS ((cpp_reader *, unsigned int,
 static void cb_file_change PARAMS ((cpp_reader *, const struct line_map *));
 static void cb_def_pragma PARAMS ((cpp_reader *, unsigned int));
 
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+extern int i_Line_Dummy_Output_Flg;	
+extern int i_Asm_CRLF_Line_Init_Flg;
+char c_Save_Pre_Filename[2000] = { 0 };		/* C33: Save the last output file name. */
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
 /* Preprocess and output.  */
 void
 cpp_preprocess_file (pfile, in_fname, out_stream)
@@ -219,6 +226,8 @@ maybe_print_line (pfile, map, line)
      const struct line_map *map;
      unsigned int line;
 {
+  int i_len;			/* ADD K.Watanabe V1.7 */
+  
   /* End the previous line of text.  */
   if (pfile->print.printed)
     {
@@ -227,6 +236,11 @@ maybe_print_line (pfile, map, line)
       pfile->print.printed = 0;
     }
 
+  /* CHG K.Watanabe V1.7 >>>>>>> */
+  /* C33: In the assembler source files, let it output exactly at the new lines which continue 8 or more lines.
+          The following process is necessary because gnu33 assember is version 2.95.2, and it can't correspond
+          to the format of "#souce file line No."                                                               */
+  #if 0
   if (line >= pfile->print.line && line < pfile->print.line + 8)
     {
       while (line > pfile->print.line)
@@ -237,6 +251,34 @@ maybe_print_line (pfile, map, line)
     }
   else
     print_line (pfile, map, line, "");
+  #endif
+
+  i_len = strlen( pfile->map->to_file );
+  if( ( pfile->map->to_file[ i_len- 1 ] == 's' ) || ( pfile->map->to_file[ i_len- 1 ] == 'S' ) ){
+	  if ( line >= pfile->print.line && line )
+	    {
+	      while (line > pfile->print.line)
+		{
+		  putc ('\n', pfile->print.outf);
+		  pfile->print.line++;
+		}
+	    }
+	  else
+	    print_line (pfile, map, line, "");  
+  } else {
+	  if (line >= pfile->print.line && line < pfile->print.line + 8)
+	    {
+	      while (line > pfile->print.line)
+		{
+		  putc ('\n', pfile->print.outf);
+		  pfile->print.line++;
+		}
+	    }
+	  else
+	    print_line (pfile, map, line, "");
+  }	    
+  /* CHG K.Watanabe V1.7 <<<<<<< */
+  
 }
 
 /* Output a line marker for logical line LINE.  Special flags are "1"
@@ -248,6 +290,11 @@ print_line (pfile, map, line, special_flags)
      unsigned int line;
      const char *special_flags;
 {
+	/* ADD K.Watanabe V1.7 >>>>>>> */
+	int i_len;			
+	int i_ret;
+	/* ADD K.Watanabe V1.7 <<<<<<< */
+	
   /* End any previous line of text.  */
   if (pfile->print.printed)
     putc ('\n', pfile->print.outf);
@@ -265,16 +312,46 @@ print_line (pfile, map, line, special_flags)
       p = cpp_quote_string (to_file_quoted,
 			    (unsigned char *)map->to_file, to_file_len);
       *p = '\0';
-      fprintf (pfile->print.outf, "# %u \"%s\"%s",
-	       SOURCE_LINE (map, pfile->print.line),
-	       to_file_quoted, special_flags);
-
-      if (map->sysp == 2)
-	fputs (" 3 4", pfile->print.outf);
-      else if (map->sysp == 1)
-	fputs (" 3", pfile->print.outf);
-
-      putc ('\n', pfile->print.outf);
+      /* ADD K.Watanabe V1.7 >>>>>>> */
+      /* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+      
+      if( i_Line_Dummy_Output_Flg == 0 ){		 
+      		/* C33: Do not output the same name at the plural times, when it is the assember source file. */
+		  	i_ret = strcmp( c_Save_Pre_Filename,to_file_quoted );
+	        i_len = strlen( to_file_quoted );
+			if( ( ( to_file_quoted[ i_len- 1 ] == 's' ) || ( to_file_quoted[ i_len- 1 ] == 'S' ) ) 
+																					&& ( i_ret == 0 ) ){
+									;
+			} else {				
+      /* ADD K.Watanabe V1.7 <<<<<<< */
+			      fprintf (pfile->print.outf, "# %u \"%s\"%s",
+				       SOURCE_LINE (map, pfile->print.line),
+				       to_file_quoted, special_flags);
+	    
+			      if (map->sysp == 2)
+					fputs (" 3 4", pfile->print.outf);
+			      else if (map->sysp == 1)
+					fputs (" 3", pfile->print.outf);
+
+			      	putc ('\n', pfile->print.outf); 
+      
+      /* ADD K.Watanabe V1.7 >>>>>>> */      
+      /* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+			      if( ( ( to_file_quoted[ i_len- 1 ] == 's' ) || ( to_file_quoted[ i_len- 1 ] == 'S' ) )
+														      		&& ( i_Asm_CRLF_Line_Init_Flg == 0 ) ){
+					  i_Asm_CRLF_Line_Init_Flg = 1;
+			      } else if( ( ( to_file_quoted[ i_len- 1 ] == 's' ) || ( to_file_quoted[ i_len- 1 ] == 'S' ) )
+														      		&& ( i_Asm_CRLF_Line_Init_Flg == 1 ) ){
+				      putc ('\n', pfile->print.outf);
+				  } else {
+				     	;
+				  }
+				  /* C33: Do not output the same name at the plural times, when it is the assember source file. */
+				  memset( c_Save_Pre_Filename,0,sizeof( c_Save_Pre_Filename ) );
+				  strcpy( c_Save_Pre_Filename,to_file_quoted );
+			}			  
+	  }
+      /* ADD K.Watanabe V1.7 <<<<<<< */
     }
 }
 
diff --git a/gcc/final.c b/gcc/final.c
index 94a0f4c..efca8fc 100644
--- a/gcc/final.c
+++ b/gcc/final.c
@@ -899,6 +899,12 @@ insn_current_reference_address (branch)
   rtx dest, seq;
   int seq_uid;
 
+/* ADD K.Watanabe V1.7 >>>>>>> */
+#if 1	/* GNU-GCC-008 2001/6/28 watanabe */
+  int insn_length;
+#endif	/* GNU-GCC-008 2001/6/28 watanabe */
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
   if (! INSN_ADDRESSES_SET_P ())
     return 0;
 
@@ -911,6 +917,18 @@ insn_current_reference_address (branch)
        We assume here that FUNCTION_BOUNDARY / BITS_PER_UNIT is larger than
        any alignment we'd encounter, so we skip the call to align_fuzz.  */
     return insn_current_address;
+    
+/* ADD K.Watanabe V1.7 >>>>>>> */    
+#if 1	/* GNU-GCC-008 2001/6/28 watanabe */
+  insn_length = insn_lengths[seq_uid];
+  if (GET_CODE (PATTERN (seq)) == SEQUENCE)
+    {
+      if (const_num_delay_slots (XVECEXP (PATTERN (seq), 0, 0)) == 1)
+        insn_length -= 2;
+    }
+#endif	/* GNU-GCC-008 2001/6/28 watanabe */
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
   dest = JUMP_LABEL (branch);
 
   /* BRANCH has no proper alignment chain set, so use SEQ.
@@ -918,15 +936,81 @@ insn_current_reference_address (branch)
   if (INSN_SHUID (seq) < INSN_SHUID (dest))
     {
       /* Forward branch.  */
+/* ADD K.Watanabe V1.7 >>>>>>> */      
+#if 0	/* GNU-GCC-008 2001/6/27 watanabe */      
       return (insn_last_address + insn_lengths[seq_uid]
 	      - align_fuzz (seq, dest, length_unit_log, ~0));
+#else	/* GNU-GCC-008 2001/6/27 watanabe */
+/* ADD K.Watanabe V1.7 <<<<<<< */	      
+      if (insn_length == 2)
+        {
+          return (insn_last_address
+	          - align_fuzz (seq, dest, length_unit_log, ~0));
+	}
+      else if (insn_length == 4)
+        {
+          return (insn_last_address + 2
+	          - align_fuzz (seq, dest, length_unit_log, ~0));
+	}
+      else if (insn_length == 6)
+        {
+          return (insn_last_address + 4
+	          - align_fuzz (seq, dest, length_unit_log, ~0));
+	}
+/* ADD K.Watanabe V1.7 >>>>>>> */	
+#if 1	/* GNU-GCC-042 2002/1/30 watanabe */
+      else if (insn_length == 8)
+        {
+          return (insn_last_address + 6
+	          - align_fuzz (seq, dest, length_unit_log, ~0));
+	}
+#endif	/* GNU-GCC-042 2002/1/30 watanabe */
+/* ADD K.Watanabe V1.7 <<<<<<< */
+      else 
+        {
+	  abort();
+	}
+#endif	/* GNU-GCC-008 2001/6/27 watanabe *//* ADD K.Watanabe V1.7 */
     }
   else
     {
       /* Backward branch.  */
+/* ADD K.Watanabe V1.7 >>>>>>> */
+#if 0	/* GNU-GCC-008 2001/6/27 watanabe */    
       return (insn_current_address
 	      + align_fuzz (dest, seq, length_unit_log, ~0));
+#else	/* GNU-GCC-008 2001/6/27 watanabe */
+/* ADD K.Watanabe V1.7 <<<<<<< */
+      if (insn_length == 2)
+        {
+          return (insn_last_address
+	          + align_fuzz (dest, seq, length_unit_log, ~0));
+	}
+      else if (insn_length == 4)
+        {
+          return (insn_last_address + 2
+	          + align_fuzz (dest, seq, length_unit_log, ~0));
+	}
+      else if (insn_length == 6)
+        {
+          return (insn_last_address + 4
+	          + align_fuzz (dest, seq, length_unit_log, ~0));
+	}
+/* ADD K.Watanabe V1.7 >>>>>>> */	
+#if 1	/* GNU-GCC-042 2002/1/30 watanabe */
+      else if (insn_length == 8)
+        {
+          return (insn_last_address + 6
+	          + align_fuzz (dest, seq, length_unit_log, ~0));
+	}
+#endif	/* GNU-GCC-042 2002/1/30 watanabe */	      
+/* ADD K.Watanabe V1.7 <<<<<<< */
+      else
+        {
+	  abort();
+	}
     }
+#endif	/* GNU-GCC-008 2001/6/27 watanabe *//* ADD K.Watanabe V1.7 */
 }
 #endif /* HAVE_ATTR_length */
 
diff --git a/gcc/gcc.c b/gcc/gcc.c
index 08a37cd..a5c9ed6 100644
--- a/gcc/gcc.c
+++ b/gcc/gcc.c
@@ -6184,7 +6184,12 @@ main (argc, argv)
 
       if (! strncmp (version_string, compiler_version, n)
 	  && compiler_version[n] == 0)
+#ifdef EPSON    /* CHG K.Watanabe V1.7 >>>>>>> */
+    /* xgcc prints its c33-compiler version. */
+	notice ("gcc version %s%s\n", version_string, C33_TARGET_VERSION );
+#else	  
 	notice ("gcc version %s\n", version_string);
+#endif			/* CHG K.Watanabe V1.7 <<<<<<< */	
       else
 	notice ("gcc driver version %s executing gcc version %s\n",
 		version_string, compiler_version);
diff --git a/gcc/line-map.c b/gcc/line-map.c
index a0f3ee5..a4e6c6c 100644
--- a/gcc/line-map.c
+++ b/gcc/line-map.c
@@ -25,6 +25,11 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 #include "line-map.h"
 #include "intl.h"
 
+/* ADD K.Watanabe V1.7 >>>>>>> */
+/* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+extern int i_Asm_Adjust_Line_Init_Flg;
+/* ADD K.Watanabe V1.7 <<<<<<< */
+
 static void trace_include
   PARAMS ((const struct line_maps *, const struct line_map *));
 
@@ -80,7 +85,8 @@ add_line_map (set, reason, sysp, from_line, to_file, to_line)
      unsigned int to_line;
 {
   struct line_map *map;
-
+  int i_len;		/* ADD K.Watanabe V1.7 */
+  
   if (set->used && from_line < set->maps[set->used - 1].from_line)
     abort ();
 
@@ -124,7 +130,18 @@ add_line_map (set, reason, sysp, from_line, to_file, to_line)
       if (error || to_file == NULL)
 	{
 	  to_file = from->to_file;
-	  to_line = LAST_SOURCE_LINE (from) + 1;
+	/* CHG K.Watanabe V1.7 >>>>>>> */
+	/* C33: Output the same content with version 2.95.2, when the assembler source files are preprocessed. */
+/*	  to_line = LAST_SOURCE_LINE (from) + 1; */
+	  i_len = strlen( to_file );
+      if( ( ( to_file[ i_len- 1 ] == 's' ) || ( to_file[ i_len- 1 ] == 'S' ) )
+								      			&& ( i_Asm_Adjust_Line_Init_Flg == 0 ) ){
+		  to_line = LAST_SOURCE_LINE (from);
+		  i_Asm_Adjust_Line_Init_Flg = 1;
+	  } else {
+		  to_line = LAST_SOURCE_LINE (from) + 1; 
+ 	  }		  
+	/* CHG K.Watanabe V1.7 <<<<<<< */	  
 	  sysp = from->sysp;
 	}
     }
diff --git a/gcc/protoize.c b/gcc/protoize.c
index e039d6d..4d2763d 100644
--- a/gcc/protoize.c
+++ b/gcc/protoize.c
@@ -592,6 +592,7 @@ safe_read (desc, ptr, len)
      int len;
 {
   int left = len;
+
   while (left > 0) {
     int nchars = read (desc, ptr, left);
     if (nchars < 0)
@@ -623,6 +624,7 @@ safe_write (desc, ptr, len, out_fname)
 {
   while (len > 0) {
     int written = write (desc, ptr, len);
+
     if (written < 0)
       {
 	int errno_val = errno;
diff --git a/gcc/toplev.c b/gcc/toplev.c
index adccdc4..44125b3 100644
--- a/gcc/toplev.c
+++ b/gcc/toplev.c
@@ -4557,6 +4557,25 @@ print_version (file, indent)
      FILE *file;
      const char *indent;
 {
+
+#ifdef EPSON    /* CHG K.Watanabe V1.7 >>>>>>> */
+    /* cc1 prints its c33-compiler version. */
+
+#ifndef __VERSION__
+#define __VERSION__ "[?]"
+#endif
+  fnotice (file,
+#ifdef __GNUC__
+	   "%s%s%s version %s (%s) compiled by GNU C version %s%s.\n"
+#else
+	   "%s%s%s version %s (%s) compiled by CC.\n"
+#endif
+	   , indent, *indent != 0 ? " " : "",
+	   lang_hooks.name, version_string, TARGET_NAME, __VERSION__, 
+	   C33_TARGET_VERSION );
+
+#else
+
 #ifndef __VERSION__
 #define __VERSION__ "[?]"
 #endif
@@ -4569,6 +4588,8 @@ print_version (file, indent)
 	   , indent, *indent != 0 ? " " : "",
 	   lang_hooks.name, version_string, TARGET_NAME,
 	   indent, __VERSION__);
+#endif			/* #ifndef EPSON *//* CHG K.Watanabe V1.7 <<<<<<< */
+	   
   fnotice (file, "%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\n",
 	   indent, *indent != 0 ? " " : "",
 	   PARAM_VALUE (GGC_MIN_EXPAND), PARAM_VALUE (GGC_MIN_HEAPSIZE));
@@ -4878,6 +4899,36 @@ parse_options_and_default_flags (argc, argv)
       flag_crossjumping = 1;
       flag_if_conversion = 1;
       flag_if_conversion2 = 1;
+      
+    /* ADD K.Watanabe V1.7 >>>>>>> */
+    /* C33: Correspondence to a bug.													*/
+    /*      Enable "-fforce-addr" which is the compiler option with default             */
+    /*      only when it is "-O".                                                       */
+    /* -fforce-addr -- This options means that the content of memory is loaded to       */
+    /*                 the register, and the register is referenced.                    */ 
+    /*																					*/
+    /* The option above is set because the following bug is occurred                    */
+    /* at the "-O" && ( Not "-medda32" or Advanced mode ).                              */
+    /*																					*/
+    /* "-fforce-addr" is enabled with default at the "-O", because the state of         */
+    /* existence of "-medda32" / Advanced mode can not be checked in this function.     */
+    /*																					*/
+	/*	 xld.w	[%sp+132],%r8    														*/
+	/* 	.......																			*/
+	/*	xld.w	[%sp+132],%r11															*/
+	/*	.......																			*/
+	/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;														*/
+	/* xld.w	%r8,[%sp+132]	---- @													*/
+	/* ;;;;;;;;;;;;;;;;;;;;;;;;;;;														*/
+	/* xld.w	[%sp+176],%r8   ---- A													*/
+	/*																					*/
+	/* The code of @ is deleted in the process of optimization, 						*/
+	/* and the right value is not set to [%sp+176]( which is A ).						*/
+	
+	  if( optimize == 1 ){
+  		 flag_force_addr = 1;
+      } 	      
+      /* ADD K.Watanabe V1.7 <<<<<<< */       
     }
 
   if (optimize >= 2)
diff --git a/gcc/tree.h b/gcc/tree.h
index 1ad4b14..56fcb5f 100644
--- a/gcc/tree.h
+++ b/gcc/tree.h
@@ -413,11 +413,9 @@ extern void tree_vec_elt_check_failed PARAMS ((int, int, const char *,
 
 /* Nonzero if TYPE represents an integral type.  Note that we do not
    include COMPLEX types here.  */
-
 #define INTEGRAL_TYPE_P(TYPE)  \
   (TREE_CODE (TYPE) == INTEGER_TYPE || TREE_CODE (TYPE) == ENUMERAL_TYPE  \
    || TREE_CODE (TYPE) == BOOLEAN_TYPE || TREE_CODE (TYPE) == CHAR_TYPE)
-
 /* Nonzero if TYPE represents a floating-point type, including complex
    floating-point types.  */
 
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 9a76099..5bd5018 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -470,7 +470,7 @@ resolve_unique_section (decl, reloc, flag_function_or_data_sections)
       && targetm.have_named_sections
       && (flag_function_or_data_sections
 	  || DECL_ONE_ONLY (decl)))
-    (*targetm.asm_out.unique_section) (decl, reloc);
+    (*targetm.asm_out.unique_section) (decl, reloc); 
 }
 
 #ifdef BSS_SECTION_ASM_OP
@@ -563,7 +563,7 @@ function_section (decl)
 {
   if (decl != NULL_TREE
       && DECL_SECTION_NAME (decl) != NULL_TREE)
-    named_section (decl, (char *) 0, 0);
+    named_section (decl, (char *) 0, 0); 
   else
     text_section ();
 }
@@ -1583,12 +1583,23 @@ assemble_variable (decl, top_level, at_end, dont_output_data)
       if (DECL_COMMON (decl))
 	sorry ("thread-local COMMON data not implemented");
     }
+/* CHG K.Watanabe V1.7 >>>>>>> */    
+/* C33: Allocate to ".data" section even when it is initizalized by 0. */
+#if 0
   else if (DECL_INITIAL (decl) == 0
 	   || DECL_INITIAL (decl) == error_mark_node
 	   || (flag_zero_initialized_in_bss
 	       /* Leave constant zeroes in .rodata so they can be shared.  */
 	       && !TREE_READONLY (decl)
 	       && initializer_zerop (DECL_INITIAL (decl))))
+#endif      
+  else if (DECL_INITIAL (decl) == 0
+	   || DECL_INITIAL (decl) == error_mark_node
+	   || (flag_zero_initialized_in_bss
+	       /* Leave constant zeroes in .rodata so they can be shared.  */
+	       && !TREE_READONLY (decl)
+	       && 0 ))
+/* CHG K.Watanabe V1.7 <<<<<<< */
     {
       unsigned HOST_WIDE_INT size = tree_low_cst (DECL_SIZE_UNIT (decl), 1);
       unsigned HOST_WIDE_INT rounded = size;
diff --git a/include/obstack.h b/include/obstack.h
index d86d9f2..ab960e9 100644
--- a/include/obstack.h
+++ b/include/obstack.h
@@ -418,6 +418,9 @@ __extension__								\
    and that the data added so far to the current object
    shares that much alignment.  */
 
+
+// CHG K.Watanabe V1.8 >>>>>>>
+#if 0
 # define obstack_ptr_grow(OBSTACK,datum)				\
 __extension__								\
 ({ struct obstack *__o = (OBSTACK);					\
@@ -425,6 +428,19 @@ __extension__								\
      _obstack_newchunk (__o, sizeof (void *));				\
    *((void **)__o->next_free)++ = ((void *)datum);			\
    (void) 0; })
+#endif
+
+
+# define obstack_ptr_grow(OBSTACK,datum)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (void *));				\
+     *((void **)__o->next_free) = ((void *)datum); \
+     __o->next_free += sizeof(void *); \
+   (void) 0; })
+// CHG K.Watanabe V1.8 <<<<<<<
+
 
 # define obstack_int_grow(OBSTACK,datum)				\
 __extension__								\
diff --git a/libstdc++-v3/include/c_std/std_cstring.h b/libstdc++-v3/include/c_std/std_cstring.h
index 066342a..4cbd121 100644
--- a/libstdc++-v3/include/c_std/std_cstring.h
+++ b/libstdc++-v3/include/c_std/std_cstring.h
@@ -101,25 +101,21 @@ namespace std
   { return memchr(const_cast<const void*>(__p), __c, __n); }
 
   using ::strchr;
-
   inline char*
   strchr(char* __s1, int __n)
   { return __builtin_strchr(const_cast<const char*>(__s1), __n); }
 
   using ::strpbrk;
-
   inline char*
   strpbrk(char* __s1, const char* __s2)
   { return __builtin_strpbrk(const_cast<const char*>(__s1), __s2); }
 
   using ::strrchr;
-
   inline char*
   strrchr(char* __s1, int __n)
   { return __builtin_strrchr(const_cast<const char*>(__s1), __n); }
 
   using ::strstr;
-
   inline char*
   strstr(char* __s1, const char* __s2)
   { return __builtin_strstr(const_cast<const char*>(__s1), __s2); }
-- 
1.5.4.3

