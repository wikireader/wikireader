From 4e548b6827ab9d2e8a82e0e8b0e5ab5cd891f54b Mon Sep 17 00:00:00 2001
From: Holger Freyther <ich@tamarin.(none)>
Date: Thu, 11 Sep 2008 14:55:33 +0200
Subject: [PATCH] [binutils] EPSON changes to binutils

---
 MAKE.sh                        |  161 ++
 bfd/Makefile.am                |    8 +
 bfd/Makefile.in                |    8 +
 bfd/archures.c                 |    2 +
 bfd/bfd-in2.h                  |   60 +-
 bfd/config.bfd                 |    5 +
 bfd/configure                  |    1 +
 bfd/cpu-c33.c                  |  109 +
 bfd/elf.c                      |    7 +
 bfd/elf32-c33.c                | 2730 +++++++++++++++++++++
 bfd/syms.c                     |   11 +
 bfd/targets.c                  |    1 +
 binutils/Makefile.am           |    1 +
 binutils/Makefile.in           |    1 +
 binutils/objdump.c             |   95 +-
 binutils/stabs.c               |    7 +
 binutils/version.c             |    7 +
 config.sub                     |    4 +-
 configure.in                   |    3 +
 gas/Makefile.am                |   24 +-
 gas/Makefile.in                |   31 +-
 gas/as.c                       |  851 +++++---
 gas/config/gas/config/tc-c33.c | 4382 ++++++++++++++++++++++++++++++++++
 gas/config/tc-c33.c            | 5098 ++++++++++++++++++++++++++++++++++++++++
 gas/config/tc-c33.h            |   78 +
 gas/configure                  |    3 +
 gas/configure.in               |    1 +
 gas/doc/Makefile.am            |    1 +
 gas/ext_remove.c               | 2014 ++++++++++++++++
 gas/ext_remove.h               |  176 ++
 gas/input-scrub.c              |   31 +-
 gas/read.c                     | 3438 +++++++++++++++-------------
 gas/stabs.c                    |  171 +-
 gas/write.c                    | 2283 +++++++++---------
 include/dis-asm.h              |    4 +
 include/elf/c33.h              |  128 +
 include/elf/common.h           |    6 +
 include/opcode/c33.h           |  205 ++
 ld/Makefile.am                 |    3 +
 ld/Makefile.in                 |    3 +
 ld/configure.tgt               |    1 +
 ld/emulparams/c33.sh           |   10 +
 ld/emultempl/c33.em            |  128 +
 ld/ldlang.c                    | 2986 ++++++++++++-----------
 ld/ldmain.c                    |  711 +++---
 ld/ldver.c                     |   18 +-
 ld/lexsup.c                    | 1335 ++++++-----
 ld/scripttempl/c33.sc          |   98 +
 opcodes/Makefile.am            |    8 +
 opcodes/Makefile.in            |    8 +
 opcodes/c33-dis.c              | 2824 ++++++++++++++++++++++
 opcodes/c33-opc.c              | 2146 +++++++++++++++++
 opcodes/configure              |    1 +
 opcodes/configure.in           |    1 +
 opcodes/disassemble.c          |    9 +
 55 files changed, 26899 insertions(+), 5537 deletions(-)
 create mode 100755 MAKE.sh
 create mode 100644 bfd/cpu-c33.c
 create mode 100644 bfd/elf32-c33.c
 create mode 100644 gas/config/gas/config/tc-c33.c
 create mode 100644 gas/config/tc-c33.c
 create mode 100644 gas/config/tc-c33.h
 create mode 100644 gas/ext_remove.c
 create mode 100644 gas/ext_remove.h
 create mode 100644 include/elf/c33.h
 create mode 100644 include/opcode/c33.h
 create mode 100644 ld/emulparams/c33.sh
 create mode 100644 ld/emultempl/c33.em
 create mode 100644 ld/scripttempl/c33.sc
 create mode 100644 opcodes/c33-dis.c
 create mode 100644 opcodes/c33-opc.c

diff --git a/MAKE.sh b/MAKE.sh
new file mode 100755
index 0000000..09c88de
--- /dev/null
+++ b/MAKE.sh
@@ -0,0 +1,161 @@
+#!/bin/sh
+
+echo "@@@@@ START: `date`"
+
+CROSS_TARGET=c33-epson-elf
+INSTDIR=/usr/local/c33
+PREFIX=c33-epson-elf-
+TARGETS="ld as objdump"
+TARGETS=$TARGETS" ar ranlib objcopy nm strip size strings"
+TARGETS=$TARGETS" readelf addr2line cxxfilt"
+WORKDIR=c33-binutils
+ARCHIVE_DIR=$WORKDIR/archive
+ARCHIVE_DATE=`date +%y%m%d`
+
+SRCDIR=binutils-2.10.1
+
+
+case `uname -s` in
+CYGWIN*)
+	EXE=.exe
+	;;
+Linux*)
+	EXE=
+	;;
+*)
+	EXE=
+	;;
+esac
+LANG=C
+
+clean=no
+config=no
+build=no
+install=no
+tags=no
+archive=no
+
+if [ $# -eq 0 ]; then
+	clean=yes
+	config=yes
+	build=yes
+	install=yes
+	tags=yes
+fi
+
+while [ $# -gt 0 ]; do
+	case $1 in
+	all)
+		clean=yes
+		config=yes
+		build=yes
+		install=yes
+		tags=yes
+		;;
+	clean)
+		clean=yes
+		;;
+	config)
+		config=yes
+		;;
+	build)
+		build=yes
+		;;
+	install)
+		install=yes
+		;;
+	tags)
+		tags=yes
+		;;
+	archive)
+		archive=yes
+		;;
+	esac
+
+	shift
+done
+
+if [ "$clean" = "yes" ]; then
+	echo "@@@@@ CLEAN: `date`"
+
+	if [ -e $$WORKDIR ]; then
+		mv $WORKDIR $WORKDIR-gomi
+		rm -rf $WORKDIR-gomi
+	fi
+fi
+
+if [ "$config" = "yes" ]; then
+	echo "@@@@@ CONFIG: `date`"
+
+	mkdir $WORKDIR
+	(cd $WORKDIR; \
+		../$SRCDIR/configure \
+			--target=$CROSS_TARGET \
+			--prefix=$INSTDIR ) || exit 1
+fi
+
+if [ "$build" = "yes" ]; then
+	echo "@@@@@ BUILD: `date`"
+
+#	(cd $WORKDIR; make) || exit 1
+	(cd $WORKDIR; make clean all) || exit 1
+
+	cp $WORKDIR/ld/ld-new$EXE c33-ld$EXE
+	cp $WORKDIR/gas/as-new$EXE c33-as$EXE
+	cp $WORKDIR/binutils/objdump$EXE c33-objdump$EXE
+
+	cp $WORKDIR/binutils/addr2line$EXE c33-addr2line$EXE
+	cp $WORKDIR/binutils/ar$EXE c33-ar$EXE
+	cp $WORKDIR/binutils/cxxfilt$EXE c33-cxxfilt$EXE
+	cp $WORKDIR/binutils/nm-new$EXE c33-nm$EXE
+	cp $WORKDIR/binutils/objcopy$EXE c33-objcopy$EXE
+	cp $WORKDIR/binutils/ranlib$EXE c33-ranlib$EXE
+	cp $WORKDIR/binutils/readelf$EXE c33-readelf$EXE
+	cp $WORKDIR/binutils/size$EXE c33-size$EXE
+	cp $WORKDIR/binutils/strings$EXE c33-strings$EXE
+	cp $WORKDIR/binutils/strip-new$EXE c33-strip$EXE
+
+
+	for i in $TARGETS; do
+		strip c33-$i$EXE
+	done
+
+	cp c33-as$EXE as_org$EXE
+	cp c33-ld$EXE ld$EXE
+	cp c33-objdump$EXE objdump$EXE
+
+fi
+
+if [ "$install" = "yes" ]; then
+	echo "@@@@@ INSTALL: `date`"
+
+	mkdir -p $INSTDIR/bin
+	for i in $TARGETS; do
+		cp -p c33-$i$EXE $INSTDIR/bin/$PREFIX$i$EXE
+	done
+fi
+
+if [ "$tags" = "yes" ]; then
+	echo "@@@@@ TAGS: `date`"
+
+	rm -rf tags
+	ctags -R $SRCDIR
+fi
+
+if [ "$archive" = "yes" ]; then
+	echo "@@@@@ ARCHIVE: `date`"
+	mkdir -p $ARCHIVE_DIR
+
+	echo "Archive to '$ARCHIVE_DIR/$SRCDIR-$ARCHIVE_DATE.tgz'"
+	if [ -f $ARCHIVE_DIR/$SRCDIR-$ARCHIVE_DATE.tgz ]; then
+		echo -n "This file is exist.  Really over write? "
+		read x
+	fi
+	tar cfz $ARCHIVE_DIR/$SRCDIR-$ARCHIVE_DATE.tgz \
+		MAKE.sh \
+		$SRCDIR
+fi
+
+echo "@@@@@ DONE: `date`"
+
+exit 0
diff --git a/bfd/Makefile.am b/bfd/Makefile.am
index 2d38959..116cf71 100644
--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -68,6 +68,7 @@ ALL_MACHINES = \
 	cpu-tic30.lo \
 	cpu-tic80.lo \
 	cpu-v850.lo \
+	cpu-c33.lo \
 	cpu-vax.lo \
 	cpu-we32k.lo \
 	cpu-w65.lo \
@@ -105,6 +106,7 @@ ALL_MACHINES_CFILES = \
 	cpu-tic30.c \
 	cpu-tic80.c \
 	cpu-v850.c \
+	cpu-c33.c \
 	cpu-vax.c \
 	cpu-we32k.c \
 	cpu-w65.c \
@@ -180,6 +182,7 @@ BFD32_BACKENDS = \
 	elf32-sh.lo \
 	elf32-sparc.lo \
 	elf32-v850.lo \
+	elf32-c33.lo \
 	elf32.lo \
 	elflink.lo \
 	epoc-pe-arm.lo \
@@ -310,6 +313,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-sh.c \
 	elf32-sparc.c \
 	elf32-v850.c \
+	elf32-c33.c \
 	elf32.c \
 	elflink.c \
 	epoc-pe-arm.c \
@@ -716,6 +720,7 @@ cpu-sparc.lo: cpu-sparc.c
 cpu-tic30.lo: cpu-tic30.c
 cpu-tic80.lo: cpu-tic80.c
 cpu-v850.lo: cpu-v850.c
+cpu-c33.lo: cpu-c33.c
 cpu-vax.lo: cpu-vax.c
 cpu-we32k.lo: cpu-we32k.c
 cpu-w65.lo: cpu-w65.c
@@ -918,6 +923,9 @@ elf32-sparc.lo: elf32-sparc.c $(INCDIR)/bfdlink.h elf-bfd.h \
 elf32-v850.lo: elf32-v850.c $(INCDIR)/bfdlink.h elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/elf/v850.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
+elf32-c33.lo: elf32-c33.c $(INCDIR)/bfdlink.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/elf/c33.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elf32.lo: elf32.c elfcode.h $(INCDIR)/bfdlink.h elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   elfcore.h elflink.h
diff --git a/bfd/Makefile.in b/bfd/Makefile.in
index bb8e06c..39992f4 100644
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -183,6 +183,7 @@ ALL_MACHINES = \
 	cpu-tic30.lo \
 	cpu-tic80.lo \
 	cpu-v850.lo \
+	cpu-c33.lo \
 	cpu-vax.lo \
 	cpu-we32k.lo \
 	cpu-w65.lo \
@@ -221,6 +222,7 @@ ALL_MACHINES_CFILES = \
 	cpu-tic30.c \
 	cpu-tic80.c \
 	cpu-v850.c \
+	cpu-c33.c \
 	cpu-vax.c \
 	cpu-we32k.c \
 	cpu-w65.c \
@@ -297,6 +299,7 @@ BFD32_BACKENDS = \
 	elf32-sh.lo \
 	elf32-sparc.lo \
 	elf32-v850.lo \
+	elf32-c33.lo \
 	elf32.lo \
 	elflink.lo \
 	epoc-pe-arm.lo \
@@ -428,6 +431,7 @@ BFD32_BACKENDS_CFILES = \
 	elf32-sh.c \
 	elf32-sparc.c \
 	elf32-v850.c \
+	elf32-c33.c \
 	elf32.c \
 	elflink.c \
 	epoc-pe-arm.c \
@@ -1244,6 +1248,7 @@ cpu-sparc.lo: cpu-sparc.c
 cpu-tic30.lo: cpu-tic30.c
 cpu-tic80.lo: cpu-tic80.c
 cpu-v850.lo: cpu-v850.c
+cpu-c33.lo: cpu-c33.c
 cpu-vax.lo: cpu-vax.c
 cpu-we32k.lo: cpu-we32k.c
 cpu-w65.lo: cpu-w65.c
@@ -1446,6 +1451,9 @@ elf32-sparc.lo: elf32-sparc.c $(INCDIR)/bfdlink.h elf-bfd.h \
 elf32-v850.lo: elf32-v850.c $(INCDIR)/bfdlink.h elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/elf/v850.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
+elf32-c33.lo: elf32-c33.c $(INCDIR)/bfdlink.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/elf/c33.h $(INCDIR)/elf/reloc-macros.h elf32-target.h
 elf32.lo: elf32.c elfcode.h $(INCDIR)/bfdlink.h elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   elfcore.h elflink.h
diff --git a/bfd/archures.c b/bfd/archures.c
index 7462592..9bb6a1c 100644
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -274,6 +274,7 @@ extern const bfd_arch_info_type bfd_z8k_arch;
 extern const bfd_arch_info_type bfd_ns32k_arch;
 extern const bfd_arch_info_type bfd_w65_arch;
 extern const bfd_arch_info_type bfd_v850_arch;
+extern const bfd_arch_info_type bfd_c33_arch;
 extern const bfd_arch_info_type bfd_fr30_arch;
 extern const bfd_arch_info_type bfd_mcore_arch;
 extern const bfd_arch_info_type bfd_avr_arch;
@@ -314,6 +315,7 @@ static const bfd_arch_info_type * const bfd_archures_list[] =
   &bfd_ns32k_arch,
   &bfd_w65_arch,
   &bfd_v850_arch,
+  &bfd_c33_arch,
   &bfd_fr30_arch,
   &bfd_mcore_arch,
   &bfd_avr_arch,
diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 4c3eea0..6988b50 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1420,6 +1420,8 @@ enum bfd_architecture
 #define bfd_mach_avr2          2
 #define bfd_mach_avr3          3
 #define bfd_mach_avr4          4
+  bfd_arch_c33,								/* 追加 2001.2.19 ide */
+#define bfd_mach_c33          0				/* 追加 2001.2.19 ide */
   bfd_arch_last
   };
 
@@ -1515,11 +1517,32 @@ typedef enum bfd_reloc_status
         /* The symbol to relocate against was undefined. */
   bfd_reloc_undefined,
 
+/* add tazaki 2001.11.20 >>>>> */
+  bfd_reloc_over_doff_globalpointer,
+  bfd_reloc_over_goff_globalpointer,
+  bfd_reloc_over_soff_globalpointer,
+  bfd_reloc_over_toff_globalpointer,
+  bfd_reloc_over_zoff_globalpointer,
+  bfd_reloc_doff_over_64mb,
+  bfd_reloc_doff_over_8kb,
+  bfd_reloc_goff_over_8kb,
+  bfd_reloc_soff_over_64mb,
+  bfd_reloc_soff_over_8kb,
+  bfd_reloc_toff_over_64mb,
+  bfd_reloc_toff_over_8kb,
+  bfd_reloc_zoff_over_64mb,
+  bfd_reloc_zoff_over_8kb,
+  bfd_reloc_dpoff_over_512kb,
+  bfd_reloc_dpoff_over_64b,
+/* add tazaki 2001.11.20 <<<<< */
+
         /* The relocation was performed, but may not be ok - presently
           generated only when linking i960 coff files with i960 b.out
           symbols.  If this type is returned, the error_message argument
           to bfd_perform_relocation will be set.  */
   bfd_reloc_dangerous
+  
+
  }
  bfd_reloc_status_type;
 
@@ -2376,6 +2399,39 @@ value of SUBI insn. */
 into 22 bits. */
   BFD_RELOC_AVR_CALL,
 
+
+  /* cc33 relocations */
+  BFD_RELOC_C33_AH,
+  BFD_RELOC_C33_AL,
+  BFD_RELOC_C33_RH,
+  BFD_RELOC_C33_RM,
+  BFD_RELOC_C33_RL,
+  BFD_RELOC_C33_S_RH,	/* add tazaki 2002.05.02 */
+  BFD_RELOC_C33_S_RM,	/* add tazaki 2002.05.02 */
+  BFD_RELOC_C33_S_RL,	/* add tazaki 2002.05.02 */
+  BFD_RELOC_C33_JP,	/* add tazaki 2002.04.22 */
+  BFD_RELOC_C33_H,
+  BFD_RELOC_C33_M,
+  BFD_RELOC_C33_L,
+  BFD_RELOC_C33_DH, /* add tazaki 2002.01.11 */
+  BFD_RELOC_C33_DL, /* add tazaki 2002.01.11 */
+  BFD_RELOC_C33_GL, /* add tazaki 2001.07.13 */
+  BFD_RELOC_C33_SH, /* add tazaki 2001.11.07 */
+  BFD_RELOC_C33_SL, /* add tazaki 2001.07.13 */
+  BFD_RELOC_C33_TH, /* add tazaki 2001.11.07 */
+  BFD_RELOC_C33_TL, /* add tazaki 2001.07.13 */
+  BFD_RELOC_C33_ZH, /* add tazaki 2001.11.07 */
+  BFD_RELOC_C33_ZL, /* add tazaki 2001.07.13 */
+  BFD_RELOC_C33_DPH,/* add tazaki 2001.11.08 */
+  BFD_RELOC_C33_DPM,/* add tazaki 2001.11.08 */
+  BFD_RELOC_C33_DPL,/* add tazaki 2001.11.08 */
+  BFD_RELOC_C33_LOOP,/* add tazaki 2002.03.05 */
+  BFD_RELOC_C33_PUSHN_R0, /* add tazaki 2004/08/19 */
+  BFD_RELOC_C33_PUSHN_R1, /* add tazaki 2004/08/19 */
+  BFD_RELOC_C33_PUSH_R1,  /* add tazaki 2004/08/19 */
+
+
+
 /* These two relocations are used by the linker to determine which of
 the entries in a C++ virtual function table are actually used.  When
 the --gc-sections option is given, the linker will zero out the entries
@@ -2395,7 +2451,9 @@ is stored in the reloc's addend.  For Rel hosts, we are forced to put
 this offset in the reloc's section offset. */
   BFD_RELOC_VTABLE_INHERIT,
   BFD_RELOC_VTABLE_ENTRY,
-  BFD_RELOC_UNUSED };
+  BFD_RELOC_UNUSED,
+  
+   };
 typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
 reloc_howto_type *
 
diff --git a/bfd/config.bfd b/bfd/config.bfd
index 3adc5ae..b5f041f 100755
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -44,6 +44,7 @@ powerpc*) targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
 rs6000)	targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
 sparc*) targ_archs=bfd_sparc_arch ;;
 v850*)	targ_archs=bfd_v850_arch ;;
+c33*)	targ_archs=bfd_c33_arch ;;
 z8k*)	targ_archs=bfd_z8k_arch ;;
 *)	targ_archs=bfd_${targ_cpu}_arch ;;
 esac
@@ -767,6 +768,10 @@ case "${targ}" in
     ;;
 
 
+   c33-*-*)
+    targ_defvec=bfd_elf32_c33_vec
+    ;;
+
   v850-*-*)
     targ_defvec=bfd_elf32_v850_vec
     ;;
diff --git a/bfd/configure b/bfd/configure
index 89f979e..1bd4958 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -5111,6 +5111,7 @@ do
     bfd_elf32_shl_vec)		tb="$tb elf32-sh.lo elf32.lo $elf coff-sh.lo" ;;
     bfd_elf32_sparc_vec)	tb="$tb elf32-sparc.lo elf32.lo $elf" ;;
     bfd_elf32_v850_vec)		tb="$tb elf32-v850.lo elf32.lo $elf" ;;
+    bfd_elf32_c33_vec)		tb="$tb elf32-c33.lo elf32.lo $elf" ;;
     bfd_elf64_big_generic_vec) 	tb="$tb elf64-gen.lo elf64.lo $elf"
 				target64=true ;;
     bfd_elf64_little_generic_vec) tb="$tb elf64-gen.lo elf64.lo $elf"
diff --git a/bfd/cpu-c33.c b/bfd/cpu-c33.c
new file mode 100644
index 0000000..384f51c
--- /dev/null
+++ b/bfd/cpu-c33.c
@@ -0,0 +1,109 @@
+/* BFD support for the NEC V850 processor
+   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+#include <ctype.h>
+
+static boolean 
+scan (info, string)
+     const struct bfd_arch_info * info;
+     const char * string;
+{
+  const char *ptr_src;
+  const char *ptr_tst;
+  unsigned long number;
+  enum bfd_architecture arch;
+
+  /* First test for an exact match */
+  if (strcasecmp (string, info->printable_name) == 0)
+    return true;
+
+  /* See how much of the supplied string matches with the
+     architecture, eg the string m68k:68020 would match the m68k entry
+     up to the :, then we get left with the machine number */
+
+  for (ptr_src = string, ptr_tst = info->arch_name; 
+       *ptr_src && *ptr_tst;
+       ptr_src++, ptr_tst++) 
+    {
+      if (*ptr_src != *ptr_tst) break;
+    }
+
+  /* Chewed up as much of the architecture as will match, skip any
+     colons */
+  if (*ptr_src == ':')
+    ptr_src++;
+  
+  if (*ptr_src == 0)
+    {
+      /* nothing more, then only keep this one if it is the default
+	 machine for this architecture */
+      return info->the_default;
+    }
+
+  number = 0;
+  while (isdigit ((unsigned char) *ptr_src))
+    {
+      number = number * 10 + * ptr_src  - '0';
+      ptr_src++;
+    }
+
+  switch (number) 
+    {
+#if 0
+    case bfd_mach_v850e:  arch = bfd_arch_v850; break;
+    case bfd_mach_v850ea: arch = bfd_arch_v850; break;
+#endif
+    default:  
+      return false;
+    }
+
+  if (arch != info->arch) 
+    return false;
+
+  if (number != info->mach)
+    return false;
+
+  return true;
+}
+
+#define N(number, print, default, next)  \
+{  32, 32, 8, bfd_arch_c33, number, "c33", print, 2, default, \
+     bfd_default_compatible, scan, next }
+
+#define NEXT NULL
+#if 0
+static const bfd_arch_info_type arch_info_struct[] = 
+{
+  N (bfd_mach_v850e,  "v850e",  false, &arch_info_struct[1]),
+  N (bfd_mach_v850ea, "v850ea", false, NULL)
+};
+#undef NEXT
+#define NEXT &arch_info_struct[0]
+
+const bfd_arch_info_type bfd_c33_arch =
+  N (bfd_mach_c33, "c33", true, NEXT);
+#endif
+
+
+const bfd_arch_info_type bfd_c33_arch =
+  N (0, "c33", true, NULL);
diff --git a/bfd/elf.c b/bfd/elf.c
index e8e7e37..b591ee4 100644
--- a/bfd/elf.c
+++ b/bfd/elf.c
@@ -392,6 +392,7 @@ _bfd_elf_make_section_from_shdr (abfd, hdr, name)
      The symbols will be defined as weak, so that multiple definitions
      are permitted.  The GNU linker extension is to actually discard
      all but one of the sections.  */
+
   if (strncmp (name, ".gnu.linkonce", sizeof ".gnu.linkonce" - 1) == 0)
     flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
 
@@ -3306,6 +3307,12 @@ prep_headers (abfd)
     case bfd_arch_pj:
       i_ehdrp->e_machine = EM_PJ;
       break;
+/* >>>>> ADDED D.Fujimoto 2007/10/15  Seiko Epson processor (S1C33) */
+	// this flag will be written in o and elf files
+    case bfd_arch_c33:
+      i_ehdrp->e_machine = EM_SE_C33;
+      break;
+/* <<<<< ADDED D.Fujimoto 2007/10/15  Seiko Epson processor (S1C33) */
       /* also note that EM_M32, AT&T WE32100 is unknown to bfd */
     default:
       i_ehdrp->e_machine = EM_NONE;
diff --git a/bfd/elf32-c33.c b/bfd/elf32-c33.c
new file mode 100644
index 0000000..ba5d1c8
--- /dev/null
+++ b/bfd/elf32-c33.c
@@ -0,0 +1,2730 @@
+/* c33-specific support for 32-bit ELF
+   Copyright (C) 1996, 1997, 1998, 1999,2001 Free Software Foundation, Inc.
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+
+/* XXX FIXME: This code is littered with 32bit int, 16bit short, 8bit char
+   dependencies.  As is the gas & simulator code or the c33.  */
+
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/c33.h"
+#include "libiberty.h"		// ADDED D.Fujimoto 2007/10/02
+
+/* sign-extend a 24-bit number */
+#define SEXT24(x)	((((x) & 0xffffff) ^ (~ 0x7fffff)) + 0x800000)
+      
+static reloc_howto_type *c33_elf_reloc_type_lookup
+  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
+static void c33_elf_info_to_howto_rel
+  PARAMS ((bfd *, arelent *, Elf32_Internal_Rel *));
+static void c33_elf_info_to_howto_rela
+  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
+static bfd_reloc_status_type c33_elf_reloc
+  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
+static boolean c33_elf_is_local_label_name
+  PARAMS ((bfd *, const char *));
+static boolean c33_elf_relocate_section
+  PARAMS((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
+	  Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
+static bfd_reloc_status_type c33_elf_perform_relocation
+  PARAMS ((bfd *, int, bfd_vma, bfd_byte *,unsigned long));
+static boolean c33_elf_check_relocs
+  PARAMS ((bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *));
+
+#if 0
+static void remember_ah_reloc
+  PARAMS ((bfd *, bfd_vma, bfd_byte *));
+static bfd_byte * find_remembered_ah_reloc
+  PARAMS ((bfd_vma,bfd_byte*));
+#endif
+
+static bfd_reloc_status_type c33_elf_final_link_relocate
+  PARAMS ((reloc_howto_type *, bfd *, bfd *, asection *, bfd_byte *, bfd_vma,
+	   bfd_vma, bfd_vma, struct bfd_link_info *, asection *, int));
+#if 0
+static boolean c33_elf_object_p
+  PARAMS ((bfd *));
+#endif
+static boolean c33_elf_fake_sections
+  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *));
+#if 0
+static void c33_elf_final_write_processing
+  PARAMS ((bfd *, boolean));
+#endif
+static boolean c33_elf_set_private_flags
+  PARAMS ((bfd *, flagword));
+static boolean c33_elf_copy_private_bfd_data
+  PARAMS ((bfd *, bfd *));
+static const char* c33_elf_get_mode_string
+  PARAMS ((char mode_flag));
+static boolean c33_elf_merge_private_bfd_data
+  PARAMS ((bfd *, bfd *));
+static boolean c33_elf_print_private_bfd_data
+  PARAMS ((bfd *, PTR));
+static boolean c33_elf_section_from_bfd_section
+  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *, int *));
+static void c33_elf_symbol_processing
+  PARAMS ((bfd *, asymbol *));
+static boolean c33_elf_add_symbol_hook
+  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
+	   const char **, flagword *, asection **, bfd_vma *));
+static boolean c33_elf_link_output_symbol_hook
+  PARAMS ((bfd *, struct bfd_link_info *, const char *,
+	   Elf_Internal_Sym *, asection *));
+static boolean c33_elf_section_from_shdr
+  PARAMS ((bfd *, Elf_Internal_Shdr *, char *));
+
+/* シンボルのリロケーション情報 */
+/* Note: It is REQUIRED that the 'type' value of each entry in this array
+   match the index of the entry in the array.  */
+static reloc_howto_type c33_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_C33_NONE,			/* type */
+	 0,				/* rightshift */
+	 2,				/* size (0 = byte, 1 = short, 2 = long) */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_bitfield,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_C33_NONE",			/* name */
+	 false,				/* partial_inplace */
+	 0,				/* src_mask */
+	 0,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Simple 32bit reloc.  */
+  HOWTO (R_C33_32,			/* type */
+	 0,				/* rightshift */
+	 2,				/* size (0 = byte, 1 = short, 2 = long) */
+	 32,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_C33_32",			/* name */
+	 false,				/* partial_inplace */
+	 0xffffffff,			/* src_mask */
+	 0xffffffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Simple 16bit reloc.  */
+  HOWTO (R_C33_16,			/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 16,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_C33_16",			/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* Simple 8bit reloc.	 */
+  HOWTO (R_C33_8,			/* type */
+	 0,				/* rightshift */
+	 0,				/* size (0 = byte, 1 = short, 2 = long) */
+	 8,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 bfd_elf_generic_reloc,		/* special_function */
+	 "R_C33_8",			/* name */
+	 false,				/* partial_inplace */
+	 0xff,				/* src_mask */
+	 0xff,				/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @ah LABEL(25:13) */
+  HOWTO (R_C33_AH,	/* type */
+	 0,			/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_AH",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @al LABEL(12:0) */
+  HOWTO (R_C33_AL,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_AL",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @rh <LABEL-PC>(31:22) */
+  HOWTO (R_C33_RH,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_RH",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @rm <LABEL-PC>(21:9) */
+  HOWTO (R_C33_RM,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_RM",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @rl <LABEL-PC>(8:0) */
+  HOWTO (R_C33_RL,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_RL",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @h LABEL(31:19) */
+  HOWTO (R_C33_H,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_H",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @m LABEL(18:6) */
+  HOWTO (R_C33_M,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_M",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @l LABEL(5:0) */
+  HOWTO (R_C33_L,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 6,					/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_L",			/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* doff_hi(LABEL(25:13)) */  /* add tazaki 2002.01.11 */
+  HOWTO (R_C33_DH,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_DH",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* doff_lo(LABEL(12:0)) */  /* add tazaki 2002.01.11 */
+  HOWTO (R_C33_DL,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_DL",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* goff_lo(LABEL(12:0)) */  /* add tazaki 2001.07.24 */
+  HOWTO (R_C33_GL,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_GL",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* soff_hi(LABEL(25:13)) */  /* add tazaki 2001.11.07 */
+  HOWTO (R_C33_SH,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_SH",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* soff_lo(LABEL(12:0)) */  /* add tazaki 2001.07.24 */
+  HOWTO (R_C33_SL,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_SL",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* toff_hi(LABEL(25:13)) */  /* add tazaki 2001.11.07 */
+  HOWTO (R_C33_TH,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_TH",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* toff_lo(LABEL(12:0)) */  /* add tazaki 2001.07.24 */
+  HOWTO (R_C33_TL,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_TL",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* toff_hi(LABEL(25:13)) */  /* add tazaki 2001.11.07 */
+  HOWTO (R_C33_ZH,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_ZH",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* zoff_lo(LABEL(12:0)) */  /* add tazaki 2001.07.24 */
+  HOWTO (R_C33_ZL,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_ZL",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* (symbol+imm - dp)@31:19 */
+  HOWTO (R_C33_DPH,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_DPH",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* (symbol+imm - dp)@18:6 */
+  HOWTO (R_C33_DPM,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33DP_DPM",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* (symbol+imm - dp)@5:0 */
+  HOWTO (R_C33_DPL,		/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 6,					/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_DPL",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* loop <LABEL-PC>(4:0) */
+  HOWTO (R_C33_LOOP,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 4,					/* bitsize */
+	 true,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_LOOP",		/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* l <LABEL-PC>(8:0) */
+  HOWTO (R_C33_JP,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_JP",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+/* add T.Tazaki 2002.05.02 sjp,scall,xjp,xcall symbol mask >>> */
+
+  /* @rh <LABEL-PC>(31:22) */
+  HOWTO (R_C33_S_RH,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_S_RH",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @rm <LABEL-PC>(21:9) */
+  HOWTO (R_C33_S_RM,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_S_RM",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /* @rl <LABEL-PC>(8:0) */
+  HOWTO (R_C33_S_RL,	/* type */
+	 0,				/* rightshift */
+	 1,				/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 true,				/* pc_relative */
+	 0,				/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_S_RL",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+/* add T.Tazaki 2002.05.02 sjp,scall,xjp,xcall symbol mask <<< */
+
+  /*  pushn %r0  */  /* add tazaki 2004/08/19 */
+  HOWTO (R_C33_PUSHN_R0,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_PUSHN_R0",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /*  pushn %r1  */  /* add tazaki 2004/08/19 */
+  HOWTO (R_C33_PUSHN_R1,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_PUSHN_R1",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false),			/* pcrel_offset */
+
+  /*  push %r1  */  /* add tazaki 2004/08/19 */
+  HOWTO (R_C33_PUSH_R1,	/* type */
+	 0,					/* rightshift */
+	 1,					/* size (0 = byte, 1 = short, 2 = long) */
+	 13,				/* bitsize */
+	 false,				/* pc_relative */
+	 0,					/* bitpos */
+	 complain_overflow_dont,	/* complain_on_overflow */
+	 c33_elf_reloc,		/* special_function */
+	 "R_C33_PUSH_R1",	/* name */
+	 false,				/* partial_inplace */
+	 0xffff,			/* src_mask */
+	 0xffff,			/* dst_mask */
+	 false)				/* pcrel_offset */
+
+};
+
+/* Map BFD reloc types to c33 ELF reloc types.  */
+
+struct c33_elf_reloc_map
+{
+  /* BFD_RELOC_C33_CALLT_16_16_OFFSET is 258, which will not fix in an
+     unsigned char.  */
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned char elf_reloc_val;
+};
+
+static const struct c33_elf_reloc_map c33_elf_reloc_map[] =
+{
+  { BFD_RELOC_NONE,		R_C33_NONE },
+  { BFD_RELOC_32,		R_C33_32 },
+  { BFD_RELOC_16,		R_C33_16 },
+  { BFD_RELOC_8,		R_C33_8 },
+  { BFD_RELOC_C33_AH,	R_C33_AH },
+  { BFD_RELOC_C33_AL,	R_C33_AL },
+  { BFD_RELOC_C33_RH,	R_C33_RH },
+  { BFD_RELOC_C33_RM,	R_C33_RM },
+  { BFD_RELOC_C33_RL,	R_C33_RL },
+  { BFD_RELOC_C33_S_RH,	R_C33_S_RH },	/* add tazaki 2002.05.02 */
+  { BFD_RELOC_C33_S_RM,	R_C33_S_RM },	/* add tazaki 2002.05.02 */
+  { BFD_RELOC_C33_S_RL,	R_C33_S_RL },	/* add tazaki 2002.05.02 */
+  { BFD_RELOC_C33_JP,	R_C33_JP },	/* add tazaki 2002.05.02 */
+  { BFD_RELOC_C33_H,	R_C33_H },
+  { BFD_RELOC_C33_M,	R_C33_M },
+  { BFD_RELOC_C33_L,	R_C33_L },
+  { BFD_RELOC_C33_DH,	R_C33_DH },	/* add tazaki 2002.01.11 */
+  { BFD_RELOC_C33_DL,	R_C33_DL }, /* add tazaki 2002.01.11 */
+  { BFD_RELOC_C33_GL,	R_C33_GL }, /* add tazaki 2001.07.13 */
+  { BFD_RELOC_C33_SH,	R_C33_SH }, /* add tazaki 2001.11.07 */
+  { BFD_RELOC_C33_SL,	R_C33_SL }, /* add tazaki 2001.07.13 */
+  { BFD_RELOC_C33_TH,	R_C33_TH }, /* add tazaki 2001.11.07 */
+  { BFD_RELOC_C33_TL,	R_C33_TL }, /* add tazaki 2001.07.13 */
+  { BFD_RELOC_C33_ZH,	R_C33_ZH }, /* add tazaki 2001.11.07 */
+  { BFD_RELOC_C33_ZL,	R_C33_ZL }, /* add tazaki 2001.07.13 */
+  { BFD_RELOC_C33_DPH,	R_C33_DPH },/* add tazaki 2001.11.08 */
+  { BFD_RELOC_C33_DPM,	R_C33_DPM },/* add tazaki 2001.11.08 */
+  { BFD_RELOC_C33_DPL,	R_C33_DPL }, /* add tazaki 2001.11.08 */
+  { BFD_RELOC_C33_LOOP,	R_C33_LOOP }, /* add tazaki 2002.03.05 */
+  { BFD_RELOC_C33_PUSHN_R0,	R_C33_PUSHN_R0 }, /* add tazaki 2004/08/19 */
+  { BFD_RELOC_C33_PUSHN_R1,	R_C33_PUSHN_R1 }, /* add tazaki 2004/08/19 */
+  { BFD_RELOC_C33_PUSH_R1,	R_C33_PUSH_R1 }   /* add tazaki 2004/08/19 */
+};
+
+
+/* Map a bfd relocation into the appropriate howto structure */
+static reloc_howto_type *
+c33_elf_reloc_type_lookup (abfd, code)
+     bfd *                     abfd ATTRIBUTE_UNUSED;
+     bfd_reloc_code_real_type  code;
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (c33_elf_reloc_map) / sizeof (struct c33_elf_reloc_map);
+       i++)
+    {
+      if (c33_elf_reloc_map[i].bfd_reloc_val == code)
+	{
+	  BFD_ASSERT (c33_elf_howto_table[c33_elf_reloc_map[i].elf_reloc_val].type == c33_elf_reloc_map[i].elf_reloc_val);
+	  
+	  return & c33_elf_howto_table[c33_elf_reloc_map[i].elf_reloc_val];
+	}
+    }
+
+  return NULL;
+}
+
+
+/* Set the howto pointer for an c33 ELF reloc.  */
+static void
+c33_elf_info_to_howto_rel (abfd, cache_ptr, dst)
+     bfd *                 abfd ATTRIBUTE_UNUSED;
+     arelent *             cache_ptr;
+     Elf32_Internal_Rel *  dst;
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_C33_max);
+  cache_ptr->howto = &c33_elf_howto_table[r_type];
+}
+
+/* Set the howto pointer for a C33 ELF reloc (type RELA). */
+static void
+c33_elf_info_to_howto_rela (abfd, cache_ptr, dst)
+     bfd *                 abfd ATTRIBUTE_UNUSED;
+     arelent *             cache_ptr;
+     Elf32_Internal_Rela   *dst;
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_C33_max);
+  cache_ptr->howto = &c33_elf_howto_table[r_type];
+}
+
+
+/* Look through the relocs for a section during the first phase, and
+   allocate space in the global offset table or procedure linkage
+   table.  */
+
+static boolean
+c33_elf_check_relocs (abfd, info, sec, relocs)
+     bfd *                      abfd;
+     struct bfd_link_info *     info;
+     asection *                 sec;
+     const Elf_Internal_Rela *  relocs;
+{
+  boolean ret = true;
+  bfd *dynobj;
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+  const Elf_Internal_Rela *rel_end;
+  asection *sreloc;
+  enum c33_reloc_type r_type;
+
+
+
+  if (info->relocateable)
+    return true;
+
+#ifdef DEBUG
+  fprintf (stderr, "c33_elf_check_relocs called for section %s in %s\n",
+	   bfd_get_section_name (abfd, sec),
+	   bfd_get_filename (abfd));
+#endif
+
+  dynobj = elf_hash_table (info)->dynobj;
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  sreloc = NULL;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+			h = NULL;
+      else
+			h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+
+      r_type = (enum c33_reloc_type) ELF32_R_TYPE (rel->r_info);
+      switch (r_type)
+		{
+			default:
+			case R_C33_NONE:
+			case R_C33_32:
+			case R_C33_16:
+			case R_C33_8:
+			case R_C33_AH:
+			case R_C33_AL:
+			case R_C33_RH:
+			case R_C33_RM:
+			case R_C33_RL:
+			case R_C33_S_RH:	/* add tazaki 2002.05.02 */
+			case R_C33_S_RM:	/* add tazaki 2002.05.02 */
+			case R_C33_S_RL:	/* add tazaki 2002.05.02 */
+			case R_C33_JP:	/* add tazaki 2002.04.22 */
+			case R_C33_H:
+			case R_C33_M:
+			case R_C33_L:
+			/* >>>>> add tazaki 2002.03.05 */
+			case R_C33_DH:
+			case R_C33_DL:
+			case R_C33_GL:
+			case R_C33_SH:
+			case R_C33_SL:
+			case R_C33_TH:
+			case R_C33_TL:
+			case R_C33_ZH:
+			case R_C33_ZL:
+			case R_C33_DPH:
+			case R_C33_DPM:
+			case R_C33_DPL:
+			case R_C33_LOOP:
+			/* <<<<< add tazaki 2002.03.05 */
+			case R_C33_PUSHN_R0:	/* add T.Tazaki 2004/08/19 */
+			case R_C33_PUSHN_R1:	/* add T.Tazaki 2004/08/19 */
+			case R_C33_PUSH_R1:		/* add T.Tazaki 2004/08/19 */
+			  break;
+
+		}
+    }
+
+  return ret;
+}
+
+/*
+ * In the old version, when an entry was checked out from the table,
+ * it was deleted.  This produced an error if the entry was needed
+ * more than once, as the second attempted retry failed.
+ *
+ * In the current version, the entry is not deleted, instead we set
+ * the field 'found' to true.  If a second lookup matches the same
+ * entry, then we know that the ah reloc has already been updated
+ * and does not need to be updated a second time.
+ *
+ * TODO - TOFIX: If it is possible that we need to restore 2 different
+ * addresses from the same table entry, where the first generates an
+ * overflow, whilst the second do not, then this code will fail.
+ */
+
+typedef struct ah_location
+{
+  bfd_vma       addend;
+  bfd_byte *    address;
+  unsigned long counter;
+  boolean       found;
+  struct ah_location * next;
+}
+ah_location;
+
+static ah_location *  previous_ah;
+static ah_location *  free_ah;
+static unsigned long     ah_counter;
+
+#if 0
+static void
+remember_ah_reloc (abfd, addend, address)
+     bfd *      abfd;
+     bfd_vma    addend;
+     bfd_byte * address;
+{
+  ah_location * entry = NULL;
+  
+  /* Find a free structure.  */
+  if (free_ah == NULL)
+    free_ah = (ah_location *) bfd_zalloc (abfd, sizeof (* free_ah));
+
+  entry      = free_ah;
+  free_ah = free_ah->next;
+  
+  entry->addend  = addend;
+  entry->address = address;
+  entry->counter = ah_counter ++;
+  entry->found   = false;
+  entry->next    = previous_ah;
+  previous_ah = entry;
+  
+  /* Cope with wrap around of our counter.  */
+  if (ah_counter == 0)
+    {
+      /* XXX - Assume that all counter entries differ only in their low 16 bits.  */
+      for (entry = previous_ah; entry != NULL; entry = entry->next)
+	entry->counter &= 0xffff;
+
+      ah_counter = 0x10000;
+    }
+  
+  return;
+}
+
+static bfd_byte *
+find_remembered_ah_reloc (addend,address)
+     bfd_vma   addend;
+     bfd_byte * address;
+{
+  ah_location * entry;
+  
+  if( previous_ah == NULL ){	/* add tazaki 2001.11.01 */
+      return NULL;
+  }
+
+  /* Search the table.  Record the most recent entry that matches.  */
+	entry = previous_ah;
+	
+	/* 直前にext @ahが存在するか */
+	if ((entry->addend == addend)  && (entry->address == address-2))
+	{
+		return entry->address;
+	}
+	else {
+		return NULL;
+	}
+}
+
+#endif
+
+/* >>>>>>>>>>  add tazaki 2002.03.04              */
+bfd_byte * g_doff_hi_address = NULL;
+bfd_byte * g_soff_hi_address = NULL;
+bfd_byte * g_toff_hi_address = NULL;
+bfd_byte * g_zoff_hi_address = NULL;
+bfd_byte * g_symbol_mask_ah_address = NULL;
+bfd_byte * g_symbol_mask_rh_address = NULL;
+bfd_byte * g_symbol_mask_rm_address = NULL;
+bfd_byte * g_dpoff_h_address = NULL;
+bfd_byte * g_dpoff_m_address = NULL;
+/* <<<<<<<<<<  add tazaki 2002.03.04              */
+
+
+/* 未解決のシンボルを確定する */
+/* FIXME:  The code here probably ought to be removed and the code in reloc.c
+   allowed to do its  stuff instead.  At least for most of the relocs, anwyay.  */
+static bfd_reloc_status_type
+c33_elf_perform_relocation (abfd, r_type, addend, address,gp)
+     bfd *      abfd;
+     int        r_type;
+     bfd_vma    addend;
+     bfd_byte * address;
+	unsigned long	gp;		/* DA,SDA,TDA,ZDA */
+
+{
+	unsigned long insn;
+	bfd_signed_vma saddend = (bfd_signed_vma) addend;
+  
+	switch (r_type)
+    {
+		case R_C33_32:
+      		bfd_put_32 (abfd, addend, address);
+      		return bfd_reloc_ok;
+
+		case R_C33_16:
+			addend += bfd_get_16 (abfd, address);
+			saddend = (bfd_signed_vma) addend;
+      		if (saddend > 0x7fff || saddend < -0x8000)
+				return bfd_reloc_overflow;
+      		insn = addend;
+      		break;
+
+		case R_C33_8:
+      		addend += (char) bfd_get_8 (abfd, address);
+
+      		saddend = (bfd_signed_vma) addend;
+      		if (saddend > 0x7f || saddend < -0x80)
+				return bfd_reloc_overflow;
+
+      		bfd_put_8 (abfd, addend, address);
+      		return bfd_reloc_ok;
+
+    	case R_C33_AH:	/* @ah (25:13) */
+			/* Remember where this relocation took place.  */
+		    g_symbol_mask_ah_address = address;
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+			/* over 26bit ? */
+			if ( addend > 0x3ffffff )
+				return bfd_reloc_outofrange;
+
+			/* add symbol25:13 to insn */
+			insn += ((addend >> 13) & 0x1fff);
+			break;
+
+    	case R_C33_AL:	/* @al (12:0) */
+			insn = bfd_get_16(abfd, address);
+
+			if (g_symbol_mask_ah_address != (address - 2)){
+				/* over 13bit ? */
+	      		if (addend > 0x1fff)
+						return bfd_reloc_outofrange;
+			}
+
+			insn += (addend & 0x1fff);
+			break;
+
+		case R_C33_RH:	 /* LABEL-PC(31:22) */
+		case R_C33_S_RH: /* LABEL-PC(31:22) */ /* add T.Tazaki 2002.05.02 */
+			/* Remember where this relocation took place.  */
+		    g_symbol_mask_rh_address = address;
+
+			insn = bfd_get_16(abfd, address);
+			insn += (((addend - 4) >> 19) & 0x1ff8);
+			break;
+		
+		case R_C33_RM:	/* LABEL-PC(21:9)  */
+		case R_C33_S_RM: /* LABEL-PC(31:22) */ /* add T.Tazaki 2002.05.02 */
+			/* Remember where this relocation took place.  */
+		    g_symbol_mask_rm_address = address;
+
+			insn = bfd_get_16(abfd, address);
+
+			/* if exist @rh before ext ? */
+			if (g_symbol_mask_rh_address != (address - 2)){
+				saddend = (bfd_signed_vma) addend;
+				/* over signed 22bit ? */
+		      	if ((saddend - 2) > 0x1ffffe || (saddend - 2 ) < -0x200000 ) /* tazaki 2002.04.24 */
+						return bfd_reloc_outofrange;
+			}
+			insn += (((addend - 2) >> 9) & 0x1fff);
+			break;
+
+		case R_C33_JP:	/* LABEL-PC(8:0)   */
+		case R_C33_RL:	/* LABEL-PC(8:0)   */
+		case R_C33_S_RL: /* LABEL-PC(31:22) */ /* add T.Tazaki 2002.05.02 */
+						/* sign8=sign32(8:1) sign32(0)=0 */
+			insn = bfd_get_16(abfd, address);
+
+			/* if exist @rm before ext ? */
+			if (g_symbol_mask_rm_address != (address - 2)){
+				
+				saddend = (bfd_signed_vma) addend;
+				/* over signed 8bit ? */
+	      		if (saddend > 254 || saddend < -256)
+						return bfd_reloc_outofrange;
+			}
+
+			insn += ((addend >> 1) & 0xff);
+			break;
+
+		case R_C33_H:	/* LABEL(31:19) */
+			insn = bfd_get_16(abfd, address);
+			insn += ((addend >> 19) & 0x1fff);
+			break;
+
+		case R_C33_M:	/* LABEL(18:6)  */
+			insn = bfd_get_16(abfd, address);
+			insn += ((addend >> 6) & 0x1fff);
+			break;
+
+		case R_C33_L:	/* LABEL(5:0)   */
+						/* ld.w %rd,LABEL@l */
+			insn = bfd_get_16(abfd, address);
+			insn += (addend & 0x3f) << 4;
+			break;
+
+	    case R_C33_DH:	/* doff_hi(LABEL) (25:13) */
+			/* default=0x0 & Warning display */
+
+			/* Remember where this relocation took place.  */
+		    g_doff_hi_address = address;
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_doff_globalpointer;
+
+			/* over 26bit ? */
+			if (addend > 0x3ffffff)
+				return bfd_reloc_doff_over_64mb;
+
+			/* add symbol25:13 to insn */
+			insn += ((addend >> 13) & 0x1fff);
+			break;
+			
+	    case R_C33_DL:	/* doff_lo(LABEL) (12:0) */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else{
+				return bfd_reloc_over_doff_globalpointer;
+			}
+
+			/* over 13bit ? */
+			if (addend > 0x1fff){
+				/* if exist doff_hi() before ext ? */
+				if (g_doff_hi_address != (address - 2)){
+					return bfd_reloc_doff_over_8kb;
+				}
+			}
+			
+			insn += (addend & 0x1fff);
+			break;
+
+			
+	    case R_C33_GL:	/* goff_lo(LABEL) (12:0) */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else{
+				return bfd_reloc_over_goff_globalpointer;
+			}
+
+			/* over 13bit ? */
+			if (addend > 0x1fff){
+				return bfd_reloc_goff_over_8kb;
+			}
+			
+			insn += (addend & 0x1fff);
+			break;
+
+	    case R_C33_SH:	/* soff_hi(LABEL) (25:13) */
+
+			/* Remember where this relocation took place.  */
+		    g_soff_hi_address = address;
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_soff_globalpointer;
+
+			/* over 26bit ? */
+			if (addend > 0x3ffffff)
+				return bfd_reloc_soff_over_64mb;
+
+			/* add symbol25:13 to insn */
+			insn += ((addend >> 13) & 0x1fff);
+			break;
+			
+	    case R_C33_SL:	/* soff_lo(LABEL) (12:0) */
+
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_soff_globalpointer;
+
+			if (addend > 0x1fff){
+				/* if exist soff_hi() before ext ? */
+				if (g_soff_hi_address != (address - 2)){
+					return bfd_reloc_soff_over_8kb;
+				}
+			}
+
+			insn += (addend & 0x1fff);
+			break;
+
+	    case R_C33_TH:	/* toff_hi(LABEL) (25:13) */
+
+			/* Remember where this relocation took place.  */
+		    g_toff_hi_address = address;
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_toff_globalpointer;
+
+			/* over 26bit ? */
+			if (addend > 0x3ffffff)
+				return bfd_reloc_toff_over_64mb;
+
+			/* add symbol25:13 to insn */
+			insn += ((addend >> 13) & 0x1fff);
+			break;
+			
+	    case R_C33_TL:	/* toff_lo(LABEL) (12:0) */
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_toff_globalpointer;
+
+			/* over 13bit ? */
+			if (addend > 0x1fff){
+				/* if exist toff_hi() before ext ? */
+				if (g_toff_hi_address != (address - 2)){
+					return bfd_reloc_toff_over_8kb;
+				}
+			}
+
+			insn += (addend & 0x1fff);
+			break;
+
+	    case R_C33_ZH:	/* zoff_hi(LABEL) (25:13) */
+
+			/* Remember where this relocation took place.  */
+		    g_zoff_hi_address = address;
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_zoff_globalpointer;
+
+			/* over 26bit ? */
+			if (addend > 0x3ffffff)
+				return bfd_reloc_zoff_over_64mb;
+
+			/* add symbol25:13 to insn */
+			insn += ((addend >> 13) & 0x1fff);
+			break;
+			
+	    case R_C33_ZL:	/* zoff_lo(LABEL) (12:0) */
+
+			insn = bfd_get_16(abfd, address);
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_zoff_globalpointer;
+
+			/* over 13bit ? */
+			if (addend > 0x1fff){
+				/* if exist zoff_hi() before ext ? */
+				if (g_zoff_hi_address != (address - 2)){
+					return bfd_reloc_zoff_over_8kb;
+				}
+			}
+
+			insn += (addend & 0x1fff);
+			break;
+
+		case R_C33_DPH:	/* (symbol+imm - %dp)@31:19 */
+
+			/* Remember where this relocation took place.  */
+		    g_dpoff_h_address = address;
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_doff_globalpointer;
+
+			/* Get Instruction code */
+			insn = bfd_get_16(abfd, address);
+			insn += ((addend >> 19) & 0x1fff);
+			break;
+
+		case R_C33_DPM:	/* (symbol+imm - %dp)@18:6 */
+			/* Remember where this relocation took place.  */
+		    g_dpoff_m_address = address;
+
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_doff_globalpointer;
+
+			/* over 19bit ? */
+			if (addend > 0x7ffff){
+				/* if exist dpoff_h() before ext ? */
+				if (g_dpoff_h_address != (address - 2)){
+					return bfd_reloc_dpoff_over_512kb;
+				}
+			}
+
+			insn = bfd_get_16(abfd, address);
+			insn += ((addend >> 6) & 0x1fff);
+			break;
+
+		case R_C33_DPL:	/* (symbol+imm - %dp)@5:0 */
+			if (addend >= gp)
+				addend -= gp;
+			else
+				return bfd_reloc_over_doff_globalpointer;
+
+			/* over 6bit ? */
+			if (addend > 0x3f){
+				/* if exist dpoff_m() before ext ? */
+				if (g_dpoff_m_address != (address - 2)){
+					return bfd_reloc_dpoff_over_64b;
+				}
+			}
+
+			insn = bfd_get_16(abfd, address);
+			insn += (addend & 0x3f) << 4;
+			break;
+
+		case R_C33_LOOP:	/* LABEL-PC(4:0)   */
+			/* imm5=imm4(4:1) */
+			insn = bfd_get_16(abfd, address);
+
+			saddend = (bfd_signed_vma)(addend - *address);
+			/* over imm4bit ? */
+      		if (saddend > 30 || saddend < 0)
+				return bfd_reloc_outofrange;
+
+			/* "   loop %rc,Label-2 " 表現は使用し辛いので、 "loop %rc,Label" を可能とするため-１する。 add T.Tazaki 2004/09/22 >>> */
+			/* "   nop              " */
+			/* "   nop              " */
+			/* "Label:              " */
+			
+//			insn += (((addend - *address) & 0x1e) << 3);
+			insn += ((((addend - *address)-1) & 0x1e) << 3);
+
+			/* add T.Tazaki 2004/09/22 <<< */
+			break;
+
+		/* add T.Tazaki 2004/08/19 >>> */
+	    case R_C33_PUSHN_R0:	/* xld,xbtst 展開後の最初の　"pushn %r0 */
+			insn = bfd_get_16(abfd, address);
+
+			insn = 0x0200;	/* pushn %r0 */
+			break;
+	    case R_C33_PUSHN_R1:	/* xld,xbtst 展開後の最初の　"pushn %r1 */
+			insn = bfd_get_16(abfd, address);
+
+			insn = 0x0201;	/* pushn %r1 */
+			break;
+	    case R_C33_PUSH_R1:		/* ADV or PE  xld,xbtst 展開後の最初の　"push %r1 */
+			insn = bfd_get_16(abfd, address);
+
+			insn = 0x0011;	/* push %r1 */
+			break;
+		/* add T.Tazaki 2004/08/19 <<< */
+
+
+    	default:
+      		/* fprintf (stderr, "reloc type %d not SUPPORTED\n", r_type ); */
+      		return bfd_reloc_notsupported;
+
+	}
+  	
+  	bfd_put_16 (abfd, insn, address);
+  	return bfd_reloc_ok;
+}
+
+
+
+/* Insert the addend into the instruction.  */
+static bfd_reloc_status_type
+c33_elf_reloc (abfd, reloc, symbol, data, isection, obfd, err)
+     bfd *       abfd ATTRIBUTE_UNUSED;
+     arelent *   reloc;
+     asymbol *   symbol;
+     PTR         data ATTRIBUTE_UNUSED;
+     asection *  isection;
+     bfd *       obfd;
+     char **     err ATTRIBUTE_UNUSED;
+{
+  long relocation;
+  
+  /* If there is an output BFD,
+     and the symbol is not a section name (which is only defined at final link time),
+     and either we are not putting the addend into the instruction
+         or the addend is zero, so there is nothing to add into the instruction
+     then just fixup the address and return.  */
+  if (obfd != (bfd *) NULL
+      && (symbol->flags & BSF_SECTION_SYM) == 0
+      && (! reloc->howto->partial_inplace
+	  || reloc->addend == 0))
+    {
+      reloc->address += isection->output_offset;
+      return bfd_reloc_ok;
+    }
+#if 0  
+  else if (obfd != NULL)
+    {
+      return bfd_reloc_continue;
+    }
+#endif
+  
+  /* Catch relocs involving undefined symbols.  */
+  if (bfd_is_und_section (symbol->section)
+      && (symbol->flags & BSF_WEAK) == 0
+      && obfd == NULL)
+    return bfd_reloc_undefined;
+
+  /* We handle final linking of some relocs ourselves.  */
+
+  /* Is the address of the relocation really within the section?  */
+  if (reloc->address > isection->_cooked_size)
+    return bfd_reloc_outofrange;
+  
+  /* Work out which section the relocation is targetted at and the
+     initial relocation command value.  */
+  
+  /* Get symbol value.  (Common symbols are special.)  */
+  if (bfd_is_com_section (symbol->section))
+    relocation = 0;
+  else
+    relocation = symbol->value;
+  
+  /* Convert input-section-relative symbol value to absolute + addend.  */
+  relocation += symbol->section->output_section->vma;
+  relocation += symbol->section->output_offset;
+  relocation += reloc->addend;
+  
+  if (reloc->howto->pc_relative == true)
+    {
+      /* Here the variable relocation holds the final address of the
+	 symbol we are relocating against, plus any addend.  */
+      relocation -= isection->output_section->vma + isection->output_offset;
+      
+      /* Deal with pcrel_offset */
+      relocation -= reloc->address;
+    }
+
+  reloc->addend = relocation;	
+  return bfd_reloc_ok;
+}
+
+
+/* Check local label name */
+/*ARGSUSED*/
+static boolean
+c33_elf_is_local_label_name (abfd, name)
+     bfd *         abfd ATTRIBUTE_UNUSED;
+     const char *  name;
+{
+  return ((name[0] == '_' && name[1] == '_' && name[2] == 'L'));
+}
+
+
+/* The symbol changed by relocation at the time of a link is solved. */
+
+int	i_dp_warn_flag = 0;		/* add tazaki 2002.01.11 */
+int	i_gdp_warn_flag = 0;	/* add tazaki 2002.01.11 */
+int	i_sdp_warn_flag = 0;	/* add tazaki 2002.01.11 */
+int	i_tdp_warn_flag = 0;	/* add tazaki 2002.01.11 */
+int	i_zdp_warn_flag = 0;	/* add tazaki 2002.01.11 */
+
+/* Perform a relocation as part of a final link.  */
+static bfd_reloc_status_type
+c33_elf_final_link_relocate (howto, input_bfd, output_bfd,
+				    input_section, contents, offset, value,
+				    addend, info, sym_sec, is_local)
+     reloc_howto_type *      howto;
+     bfd *                   input_bfd;
+     bfd *                   output_bfd ATTRIBUTE_UNUSED;
+     asection *              input_section;
+     bfd_byte *              contents;
+     bfd_vma                 offset;
+     bfd_vma                 value;
+     bfd_vma                 addend;
+     struct bfd_link_info *  info;
+     asection *              sym_sec;
+     int                     is_local ATTRIBUTE_UNUSED;
+{
+  unsigned long  r_type   = howto->type;
+  bfd_byte *     hit_data = contents + offset;
+		unsigned long                gp = 0;
+		struct bfd_link_hash_entry * h;
+
+  /* Adjust the value according to the relocation.  */
+  switch (r_type)
+    {
+    case R_C33_16:
+    case R_C33_32:
+    case R_C33_8:
+	case R_C33_H:
+	case R_C33_M:
+	case R_C33_L:
+    case R_C33_AH:
+    case R_C33_AL:
+		break;
+
+   	case R_C33_RH:
+	case R_C33_RM:
+	case R_C33_RL:
+   	case R_C33_S_RH:
+	case R_C33_S_RM:
+	case R_C33_S_RL:
+	case R_C33_JP:
+	case R_C33_LOOP:
+		/* set PC relative value */
+		value -= (input_section->output_section->vma
+		+ input_section->output_offset);
+		value -= offset;
+		break;
+
+	case R_C33_PUSHN_R0:		/* add T.Tazaki 2004/08/19 */
+	case R_C33_PUSHN_R1:		/* add T.Tazaki 2004/08/19 */
+	case R_C33_PUSH_R1:			/* add T.Tazaki 2004/08/19 */
+    case R_C33_NONE:
+      return bfd_reloc_ok;
+
+	/* add tazaki 2001.08.02 >>>>> */
+
+	case R_C33_DH:
+	case R_C33_DL:
+
+		/* Get the value of __dp.  */
+		h = bfd_link_hash_lookup (info->hash, "__dp", false, false, true);
+		if (h == (struct bfd_link_hash_entry *) NULL
+		    || h->type != bfd_link_hash_defined)
+		{
+			gp = 0;
+			if( i_dp_warn_flag == 0 ){
+				fprintf( stderr,"Warning: __dp symbol cannot be refered to.\n" );
+				i_dp_warn_flag = 1;
+			}
+		}
+		else {
+			gp = (h->u.def.value
+		      + h->u.def.section->output_section->vma
+		      + h->u.def.section->output_offset);
+		}
+
+      	break;
+
+	case R_C33_GL:
+
+		/* Get the value of __gdp.  */
+		h = bfd_link_hash_lookup (info->hash, "__gdp", false, false, true);
+		if (h == (struct bfd_link_hash_entry *) NULL
+		    || h->type != bfd_link_hash_defined)
+		{
+			gp = 0;
+			if( i_gdp_warn_flag == 0 ){
+				fprintf( stderr,"Warning: __gdp symbol cannot be refered to.\n" );
+				i_gdp_warn_flag = 1;
+			}
+		}
+		else {
+			gp = (h->u.def.value
+		      + h->u.def.section->output_section->vma
+		      + h->u.def.section->output_offset);
+		}
+
+      	break;
+
+	case R_C33_SH:
+	case R_C33_SL:
+		/* Get the value of __sdp.  */
+		h = bfd_link_hash_lookup (info->hash, "__sdp", false, false, true);
+		if (h == (struct bfd_link_hash_entry *) NULL
+		    || h->type != bfd_link_hash_defined)
+		{
+			gp = 0;
+			if( i_sdp_warn_flag == 0 ){
+				fprintf( stderr,"Warning: __sdp symbol cannot be refered to.\n" );
+				i_sdp_warn_flag = 1;
+			}
+		}else{
+			gp = (h->u.def.value
+			      + h->u.def.section->output_section->vma
+			      + h->u.def.section->output_offset);
+		}
+		break;
+
+	case R_C33_TH:
+	case R_C33_TL:
+		/* Get the value of __tdp.  */
+		h = bfd_link_hash_lookup (info->hash, "__tdp", false, false, true);
+		if (h == (struct bfd_link_hash_entry *) NULL
+		    || h->type != bfd_link_hash_defined)
+		{
+			gp = 0;
+			if( i_tdp_warn_flag == 0 ){
+				fprintf( stderr,"Warning: __tdp symbol cannot be refered to.\n" );
+				i_tdp_warn_flag = 1;
+			}
+		}else{
+			gp = (h->u.def.value
+			      + h->u.def.section->output_section->vma
+			      + h->u.def.section->output_offset);
+		}
+		break;
+
+	case R_C33_ZH:
+	case R_C33_ZL:
+		/* Get the value of __zdp.  */
+		h = bfd_link_hash_lookup (info->hash, "__zdp", false, false, true);
+		if (h == (struct bfd_link_hash_entry *) NULL
+		    || h->type != bfd_link_hash_defined)
+		{
+			gp = 0;
+			if( i_zdp_warn_flag == 0 ){
+				fprintf( stderr,"Warning: __zdp symbol cannot be refered to.\n" );
+				i_zdp_warn_flag = 1;
+			}
+		}else{
+			gp = (h->u.def.value
+			      + h->u.def.section->output_section->vma
+			      + h->u.def.section->output_offset);
+		}
+		break;
+
+	case R_C33_DPH:
+	case R_C33_DPM:
+	case R_C33_DPL:
+
+		/* Get the value of __dp.  */
+		h = bfd_link_hash_lookup (info->hash, "__dp", false, false, true);
+		if (h == (struct bfd_link_hash_entry *) NULL
+		    || h->type != bfd_link_hash_defined)
+		{
+			gp = 0;
+			if( i_dp_warn_flag == 0 ){
+				fprintf( stderr,"Warning: __dp symbol cannot be refered to.\n" );
+				i_dp_warn_flag = 1;
+			}
+		}
+		else {
+			gp = (h->u.def.value
+		      + h->u.def.section->output_section->vma
+		      + h->u.def.section->output_offset);
+		}
+
+      	break;
+
+	default:
+	    	return bfd_reloc_notsupported;
+	}
+
+
+	/* add tazaki 2001.08.02 <<<<< */
+
+  /* Perform the relocation.  */
+  return c33_elf_perform_relocation (input_bfd, r_type, value + addend, hit_data,gp); 
+}
+
+
+/* Relocate an C33 ELF section.  */
+static boolean
+c33_elf_relocate_section (output_bfd, info, input_bfd, input_section,
+			   contents, relocs, local_syms, local_sections)
+     bfd *                  output_bfd;
+     struct bfd_link_info * info;
+     bfd *                  input_bfd;
+     asection *             input_section;
+     bfd_byte *             contents;
+     Elf_Internal_Rela *    relocs;
+     Elf_Internal_Sym *     local_syms;
+     asection **            local_sections;
+{
+  Elf_Internal_Shdr *           symtab_hdr;
+  struct elf_link_hash_entry ** sym_hashes;
+  Elf_Internal_Rela *           rel;
+  Elf_Internal_Rela *           relend;
+
+  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+
+  if (sym_hashes == NULL)
+    {
+      info->callbacks->warning
+	(info, "no hash table available", NULL, input_bfd, input_section, 0);
+
+      return false;
+    }
+  
+  /* Reset the list of remembered HI16S relocs to empty.  */
+  free_ah     = previous_ah;
+  previous_ah = NULL;
+  ah_counter  = 0;
+
+  
+  rel    = relocs;
+  relend = relocs + input_section->reloc_count;
+  for (; rel < relend; rel++)
+    {
+      int                          r_type;
+      reloc_howto_type *           howto;
+      unsigned long                r_symndx;
+      Elf_Internal_Sym *           sym;
+      asection *                   sec;
+      struct elf_link_hash_entry * h;
+      bfd_vma                      relocation;
+      bfd_reloc_status_type        r;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      r_type   = ELF32_R_TYPE (rel->r_info);
+      howto = c33_elf_howto_table + r_type;
+
+      if (info->relocateable)
+	{
+	  /* This is a relocateable link.  We don't have to change
+             anything, unless the reloc is against a section symbol,
+             in which case we have to adjust according to where the
+             section symbol winds up in the output section.  */
+	  if (r_symndx < symtab_hdr->sh_info)
+	    {
+	      sym = local_syms + r_symndx;
+	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
+		{
+		  sec = local_sections[r_symndx];
+		  rel->r_addend += sec->output_offset + sym->st_value;
+		}
+	    }
+
+	  continue;
+	}
+
+      /* This is a final link.  */
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = (sec->output_section->vma
+			+ sec->output_offset
+			+ sym->st_value);
+#if 0
+	  {
+	    char * name;
+	    name = bfd_elf_string_from_elf_section (input_bfd, symtab_hdr->sh_link, sym->st_name);
+	    name = (name == NULL) ? "<none>" : name;
+fprintf (stderr, "local: sec: %s, sym: %s (%d), value: %x + %x + %x addend %x\n",
+	 sec->name, name, sym->st_name,
+	 sec->output_section->vma, sec->output_offset, sym->st_value, rel->r_addend);
+	  }
+#endif
+	}
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	  
+	  if (h->root.type == bfd_link_hash_defined
+	      || h->root.type == bfd_link_hash_defweak)
+	    {
+	      sec = h->root.u.def.section;
+	      relocation = (h->root.u.def.value
+			    + sec->output_section->vma
+			    + sec->output_offset);
+#if 0
+fprintf (stderr, "defined: sec: %s, name: %s, value: %x + %x + %x gives: %x\n",
+	 sec->name, h->root.root.string, h->root.u.def.value, sec->output_section->vma, sec->output_offset, relocation);
+#endif
+	    }
+	  else if (h->root.type == bfd_link_hash_undefweak)
+	    {
+#if 0
+fprintf (stderr, "undefined: sec: %s, name: %s\n",
+	 sec->name, h->root.root.string);
+#endif
+	      relocation = 0;
+	    }
+	  else
+	    {
+	      if (! ((*info->callbacks->undefined_symbol)
+		     (info, h->root.root.string, input_bfd,
+		      input_section, rel->r_offset, true)))
+		return false;
+#if 0
+fprintf (stderr, "unknown: name: %s\n", h->root.root.string);
+#endif
+	      relocation = 0;
+	    }
+	}
+
+      /* FIXME: We should use the addend, but the COFF relocations
+         don't.  */
+      r = c33_elf_final_link_relocate (howto, input_bfd, output_bfd,
+					input_section,
+					contents, rel->r_offset,
+					relocation, rel->r_addend,
+					info, sec, h == NULL);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char * name;
+	  const char * msg = (const char *)0;
+
+	  if (h != NULL)
+	    name = h->root.root.string;
+	  else
+	    {
+	      name = (bfd_elf_string_from_elf_section
+		      (input_bfd, symtab_hdr->sh_link, sym->st_name));
+	      if (name == NULL || *name == '\0')
+			name = bfd_section_name (input_bfd, sec);
+	    }
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      if (! ((*info->callbacks->reloc_overflow)
+		     (info, name, howto->name, (bfd_vma) 0,
+		      input_bfd, input_section, rel->r_offset)))
+		return false;
+	      break;
+
+	    case bfd_reloc_undefined:
+	      if (! ((*info->callbacks->undefined_symbol)
+		     (info, name, input_bfd, input_section,
+		      rel->r_offset, true)))
+		return false;
+	      break;
+
+	    case bfd_reloc_outofrange:
+//	      msg = _("internal error: out of range error");		/* Change T.Tazaki 2003/11/18 */
+	      msg = _("out of range error");						/* Change T.Tazaki 2003/11/18 */
+	      goto common_error;
+
+	    case bfd_reloc_notsupported:
+	      msg = _("internal error: unsupported relocation error");
+	      goto common_error;
+
+	    case bfd_reloc_dangerous:
+	      msg = _("internal error: dangerous relocation");
+	      goto common_error;
+
+	    case bfd_reloc_other:
+	      msg = _("could not locate special linker symbol __gp");
+	      goto common_error;
+
+	    case bfd_reloc_continue:
+	      msg = _("could not locate special linker symbol __ep");
+	      goto common_error;
+
+	    case (bfd_reloc_dangerous + 1):
+	      msg = _("could not locate special linker symbol __ctbp");
+	      goto common_error;
+
+/* add tazaki 2002.01.11 >>>>> */
+		case bfd_reloc_over_doff_globalpointer:
+	      msg = _("Default Data area pointer value is larger than symbol address value.");
+	      goto common_error;
+
+		case bfd_reloc_over_goff_globalpointer:
+	      msg = _("G Data area pointer value is larger than symbol address value.");
+	      goto common_error;
+
+		case bfd_reloc_over_soff_globalpointer:
+	      msg = _("S Data area pointer value is larger than symbol address value.");
+	      goto common_error;
+
+		case bfd_reloc_over_toff_globalpointer:
+	      msg = _("T Data area pointer value is larger than symbol address value.");
+	      goto common_error;
+
+		case bfd_reloc_over_zoff_globalpointer:
+	      msg = _("Z Data area pointer value is larger than symbol address value.");
+	      goto common_error;
+
+		case bfd_reloc_doff_over_64mb:
+	      msg = _("The offset value of a symbol is over 64MB.(default data area)");
+	      goto common_error;
+
+		case bfd_reloc_doff_over_8kb:
+	      msg = _("The offset value of a symbol is over 8KB.(default data area)");
+	      goto common_error;
+
+		case bfd_reloc_goff_over_8kb:
+	      msg = _("The offset value of a symbol is over 8KB.(G data area)");
+	      goto common_error;
+
+		case bfd_reloc_soff_over_64mb:
+	      msg = _("The offset value of a symbol is over 64MB.(S data area)");
+	      goto common_error;
+
+		case bfd_reloc_soff_over_8kb:
+	      msg = _("The offset value of a symbol is over 8KB.(S data area)");
+	      goto common_error;
+
+		case bfd_reloc_toff_over_64mb:
+	      msg = _("The offset value of a symbol is over 64MB.(T data area)");
+	      goto common_error;
+
+		case bfd_reloc_toff_over_8kb:
+	      msg = _("The offset value of a symbol is over 8KB.(T data area)");
+	      goto common_error;
+
+		case bfd_reloc_zoff_over_64mb:
+	      msg = _("The offset value of a symbol is over 64MB.(Z data area)");
+	      goto common_error;
+
+		case bfd_reloc_zoff_over_8kb:
+	      msg = _("The offset value of a symbol is over 8KB.(Z data area)");
+	      goto common_error;
+
+		case bfd_reloc_dpoff_over_512kb:
+	      msg = _("The offset value of a symbol is over 512KB.(default data area)");
+	      goto common_error;
+		
+		case bfd_reloc_dpoff_over_64b:
+	      msg = _("The offset value of a symbol is over 64byte.(default data area)");
+	      goto common_error;
+		
+/* add tazaki 2002.01.11 <<<<< */
+
+	    default:
+	      msg = _("internal error: unknown error");
+	      /* fall through */
+
+	    common_error:
+	      if (!((*info->callbacks->warning)
+		    (info, msg, name, input_bfd, input_section,
+		     rel->r_offset)))
+		return false;
+	      break;
+	    }
+	}
+    }
+
+  return true;
+}
+
+static boolean
+c33_elf_gc_sweep_hook (abfd, info, sec, relocs)
+     bfd *abfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info *info ATTRIBUTE_UNUSED;
+     asection *sec ATTRIBUTE_UNUSED;
+     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
+{
+  /* No got and plt entries for c33-elf */
+  return true;
+}
+
+static asection *
+c33_elf_gc_mark_hook (abfd, info, rel, h, sym)
+       bfd *abfd;
+       struct bfd_link_info *info ATTRIBUTE_UNUSED;
+       Elf_Internal_Rela *rel;
+       struct elf_link_hash_entry *h;
+       Elf_Internal_Sym *sym;
+{
+  if (h != NULL)
+    {
+      switch (ELF32_R_TYPE (rel->r_info))
+      {
+      default:
+        switch (h->root.type)
+          {
+          case bfd_link_hash_defined:
+          case bfd_link_hash_defweak:
+            return h->root.u.def.section;
+
+          case bfd_link_hash_common:
+            return h->root.u.c.p->section;
+
+	  default:
+	    break;
+          }
+       }
+     }
+   else
+     {
+       if (!(elf_bad_symtab (abfd)
+           && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
+         && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
+                && sym->st_shndx != SHN_COMMON))
+          {
+            return bfd_section_from_elf_index (abfd, sym->st_shndx);
+          }
+      }
+  return NULL;
+}
+
+/* Store the machine number in the flags field.  */
+/* Function to keep C33 specific file flags. */
+static boolean
+c33_elf_set_private_flags (abfd, flags)
+     bfd *    abfd;
+     flagword flags;
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+	      || elf_elfheader (abfd)->e_flags == flags);
+
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = true;
+
+  return true;
+}
+
+/* Copy backend specific data from one object module to another */
+static boolean
+c33_elf_copy_private_bfd_data (ibfd, obfd)
+     bfd * ibfd;
+     bfd * obfd;
+{
+  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return true;
+
+  BFD_ASSERT (!elf_flags_init (obfd)
+	      || (elf_elfheader (obfd)->e_flags
+		  == elf_elfheader (ibfd)->e_flags));
+
+  elf_gp (obfd) = elf_gp (ibfd);
+  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
+  elf_flags_init (obfd) = true;
+  return true;
+}
+
+
+/* >>>>> ADDED D.Fujimoto 2007/10/01 */
+static const char* c33_elf_get_mode_string(char mode_flag)
+{
+	switch (mode_flag) {
+		case 'A': return "ADV";
+		case 'P': return "PE";
+		default : return "STD";
+	}
+}
+/* <<<<< ADDED D.Fujimoto 2007/10/01 */
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+static boolean
+c33_elf_merge_private_bfd_data (ibfd, obfd)
+     bfd * ibfd;
+     bfd * obfd;
+{
+  flagword out_flags;
+  flagword in_flags;
+
+/* >>>>> ADDED D.Fujimoto 2007/10/01 link error for mixing core object files */
+	unsigned char mode_flag = 0;			// STD=0x0, PE='P', ADV='A'
+	static unsigned char initial_mode_flag;
+	static char initial_object_filename[512];
+	static boolean done_once = false;
+/* <<<<< ADDED D.Fujimoto 2007/10/01 link error for mixing core object files */
+
+  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
+      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return true;
+
+  in_flags = elf_elfheader (ibfd)->e_flags;
+  out_flags = elf_elfheader (obfd)->e_flags;
+
+/* >>>>> ADDED D.Fujimoto 2007/10/15 link error when input object files are not for C33 */
+	if (elf_elfheader(ibfd)->e_machine != 0) {	// 0 will not be checked because of compatibility
+		if (elf_elfheader(ibfd)->e_machine != EM_SE_C33) {
+			fprintf (stderr, "Error: Input object file %s ", bfd_get_filename(ibfd));
+			if (bfd_my_archive(ibfd) != NULL) {
+				fprintf(stderr, "included from %s ", bfd_my_archive(ibfd)->filename);
+			}
+			fprintf(stderr, "is not for C33.\n");
+
+			xexit(1);
+		}
+	}
+/* <<<<< ADDED D.Fujimoto 2007/10/15 link error when input object files are not for C33 */
+
+/* >>>>> ADDED D.Fujimoto 2007/10/01 link error for mixing core object files */
+	// get the flag from the object file
+	mode_flag = (unsigned char) (elf_elfheader(ibfd)->e_flags >> 24);
+
+	// get initial mode
+	if (!done_once) {
+		initial_mode_flag = mode_flag;
+		strncpy(initial_object_filename, bfd_get_filename(ibfd), 512);
+		done_once = true;
+	}
+
+	// check mode
+	if (mode_flag != initial_mode_flag) {
+
+		// show an error and exit without creating executable
+		fprintf(stderr, "Error: Cannot link %s object %s ", c33_elf_get_mode_string(mode_flag), bfd_get_filename(ibfd));
+		if (bfd_my_archive(ibfd) != NULL) {
+			fprintf(stderr, "included from %s ", bfd_my_archive(ibfd)->filename);
+		}
+		fprintf(stderr, "with %s object %s\n", c33_elf_get_mode_string(initial_mode_flag), initial_object_filename);
+		xexit(1);
+
+	}
+
+	// set ELF e_flags bit31-28 (e_machine is set in elf.c)
+	elf_elfheader(obfd)->e_flags = initial_mode_flag << 24;
+/* <<<<< ADDED D.Fujimoto 2007/10/01 link error for mixing core object files */
+
+  if (! elf_flags_init (obfd))
+    {
+      /* If the input is the default architecture then do not
+	 bother setting the flags for the output architecture,
+	 instead allow future merges to do this.  If no future
+	 merges ever set these flags then they will retain their
+	 unitialised values, which surprise surprise, correspond
+	 to the default values.  */
+      if (bfd_get_arch_info (ibfd)->the_default)
+	return true;
+      
+      elf_flags_init (obfd) = true;
+      elf_elfheader (obfd)->e_flags = in_flags;
+
+      if (bfd_get_arch (obfd) == bfd_get_arch (ibfd)
+	  && bfd_get_arch_info (obfd)->the_default)
+	{
+	  return bfd_set_arch_mach (obfd, bfd_get_arch (ibfd), bfd_get_mach (ibfd));
+	}
+
+      return true;
+    }
+
+  /* Check flag compatibility.  */
+  if (in_flags == out_flags)
+    return true;
+  return true;
+}
+/* Display the flags field */
+
+static boolean
+c33_elf_print_private_bfd_data (abfd, ptr)
+     bfd *   abfd;
+     PTR     ptr;
+{
+
+  
+  BFD_ASSERT (abfd != NULL && ptr != NULL);
+  
+  _bfd_elf_print_private_bfd_data (abfd, ptr);
+  return true;
+}
+
+/* C33 ELF uses four common sections.  One is the usual one, and the
+   others are for (small) objects in one of the special data areas:
+   small, tiny and zero.  All the objects are kept together, and then
+   referenced via the gp register, the ep register or the r0 register
+   respectively, which yields smaller, faster assembler code.  This
+   approach is copied from elf32-mips.c.  */
+/* del tazaki
+static asection  c33_elf_scomm_section;
+static asymbol   c33_elf_scomm_symbol;
+static asymbol * c33_elf_scomm_symbol_ptr;
+static asection  c33_elf_comm_section;
+static asymbol   c33_elf_comm_symbol;
+static asymbol * c33_elf_comm_symbol_ptr;
+static asection  c33_elf_lcomm_section;
+static asymbol   c33_elf_lcomm_symbol;
+static asymbol * c33_elf_lcomm_symbol_ptr;
+*/
+static asection  c33_elf_comm_section;
+static asymbol   c33_elf_comm_symbol;
+static asymbol * c33_elf_comm_symbol_ptr;
+static asection  c33_elf_gcomm_section;
+static asymbol   c33_elf_gcomm_symbol;
+static asymbol * c33_elf_gcomm_symbol_ptr;
+static asection  c33_elf_scomm_section;
+static asymbol   c33_elf_scomm_symbol;
+static asymbol * c33_elf_scomm_symbol_ptr;
+static asection  c33_elf_tcomm_section;
+static asymbol   c33_elf_tcomm_symbol;
+static asymbol * c33_elf_tcomm_symbol_ptr;
+static asection  c33_elf_zcomm_section;
+static asymbol   c33_elf_zcomm_symbol;
+static asymbol * c33_elf_zcomm_symbol_ptr;
+
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+static asection  c33_elf_gbss_section;
+static asymbol   c33_elf_gbss_symbol;
+static asymbol * c33_elf_gbss_symbol_ptr;
+static asection  c33_elf_sbss_section;
+static asymbol   c33_elf_sbss_symbol;
+static asymbol * c33_elf_sbss_symbol_ptr;
+static asection  c33_elf_tbss_section;
+static asymbol   c33_elf_tbss_symbol;
+static asymbol * c33_elf_tbss_symbol_ptr;
+static asection  c33_elf_zbss_section;
+static asymbol   c33_elf_zbss_symbol;
+static asymbol * c33_elf_zbss_symbol_ptr;
+#endif
+
+/* Given a BFD section, try to locate the corresponding ELF section
+   index.  */
+
+static boolean
+c33_elf_section_from_bfd_section (abfd, hdr, sec, retval)
+     bfd *                 abfd ATTRIBUTE_UNUSED;
+     Elf32_Internal_Shdr * hdr ATTRIBUTE_UNUSED;
+     asection *            sec;
+     int *                 retval;
+{
+  if (strcmp (bfd_get_section_name (abfd, sec), ".comm") == 0)
+    *retval = SHN_C33_COMM;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".gcomm") == 0)
+    *retval = SHN_C33_GCOMM;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".scomm") == 0)
+    *retval = SHN_C33_SCOMM;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".tcomm") == 0)
+    *retval = SHN_C33_TCOMM;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".zcomm") == 0)
+    *retval = SHN_C33_ZCOMM;
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".gbss") == 0)
+    *retval = SHN_C33_GBSS;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".sbss") == 0)
+    *retval = SHN_C33_SBSS;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".tbss") == 0)
+    *retval = SHN_C33_TBSS;
+  else if (strcmp (bfd_get_section_name (abfd, sec), ".zbss") == 0)
+    *retval = SHN_C33_ZBSS;
+#endif
+  else
+    return false;
+  
+  
+  return true;
+}
+
+/* Handle the special c33 section numbers that a symbol may use.  */
+
+static void
+c33_elf_symbol_processing (abfd, asym)
+     bfd *     abfd;
+     asymbol * asym;
+{
+  elf_symbol_type * elfsym = (elf_symbol_type *) asym;
+  unsigned short index;
+  
+  index = elfsym->internal_elf_sym.st_shndx;
+
+  /* If the section index is an "ordinary" index, then it may
+     refer to a c33 specific section created by the assembler.
+     Check the section's type and change the index it matches.
+     
+     FIXME: Should we alter the st_shndx field as well ?  */
+    /* Modify tazaki 2001.07.25 */
+  
+  if (index < elf_elfheader(abfd)[0].e_shnum)
+    switch (elf_elfsections(abfd)[index]->sh_type)
+      {
+      case SHT_C33_COMM:
+			index = SHN_C33_COMM;
+			break;
+      case SHT_C33_GCOMM:
+			index = SHN_C33_GCOMM;
+			break;
+      case SHT_C33_SCOMM:
+			index = SHN_C33_SCOMM;
+			break;
+      case SHT_C33_TCOMM:
+			index = SHN_C33_TCOMM;
+			break;
+      case SHT_C33_ZCOMM:
+			index = SHN_C33_ZCOMM;
+			break;
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+      case SHT_C33_GBSS:
+			index = SHN_C33_GBSS;
+			break;
+      case SHT_C33_SBSS:
+			index = SHN_C33_SBSS;
+			break;
+      case SHT_C33_TBSS:
+			index = SHN_C33_TBSS;
+			break;
+      case SHT_C33_ZBSS:
+			index = SHN_C33_ZBSS;
+			break;
+#endif
+      default:
+			break;
+      }
+  
+  switch (index)
+    {
+    case SHN_C33_COMM:
+      if (c33_elf_comm_section.name == NULL)
+	{
+	  /* Initialize the small common section.  */
+	  c33_elf_comm_section.name           = ".comm";
+	  c33_elf_comm_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_comm_section.output_section = & c33_elf_comm_section;
+	  c33_elf_comm_section.symbol         = & c33_elf_comm_symbol;
+	  c33_elf_comm_section.symbol_ptr_ptr = & c33_elf_comm_symbol_ptr;
+	  c33_elf_comm_symbol.name            = ".comm";
+	  c33_elf_comm_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_comm_symbol.section         = & c33_elf_comm_section;
+	  c33_elf_comm_symbol_ptr             = & c33_elf_comm_symbol;
+	}
+      asym->section = & c33_elf_comm_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_GCOMM:
+      if (c33_elf_gcomm_section.name == NULL)
+	{
+	  /* Initialize the G common section.  */
+	  c33_elf_gcomm_section.name           = ".gcomm";
+	  c33_elf_gcomm_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_gcomm_section.output_section = & c33_elf_gcomm_section;
+	  c33_elf_gcomm_section.symbol         = & c33_elf_gcomm_symbol;
+	  c33_elf_gcomm_section.symbol_ptr_ptr = & c33_elf_gcomm_symbol_ptr;
+	  c33_elf_gcomm_symbol.name            = ".gcomm";
+	  c33_elf_gcomm_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_gcomm_symbol.section         = & c33_elf_gcomm_section;
+	  c33_elf_gcomm_symbol_ptr             = & c33_elf_gcomm_symbol;
+	}
+      asym->section = & c33_elf_gcomm_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_SCOMM:
+      if (c33_elf_scomm_section.name == NULL)
+	{
+	  /* Initialize S common section.  */
+	  c33_elf_scomm_section.name           = ".scomm";
+	  c33_elf_scomm_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_scomm_section.output_section = & c33_elf_scomm_section;
+	  c33_elf_scomm_section.symbol         = & c33_elf_scomm_symbol;
+	  c33_elf_scomm_section.symbol_ptr_ptr = & c33_elf_scomm_symbol_ptr;
+	  c33_elf_scomm_symbol.name            = ".scomm";
+	  c33_elf_scomm_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_scomm_symbol.section         = & c33_elf_scomm_section;
+	  c33_elf_scomm_symbol_ptr             = & c33_elf_scomm_symbol;
+	}
+      asym->section = & c33_elf_scomm_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_TCOMM:
+      if (c33_elf_tcomm_section.name == NULL)
+	{
+	  /* Initialize the T common section.  */
+	  c33_elf_tcomm_section.name           = ".tcomm";
+	  c33_elf_tcomm_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_tcomm_section.output_section = & c33_elf_tcomm_section;
+	  c33_elf_tcomm_section.symbol         = & c33_elf_tcomm_symbol;
+	  c33_elf_tcomm_section.symbol_ptr_ptr = & c33_elf_tcomm_symbol_ptr;
+	  c33_elf_tcomm_symbol.name            = ".tcomm";
+	  c33_elf_tcomm_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_tcomm_symbol.section         = & c33_elf_tcomm_section;
+	  c33_elf_tcomm_symbol_ptr             = & c33_elf_tcomm_symbol;
+	}
+      asym->section = & c33_elf_tcomm_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_ZCOMM:
+      if (c33_elf_zcomm_section.name == NULL)
+	{
+	  /* Initialize the Z common section.  */
+	  c33_elf_zcomm_section.name           = ".zcomm";
+	  c33_elf_zcomm_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_zcomm_section.output_section = & c33_elf_zcomm_section;
+	  c33_elf_zcomm_section.symbol         = & c33_elf_zcomm_symbol;
+	  c33_elf_zcomm_section.symbol_ptr_ptr = & c33_elf_zcomm_symbol_ptr;
+	  c33_elf_zcomm_symbol.name            = ".zcomm";
+	  c33_elf_zcomm_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_zcomm_symbol.section         = & c33_elf_zcomm_section;
+	  c33_elf_zcomm_symbol_ptr             = & c33_elf_zcomm_symbol;
+	}
+      asym->section = & c33_elf_zcomm_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+    case SHN_C33_GBSS:
+      if (c33_elf_gbss_section.name == NULL)
+	{
+	  /* Initialize the Local G common section.  */
+	  c33_elf_gbss_section.name           = ".gbss";
+	  c33_elf_gbss_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_gbss_section.output_section = & c33_elf_gbss_section;
+	  c33_elf_gbss_section.symbol         = & c33_elf_gbss_symbol;
+	  c33_elf_gbss_section.symbol_ptr_ptr = & c33_elf_gbss_symbol_ptr;
+	  c33_elf_gbss_symbol.name            = ".gbss";
+	  c33_elf_gbss_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_gbss_symbol.section         = & c33_elf_gbss_section;
+	  c33_elf_gbss_symbol_ptr             = & c33_elf_gbss_symbol;
+	}
+      asym->section = & c33_elf_gbss_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_SBSS:
+      if (c33_elf_sbss_section.name == NULL)
+	{
+	  /* Initialize the Local S common section.  */
+	  c33_elf_sbss_section.name           = ".sbss";
+	  c33_elf_sbss_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_sbss_section.output_section = & c33_elf_sbss_section;
+	  c33_elf_sbss_section.symbol         = & c33_elf_sbss_symbol;
+	  c33_elf_sbss_section.symbol_ptr_ptr = & c33_elf_sbss_symbol_ptr;
+	  c33_elf_sbss_symbol.name            = ".sbss";
+	  c33_elf_sbss_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_sbss_symbol.section         = & c33_elf_sbss_section;
+	  c33_elf_sbss_symbol_ptr             = & c33_elf_sbss_symbol;
+	}
+      asym->section = & c33_elf_sbss_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_TBSS:
+      if (c33_elf_tbss_section.name == NULL)
+	{
+	  /* Initialize the Local T common section.  */
+	  c33_elf_tbss_section.name           = ".tbss";
+	  c33_elf_tbss_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_tbss_section.output_section = & c33_elf_tbss_section;
+	  c33_elf_tbss_section.symbol         = & c33_elf_tbss_symbol;
+	  c33_elf_tbss_section.symbol_ptr_ptr = & c33_elf_tbss_symbol_ptr;
+	  c33_elf_tbss_symbol.name            = ".tbss";
+	  c33_elf_tbss_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_tbss_symbol.section         = & c33_elf_tbss_section;
+	  c33_elf_tbss_symbol_ptr             = & c33_elf_tbss_symbol;
+	}
+      asym->section = & c33_elf_tbss_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+
+    case SHN_C33_ZBSS:
+      if (c33_elf_zbss_section.name == NULL)
+	{
+	  /* Initialize the Local Z common section.  */
+	  c33_elf_zbss_section.name           = ".zbss";
+	  c33_elf_zbss_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_zbss_section.output_section = & c33_elf_zbss_section;
+	  c33_elf_zbss_section.symbol         = & c33_elf_zbss_symbol;
+	  c33_elf_zbss_section.symbol_ptr_ptr = & c33_elf_zbss_symbol_ptr;
+	  c33_elf_zbss_symbol.name            = ".zbss";
+	  c33_elf_zbss_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_zbss_symbol.section         = & c33_elf_zbss_section;
+	  c33_elf_zbss_symbol_ptr             = & c33_elf_zbss_symbol;
+	}
+      asym->section = & c33_elf_zbss_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+#endif
+
+/* gp参照用に必要？ */
+/*
+    case SHN_C33_SCOMMON:
+      if (c33_elf_scomm_section.name == NULL)
+	{
+	  c33_elf_scomm_section.name           = ".scommon";
+	  c33_elf_scomm_section.flags          = SEC_IS_COMMON | SEC_ALLOC | SEC_DATA;
+	  c33_elf_scomm_section.output_section = & c33_elf_scomm_section;
+	  c33_elf_scomm_section.symbol         = & c33_elf_scomm_symbol;
+	  c33_elf_scomm_section.symbol_ptr_ptr = & c33_elf_scomm_symbol_ptr;
+	  c33_elf_scomm_symbol.name            = ".scommon";
+	  c33_elf_scomm_symbol.flags           = BSF_SECTION_SYM;
+	  c33_elf_scomm_symbol.section         = & c33_elf_scomm_section;
+	  c33_elf_scomm_symbol_ptr             = & c33_elf_scomm_symbol;
+	}
+      asym->section = & c33_elf_scomm_section;
+      asym->value = elfsym->internal_elf_sym.st_size;
+      break;
+*/
+    }
+}
+
+/* Hook called by the linker routine which adds symbols from an object
+   file.  We must handle the special c33 section numbers here.  */
+
+/*ARGSUSED*/
+/* Modify tazaki 2001.07.25 */
+static boolean
+c33_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
+     bfd *                    abfd;
+     struct bfd_link_info *   info ATTRIBUTE_UNUSED;
+     const Elf_Internal_Sym * sym;
+     const char **            namep ATTRIBUTE_UNUSED;
+     flagword *               flagsp ATTRIBUTE_UNUSED;
+     asection **              secp;
+     bfd_vma *                valp;
+{
+  int index = sym->st_shndx;
+  
+  /* If the section index is an "ordinary" index, then it may
+     refer to a c33 specific section created by the assembler.
+     Check the section's type and change the index it matches.
+     
+     FIXME: Should we alter the st_shndx field as well ?  */
+  
+  if (index < elf_elfheader(abfd)[0].e_shnum)
+    switch (elf_elfsections(abfd)[index]->sh_type)
+      {
+    /* del tazaki 2001.07.25
+      case SHT_C33_SCOMMON:
+			index = SHN_C33_SCOMMON;
+			break;
+	*/
+/* add tazaki 2001.11.19 >>>>> */
+      case SHT_C33_COMM:
+			index = SHN_C33_COMM;
+			break;
+      case SHT_C33_GCOMM:
+			index = SHN_C33_GCOMM;
+			break;
+      case SHT_C33_SCOMM:
+			index = SHN_C33_SCOMM;
+			break;
+      case SHT_C33_TCOMM:
+			index = SHN_C33_TCOMM;
+			break;
+      case SHT_C33_ZCOMM:
+			index = SHN_C33_ZCOMM;
+			break;
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+      case SHT_C33_GBSS:
+			index = SHN_C33_GBSS;
+			break;
+      case SHT_C33_SBSS:
+			index = SHN_C33_SBSS;
+			break;
+      case SHT_C33_TBSS:
+			index = SHN_C33_TBSS;
+			break;
+      case SHT_C33_ZBSS:
+			index = SHN_C33_ZBSS;
+			break;
+#endif
+/* add tazaki 2001.11.19 <<<<< */
+	
+      default:
+	break;
+      }
+  
+  switch (index)
+    {
+/* del tazaki 2001.07.25
+    case SHN_C33_SCOMMON:
+      *secp = bfd_make_section_old_way (abfd, ".scommon");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+*/    
+/* add tazaki 2001.11.19 >>>>> */
+    case SHN_C33_COMM:
+      *secp = bfd_make_section_old_way (abfd, ".comm");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+      
+    case SHN_C33_GCOMM:
+      *secp = bfd_make_section_old_way (abfd, ".gcomm");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_C33_SCOMM:
+      *secp = bfd_make_section_old_way (abfd, ".scomm");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_C33_TCOMM:
+      *secp = bfd_make_section_old_way (abfd, ".tcomm");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_C33_ZCOMM:
+      *secp = bfd_make_section_old_way (abfd, ".zcomm");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+    case SHN_C33_GBSS:
+      *secp = bfd_make_section_old_way (abfd, ".gbss");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_C33_SBSS:
+      *secp = bfd_make_section_old_way (abfd, ".sbss");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_C33_TBSS:
+      *secp = bfd_make_section_old_way (abfd, ".tbss");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+
+    case SHN_C33_ZBSS:
+      *secp = bfd_make_section_old_way (abfd, ".zbss");
+      (*secp)->flags |= SEC_IS_COMMON;
+      *valp = sym->st_size;
+      break;
+#endif
+
+/* add tazaki 2001.11.19 <<<<< */
+    }
+
+  return true;
+}
+
+/*ARGSIGNORED*/
+static boolean
+c33_elf_link_output_symbol_hook (abfd, info, name, sym, input_sec)
+     bfd *                  abfd ATTRIBUTE_UNUSED;
+     struct bfd_link_info * info ATTRIBUTE_UNUSED;
+     const char *           name ATTRIBUTE_UNUSED;
+     Elf_Internal_Sym *     sym;
+     asection *             input_sec;
+{
+  /* If we see a common symbol, which implies a relocatable link, then
+     if a symbol was in a special common section in an input file, mark
+     it as a special common in the output file.  */
+  
+  if (sym->st_shndx == SHN_COMMON)
+    {
+      if (strcmp (input_sec->name, ".comm") == 0)
+	sym->st_shndx = SHN_C33_COMM;
+      else if (strcmp (input_sec->name, ".gcomm") == 0)
+	sym->st_shndx = SHN_C33_GCOMM;
+      else if (strcmp (input_sec->name, ".scomm") == 0)
+	sym->st_shndx = SHN_C33_SCOMM;
+      else if (strcmp (input_sec->name, ".tcomm") == 0)
+	sym->st_shndx = SHN_C33_TCOMM;
+      else if (strcmp (input_sec->name, ".zcomm") == 0)
+	sym->st_shndx = SHN_C33_ZCOMM;
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+      else if (strcmp (input_sec->name, ".gbss") == 0)
+	sym->st_shndx = SHN_C33_GBSS;
+      else if (strcmp (input_sec->name, ".sbss") == 0)
+	sym->st_shndx = SHN_C33_SBSS;
+      else if (strcmp (input_sec->name, ".tbss") == 0)
+	sym->st_shndx = SHN_C33_TBSS;
+      else if (strcmp (input_sec->name, ".zbss") == 0)
+	sym->st_shndx = SHN_C33_ZBSS;
+#endif
+    }
+
+  return true;
+}
+
+/* Modify tazaki 2001.07.25 */
+static boolean
+c33_elf_section_from_shdr (abfd, hdr, name)
+     bfd *               abfd;
+     Elf_Internal_Shdr * hdr;
+     char *              name;
+{
+  /* There ought to be a place to keep ELF backend specific flags, but
+     at the moment there isn't one.  We just keep track of the
+     sections by their name, instead.  */
+
+  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
+    return false;
+
+  switch (hdr->sh_type)
+    {
+/*    case SHT_C33_SCOMMON:	*/
+    case SHT_C33_COMM:
+    case SHT_C33_GCOMM:
+    case SHT_C33_SCOMM:
+    case SHT_C33_TCOMM:
+    case SHT_C33_ZCOMM:
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+    case SHT_C33_GBSS:
+    case SHT_C33_SBSS:
+    case SHT_C33_TBSS:
+    case SHT_C33_ZBSS:
+#endif
+      if (! bfd_set_section_flags (abfd, hdr->bfd_section,
+				   (bfd_get_section_flags (abfd,
+							   hdr->bfd_section)
+				    | SEC_IS_COMMON)))
+	return false;
+    }
+
+  return true;
+}
+
+/* Set the correct type for a C33 ELF section.  We do this by the
+   section name, which is a hack, but ought to work.  */
+
+/* Modify tazaki 2001.11.19 >>>>> */
+
+static boolean
+c33_elf_fake_sections (abfd, hdr, sec)
+     bfd *                 abfd ATTRIBUTE_UNUSED;
+     Elf32_Internal_Shdr * hdr;
+     asection *            sec;
+{
+  register const char * name;
+
+  name = bfd_get_section_name (abfd, sec);
+
+  if (strcmp (name, ".comm") == 0)
+    {
+      hdr->sh_type = SHT_C33_COMM;
+    }
+  else if (strcmp (name, ".gcomm") == 0)
+    {
+      hdr->sh_type = SHT_C33_GCOMM;
+    }
+  else if (strcmp (name, ".scomm") == 0)
+    {
+      hdr->sh_type = SHT_C33_SCOMM;
+    }
+  else if (strcmp (name, ".tcomm") == 0)
+    {
+      hdr->sh_type = SHT_C33_TCOMM;
+    }
+  else if (strcmp (name, ".zcomm") == 0)
+    {
+      hdr->sh_type = SHT_C33_ZCOMM;
+    }
+/* del 2002/07/17 T.Tazaki >>> */
+#if 0
+  else if (strcmp (name, ".gbss") == 0)
+    {
+      hdr->sh_type = SHT_C33_GBSS;
+    }
+  else if (strcmp (name, ".sbss") == 0)
+    {
+      hdr->sh_type = SHT_C33_SBSS;
+    }
+  else if (strcmp (name, ".tbss") == 0)
+    {
+      hdr->sh_type = SHT_C33_TBSS;
+    }
+  else if (strcmp (name, ".zbss") == 0)
+    {
+      hdr->sh_type = SHT_C33_ZBSS;
+    }
+#endif 
+  
+  return true;
+}
+/* Modify tazaki 2001.11.19 <<<<< */
+
+
+
+#define TARGET_LITTLE_SYM			bfd_elf32_c33_vec
+#define TARGET_LITTLE_NAME			"elf32-c33"
+#define ELF_ARCH					bfd_arch_c33
+/* >>>>> MODIFIED D.Fujimoto 2007/10/15 machine code */
+#define ELF_MACHINE_CODE			EM_NONE		//	do not change to EM_SE_C33
+/* <<<<< MODIFIED D.Fujimoto 2007/10/15 machine code */
+#define ELF_MAXPAGESIZE				0x1000
+	
+#define elf_info_to_howto			c33_elf_info_to_howto_rela
+#define elf_info_to_howto_rel			c33_elf_info_to_howto_rel
+
+#define elf_backend_check_relocs		c33_elf_check_relocs
+#define elf_backend_relocate_section    	c33_elf_relocate_section
+
+#if 0
+#define elf_backend_object_p			c33_elf_object_p
+#define elf_backend_final_write_processing 	c33_elf_final_write_processing
+#endif
+
+#define elf_backend_section_from_bfd_section 	c33_elf_section_from_bfd_section
+#define elf_backend_symbol_processing		c33_elf_symbol_processing
+#define elf_backend_add_symbol_hook		c33_elf_add_symbol_hook
+#define elf_backend_link_output_symbol_hook 	c33_elf_link_output_symbol_hook
+#define elf_backend_section_from_shdr		c33_elf_section_from_shdr
+#define elf_backend_fake_sections		c33_elf_fake_sections
+#define elf_backend_gc_mark_hook                c33_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook               c33_elf_gc_sweep_hook
+
+#define elf_backend_can_gc_sections 1
+
+
+#define bfd_elf32_bfd_is_local_label_name	c33_elf_is_local_label_name
+#define bfd_elf32_bfd_reloc_type_lookup		c33_elf_reloc_type_lookup
+#define bfd_elf32_bfd_copy_private_bfd_data 	c33_elf_copy_private_bfd_data
+#define bfd_elf32_bfd_merge_private_bfd_data 	c33_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags		c33_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data	c33_elf_print_private_bfd_data
+
+/* change leading_char for map file  T.Tazaki 2003/12/09 >>> */
+//#define elf_symbol_leading_char			'_'
+#define elf_symbol_leading_char			'#'
+/* change T.Tazaki 2003/12/09 <<< */
+
+#include "elf32-target.h"
diff --git a/bfd/syms.c b/bfd/syms.c
index 6546f58..944c73b 100644
--- a/bfd/syms.c
+++ b/bfd/syms.c
@@ -1234,7 +1234,18 @@ _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset, pfound,
 	case N_BSLINE:
 	  /* A line number.  The value is relative to the start of the
              current function.  */
+	  /* >>>>> change  T.Tazaik 2002/01/29 */
+	  /*
 	  val = indexentry->val + bfd_get_32 (abfd, stab + VALOFF);
+	  */
+	  if ( strncmp( 
+	   ( indexentry->file_name ) + strlen( indexentry->file_name ) - 2  ,
+	  ".c", 2 ) == 0 ) {
+	      val = indexentry->val + bfd_get_32 (abfd, stab + VALOFF);
+	  } else {
+	      val = bfd_get_32 (abfd, stab + VALOFF);
+	  }
+	  /* <<<<< change T.Tazaik 2002/01/29 */
 	  if (val <= offset)
 	    {
 	      *pline = bfd_get_16 (abfd, stab + DESCOFF);
diff --git a/bfd/targets.c b/bfd/targets.c
index 1f2217b..711025e 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -539,6 +539,7 @@ extern const bfd_target bfd_elf32_sh_vec;
 extern const bfd_target bfd_elf32_shl_vec;
 extern const bfd_target bfd_elf32_sparc_vec;
 extern const bfd_target bfd_elf32_v850_vec;
+extern const bfd_target bfd_elf32_c33_vec;
 extern const bfd_target bfd_elf32_fr30_vec;
 extern const bfd_target bfd_elf32_mcore_big_vec;
 extern const bfd_target bfd_elf32_mcore_little_vec;
diff --git a/binutils/Makefile.am b/binutils/Makefile.am
index a6eb22a..34fd193 100644
--- a/binutils/Makefile.am
+++ b/binutils/Makefile.am
@@ -474,6 +474,7 @@ readelf.o: readelf.c ../bfd/bfd.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/dwarf2.h $(INCDIR)/elf/i386.h $(INCDIR)/elf/reloc-macros.h \
   $(INCDIR)/elf/v850.h $(INCDIR)/elf/ppc.h $(INCDIR)/elf/mips.h \
+  $(INCDIR)/elf/c33.h \
   $(INCDIR)/elf/alpha.h $(INCDIR)/elf/arm.h $(INCDIR)/elf/m68k.h \
   $(INCDIR)/elf/sparc.h $(INCDIR)/elf/m32r.h $(INCDIR)/elf/d10v.h \
   $(INCDIR)/elf/d30v.h $(INCDIR)/elf/sh.h $(INCDIR)/elf/mn10200.h \
diff --git a/binutils/Makefile.in b/binutils/Makefile.in
index f4178de..d947a9b 100644
--- a/binutils/Makefile.in
+++ b/binutils/Makefile.in
@@ -1299,6 +1299,7 @@ readelf.o: readelf.c ../bfd/bfd.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/external.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/dwarf2.h $(INCDIR)/elf/i386.h $(INCDIR)/elf/reloc-macros.h \
   $(INCDIR)/elf/v850.h $(INCDIR)/elf/ppc.h $(INCDIR)/elf/mips.h \
+  $(INCDIR)/elf/c33.h \
   $(INCDIR)/elf/alpha.h $(INCDIR)/elf/arm.h $(INCDIR)/elf/m68k.h \
   $(INCDIR)/elf/sparc.h $(INCDIR)/elf/m32r.h $(INCDIR)/elf/d10v.h \
   $(INCDIR)/elf/d30v.h $(INCDIR)/elf/sh.h $(INCDIR)/elf/mn10200.h \
diff --git a/binutils/objdump.c b/binutils/objdump.c
index 4832e9d..f972ec3 100644
--- a/binutils/objdump.c
+++ b/binutils/objdump.c
@@ -119,6 +119,9 @@ display_file PARAMS ((char *filename, char *target));
 static void
 dump_section_header PARAMS ((bfd *, asection *, PTR));
 
+static int 
+has_debug_sections(bfd *abfd);		/* add D.Fujimoto 2006.06.12 */
+
 static void
 dump_headers PARAMS ((bfd *));
 
@@ -343,8 +346,15 @@ dump_section_header (abfd, section, ignored)
   printf_vma (bfd_get_section_vma (abfd, section));
   printf ("  ");
   printf_vma (section->lma);
-  printf ("  %08lx  2**%u", section->filepos,
-	  bfd_get_section_alignment (abfd, section));
+  /* .comm ---> alignment 2**2 fixed 		add tazaki 2001.11.06 */
+/*  if ( strcmp( bfd_get_section_name (abfd, section),".comm" ) ){	*/
+	  printf ("  %08lx  2**%u", section->filepos,
+		  bfd_get_section_alignment (abfd, section));
+/*
+  }else{
+	  printf ("  %08lx  2**2", section->filepos );
+  }
+*/
   if (! wide_output)
     printf ("\n                ");
   printf ("  ");
@@ -405,9 +415,34 @@ dump_section_header (abfd, section, ignored)
     }
 
   printf ("\n");
+
 #undef PF
 }
 
+/* >>>>> check if debugging sections are present 		add D.Fujimoto 2006.06.12 */
+static int has_debug_sections(abfd)
+	bfd *abfd ATTRIBUTE_UNUSED;
+{
+	int ret = 0;
+	const char *section_name;
+    asection *p;
+
+	for (p = abfd->sections; p != NULL; p = p->next) {
+		section_name = p->name;
+
+		// search for section names starting with .stab or .comment
+		if (strncmp(section_name, ".stab", sizeof(".stab") - 1) == 0 || 
+			strncmp(section_name, ".comment", sizeof(".comment") - 1) == 0) {
+			ret = 1;
+			break;
+		}
+
+    }
+
+	return ret;
+}
+/* <<<<< check if debugging sections are present 		add D.Fujimoto 2006.06.12 */
+
 static void
 dump_headers (abfd)
      bfd *abfd;
@@ -425,6 +460,13 @@ dump_headers (abfd)
   printf ("\n");
 
   bfd_map_over_sections (abfd, dump_section_header, (PTR) NULL);
+
+  /* >>>>> display message concerning debugging sections 		add D.Fujimoto 2006.06.12 */
+  if (has_debug_sections(abfd)) {
+    printf ("\n*** Debugging sections will not be loaded to the target ***\n\n");
+  }
+  /* <<<<< display message concerning debugging sections 		add D.Fujimoto 2006.06.12 */
+
 }
 
 static asymbol **
@@ -1251,6 +1293,9 @@ disassemble_bytes (info, disassemble_fn, insns, data,
   bfd_vma addr_offset;
   int opb = info->octets_per_byte;
 
+  bfd_byte iData1,iData2;	/* add tazaki 2001.07.31 */
+  int iFlag;				/* add tazaki 2001.07.31 */
+  
   aux = (struct objdump_disasm_info *) info->application_data;
   section = aux->sec;
 
@@ -1334,7 +1379,8 @@ disassemble_bytes (info, disassemble_fn, insns, data,
 		*s = ' ';
 	      if (*s == '\0')
 		*--s = '0';
-	      printf ("%s:\t", buf + skip_addr_chars);
+/*	      printf ("%s:\t", buf + skip_addr_chars);	*/
+	      printf ("%s: ", buf + skip_addr_chars); /* tazaki 2001.11.02 */
 	    }
 	  else
 	    {
@@ -1411,24 +1457,39 @@ disassemble_bytes (info, disassemble_fn, insns, data,
 	      else
 		bpc = 1;
 
-	      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
+	    iFlag = 0;	/* add tazaki 2001.07.31 */
+
+	    for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
 		{
 		  int k;
+/* del tazaki 2001.07.31 >>>>>
 		  if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
-		    {
+		  {
 		      for (k = bpc - 1; k >= 0; k--)
-			printf ("%02x", (unsigned) data[j + k]);
+					printf ("%02x", (unsigned) data[j + k]);
 		      putchar (' ');
-		    }
-		  else
-		    {
+		  }
+		  else{
 		      for (k = 0; k < bpc; k++)
-			printf ("%02x", (unsigned) data[j + k]);
+					printf ("%02x", (unsigned) data[j + k]);
 		      putchar (' ');
-		    }
+		  }
+<<<< del */
+/* add tazaki 2001.07.31 >>>> */
+		  if( iFlag == 0 ){
+		  	iData2 = data[j + 0];
+			iFlag = 1;
+		  }else{
+		  	iData1 = data[j + 0];
+			iFlag = 0;
+		  }
+/* add <<<< */
 		}
+		
+		printf( "%02x%02x",iData1,iData2 );	/* add tazaki 2001.07.31 */
 
-	      for (; pb < octets_per_line; pb += bpc)
+/* del tazaki 2001.11.06 >>>>>>>>>>>>>
+	    for (; pb < octets_per_line; pb += bpc)
 		{
 		  int k;
 
@@ -1437,12 +1498,12 @@ disassemble_bytes (info, disassemble_fn, insns, data,
 		  putchar (' ');
 		}
 
-	      /* Separate raw data from instruction by extra space.  */
 	      if (insns)
-		putchar ('\t');
+				putchar ('\t');	
 	      else
-		printf ("    ");
-	    }
+				printf ("    "); 
+<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< */
+      }
 
 	  if (! insns)
 	    printf ("%s", buf);
@@ -1512,7 +1573,7 @@ disassemble_bytes (info, disassemble_fn, insns, data,
 	      q = **relppp;
 
 	      if (wide_output)
-		putchar ('\t');
+		putchar ('\t');		
 	      else
 		printf ("\t\t\t");
 
diff --git a/binutils/stabs.c b/binutils/stabs.c
index 5f60035..04031cc 100644
--- a/binutils/stabs.c
+++ b/binutils/stabs.c
@@ -556,6 +556,13 @@ parse_stab (dhandle, handle, type, desc, value, string)
       if (*string == '\0')
 	return true;
 
+	/* >>>>> add T.Tazaki 2002/01/29 */
+	if ( strncmp( string +strlen( string ) - 2 , ".c", 2 ) 
+	    != 0 ){
+	    info->function_start_offset = 0x0;
+	}
+	/* <<<<< add T.Tazaki 2002/01/29 */
+
       /* Just accumulate strings until we see a non N_SO symbol.  If
          the string starts with a directory separator or some other
 	 form of absolute path specification, we discard the previously
diff --git a/binutils/version.c b/binutils/version.c
index cb893cf..da274a8 100644
--- a/binutils/version.c
+++ b/binutils/version.c
@@ -21,6 +21,8 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 #include "bfd.h"
 #include "bucomm.h"
 
+#define BINUTILS_REVISION   "2.15 <2008/05/22>"
+
 /* This is the version numbers for the binutils.  They all change in
    lockstep -- it's easier that way. */
 
@@ -35,7 +37,12 @@ print_version (name)
 {
   /* This output is intended to follow the GNU standards document.  */
   /* xgettext:c-format */
+/* change T.Tazaki 2002.01.31 >>> */
+/*
   printf ("GNU %s %s\n", name, program_version);
+*/
+  printf ("GNU %s %s (rev %s)\n", name, program_version, BINUTILS_REVISION);
+/* change T.Tazaki 2002.01.31 <<< */
   printf (_("Copyright 1997, 98, 99, 2000 Free Software Foundation, Inc.\n"));
   printf (_("\
 This program is free software; you may redistribute it under the terms of\n\
diff --git a/config.sub b/config.sub
index 42fc991..884470f 100755
--- a/config.sub
+++ b/config.sub
@@ -218,7 +218,7 @@ case $basic_machine in
 		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
 		| mips64vr5000 | miprs64vr5000el | mcore \
 		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
-		| thumb | d10v | d30v | fr30 | avr)
+		| thumb | d10v | d30v | fr30 | c33 | avr )
 		basic_machine=$basic_machine-unknown
 		;;
 	m6811 | m68hc11 | m6812 | m68hc12)
@@ -261,7 +261,7 @@ case $basic_machine in
 	      | mipstx39-* | mipstx39el-* | mcore-* \
 	      | f301-* | armv*-* | s390-* | sv1-* | t3e-* \
 	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
-	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* | fr30-* \
+	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* | fr30-* | c33-* \
 	      | bs2000-* | tic54x-* | c54x-* | x86_64-*)
 		;;
 	# Recognize the various machine names and aliases which stand
diff --git a/configure.in b/configure.in
index 8171c53..2ce6d70 100644
--- a/configure.in
+++ b/configure.in
@@ -861,6 +861,9 @@ case "${target}" in
   v850-*-*)
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
+  c33-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   v850e-*-*)
     noconfigdirs="$noconfigdirs target-libgloss"
     ;;
diff --git a/gas/Makefile.am b/gas/Makefile.am
index 49b52f7..136f719 100644
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -67,6 +67,7 @@ CPU_TYPES = \
 	vax \
 	w65 \
 	v850 \
+	c33 \
 	z8k
 
 # Object format types.  This is only used for dependency information.
@@ -169,7 +170,8 @@ GAS_CFILES = \
 	stabs.c \
 	subsegs.c \
 	symbols.c \
-	write.c
+	write.c \
+	ext_remove.c
 
 CFILES = $(GAS_CFILES) gasp.c itbl-ops.c
 
@@ -199,7 +201,8 @@ HFILES = \
 	subsegs.h \
 	symbols.h \
 	tc.h \
-	write.h
+	write.h \
+	ext_remove.h
 
 # CPU files in config.
 
@@ -237,6 +240,7 @@ TARGET_CPU_CFILES = \
 	config/tc-vax.c \
 	config/tc-w65.c \
 	config/tc-v850.c \
+	config/tc-c33.c \
 	config/tc-z8k.c
 
 TARGET_CPU_HFILES = \
@@ -273,6 +277,7 @@ TARGET_CPU_HFILES = \
 	config/tc-vax.h \
 	config/tc-w65.h \
 	config/tc-v850.h \
+	config/tc-c33.h \
 	config/tc-z8k.h
 
 # OBJ files in config
@@ -378,7 +383,9 @@ GENERIC_OBJS = \
 	ecoff.o \
 	stabs.o \
 	sb.o \
-	macro.o
+	macro.o \
+	ext_remove.o
+
 
 OBJS = $(CONFIG_OBJS) $(GENERIC_OBJS)
 
@@ -1291,6 +1298,10 @@ DEPTC_v850_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
   $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-v850.h \
   emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/opcode/v850.h
+DEPTC_c33_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-c33.h \
+  emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/opcode/c33.h
 DEPTC_z8k_coff = $(srcdir)/../opcodes/z8k-opc.h $(INCDIR)/bin-bugs.h \
   $(srcdir)/config/obj-coff.h $(srcdir)/config/tc-z8k.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/z8k.h $(BFDDIR)/libcoff.h \
@@ -1632,6 +1643,10 @@ DEPOBJ_z8k_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
   $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-z8k.h \
   emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/aout/aout64.h
+DEPOBJ_c33_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-c33.h \
+  emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/aout/aout64.h
 DEPOBJ_hppa_som = $(srcdir)/config/obj-som.h subsegs.h \
   $(INCDIR)/obstack.h $(BFDDIR)/libhppa.h $(BFDDIR)/som.h \
   $(INCDIR)/aout/stab_gnu.h $(INCDIR)/aout/stab.def
@@ -1849,6 +1864,9 @@ DEP_v850_coff = $(srcdir)/config/obj-coff.h $(srcdir)/config/tc-v850.h \
 DEP_v850_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-v850.h
+DEP_c33_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(srcdir)/config/tc-c33.h
 DEP_z8k_coff = $(srcdir)/config/obj-coff.h $(srcdir)/config/tc-z8k.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/z8k.h $(BFDDIR)/libcoff.h \
   $(INCDIR)/bfdlink.h
diff --git a/gas/Makefile.in b/gas/Makefile.in
index 569b98e..4dd7c89 100644
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -171,6 +171,7 @@ CPU_TYPES = \
 	vax \
 	w65 \
 	v850 \
+	c33 \
 	z8k
 
 
@@ -277,7 +278,8 @@ GAS_CFILES = \
 	stabs.c \
 	subsegs.c \
 	symbols.c \
-	write.c
+	write.c \
+	ext_remove.c
 
 
 CFILES = $(GAS_CFILES) gasp.c itbl-ops.c
@@ -308,7 +310,8 @@ HFILES = \
 	subsegs.h \
 	symbols.h \
 	tc.h \
-	write.h
+	write.h \
+	ext_remove.h
 
 
 # CPU files in config.
@@ -347,6 +350,7 @@ TARGET_CPU_CFILES = \
 	config/tc-vax.c \
 	config/tc-w65.c \
 	config/tc-v850.c \
+	config/tc-c33.c \
 	config/tc-z8k.c
 
 
@@ -384,6 +388,7 @@ TARGET_CPU_HFILES = \
 	config/tc-vax.h \
 	config/tc-w65.h \
 	config/tc-v850.h \
+	config/tc-c33.h \
 	config/tc-z8k.h
 
 
@@ -466,7 +471,6 @@ CONFIG_OBJS = \
 	$(ATOF_TARG_O) \
 	$(extra_objects)
 
-
 GENERIC_OBJS = \
 	app.o \
 	as.o \
@@ -495,7 +499,8 @@ GENERIC_OBJS = \
 	ecoff.o \
 	stabs.o \
 	sb.o \
-	macro.o
+	macro.o \
+	ext_remove.o
 
 
 OBJS = $(CONFIG_OBJS) $(GENERIC_OBJS)
@@ -1034,6 +1039,11 @@ DEPTC_v850_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-v850.h \
   emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/opcode/v850.h
 
+DEPTC_c33_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-c33.h \
+  emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/opcode/c33.h
+
 DEPTC_z8k_coff = $(srcdir)/../opcodes/z8k-opc.h $(INCDIR)/bin-bugs.h \
   $(srcdir)/config/obj-coff.h $(srcdir)/config/tc-z8k.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/z8k.h $(BFDDIR)/libcoff.h \
@@ -1454,6 +1464,11 @@ DEPOBJ_v850_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-v850.h \
   emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/aout/aout64.h
 
+DEPOBJ_c33_elf = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-elf.h \
+  $(BFDDIR)/elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
+  $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(srcdir)/config/tc-c33.h \
+  emul.h subsegs.h $(INCDIR)/obstack.h $(INCDIR)/aout/aout64.h
+
 DEPOBJ_z8k_coff = $(INCDIR)/bin-bugs.h $(srcdir)/config/obj-coff.h \
   $(srcdir)/config/tc-z8k.h $(INCDIR)/coff/internal.h \
   $(INCDIR)/coff/z8k.h $(BFDDIR)/libcoff.h $(INCDIR)/bfdlink.h \
@@ -1764,6 +1779,10 @@ DEP_v850_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
   $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
   $(INCDIR)/bfdlink.h $(srcdir)/config/tc-v850.h
 
+DEP_c33_elf = $(srcdir)/config/obj-elf.h $(BFDDIR)/elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(srcdir)/config/tc-c33.h
+
 DEP_z8k_coff = $(srcdir)/config/obj-coff.h $(srcdir)/config/tc-z8k.h \
   $(INCDIR)/coff/internal.h $(INCDIR)/coff/z8k.h $(BFDDIR)/libcoff.h \
   $(INCDIR)/bfdlink.h
@@ -1795,11 +1814,12 @@ itbl_test_OBJECTS =  itbl-parse.o itbl-lex.o
 itbl_test_DEPENDENCIES =  itbl-tops.o itbl-test.o \
 ../libiberty/libiberty.a
 itbl_test_LDFLAGS = 
+
 as_new_OBJECTS =  app.o as.o atof-generic.o bignum-copy.o cond.o \
 depend.o dwarf2dbg.o ecoff.o ehopt.o expr.o flonum-copy.o \
 flonum-konst.o flonum-mult.o frags.o hash.o input-file.o input-scrub.o \
 listing.o literal.o macro.o messages.o output-file.o read.o sb.o \
-stabs.o subsegs.o symbols.o write.o
+stabs.o subsegs.o symbols.o write.o ext_remove.o
 as_new_LDFLAGS = 
 gasp_new_OBJECTS =  gasp.o macro.o sb.o hash.o
 gasp_new_LDFLAGS = 
@@ -2668,6 +2688,7 @@ e-mipsecoff.o: $(srcdir)/config/e-mipsecoff.c $(INCDIR)/bin-bugs.h \
   emul.h emul-target.h
 e-mipself.o: $(srcdir)/config/e-mipself.c $(INCDIR)/bin-bugs.h \
   emul.h emul-target.h
+ext_remove.o: ext_remove.c ext_remove.h
 $(OBJS): $(DEP_@target_cpu_type@_@obj_format@)
 $(TARG_CPU_O): $(DEPTC_@target_cpu_type@_@obj_format@)
 $(OBJ_FORMAT_O): $(DEPOBJ_@target_cpu_type@_@obj_format@)
diff --git a/gas/as.c b/gas/as.c
index f02c42a..6ddea62 100644
--- a/gas/as.c
+++ b/gas/as.c
@@ -1,5 +1,5 @@
 /* as.c - GAS main program.
-   Copyright (C) 1987, 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
+   Copyright (C) 1987, 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
    Free Software Foundation, Inc.
 
    This file is part of GAS, the GNU Assembler.
@@ -26,16 +26,22 @@
  * are shared.
  *
  *
- *			bugs
+ *          bugs
  *
  * : initialisers
- *	Since no-one else says they will support them in future: I
+ *  Since no-one else says they will support them in future: I
  * don't support them now.
  *
  */
 
 #include "ansidecl.h"
 
+#define C33_AS_REVISION "2.15 <2008/05/22>"
+
+/* >>>>> DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+//#define EM_SE_C33      107      /* S1C33 Family of Seiko Epson processor add T.Tazaki 2003/05/14*/
+/* <<<<< DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+
 #define COMMON
 
 #include "as.h"
@@ -43,6 +49,7 @@
 #include "output-file.h"
 #include "sb.h"
 #include "macro.h"
+#include "ext_remove.h"				// add D.Fujimoto 2007/02/28
 
 #ifdef HAVE_ITBL_CPU
 #include "itbl-ops.h"
@@ -63,9 +70,13 @@ static void dump_statistics PARAMS ((void));
 static void perform_an_assembly_pass PARAMS ((int argc, char **argv));
 static int macro_expr PARAMS ((const char *, int, sb *, int *));
 
-int listing;			/* true if a listing is wanted */
+int listing;            /* true if a listing is wanted */
 
-static char *listing_filename = NULL;	/* Name of listing file.  */
+/* add T.Tazaki 2002.04.26 >>> */
+int g_listing = 0;
+/* add T.Tazaki 2002.04.26 <<< */
+
+static char *listing_filename = NULL;   /* Name of listing file.  */
 
 /* Type of debugging to generate.  */
 
@@ -75,7 +86,7 @@ enum debug_info_type debug_type = DEBUG_NONE;
 
 int max_macro_nest = 100;
 
-char *myname;			/* argv[0] */
+char *myname;           /* argv[0] */
 #ifdef BFD_ASSEMBLER
 segT reg_section, expr_section;
 segT text_section, data_section, bss_section;
@@ -157,10 +168,10 @@ select_emulation_mode (argc, argv)
   if (em)
     {
       for (i = 0; i < n_emulations; i++)
-	if (!strcmp (emulations[i]->name, em))
-	  break;
+    if (!strcmp (emulations[i]->name, em))
+      break;
       if (i == n_emulations)
-	as_fatal (_("unrecognized emulation name `%s'"), em);
+    as_fatal (_("unrecognized emulation name `%s'"), em);
       this_emulation = emulations[i];
     }
   else
@@ -190,10 +201,10 @@ common_emul_init ()
   if (this_emulation->fake_label_name == 0)
     {
       if (this_emulation->leading_underscore)
-	this_emulation->fake_label_name = "L0\001";
+    this_emulation->fake_label_name = "L0\001";
       else
-	/* What other parameters should we test?  */
-	this_emulation->fake_label_name = ".L0\001";
+    /* What other parameters should we test?  */
+    this_emulation->fake_label_name = ".L0\001";
     }
 }
 #endif
@@ -207,8 +218,14 @@ print_version_id ()
   printed = 1;
 
 #ifdef BFD_ASSEMBLER
+/* change T.Tazaki 2002.01.31 >>> */
+/*
   fprintf (stderr, _("GNU assembler version %s (%s) using BFD version %s"),
-	   VERSION, TARGET_ALIAS, BFD_VERSION);
+       VERSION, TARGET_ALIAS, BFD_VERSION);
+*/
+  fprintf (stderr, _("GNU assembler version %s (%s) using BFD version %s(rev %s)"),
+       VERSION, TARGET_ALIAS, BFD_VERSION, C33_AS_REVISION);
+/* change T.Tazaki 2002.01.31 <<< */
 #else
   fprintf (stderr, _("GNU assembler version %s (%s)"), VERSION, TARGET_ALIAS);
 #endif
@@ -223,17 +240,17 @@ show_usage (stream)
 
   fprintf (stream, _("\
 Options:\n\
-  -a[sub-option...]	  turn on listings\n\
-                      	  Sub-options [default hls]:\n\
-                      	  c      omit false conditionals\n\
-                      	  d      omit debugging directives\n\
-                      	  h      include high-level source\n\
-                      	  l      include assembly\n\
-                      	  m      include macro expansions\n\
-                      	  n      omit forms processing\n\
-                      	  s      include symbols\n\
-                      	  L      include line debug statistics (if applicable)\n\
-                      	  =FILE  list to FILE (must be last sub-option)\n"));
+  -a[sub-option...]   turn on listings\n\
+                          Sub-options [default hls]:\n\
+                          c      omit false conditionals\n\
+                          d      omit debugging directives\n\
+                          h      include high-level source\n\
+                          l      include assembly\n\
+                          m      include macro expansions\n\
+                          n      omit forms processing\n\
+                          s      include symbols\n\
+                          L      include line debug statistics (if applicable)\n\
+                          =FILE  list to FILE (must be last sub-option)\n"));
 
   fprintf (stream, _("\
   -D                      produce assembler debugging messages\n"));
@@ -320,6 +337,26 @@ Options:\n\
   --listing-cont-lines    set the maximum number of continuation lines used\n\
                           for the output data column of the listing\n"));
 
+/* add 2002.01.25 >>>> */
+
+  fprintf (stream, _("\
+  -mc33adv                set advanced macro assemble mode\n"));
+
+/* add 2002.01.25 <<<< */
+
+/* add T.Tazaki 2003/11/18 >>>> */
+
+  fprintf (stream, _("\
+  -mc33pe                 set PE macro assemble mode\n"));
+
+/* add T.Tazaki 2003/11/18 <<<< */
+
+
+// ADD D.Fujimoto usage for -mc33_ext option 2007/02/28 >>>>>>>
+  fprintf (stream, _("\
+  -mc33_ext               optimize ext code\n"));
+// ADD D.Fujimoto usage for -mc33_ext option 2007/02/28 <<<<<<<
+
   md_show_usage (stream);
 
   fputc ('\n', stream);
@@ -337,6 +374,19 @@ Options:\n\
  * md_parse_option definitions in config/tc-*.c
  */
 
+/* >>>>>>> add tazaki 2001.11.02 */
+int g_iAdvance = 0;     /* 0=STANDARD Architecture Mode */
+                        /* 1=Advanced Architecture Mode */
+/* <<<<<<< add tazaki 2001.11.02 */
+
+/* add T.Tazaki 2003/11/18 >>> */
+int g_iPE = 0;			/* 1=PE Architecture Mode */
+/* add T.Tazaki 2003/11/18 <<< */
+/* add T.Tazaki 2004/07/30 >>> */
+int g_iMedda32 = 0;			/* 1= No use default data area Mode */
+/* add T.Tazaki 2004/07/30 <<< */
+
+
 static void
 parse_args (pargc, pargv)
      int *pargc;
@@ -345,6 +395,14 @@ parse_args (pargc, pargv)
   int old_argc, new_argc;
   char **old_argv, **new_argv;
 
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+  int flag_plural_src = 0;			// specified plural source files
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+// ADD D.Fujimoto 2008/01/07 >>>>>>>
+  int check_all_dump_flg = 0;		// flag whether to check the all objects' dump file 
+  int i_len;
+// ADD D.Fujimoto 2008/01/07 <<<<<<<
+
   /* Starting the short option string with '-' is for programs that
      expect options and other ARGV-elements in any order and that care about
      the ordering of the two.  We describe each non-option ARGV-element
@@ -422,7 +480,32 @@ parse_args (pargc, pargv)
 #define OPTION_WARN (OPTION_STD_BASE + 18)
     {"warn", no_argument, NULL, OPTION_WARN},
 #define OPTION_WARN_FATAL (OPTION_STD_BASE + 19)
-    {"fatal-warnings", no_argument, NULL, OPTION_WARN_FATAL}
+    {"fatal-warnings", no_argument, NULL, OPTION_WARN_FATAL},
+    
+/* add tazaki 2001.12.11 Avdanced Option >>>>>> */
+
+#define OPTION_ADVANCE (OPTION_STD_BASE + 20)
+    {"mc33adv", no_argument, NULL, OPTION_ADVANCE},
+    
+/* <<<<<<<< add tazaki 2001.12.11 */
+/* add T.Tazaki 2003/11/18 PE Option >>>>>> */
+
+#define OPTION_PE (OPTION_STD_BASE + 21)
+    {"mc33pe", no_argument, NULL, OPTION_PE},
+    
+/* <<<<<<<< add T.Tazaki 2003/11/18 */
+
+/* -medda32 add T.Tazaki 2004/07/30 >>> */
+#define OPTION_MEDDA32 (OPTION_STD_BASE + 22)
+    {"medda32", no_argument, NULL, OPTION_MEDDA32},
+/* -medda32 add T.Tazaki 2004/07/30 <<< */
+
+// ADD D.Fujimoto mc33_ext option 2007/03/01 >>>>>>>
+#define OPTION_C33_EXT (OPTION_STD_BASE + 23)
+    {"mc33_ext", required_argument, NULL, OPTION_C33_EXT}
+// ADD D.Fujimoto mc33_ext option 2007/03/01 <<<<<<<
+
+
   };
 
   /* Construct the option lists from the standard list and the
@@ -431,7 +514,7 @@ parse_args (pargc, pargv)
   longopts = (struct option *) xmalloc (sizeof (std_longopts) + md_longopts_size);
   memcpy (longopts, std_longopts, sizeof (std_longopts));
   memcpy ((char *) longopts + sizeof (std_longopts),
-	  md_longopts, md_longopts_size);
+      md_longopts, md_longopts_size);
 
   /* Make a local copy of the old argv.  */
   old_argc = *pargc;
@@ -446,300 +529,381 @@ parse_args (pargc, pargv)
   while (1)
     {
       /* getopt_long_only is like getopt_long, but '-' as well as '--' can
-	 indicate a long option.  */
+     indicate a long option.  */
       int longind;
       int optc = getopt_long_only (old_argc, old_argv, shortopts, longopts,
-				   &longind);
+                   &longind);
+
+// ADD D.Fujimoto 2008/01/07 >>>>>>>
+	  // check the all objects' dump file from command line
+	  if( check_all_dump_flg == 1 ){
+		  check_all_dump_flg = 0;
+
+		  // save the dump file name
+		 if( optarg == 0 ){
+			  fprintf (stderr, _("Error : Cannot find the all objects\' dump file.\n") );
+			  xexit (EXIT_FAILURE);
+		 } else {
+			  i_len = strlen( optarg );
+              if( 0 == memcmp( ".dump",&(optarg[i_len-5]),5 ) ){
+				  cp_All_Dump_File_Name = optarg;
+				  optc = getopt_long_only (old_argc, old_argv, shortopts, longopts,&longind);
+			  } else {
+				  fprintf (stderr, _("Error : Cannot find the all objects\' dump file.\n") );
+				  xexit (EXIT_FAILURE);
+			  }
+		  }
+	  }
+// ADD D.Fujimoto 2008/01/07 <<<<<<<
+
 
       if (optc == -1)
-	break;
+    break;
 
       switch (optc)
-	{
-	default:
-	  /* md_parse_option should return 1 if it recognizes optc,
-	     0 if not.  */
-	  if (md_parse_option (optc, optarg) != 0)
-	    break;
-	  /* `-v' isn't included in the general short_opts list, so check for
-	     it explicity here before deciding we've gotten a bad argument.  */
-	  if (optc == 'v')
-	    {
+    {
+    default:
+      /* md_parse_option should return 1 if it recognizes optc,
+         0 if not.  */
+      if (md_parse_option (optc, optarg) != 0)
+        break;
+      /* `-v' isn't included in the general short_opts list, so check for
+         it explicity here before deciding we've gotten a bad argument.  */
+      if (optc == 'v')
+        {
 #ifdef VMS
-	      /* Telling getopt to treat -v's value as optional can result
-		 in it picking up a following filename argument here.  The
-		 VMS code in md_parse_option can return 0 in that case,
-		 but it has no way of pushing the filename argument back.  */
-	      if (optarg && *optarg)
-		new_argv[new_argc++] = optarg,  new_argv[new_argc] = NULL;
-	      else
+          /* Telling getopt to treat -v's value as optional can result
+         in it picking up a following filename argument here.  The
+         VMS code in md_parse_option can return 0 in that case,
+         but it has no way of pushing the filename argument back.  */
+          if (optarg && *optarg)
+        new_argv[new_argc++] = optarg,  new_argv[new_argc] = NULL;
+          else
 #else
-	      case 'v':
+          case 'v':
 #endif
-	      case OPTION_VERBOSE:
-		print_version_id ();
-	      break;
-	    }
-	  /*FALLTHRU*/
-
-	case '?':
-	  exit (EXIT_FAILURE);
-
-	case 1:			/* File name.  */
-	  if (!strcmp (optarg, "-"))
-	    optarg = "";
-	  new_argv[new_argc++] = optarg;
-	  new_argv[new_argc] = NULL;
-	  break;
-
-	case OPTION_HELP:
-	  show_usage (stdout);
-	  exit (EXIT_SUCCESS);
-
-	case OPTION_NOCPP:
-	  break;
-
-	case OPTION_STATISTICS:
-	  flag_print_statistics = 1;
-	  break;
-
-	case OPTION_STRIP_LOCAL_ABSOLUTE:
-	  flag_strip_local_absolute = 1;
-	  break;
-
-	case OPTION_TRADITIONAL_FORMAT:
-	  flag_traditional_format = 1;
-	  break;
-
-	case OPTION_VERSION:
-	  /* This output is intended to follow the GNU standards document.  */
-	  printf (_("GNU assembler %s\n"), VERSION);
-	  printf (_("Copyright 2000 Free Software Foundation, Inc.\n"));
-	  printf (_("\
+          case OPTION_VERBOSE:
+        print_version_id ();
+          break;
+        }
+      /*FALLTHRU*/
+
+    case '?':
+      exit (EXIT_FAILURE);
+
+    case 1:         /* File name.  */
+      if (!strcmp (optarg, "-"))
+        optarg = "";
+      new_argv[new_argc++] = optarg;
+      new_argv[new_argc] = NULL;
+
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+		// save the source file name
+		if( cp_Current_File_Name == 0 ){
+			cp_Current_File_Name = xstrdup(optarg);
+		} else {
+			flag_plural_src = 1;
+		}
+#endif
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+      break;
+
+/* add tazaki 2001.11.02 Avdanced Option >>>>>> */
+    case OPTION_ADVANCE:
+        g_iAdvance = 1;
+        break;
+
+/* add tazaki 2001.11.02 Avdanced Option <<<<<< */
+
+/* add T.Tazaki 2003/11/18 PE Option >>>>>> */
+    case OPTION_PE:
+        g_iPE = 1;
+        break;
+
+/* add T.Tazaki 2003/11/18 PE Option <<<<<< */
+/* add T.Tazaki 2004/07/30 -medda32 Option >>> */
+    case OPTION_MEDDA32:
+        g_iMedda32 = 1;
+        break;
+
+/* add T.Tazaki 2004/07/30 -medda32 Option <<< */
+
+// ADD D.Fujimoto check mc33_ext argument file 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+	case OPTION_C33_EXT:
+		if( optarg != NULL ){
+			int i_len = strlen( optarg );
+			if( 0 != memcmp( ".dump",&(optarg[i_len-5]),5 ) ){
+				fprintf (stderr, _("Error : Cannot find the dump file.\n"));
+				xexit (EXIT_FAILURE);
+			} else {
+				cp_Dump_File_Name = xstrdup(optarg);
+// ADD D.Fujimoto 2008/01/07 >>>>>>>
+				check_all_dump_flg = 1;
+// ADD D.Fujimoto 2008/01/07 <<<<<<<
+			}
+		} else {
+			fprintf (stderr, _("Error : Cannot find the dump file.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		break;
+#endif
+// ADD D.Fujimoto check mc33_ext argument file 2007/06/25 <<<<<<<
+
+    case OPTION_HELP:
+      show_usage (stdout);
+      exit (EXIT_SUCCESS);
+
+    case OPTION_NOCPP:
+      break;
+
+    case OPTION_STATISTICS:
+      flag_print_statistics = 1;
+      break;
+
+    case OPTION_STRIP_LOCAL_ABSOLUTE:
+      flag_strip_local_absolute = 1;
+      break;
+
+    case OPTION_TRADITIONAL_FORMAT:
+      flag_traditional_format = 1;
+      break;
+
+    case OPTION_VERSION:
+      /* This output is intended to follow the GNU standards document.  */
+      printf (_("GNU assembler %s\n"), VERSION);
+      printf (_("Copyright 2000 Free Software Foundation, Inc.\n"));
+      printf (_("\
 This program is free software; you may redistribute it under the terms of\n\
 the GNU General Public License.  This program has absolutely no warranty.\n"));
-	  printf (_("This assembler was configured for a target of `%s'.\n"),
-		  TARGET_ALIAS);
-	  exit (EXIT_SUCCESS);
+      printf (_("This assembler was configured for a target of `%s'.\n"),
+          TARGET_ALIAS);
+      exit (EXIT_SUCCESS);
 
-	case OPTION_EMULATION:
+    case OPTION_EMULATION:
 #ifdef USE_EMULATIONS
-	  if (strcmp (optarg, this_emulation->name))
-	    as_fatal (_("multiple emulation names specified"));
+      if (strcmp (optarg, this_emulation->name))
+        as_fatal (_("multiple emulation names specified"));
 #else
-	  as_fatal (_("emulations not handled in this configuration"));
+      as_fatal (_("emulations not handled in this configuration"));
 #endif
-	  break;
+      break;
 
-	case OPTION_DUMPCONFIG:
-	  fprintf (stderr, _("alias = %s\n"), TARGET_ALIAS);
-	  fprintf (stderr, _("canonical = %s\n"), TARGET_CANONICAL);
-	  fprintf (stderr, _("cpu-type = %s\n"), TARGET_CPU);
+    case OPTION_DUMPCONFIG:
+      fprintf (stderr, _("alias = %s\n"), TARGET_ALIAS);
+      fprintf (stderr, _("canonical = %s\n"), TARGET_CANONICAL);
+      fprintf (stderr, _("cpu-type = %s\n"), TARGET_CPU);
 #ifdef TARGET_OBJ_FORMAT
-	  fprintf (stderr, _("format = %s\n"), TARGET_OBJ_FORMAT);
+      fprintf (stderr, _("format = %s\n"), TARGET_OBJ_FORMAT);
 #endif
 #ifdef TARGET_FORMAT
-	  fprintf (stderr, _("bfd-target = %s\n"), TARGET_FORMAT);
+      fprintf (stderr, _("bfd-target = %s\n"), TARGET_FORMAT);
 #endif
-	  exit (EXIT_SUCCESS);
-
-	case OPTION_DEFSYM:
-	  {
-	    char *s;
-	    long i;
-	    struct defsym_list *n;
-
-	    for (s = optarg; *s != '\0' && *s != '='; s++)
-	      ;
-	    if (*s == '\0')
-	      as_fatal (_("bad defsym; format is --defsym name=value"));
-	    *s++ = '\0';
-	    i = strtol (s, (char **) NULL, 0);
-	    n = (struct defsym_list *) xmalloc (sizeof *n);
-	    n->next = defsyms;
-	    n->name = optarg;
-	    n->value = i;
-	    defsyms = n;
-	  }
-	  break;
-
-	case OPTION_INSTTBL:
-	case 't':
-	  {
-	    /* optarg is the name of the file containing the instruction 
-	       formats, opcodes, register names, etc. */
-	    struct itbl_file_list *n;
-
-	    if (optarg == NULL)
-	      {
-		as_warn ( _("No file name following -t option\n") );
-		break;
-	      }
-	    
-	    n = (struct itbl_file_list *) xmalloc (sizeof *n);
-	    n->next = itbl_files;
-	    n->name = optarg;
-	    itbl_files = n;
-
-	    /* Parse the file and add the new instructions to our internal
-	       table.  If multiple instruction tables are specified, the 
-	       information from this table gets appended onto the existing 
-	       internal table. */
-	    itbl_files->name = xstrdup (optarg);
-	    if (itbl_parse (itbl_files->name) != 0)
-	      {
-		fprintf (stderr, _("Failed to read instruction table %s\n"), 
-			 itbl_files->name);
-		exit (EXIT_SUCCESS);
-	      }
-	  }
-	  break;
+      exit (EXIT_SUCCESS);
+
+    case OPTION_DEFSYM:
+      {
+        char *s;
+        long i;
+        struct defsym_list *n;
+
+        for (s = optarg; *s != '\0' && *s != '='; s++)
+          ;
+        if (*s == '\0')
+          as_fatal (_("bad defsym; format is --defsym name=value"));
+        *s++ = '\0';
+        i = strtol (s, (char **) NULL, 0);
+        n = (struct defsym_list *) xmalloc (sizeof *n);
+        n->next = defsyms;
+        n->name = optarg;
+        n->value = i;
+        defsyms = n;
+      }
+      break;
 
-	case OPTION_DEPFILE:
-	  start_dependencies (optarg);
-	  break;
+    case OPTION_INSTTBL:
+    case 't':
+      {
+        /* optarg is the name of the file containing the instruction 
+           formats, opcodes, register names, etc. */
+        struct itbl_file_list *n;
+
+        if (optarg == NULL)
+          {
+        as_warn ( _("No file name following -t option\n") );
+        break;
+          }
+        
+        n = (struct itbl_file_list *) xmalloc (sizeof *n);
+        n->next = itbl_files;
+        n->name = optarg;
+        itbl_files = n;
+
+        /* Parse the file and add the new instructions to our internal
+           table.  If multiple instruction tables are specified, the 
+           information from this table gets appended onto the existing 
+           internal table. */
+        itbl_files->name = xstrdup (optarg);
+        if (itbl_parse (itbl_files->name) != 0)
+          {
+        fprintf (stderr, _("Failed to read instruction table %s\n"), 
+             itbl_files->name);
+        exit (EXIT_SUCCESS);
+          }
+      }
+      break;
 
-	case OPTION_GSTABS:
-	  debug_type = DEBUG_STABS;
-	  break;
+    case OPTION_DEPFILE:
+      start_dependencies (optarg);
+      break;
+
+    case OPTION_GSTABS:
+      debug_type = DEBUG_STABS;
+      break;
  
-	case OPTION_GDWARF2:
-	  debug_type = DEBUG_DWARF2;
-	  break;
+    case OPTION_GDWARF2:
+      debug_type = DEBUG_DWARF2;
+      break;
 
-	case 'J':
-	  flag_signed_overflow_ok = 1;
-	  break;
+    case 'J':
+      flag_signed_overflow_ok = 1;
+      break;
 
 #ifndef WORKING_DOT_WORD
-	case 'K':
-	  flag_warn_displacement = 1;
-	  break;
+    case 'K':
+      flag_warn_displacement = 1;
+      break;
 #endif
 
-	case 'L':
-	  flag_keep_locals = 1;
-	  break;
-
-	case OPTION_LISTING_LHS_WIDTH:
-	  listing_lhs_width = atoi(optarg);
-	  if (listing_lhs_width_second < listing_lhs_width)
-	    listing_lhs_width_second = listing_lhs_width;
-	  break;
-	case OPTION_LISTING_LHS_WIDTH2:
-	  {
-	    int tmp = atoi(optarg);
-	    if (tmp > listing_lhs_width)
-	      listing_lhs_width_second = tmp;
-	  }
-	  break;
-	case OPTION_LISTING_RHS_WIDTH:
-	  listing_rhs_width = atoi(optarg);
-	  break;
-	case OPTION_LISTING_CONT_LINES:
-	  listing_lhs_cont_lines = atoi(optarg);
-	  break;
-
-	case 'M':
-	  flag_mri = 1;
+    case 'L':
+      flag_keep_locals = 1;
+      break;
+
+    case OPTION_LISTING_LHS_WIDTH:
+      listing_lhs_width = atoi(optarg);
+      if (listing_lhs_width_second < listing_lhs_width)
+        listing_lhs_width_second = listing_lhs_width;
+      break;
+    case OPTION_LISTING_LHS_WIDTH2:
+      {
+        int tmp = atoi(optarg);
+        if (tmp > listing_lhs_width)
+          listing_lhs_width_second = tmp;
+      }
+      break;
+    case OPTION_LISTING_RHS_WIDTH:
+      listing_rhs_width = atoi(optarg);
+      break;
+    case OPTION_LISTING_CONT_LINES:
+      listing_lhs_cont_lines = atoi(optarg);
+      break;
+
+    case 'M':
+      flag_mri = 1;
 #ifdef TC_M68K
-	  flag_m68k_mri = 1;
+      flag_m68k_mri = 1;
 #endif
-	  break;
-
-	case 'R':
-	  flag_readonly_data_in_text = 1;
-	  break;
-
-	case 'W':
-	  flag_no_warnings = 1;
-	  break;
-
-	case OPTION_WARN:
-	  flag_no_warnings = 0;
-	  flag_fatal_warnings = 0;
-	  break;
-
-	case OPTION_WARN_FATAL:
-	  flag_no_warnings = 0;
-	  flag_fatal_warnings = 1;
-	  break;
-
-	case 'Z':
-	  flag_always_generate_output = 1;
-	  break;
-
-	case 'a':
-	  if (optarg)
-	    {
-	      while (*optarg)
-		{
-		  switch (*optarg)
-		    {
-		    case 'c':
-		      listing |= LISTING_NOCOND;
-		      break;
-		    case 'd':
-		      listing |= LISTING_NODEBUG;
-		      break;
-		    case 'h':
-		      listing |= LISTING_HLL;
-		      break;
-		    case 'l':
-		      listing |= LISTING_LISTING;
-		      break;
-		    case 'm':
-		      listing |= LISTING_MACEXP;
-		      break;
-		    case 'n':
-		      listing |= LISTING_NOFORM;
-		      break;
-		    case 's':
-		      listing |= LISTING_SYMBOLS;
-		      break;
-		    case '=':
-		      listing_filename = xstrdup (optarg + 1);
-		      optarg += strlen (listing_filename);
-		      break;
-		    default:
-		      as_fatal (_("invalid listing option `%c'"), *optarg);
-		      break;
-		    }
-		  optarg++;
-		}
-	    }
-	  if (!listing)
-	    listing = LISTING_DEFAULT;
-	  break;
-
-	case 'D':
-	  /* DEBUG is implemented: it debugs different */
-	  /* things from other people's assemblers. */
-	  flag_debug = 1;
-	  break;
-
-	case 'f':
-	  flag_no_comments = 1;
-	  break;
-
-	case 'I':
-	  {			/* Include file directory */
-	    char *temp = xstrdup (optarg);
-	    add_include_dir (temp);
-	    break;
-	  }
+      break;
+
+    case 'R':
+      flag_readonly_data_in_text = 1;
+      break;
 
-	case 'o':
-	  out_file_name = xstrdup (optarg);
-	  break;
+    case 'W':
+      flag_no_warnings = 1;
+      break;
 
-	case 'w':
-	  break;
+    case OPTION_WARN:
+      flag_no_warnings = 0;
+      flag_fatal_warnings = 0;
+      break;
 
-	case 'X':
-	  /* -X means treat warnings as errors */
-	  break;
-	}
+    case OPTION_WARN_FATAL:
+      flag_no_warnings = 0;
+      flag_fatal_warnings = 1;
+      break;
+
+    case 'Z':
+      flag_always_generate_output = 1;
+      break;
+
+    case 'a':
+      if (optarg)
+        {
+          while (*optarg)
+        {
+          switch (*optarg)
+            {
+            case 'c':
+              listing |= LISTING_NOCOND;
+              break;
+            case 'd':
+              listing |= LISTING_NODEBUG;
+              break;
+            case 'h':
+              listing |= LISTING_HLL;
+              break;
+            case 'l':
+              listing |= LISTING_LISTING;
+              break;
+            case 'm':
+              listing |= LISTING_MACEXP;
+              break;
+            case 'n':
+              listing |= LISTING_NOFORM;
+              break;
+            case 's':
+              listing |= LISTING_SYMBOLS;
+              break;
+            case '=':
+              listing_filename = xstrdup (optarg + 1);
+              optarg += strlen (listing_filename);
+              break;
+            default:
+              as_fatal (_("invalid listing option `%c'"), *optarg);
+              break;
+            }
+          optarg++;
+        }
+        }
+      if (!listing)
+        listing = LISTING_DEFAULT;
+        
+        g_listing = 1;  /* -a option exist: @rm,@rl Warning */
+                    /* add T.Tazaki 2002.04.26 */
+      break;
+
+    case 'D':
+      /* DEBUG is implemented: it debugs different */
+      /* things from other people's assemblers. */
+      flag_debug = 1;
+      break;
+
+    case 'f':
+      flag_no_comments = 1;
+      break;
+
+    case 'I':
+      {         /* Include file directory */
+        char *temp = xstrdup (optarg);
+        add_include_dir (temp);
+        break;
+      }
+
+    case 'o':
+      out_file_name = xstrdup (optarg);
+      break;
+
+    case 'w':
+      break;
+
+    case 'X':
+      /* -X means treat warnings as errors */
+      break;
+    }
     }
 
   free (shortopts);
@@ -747,6 +911,48 @@ the GNU General Public License.  This program has absolutely no warranty.\n"));
 
   *pargc = new_argc;
   *pargv = new_argv;
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+	// process of -mc33ext option
+	if( flag_plural_src == 1 ){
+		fprintf (stderr, _("Error : Cannot specify plurality source files.\n"));
+		xexit (EXIT_FAILURE);
+	}
+
+	if( cp_Current_File_Name != NULL ){
+		if( strlen(cp_Current_File_Name) > 0 ){
+			chk_is_file_inf( cp_Current_File_Name );	// check whether ".file" exists
+		}
+	}
+
+	if( ( cp_Current_File_Name != NULL ) 
+						&& ( cp_Dump_File_Name != NULL ) && ( out_file_name != NULL ) ){
+		if( strlen(cp_Current_File_Name) > 0 ){
+			xatexit( free_ext_heap_area );		// register "free_ext_heap_area()" into "xexit()"
+			read_cur_file_info( cp_Current_File_Name );
+			read_dump_info( cp_Dump_File_Name,out_file_name );
+
+// ADD D.Fujimoto 2008/01/07 >>>>>>>
+			// read all object dump file
+			read_all_dump_info(cp_All_Dump_File_Name, out_file_name);
+
+			// count duplicate symbols using the all object dump file
+			countDuplicateSymbols(stpp_All_Dump_Inf, ul_All_Dump_Symbol_Cnt);
+// ADD D.Fujimoto 2008/01/07 <<<<<<<
+
+			// get data pointer address
+			if (!g_iMedda32) {
+				g_dpAddress = getDataPointerAddress(DATA_POINTER_SYMBOL);
+			}
+
+			g_c33_ext = 1;
+		}
+	}
+#endif
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+
 }
 
 static long start_time;
@@ -759,6 +965,10 @@ main (argc, argv)
   int macro_alternate;
   int macro_strip_at;
   int keep_it;
+  
+  /* add T.Tazaki 2003/05/14 >>> */
+  FILE *fpOut;
+  /* add T.Tazaki 2003/05/14 <<< */
 
   start_time = get_run_time ();
 
@@ -850,7 +1060,7 @@ main (argc, argv)
       struct defsym_list *next;
 
       sym = symbol_new (defsyms->name, absolute_section, defsyms->value,
-			&zero_address_frag);
+            &zero_address_frag);
       symbol_table_insert (sym);
       next = defsyms->next;
       free (defsyms);
@@ -859,7 +1069,7 @@ main (argc, argv)
 
   PROGRESS (1);
 
-  perform_an_assembly_pass (argc, argv);	/* Assemble it. */
+  perform_an_assembly_pass (argc, argv);    /* Assemble it. */
 
   cond_finish_check (-1);
 
@@ -893,6 +1103,35 @@ main (argc, argv)
   if (keep_it)
 #endif
     output_file_close (out_file_name);
+
+/* add T.Tazaki 2003/05/14 >>> */
+    fpOut = fopen( out_file_name,"r+b" );
+    if( fpOut != NULL )
+    {
+        /* e_machine number set */
+//      fseek( fpOut, 18, SEEK_SET );
+//      fputc( EM_SE_C33, fpOut );
+
+        /* ELF header : e_flags bit31-28=CPU flag set */
+        /*  flag = 0x0  : Standard macro */
+        /*  flag = 'A'  : Advanced macro */
+        /*  flag = 'P'  : PE macro */
+
+        /* Advanced macro mode ? */
+        if( g_iAdvance == 1 )
+        {
+           fseek( fpOut, 39, SEEK_SET );
+           fputc( 'A', fpOut );
+        }
+        else if ( g_iPE == 1 )			/* add T.Tazaki 2003/11/18 */
+        {
+           fseek( fpOut, 39, SEEK_SET );
+           fputc( 'P', fpOut );
+        }
+        fclose( fpOut );
+    }
+/* add T.Tazaki 2003/05/14 <<< */
+
 #endif
 
   if (flag_fatal_warnings && had_warnings() > 0 && had_errors () == 0)
@@ -928,10 +1167,10 @@ dump_statistics ()
   long run_time = get_run_time () - start_time;
 
   fprintf (stderr, _("%s: total time in assembly: %ld.%06ld\n"),
-	   myname, run_time / 1000000, run_time % 1000000);
+       myname, run_time / 1000000, run_time % 1000000);
 #ifdef HAVE_SBRK
   fprintf (stderr, _("%s: data size %ld\n"),
-	   myname, (long) (lim - (char *) &environ));
+       myname, (long) (lim - (char *) &environ));
 #endif
 
   subsegs_print_statistics (stderr);
@@ -948,7 +1187,7 @@ dump_statistics ()
 }
 
 
-/*			perform_an_assembly_pass()
+/*          perform_an_assembly_pass()
  *
  * Here to attempt 1 pass over each input file.
  * We scan argv[*] looking for filenames or exactly "" which is
@@ -1012,11 +1251,11 @@ perform_an_assembly_pass (argc, argv)
      to have relocs, otherwise we don't find out in time. */
   applicable = bfd_applicable_section_flags (stdoutput);
   bfd_set_section_flags (stdoutput, text_section,
-			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
-				       | SEC_CODE | SEC_READONLY));
+             applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
+                       | SEC_CODE | SEC_READONLY));
   bfd_set_section_flags (stdoutput, data_section,
-			 applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
-				       | SEC_DATA));
+             applicable & (SEC_ALLOC | SEC_LOAD | SEC_RELOC
+                       | SEC_DATA));
   bfd_set_section_flags (stdoutput, bss_section, applicable & SEC_ALLOC);
   seg_info (bss_section)->bss = 1;
   subseg_new (BFD_ABS_SECTION_NAME, 0);
@@ -1036,22 +1275,22 @@ perform_an_assembly_pass (argc, argv)
   obj_begin ();
 #endif
 
-  argv++;			/* skip argv[0] */
-  argc--;			/* skip argv[0] */
+  argv++;           /* skip argv[0] */
+  argc--;           /* skip argv[0] */
   while (argc--)
     {
       if (*argv)
-	{			/* Is it a file-name argument? */
-	  PROGRESS (1);
-	  saw_a_file++;
-	  /* argv->"" if stdin desired, else->filename */
-	  read_a_source_file (*argv);
-	}
-      argv++;			/* completed that argv */
+    {           /* Is it a file-name argument? */
+      PROGRESS (1);
+      saw_a_file++;
+      /* argv->"" if stdin desired, else->filename */
+      read_a_source_file (*argv);
+    }
+      argv++;           /* completed that argv */
     }
   if (!saw_a_file)
     read_a_source_file ("");
-}				/* perform_an_assembly_pass() */
+}               /* perform_an_assembly_pass() */
 
 /* The interface between the macro code and gas expression handling.  */
 
diff --git a/gas/config/gas/config/tc-c33.c b/gas/config/gas/config/tc-c33.c
new file mode 100644
index 0000000..f247b49
--- /dev/null
+++ b/gas/config/gas/config/tc-c33.c
@@ -0,0 +1,4382 @@
+/* tc-c33.c -- Assembler code for the EPSON EOC33
+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <stdio.h>
+#include <ctype.h>
+#include "as.h"
+#include "subsegs.h"     
+#include "opcode/c33.h"
+
+#define AREA_CDA 0
+#define AREA_GDA 1
+#define AREA_ZDA 2
+#define AREA_SDA 3
+#define AREA_TDA 4
+#define AREA_LCDA 5
+#define AREA_LGDA 6
+#define AREA_LZDA 7
+#define AREA_LSDA 8
+#define AREA_LTDA 9
+
+
+#define O_spregister    O_md1   /* for c33 %sp */
+#define O_dpregister    O_md2   /* for c33 %dp */
+#define O_cond          O_md3   /* for c33 ext cond */
+#define O_op_shift      O_md4   /* for c33 ext OP */
+
+#define SGP_REG     12      /* GP register */
+#define TGP_REG     13      /* GP register */
+#define ZGP_REG     14      /* GP register */
+#define GP_REG      15      /* GP register */
+
+/* Temporarily holds the reloc in a cons expression.  */
+static bfd_reloc_code_real_type hold_cons_reloc;
+
+
+
+/* Structure to hold information about predefined registers.  */
+struct reg_name
+{
+  const char * name;
+  int          value;
+};
+
+/* Generic assembler global variables which must be defined by all targets. */
+
+/* Characters which always start a comment. */
+const char comment_chars[] = ";";
+
+/* Characters which start a comment at the beginning of a line.  */
+const char line_comment_chars[] = "";
+
+/* Characters which may be used to separate multiple commands on a 
+   single line.  */
+const char line_separator_chars[] = "";
+
+/* Characters which are used to indicate an exponent in a floating 
+   point number.  */
+const char EXP_CHARS[] = "eE";
+
+/* Characters which mean that a number is a floating point constant, 
+   as in 0d1.0.  */
+const char FLT_CHARS[] = "dD";
+
+
+const relax_typeS md_relax_table[] =
+{
+  /* Conditional branches.  */
+  {0xff,     -0x100,    2, 1},
+  {0x1fffff, -0x200000, 6, 0},
+  /* Unconditional branches.  */
+  {0xff,     -0x100,    2, 3},
+  {0x1fffff, -0x200000, 4, 0},
+};
+
+/* add tazaki 2001.12.03 */
+static segT comm_section = NULL;
+static segT gcomm_section = NULL;
+static segT scomm_section = NULL;
+static segT tcomm_section = NULL;
+static segT zcomm_section = NULL;
+static segT gbss_section = NULL;
+static segT sbss_section = NULL;
+static segT tbss_section = NULL;
+static segT zbss_section = NULL;
+/* add tazaki 2001.12.03 */
+
+/* add T.Tazaki 2002.04.26 >>> */
+extern int g_listing;
+/* add T.Tazaki 2002.04.26 <<< */
+
+/* fixups */
+#define MAX_INSN_FIXUPS (5)
+struct c33_fixup
+{
+  expressionS              exp;
+  int                      opindex;
+  bfd_reloc_code_real_type reloc;
+};
+
+struct c33_fixup fixups [MAX_INSN_FIXUPS];
+static int fc;
+
+
+
+/******************************************************************************
+    INPUT   int     area of symbol
+    RETURN  void
+    Explanation assembler false instruction(.gcomm/.scomm/.tcomm/.zcomm) Evaluation
+******************************************************************************/
+/* Copied from obj_elf_common() in gas/config/obj-elf.c */
+static void
+c33_comm (area)
+     int area;
+{
+    char *    name;
+    char      c;
+    char *    p;
+    int       temp;
+    int       size;
+    symbolS * symbolP;
+    int       have_align;
+     char * pfrag;
+
+    name = input_line_pointer;
+    c = get_symbol_end ();
+  
+    /* just after name is now '\0' */
+    p = input_line_pointer;
+    *p = c;
+  
+    /* skip space */
+    SKIP_WHITESPACE ();
+  
+    /* Is the character after ".comm" a pause character? */
+    if (*input_line_pointer != ',')
+    {
+        as_bad (_("Expected comma after symbol-name"));
+        ignore_rest_of_line ();
+        return;
+    }
+  
+    input_line_pointer ++;      /* skip ',' */
+  
+    if ((temp = get_absolute_expression ()) < 0)
+    {
+        /* xgettext:c-format */
+        as_bad (_(".COMMon length (%d.) < 0! Ignored."), temp);
+        ignore_rest_of_line ();
+        return;
+    }
+  
+    size = temp;
+    *p = 0;
+    symbolP = symbol_find_or_make (name);
+    *p = c;
+  
+/*  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))  */
+    if (S_IS_DEFINED (symbolP) )
+    {
+        as_bad (_("Ignoring attempt to re-define symbol"));
+        ignore_rest_of_line ();
+        return;
+    }
+  
+    if (S_GET_VALUE (symbolP) != 0)
+    {
+        if (S_GET_VALUE (symbolP) != size)
+        {
+            /* xgettext:c-format */
+            as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
+            S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
+        }
+    }
+  
+    know (symbol_get_frag (symbolP) == & zero_address_frag);
+  
+    if (*input_line_pointer != ',')
+        have_align = 0;
+    else
+    {
+        have_align = 1;
+        input_line_pointer++;
+        SKIP_WHITESPACE ();
+    }
+  
+    if (! have_align || *input_line_pointer != '"')
+    {
+        if (! have_align)
+            temp = 0;
+        else
+        {
+            temp = get_absolute_expression ();
+      
+        if (temp < 0)
+        {
+            temp = 0;
+            as_warn (_("Common alignment negative; 0 assumed"));
+        }
+    }
+ 
+
+/*  if (symbol_get_obj (symbolP)->local)*/
+    if (!(area == AREA_CDA || area == AREA_GDA || area == AREA_SDA || area == AREA_TDA || area == AREA_ZDA ))
+    {
+        /* NOT EXIST ROUTINE */
+        
+        segT   old_sec;
+        int    old_subsec;
+        int    align;
+        flagword    applicable;
+
+        old_sec = now_seg;
+        old_subsec = now_subseg;
+      
+        applicable = bfd_applicable_section_flags (stdoutput);
+          
+        applicable &= SEC_ALLOC;
+      
+        switch (area)
+        {
+        case AREA_CDA:
+          if (comm_section == NULL)
+          {
+
+              comm_section = subseg_new (".comm", 0);
+              
+              bfd_set_section_flags (stdoutput, comm_section, applicable);
+              
+              seg_info (comm_section)->bss = 1;
+          }
+          break;
+      
+        case AREA_GDA:
+          if (gcomm_section == NULL)
+          {
+              gcomm_section = subseg_new (".gcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, gcomm_section, applicable);
+              
+              seg_info (gcomm_section)->bss = 1;
+          }
+          break;
+      
+        case AREA_SDA:
+          if (scomm_section == NULL)
+          {
+              scomm_section = subseg_new (".scomm", 0);
+              
+              bfd_set_section_flags (stdoutput, scomm_section, applicable);
+              
+              seg_info (scomm_section)->bss = 1;
+          }
+          break;
+      
+        case AREA_TDA:
+          if (tcomm_section == NULL)
+          {
+              tcomm_section = subseg_new (".tcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, tcomm_section, applicable);
+              
+              seg_info (tcomm_section)->bss = 1;
+          }
+          break;
+
+        case AREA_ZDA:
+          if (zcomm_section == NULL)
+          {
+              zcomm_section = subseg_new (".zcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, zcomm_section, applicable);
+              
+              seg_info (zcomm_section)->bss = 1;
+          }
+          break;
+      
+        }
+
+        if (temp)
+        {
+            /* convert to a power of 2 alignment */
+            for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
+            ;
+              
+            if (temp != 1)
+            {
+                as_bad (_("Common alignment not a power of 2"));
+                ignore_rest_of_line ();
+                return;
+            }
+        }
+        else
+            align = 0;
+          
+        switch (area)
+        {
+        case AREA_CDA:
+            record_alignment (comm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (comm_section, 0);
+            break;
+
+        case AREA_GDA:
+            record_alignment (gcomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (gcomm_section, 0);
+            break;
+
+        case AREA_SDA:
+            record_alignment (scomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (scomm_section, 0);
+            break;
+
+        case AREA_TDA:
+            record_alignment (tcomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (tcomm_section, 0);
+            break;
+
+        case AREA_ZDA:
+            record_alignment (zcomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (zcomm_section, 0);
+            break;
+
+        default:
+            abort();
+        }
+          
+        if (align)
+            frag_align (align, 0, 0);
+
+        switch (area)
+        {
+        case AREA_CDA:
+          if (S_GET_SEGMENT (symbolP) == comm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_GDA:
+          if (S_GET_SEGMENT (symbolP) == gcomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_SDA:
+          if (S_GET_SEGMENT (symbolP) == scomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_TDA:
+          if (S_GET_SEGMENT (symbolP) == tcomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_ZDA:
+          if (S_GET_SEGMENT (symbolP) == zcomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        default:
+          abort ();
+        }
+      
+        symbol_set_frag (symbolP, frag_now);
+        pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                (offsetT) size, (char *) 0);
+        *pfrag = 0;
+        S_SET_SIZE (symbolP, size);
+      
+        switch (area)
+        {
+        case AREA_CDA:
+          S_SET_SEGMENT (symbolP, comm_section);
+          break;
+          
+        case AREA_GDA:
+          S_SET_SEGMENT (symbolP, gcomm_section);
+          break;
+          
+        case AREA_SDA:
+          S_SET_SEGMENT (symbolP, scomm_section);
+          break;
+          
+        case AREA_TDA:
+          S_SET_SEGMENT (symbolP, tcomm_section);
+          break;
+          
+        case AREA_ZDA:
+          S_SET_SEGMENT (symbolP, zcomm_section);
+          break;
+          
+        default:
+          abort();
+        }
+            
+        if (symbol_get_obj (symbolP)->local)
+            S_CLEAR_EXTERNAL (symbolP);
+        else
+            S_SET_EXTERNAL (symbolP);
+        
+        obj_elf_section_change_hook();
+        subseg_set (old_sec, old_subsec);
+    }
+    else
+    {
+        /*==========================================================================*/
+        /* Evaluation of .comm                                                      */
+        /*==========================================================================*/
+        segT   old_sec;
+        int    old_subsec;
+        int    align;
+        int    i_now_align; /* add 2002.01.21 */
+        i_now_align = temp; /* add 2002.01.21 */
+
+        /* computing of alignment */
+        if (temp)
+        {
+            /* convert to a power of 2 alignment */
+            for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
+            ;
+              
+            if (temp != 1)
+            {
+                as_bad (_("Common alignment not a power of 2"));
+                ignore_rest_of_line ();
+                return;
+            }
+        }
+        else
+            align = 0;
+
+        old_sec = now_seg;
+        old_subsec = now_subseg;
+
+        allocate_common:
+        
+        /* Convert .local + .xcomm to local section. */
+
+        if (symbol_get_obj (symbolP)->local){
+            switch (area)
+            {
+            case AREA_CDA:
+                    area = AREA_LCDA;
+                    break;
+            case AREA_GDA:
+                    area = AREA_LGDA;
+                    break;
+            case AREA_SDA:
+                    area = AREA_LSDA;
+                    break;
+            case AREA_TDA:
+                    area = AREA_LTDA;
+                    break;
+            case AREA_ZDA:
+                    area = AREA_LZDA;
+                    break;
+            }
+        }
+      
+        switch (area)
+        {
+        case AREA_CDA:
+          if (comm_section == NULL)
+            {
+                flagword    applicable;
+                  
+                applicable = bfd_applicable_section_flags (stdoutput);
+
+                comm_section = subseg_new (".comm", 0);
+
+                bfd_set_section_flags (stdoutput, comm_section, applicable
+                   & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                  | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, comm_section);
+            record_alignment (comm_section, align);
+
+          break;
+          
+        case AREA_GDA:
+          if (gcomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              gcomm_section = subseg_new (".gcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, gcomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, gcomm_section);
+            record_alignment (gcomm_section, align);
+          break;
+          
+        case AREA_SDA:
+          if (scomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              scomm_section = subseg_new (".scomm", 0);
+              
+              bfd_set_section_flags (stdoutput, scomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, scomm_section);
+            record_alignment (scomm_section, align);
+          break;
+          
+        case AREA_TDA:
+          if (tcomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              tcomm_section = subseg_new (".tcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, tcomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, tcomm_section);
+            record_alignment (tcomm_section, align);
+          break;
+          
+        case AREA_ZDA:
+          if (zcomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              zcomm_section = subseg_new (".zcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, zcomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, zcomm_section);
+            record_alignment (zcomm_section, align);
+          break;
+          
+          
+        case AREA_LCDA:
+            /* Convert local comm to .bss section. */
+            obj_elf_section_change_hook();
+            subseg_set (bss_section, 0);
+
+            if (S_GET_SEGMENT (symbolP) == bss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, bss_section);
+            record_alignment (bss_section, align);
+
+            break;
+          
+        case AREA_LGDA:
+          if (gbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              gbss_section = subseg_new (".gbss", 0);
+              
+              bfd_set_section_flags (stdoutput, gbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (gbss_section)->bss = 1;
+            }
+
+            record_alignment (gbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (gbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == gbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, gbss_section);
+
+            break;
+          
+        case AREA_LSDA:
+          if (sbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              sbss_section = subseg_new (".sbss", 0);
+              
+              bfd_set_section_flags (stdoutput, sbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (sbss_section)->bss = 1;
+            }
+
+            record_alignment (sbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (sbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == sbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, sbss_section);
+
+            break;
+          
+        case AREA_LTDA:
+          if (tbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              tbss_section = subseg_new (".tbss", 0);
+              
+              bfd_set_section_flags (stdoutput, tbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (tbss_section)->bss = 1;
+            }
+
+            record_alignment (tbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (tbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == tbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, tbss_section);
+
+            break;
+
+        case AREA_LZDA:
+          if (zbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              zbss_section = subseg_new (".zbss", 0);
+              
+              bfd_set_section_flags (stdoutput, zbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (zbss_section)->bss = 1;
+            }
+
+            record_alignment (zbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (zbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == zbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, zbss_section);
+
+            break;
+
+        default:
+          abort();
+        }
+
+        if (area == AREA_LCDA || area == AREA_LGDA || area == AREA_LSDA || area == AREA_LTDA || area == AREA_LZDA) /* ローカル？ */
+        {
+            S_CLEAR_EXTERNAL (symbolP);
+        }else{
+            S_SET_VALUE (symbolP, (valueT) size);
+//          S_SET_ALIGN (symbolP, temp);
+            if( i_now_align )
+                S_SET_ALIGN (symbolP, i_now_align);
+            S_SET_EXTERNAL (symbolP);
+        }
+
+        obj_elf_section_change_hook();
+        subseg_set (old_sec, old_subsec);
+
+    }
+}
+  else
+    {
+      input_line_pointer++;
+      /* @@ Some use the dot, some don't.  Can we get some consistency??  */
+      if (*input_line_pointer == '.')
+    input_line_pointer++;
+      /* @@ Some say data, some say bss.  */
+      if (strncmp (input_line_pointer, "bss\"", 4)
+      && strncmp (input_line_pointer, "data\"", 5))
+    {
+      while (*--input_line_pointer != '"')
+        ;
+      input_line_pointer--;
+      goto bad_common_segment;
+    }
+      while (*input_line_pointer++ != '"')
+    ;
+      goto allocate_common;
+    }
+
+  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
+
+  demand_empty_rest_of_line ();
+  return;
+
+  {
+  bad_common_segment:
+    p = input_line_pointer;
+    while (*p && *p != '\n')
+      p++;
+    c = *p;
+    *p = '\0';
+    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
+    *p = c;
+    input_line_pointer = p;
+    ignore_rest_of_line ();
+    return;
+  }
+}
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  {"comm",    c33_comm,    AREA_CDA},
+  {"gcomm",   c33_comm,    AREA_GDA},
+  {"scomm",   c33_comm,    AREA_SDA},
+  {"tcomm",   c33_comm,    AREA_TDA},
+  {"zcomm",   c33_comm,    AREA_ZDA},
+  { NULL,     NULL,        0}
+};
+
+/*****************************************************************************/
+
+
+
+/* Opcode hash table.  */
+static struct hash_control *c33_hash;
+
+/* This table is sorted. Suitable for searching by a binary search. */
+static const struct reg_name pre_defined_registers[] =
+{
+  { "%r0",   0 },
+  { "%r1",   1 },
+  { "%r10", 10 },
+  { "%r11", 11 },
+  { "%r12", 12 },
+  { "%r13", 13 },
+  { "%r14", 14 },
+  { "%r15", 15 },
+  { "%r2",   2 },
+  { "%r3",   3 },
+  { "%r4",   4 },
+  { "%r5",   5 },
+  { "%r6",   6 },
+  { "%r7",   7 },
+  { "%r8",   8 },
+  { "%r9",   9 },
+};
+#define REG_NAME_CNT    (sizeof (pre_defined_registers) / sizeof (struct reg_name))
+
+/* standard macro spesial registers */
+static const struct reg_name system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%psr",   0 },
+    { "%sp",    1 },
+};
+
+/* advanced macro spesial registers */
+static const struct reg_name adv_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%dp",    9 },        /* Adv */
+    { "%idir",  10 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%lco",   4 },        /* Adv */
+    { "%lea",   6 },        /* Adv */
+    { "%lsa",   5 },        /* Adv */
+    { "%pc",    15},
+    { "%psr",   0 },
+    { "%sor",   7 },        /* Adv */
+    { "%sp",    1 },
+    { "%ssp",   14 },       /* Adv */
+    { "%ttbr",  8 },        /* Adv */
+    { "%usp",   13 },       /* Adv */
+};
+
+/* ld.w %sd,%rs special registers */
+static const struct reg_name adv_load_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%dp",    9 },        /* Adv */
+    { "%idir",  10 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%lco",   4 },        /* Adv */
+    { "%lea",   6 },        /* Adv */
+    { "%lsa",   5 },        /* Adv */
+    { "%psr",   0 },
+    { "%sor",   7 },        /* Adv */
+    { "%sp",    1 },
+    { "%ssp",   14 },       /* Adv */
+    { "%ttbr",  8 },        /* Adv */
+    { "%usp",   13 },       /* Adv */
+};
+
+/* pushs , pops special registers */
+static const struct reg_name adv_pushs_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%dp",    9 },        /* Adv */
+    { "%idir",  10 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%lco",   4 },        /* Adv */
+    { "%lea",   6 },        /* Adv */
+    { "%lsa",   5 },        /* Adv */
+    { "%pc",    15 },
+    { "%psr",   0 },
+    { "%sor",   7 },        /* Adv */
+    { "%sp",    1 },
+    { "%ssp",   14 },       /* Adv */
+    { "%ttbr",  8 },        /* Adv */
+    { "%usp",   13 },       /* Adv */
+};
+
+/* PE  add T.Tazaki 2003/11/18 >>> */
+
+/* PE macro spesial registers */
+static const struct reg_name pe_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },
+    { "%idir",  10 },
+    { "%pc",    15},
+    { "%psr",   0 },
+    { "%sp",    1 },
+    { "%ttbr",  8 },
+};
+
+/* ld.w %sd,%rs special registers */
+static const struct reg_name pe_load_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%psr",   0 },
+    { "%sp",    1 },
+    { "%ttbr",  8 },
+};
+
+/* pushs , pops special registers */
+static const struct reg_name pe_pushs_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+};
+
+/* PE  add T.Tazaki 2003/11/18 <<< */
+
+#define SYSREG_NAME_CNT             (sizeof (system_registers) / sizeof (struct reg_name))
+#define ADV_SYSREG_NAME_CNT         (sizeof (adv_system_registers) / sizeof (struct reg_name))
+#define ADV_LOAD_SYSREG_NAME_CNT    (sizeof (adv_load_system_registers) / sizeof (struct reg_name))
+#define ADV_PUSHS_SYSREG_NAME_CNT   (sizeof (adv_pushs_system_registers) / sizeof (struct reg_name))
+
+/* PE  add T.Tazaki 2003/11/18 >>> */
+#define PE_SYSREG_NAME_CNT         (sizeof (pe_system_registers) / sizeof (struct reg_name))
+#define PE_LOAD_SYSREG_NAME_CNT    (sizeof (pe_load_system_registers) / sizeof (struct reg_name))
+#define PE_PUSHS_SYSREG_NAME_CNT   (sizeof (pe_pushs_system_registers) / sizeof (struct reg_name))
+/* PE  add T.Tazaki 2003/11/18 <<< */
+
+/******************************************************************************
+    INPUT   const struct reg_name * register name
+            int                     register string size
+            const char *            check register string
+            boolean                 not used
+    RETURN  int                     register number
+    Explanation Get register number
+******************************************************************************/
+/* reg_name_search does a binary search of the given register table
+   to see if "name" is a valid regiter name.  Returns the register
+   number from the array on success, or -1 on failure. */
+
+static int
+reg_name_search (regs, regcount, name, accept_numbers)
+     const struct reg_name * regs;
+     int                     regcount;
+     const char *            name;
+     boolean                 accept_numbers;
+{
+  int middle, low, high;
+  int cmp;
+  symbolS * symbolP;
+#if 0
+  /* If the register name is a symbol, then evaluate it.  */
+  if ((symbolP = symbol_find (name)) != NULL)
+    {
+      /* If the symbol is an alias for another name then use that.
+     If the symbol is an alias for a number, then return the number.  */
+      if (symbol_equated_p (symbolP))
+    {
+      name = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
+    }
+      else if (accept_numbers)
+    {
+      int reg = S_GET_VALUE (symbolP);
+      
+      if (reg >= 0 && reg <= 31)
+        return reg;
+    }
+#endif
+
+    low = 0;
+    high = regcount - 1;
+
+    do
+    {
+        middle = (low + high) / 2;
+        cmp = strcasecmp (name, regs[middle].name);
+        if (cmp < 0)
+            high = middle - 1;
+        else if (cmp > 0)
+            low = middle + 1;
+        else
+            return regs[middle].value;
+    }
+    while (low <= high);
+
+    return -1;
+}
+
+
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation A register operand is changed into a command code.
+******************************************************************************/
+/* Summary of register_name().
+ *
+ * in: Input_line_pointer points to 1st char of operand.
+ *
+ * out: A expressionS.
+ *  The operand may have been a register: in this case, X_op == O_register,
+ *  X_add_number is set to the register number, and truth is returned.
+ *  Input_line_pointer->(next non-blank) char after operand, or is in
+ *  its original state.
+ */
+static boolean
+register_name (expressionP)
+     expressionS * expressionP;
+{
+  int    reg_number;
+  char * name;
+  char * start;
+  char   c;
+    char *pNameEnd;
+    
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* Get register number */
+    reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,
+                name, FALSE);
+
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+    /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+    /* YES The right register number was acquirable. */
+
+        /* That it is a register and a register number are saved. */
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+    /* 不正 */
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+         
+        return false;
+    }
+}
+
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+            boolean
+            boolean
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation     A system register operand is changed into a command code.
+******************************************************************************/
+/* Summary of system_register_name().
+ *
+ * in:  Input_line_pointer points to 1st char of operand.
+ *      expressionP points to an expression structure to be filled in.
+ *      accept_numbers is true iff numerical register names may be used.
+ *      accept_list_names is true iff the special names PS and SR may be 
+ *      accepted.
+ *
+ * out: A expressionS structure in expressionP.
+ *  The operand may have been a register: in this case, X_op == O_register,
+ *  X_add_number is set to the register number, and truth is returned.
+ *  Input_line_pointer->(next non-blank) char after operand, or is in
+ *  its original state.
+ */
+static boolean
+system_register_name (expressionP, accept_numbers, accept_list_names)
+     expressionS * expressionP;
+     boolean       accept_numbers;
+     boolean       accept_list_names;
+{
+    int    reg_number;
+    char * name;
+    char * start;
+    char   c;
+
+
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* get register number */
+    if( g_iAdvance == 0 )
+    {
+	    if( g_iPE == 0 )
+	    {
+			/* STD */
+	        reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+	    else
+	    {
+			/* PE */	/* add T.Tazaki 2003/11/18 */
+	        reg_number = reg_name_search (pe_system_registers, PE_SYSREG_NAME_CNT, name,
+	                accept_numbers);
+		}
+    }else{
+        /* add tazaki 2001.11.12 */
+        /* ADV */
+        reg_number = reg_name_search (adv_system_registers, ADV_SYSREG_NAME_CNT, name,
+                accept_numbers);
+    }
+    
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+#if 0
+    if (reg_number < 0 && accept_numbers)
+    {
+        input_line_pointer   = start; /* reset input_line pointer */
+
+        if (isdigit (* input_line_pointer))
+        {
+            reg_number = strtol (input_line_pointer, & input_line_pointer, 10);
+
+            /* Make sure that the register number is allowable. */
+            if (   reg_number < 0
+                 || reg_number > 5
+                 && reg_number < 16
+                 || reg_number > 20
+                 )
+                {
+                reg_number = -1;
+            }
+        }
+        else if (accept_list_names)
+        {
+            c = get_symbol_end ();
+
+#if 0   /* c33 */
+            reg_number = reg_name_search (system_list_registers,
+                    SYSREGLIST_NAME_CNT, name, FALSE);
+#endif
+            * input_line_pointer = c;   /* put back the delimiting char */
+
+        }
+    }
+#endif
+      /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+
+        return false;
+    }
+}
+
+
+CONST char * md_shortopts = "m:";
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof md_longopts; 
+
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+            boolean
+            boolean
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation     A system register operand is changed into a command code.
+                    false : ld.w %pc,%rs
+******************************************************************************/
+static boolean
+load_system_register_name (expressionP, accept_numbers, accept_list_names)
+     expressionS * expressionP;
+     boolean       accept_numbers;
+     boolean       accept_list_names;
+{
+    int    reg_number;
+    char * name;
+    char * start;
+    char   c;
+
+
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* get register number */
+    if( g_iAdvance == 0 )
+    {
+	    if( g_iPE == 0 )
+	    {
+			/* STD */
+	        reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+	    else
+	    {
+			/* PE 	add T.Tazaki 2003/11/18 */
+	        reg_number = reg_name_search (pe_load_system_registers, PE_LOAD_SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+    }else{
+		/* ADV */
+        reg_number = reg_name_search (adv_load_system_registers, ADV_LOAD_SYSREG_NAME_CNT, name,
+                accept_numbers);
+    }
+    
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+    /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+
+        return false;
+    }
+}
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+            boolean
+            boolean
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation     A system register operand is changed into a command code.
+                    true : pushs %psr,%sp,%alr,%ahr,%lco,%lsa,%lea,%sor,%ttbr,%dp,%usp,%ssp,%pc
+******************************************************************************/
+static boolean
+pushs_system_register_name (expressionP, accept_numbers, accept_list_names)
+     expressionS * expressionP;
+     boolean       accept_numbers;
+     boolean       accept_list_names;
+{
+    int    reg_number;
+    char * name;
+    char * start;
+    char   c;
+
+
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* get register number */
+    if( g_iAdvance == 0 )
+    {
+	    if( g_iPE == 0 )
+	    {
+			/* STD */
+	        reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+	                accept_numbers);
+		}
+		else
+		{
+			/* PE	add T.Tazaki 2003/11/18 */
+	        reg_number = reg_name_search (pe_pushs_system_registers, PE_PUSHS_SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+    }else{
+		/* ADV */
+        reg_number = reg_name_search (adv_pushs_system_registers, ADV_PUSHS_SYSREG_NAME_CNT, name,
+                accept_numbers);
+    }
+    
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+    /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+
+        return false;
+    }
+}
+
+/******************************************************************************
+    INPUT   FILE*   not used
+    RETURN  void
+    Explanation display option
+******************************************************************************/
+void
+md_show_usage (stream)
+  FILE * stream;
+{
+    /* The special option for c33 is nothing. */
+}
+
+/******************************************************************************
+    INPUT   int     not used
+            char*   not used
+    RETURN  int     TRUE    ok
+    Explanation     Argument (option) analysis
+******************************************************************************/
+int
+md_parse_option (c, arg)
+     int    c;
+     char * arg;
+{
+#if 0
+    int Num;
+    int i;
+    if (c != 'm')
+    {
+      /* xgettext:c-format */
+      fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
+      return 0;
+    }
+
+#endif
+  return 1;
+}
+
+/******************************************************************************
+    INPUT   char*       not used
+    RETURN  symbolS*    NULL
+    Explanation Treatment of the symbol which is not defined
+******************************************************************************/
+symbolS *
+md_undefined_symbol (name)
+  char * name;
+{
+  return 0;
+}
+
+char *
+md_atof (type, litp, sizep)
+  int    type;
+  char * litp;
+  int *  sizep;
+{
+  int            prec;
+  LITTLENUM_TYPE words[4];
+  char *         t;
+  int            i;
+
+  switch (type)
+    {
+    case 'f':
+      prec = 2;
+      break;
+
+    case 'd':
+      prec = 4;
+      break;
+
+    default:
+      *sizep = 0;
+      return _("bad call to md_atof");
+    }
+  
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizep = prec * 2;
+
+  for (i = prec - 1; i >= 0; i--)
+    {
+      md_number_to_chars (litp, (valueT) words[i], 2);
+      litp += 2;
+    }
+
+  return NULL;
+}
+
+
+/* Very gross.  */
+void
+md_convert_frag (abfd, sec, fragP)
+  bfd *      abfd;
+  asection * sec;
+  fragS *    fragP;
+{
+  subseg_change (sec, 0);
+  
+  /* In range conditional or unconditional branch.  */
+  if (fragP->fr_subtype == 0 || fragP->fr_subtype == 2)
+    {
+      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
+           fragP->fr_offset, 1, BFD_RELOC_UNUSED + (int)fragP->fr_opcode);
+      fragP->fr_var = 0;
+      fragP->fr_fix += 2;
+    }
+  /* Out of range conditional branch.  Emit a branch around a jump.  */
+  else if (fragP->fr_subtype == 1)
+    {
+      unsigned char *buffer = 
+    (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
+
+      /* Reverse the condition of the first branch.  */
+      buffer[0] ^= 0x08;
+      /* Mask off all the displacement bits.  */
+      buffer[0] &= 0x8f;
+      buffer[1] &= 0x07;
+      /* Now set the displacement bits so that we branch
+     around the unconditional branch.  */
+      buffer[0] |= 0x30;
+
+      /* Now create the unconditional branch + fixup to the final
+     target.  */
+      md_number_to_chars (buffer + 2, 0x00000780, 4);
+      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
+           fragP->fr_offset, 1, BFD_RELOC_UNUSED +
+           (int) fragP->fr_opcode + 1);
+      fragP->fr_var = 0;
+      fragP->fr_fix += 6;
+    }
+  /* Out of range unconditional branch.  Emit a jump.  */
+  else if (fragP->fr_subtype == 3)
+    {
+      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x00000780, 4);
+      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
+           fragP->fr_offset, 1, BFD_RELOC_UNUSED +
+           (int) fragP->fr_opcode + 1);
+      fragP->fr_var = 0;
+      fragP->fr_fix += 4;
+    }
+  else
+    abort ();
+}
+
+valueT
+md_section_align (seg, addr)
+     asection * seg;
+     valueT     addr;
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+/******************************************************************************
+    INPUT   NONE
+    RETURN  void
+    Explanation An assembler initial cofiguration peculiar to a model
+******************************************************************************/
+void
+md_begin ()
+{
+  char *                              prev_name = "";
+  register const struct c33_opcode * op;
+  flagword                            applicable;
+
+    /* Create hash table */
+  c33_hash = hash_new();
+
+  /* Insert unique names into hash table.  The C33 instruction set
+     has many identical opcode names that have different opcodes based
+     on the operands.  This hash table then provides a quick index to
+     the first opcode with a particular name in the opcode table.  */
+
+    /* nemonic registered into the operation code table is registered into a hash table.*/
+    
+    /* >>>>>> tazaki 2001.11.07 */
+    if( g_iAdvance == 0 )		/* cpu = standard ? */
+    {  
+    	if( g_iPE == 0 )
+    	{
+			if( g_iMedda32 == 0 )
+			{
+		        op = c33_opcodes;           /* STANDARD table */
+		    }
+		    else
+		    {
+		        op = c33_opcodes32;         /* STANDARD table : No use default data area  add T.Tazaki 2004/07/30 */
+		    }
+	    }
+	    else
+	    {
+			if( g_iMedda32 == 0 )
+			{
+		        op = c33_pe_opcodes;  	    /* PE table 	add T.Tazaki 2003/11/18 */
+			}
+			else
+			{
+		        op = c33_pe_opcodes32;      /* PE table : No use default data area  add T.Tazaki 2004/07/30 */
+		    }
+		}
+    }
+    else
+    {
+		if( g_iMedda32 == 0 )
+		{
+	        op = c33_advance_opcodes;       /* ADVANCE table */
+	    }
+	    else
+	    {
+	        op = c33_advance_opcodes32;     /* ADVANCE table : No use default data area  add T.Tazaki 2004/07/30 */
+		}
+    }
+    /* <<<<<< tazaki 2001.11.07 */
+    
+    while (op->name)
+    {
+        if (strcmp (prev_name, op->name)) 
+        {
+            prev_name = (char *) op->name;
+            hash_insert (c33_hash, op->name, (char *) op);
+        }
+        op++;
+    }
+#if 0   /* c33 */
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
+#endif  /* c33 */
+
+    applicable = bfd_applicable_section_flags (stdoutput);
+}
+
+/******************************************************************************
+    INPUT   int     NONE
+    RETURN  bfd_reloc_code_real_type
+    Explanation analysys symbol mask
+******************************************************************************/
+/* Warning: The code in this function relies upon the definitions
+   in the c33_operands[] array (defined in opcodes/c33-opc.c)
+   matching the hard coded values contained herein.  */
+
+static bfd_reloc_code_real_type
+c33_reloc_prefix ()
+{
+    
+    /* Is it the prefix of a symbol mask? */
+    if (*input_line_pointer == '@'){
+        input_line_pointer++;
+    }else{
+
+        /* NO  */
+        return BFD_RELOC_UNUSED;
+    }
+#define CHECK_(name, reloc)                                             \
+    if (strncmp (input_line_pointer, name, strlen (name) ) == 0)    \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+        return reloc;                                           \
+    }
+        
+    CHECK_ ("ah",   BFD_RELOC_C33_AH);      /* LABEL(25:13) */
+    CHECK_ ("al",   BFD_RELOC_C33_AL);      /* LABEL(12:0)  */
+    CHECK_ ("rh",   BFD_RELOC_C33_RH);      /* <LABEL-PC>(32:22)    */
+    CHECK_ ("rm",   BFD_RELOC_C33_RM);      /* <LABEL-PC>(21:9) */
+    CHECK_ ("rl",   BFD_RELOC_C33_RL);      /* <LABEL-PC>(8:0)  */
+    CHECK_ ("h",    BFD_RELOC_C33_H);       /* LABEL(31:19) */
+    CHECK_ ("m",    BFD_RELOC_C33_M);       /* LABEL(18:6)  */
+    CHECK_ ("l",    BFD_RELOC_C33_L);       /* LABEL(5:0)   */
+
+    CHECK_ ("AH",   BFD_RELOC_C33_AH);      /* LABEL(25:13) */
+    CHECK_ ("AL",   BFD_RELOC_C33_AL);      /* LABEL(12:0)  */
+    CHECK_ ("RH",   BFD_RELOC_C33_RH);      /* <LABEL-PC>(32:22)    */
+    CHECK_ ("RM",   BFD_RELOC_C33_RM);      /* <LABEL-PC>(21:9) */
+    CHECK_ ("RL",   BFD_RELOC_C33_RL);      /* <LABEL-PC>(8:0)  */
+    CHECK_ ("H",    BFD_RELOC_C33_H);       /* LABEL(31:19) */
+    CHECK_ ("M",    BFD_RELOC_C33_M);       /* LABEL(18:6)  */
+    CHECK_ ("L",    BFD_RELOC_C33_L);       /* LABEL(5:0)   */
+
+    return BFD_RELOC_UNUSED;
+}
+
+/* add tazaki 2001.12.03 >>>>> */
+
+/* Warning: The code in this function relies upon the definitions
+   in the c33_operands[] array (defined in opcodes/c33-opc.c)
+   matching the hard coded values contained herein.  */
+
+/******************************************************************************
+    INPUT   int     NONE
+    RETURN  bfd_reloc_code_real_type
+    Explanation analisys symbol offset
+******************************************************************************/
+static bfd_reloc_code_real_type
+c33_reloc_prefix_offset ()
+{
+  boolean paren_skipped = false;
+
+
+#define CHECK2_(name, reloc)                                            \
+    if (strncmp (input_line_pointer, name##"(", strlen (name) + 1 ) == 0)   \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+            return reloc;                                           \
+    }
+
+    CHECK2_ ("doff_hi",   BFD_RELOC_C33_DH);        /* (symbol - default data pointer)  */
+    CHECK2_ ("doff_lo",   BFD_RELOC_C33_DL);        /* (symbol - default data pointer)  */
+    CHECK2_ ("goff_lo",   BFD_RELOC_C33_GL);        /* (symbol - g data pointer)    */
+    CHECK2_ ("soff_hi",   BFD_RELOC_C33_SH);        /* (symbol - s data pointer)    */
+    CHECK2_ ("soff_lo",   BFD_RELOC_C33_SL);        /* (symbol - s data pointer)    */
+    CHECK2_ ("toff_hi",   BFD_RELOC_C33_TH);        /* (symbol - t data pointer)    */
+    CHECK2_ ("toff_lo",   BFD_RELOC_C33_TL);        /* (symbol - t data pointer)    */
+    CHECK2_ ("zoff_hi",   BFD_RELOC_C33_ZH);        /* (symbol - z data pointer)    */
+    CHECK2_ ("zoff_lo",   BFD_RELOC_C33_ZL);        /* (symbol - z data pointer)    */
+    CHECK2_ ("dpoff_h",   BFD_RELOC_C33_DPH);       /* (symbol - default data pointer)  */
+    CHECK2_ ("dpoff_m",   BFD_RELOC_C33_DPM);       /* (symbol - default data pointer)  */
+    CHECK2_ ("dpoff_l",   BFD_RELOC_C33_DPL);       /* (symbol - default data pointer)  */
+
+    CHECK2_ ("DOFF_HI",   BFD_RELOC_C33_DH);        /* (symbol - default data pointer)  */
+    CHECK2_ ("DOFF_LO",   BFD_RELOC_C33_DL);        /* (symbol - default data pointer)  */
+    CHECK2_ ("GOFF_LO",   BFD_RELOC_C33_GL);        /* (symbol - g data pointer)    */
+    CHECK2_ ("SOFF_HI",   BFD_RELOC_C33_SH);        /* (symbol - s data pointer)    */
+    CHECK2_ ("SOFF_LO",   BFD_RELOC_C33_SL);        /* (symbol - s data pointer)    */
+    CHECK2_ ("TOFF_HI",   BFD_RELOC_C33_TH);        /* (symbol - t data pointer)    */
+    CHECK2_ ("TOFF_LO",   BFD_RELOC_C33_TL);        /* (symbol - t data pointer)    */
+    CHECK2_ ("ZOFF_HI",   BFD_RELOC_C33_ZH);        /* (symbol - z data pointer)    */
+    CHECK2_ ("ZOFF_LO",   BFD_RELOC_C33_ZL);        /* (symbol - z data pointer)    */
+    CHECK2_ ("DPOFF_H",   BFD_RELOC_C33_DPH);       /* (symbol - default data pointer)  */
+    CHECK2_ ("DPOFF_M",   BFD_RELOC_C33_DPM);       /* (symbol - default data pointer)  */
+    CHECK2_ ("DPOFF_L",   BFD_RELOC_C33_DPL);       /* (symbol - default data pointer)  */
+
+    return BFD_RELOC_UNUSED;
+
+}
+
+/* add tazaki 2002.02.29 >>>>> */
+/******************************************************************************
+    INPUT   NONE
+    RETURN  operand code
+    advanced macro "EXT COND" instruction operand analysis
+******************************************************************************/
+static int
+c33_condition ()
+{
+  boolean paren_skipped = false;
+
+
+#define CHECK3_(name, cond)                                         \
+    if (strncmp (input_line_pointer, name, strlen (name) ) == 0)    \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+            return cond;                                            \
+    }
+
+    CHECK3_ ("gt",   0x04);
+    CHECK3_ ("ge",   0x05);
+    CHECK3_ ("lt",   0x06);
+    CHECK3_ ("le",   0x07);
+    CHECK3_ ("ugt",  0x08);
+    CHECK3_ ("uge",  0x09);
+    CHECK3_ ("ult",  0x0a);
+    CHECK3_ ("ule",  0x0b);
+    CHECK3_ ("eq",   0x0c);
+    CHECK3_ ("ne",   0x0d);
+
+    return 0;
+
+}
+/* add tazaki 2002.02.29 >>>>> */
+/******************************************************************************
+    INPUT   NONE
+    RETURN  operand code
+    advanced macro "EXT OP,imm2" or "EXT %RB,OP,imm2" instruction operand analysis
+******************************************************************************/
+static int
+c33_op_shift ()
+{
+  boolean paren_skipped = false;
+
+
+#define CHECK4_(name, op_shift_code)                                \
+    if (strncmp (input_line_pointer, name, strlen (name) ) == 0)    \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+            return op_shift_code;                                   \
+    }
+
+    CHECK4_ ("sra",   0x01);
+    CHECK4_ ("srl",   0x02);
+    CHECK4_ ("sll",   0x03);
+
+    return 0;
+
+}
+
+/******************************************************************************
+    INPUT   unsigned long
+            const struct c33_operand*   operand
+            offsetT
+            char*
+            unsigned int
+            char*
+            int
+    RETURN  unsigned long
+    Explanation An operand and an operation code are made into a command code.
+******************************************************************************/
+ unsigned long               ulrd;		/* add T.Tazaki 2004/07/23 */
+
+/* Insert an operand value into an instruction.  */
+static unsigned long
+c33_insert_operand (insn, operand, val, file, line, str,flags)
+     unsigned long               insn;
+     const struct c33_operand * operand;
+     offsetT                     val;
+     char *                      file;
+     unsigned int                line;
+     char *                      str;
+     int                        flags;
+{
+
+    long    min, max, lval;
+    unsigned long   ulValue, ulMask;
+    int     iSign;
+
+    /* Does a function exist? */
+    if (operand->insert)
+    {
+    /* YES */
+    
+        const char * message = NULL;
+
+        insn = operand->insert (insn, val, & message);
+        if (message != NULL)
+        {
+            if (str)
+            {
+                if (file == (char *) NULL)
+                    as_warn ("%s: %s", str, message);
+                else
+                    as_warn_where (file, line, "%s: %s", str, message);
+            }
+            else
+            {
+                if (file == (char *) NULL)
+                    as_warn (message);
+                else
+                    as_warn_where (file, line, message);
+            }
+        }
+    }
+    else
+    {
+    /* NO  */
+    
+//      long    min, max, lval;
+//      unsigned long   ulValue, ulMask;
+//      int     iSign;
+
+        lval = val; /* T.Tazaki 2002.02.27 */
+
+        if( operand->range < 32 ){
+
+            /* Restore min and mix to expected values for decimal ranges.  */
+
+            if (flags & C33_OPERAND_SIGNED){
+
+                ulValue = val;
+
+                ulMask = 0xffffffff >> ( operand->range - 1 );
+                ulMask <<= ( operand->range - 1 );
+                if(( ulValue & ulMask ) == ulMask ){
+                    iSign = 1;  /* (-) */       /* "jp 0xffffff81" */
+                }else{
+                    if( ( ulValue & ulMask ) == (1 << ( operand->range - 1 )) ){    /* only sign bit = 1 ? */
+                        iSign = 1;      /* (-) */   /* "jp 0x81" */
+                    }else{
+                        if(( ulValue & ulMask ) == 0 ){ /* sign bit = 0 ? */
+                            iSign = 0;  /* (+) */   /* "jp 0x40" */
+                        }else{
+                            iSign = 2;  /* Warninng */
+                        }
+                    }
+                }
+
+                if( iSign == 2 ){   /* Invalid range ?  "jp 0x102" */
+                    const char * err = _("operand out of range (%s not between %ld and %ld)");
+                    char         buf[100];
+
+                    max = (1 << ( operand->range - 1 )) - 1;    /* T.Tazaki 2002.02.27 */
+                    min = - (1 << (operand->range - 1));        /* T.Tazaki 2002.02.27 */
+                    if (str)
+                    {
+                      sprintf (buf, "%s: ", str);
+                      
+                      sprint_value (buf + strlen (buf), val);
+                    }
+                    else
+                        sprint_value (buf, lval);
+              
+                    if (file == (char *) NULL)
+                        as_warn (err, buf, min, max);
+                    else
+                        as_warn_where (file, line, err, buf, min, max);
+                }
+                else
+                {
+                    if( iSign == 0 ){   /* (+) ? */
+                        lval = val;
+                    }else{
+                        if( iSign == 1 ){ /* (-) ? */
+                            lval = ulValue | ulMask;    /* sign extend */
+                        }
+                    }
+                    
+        /*          max = (1 << ( operand->bits - 1 )) - 1;
+                    min = - (1 << (operand->bits - 1));         */
+                    max = (1 << ( operand->range - 1 )) - 1;    /* T.Tazaki 2002.02.27 */
+                    min = - (1 << (operand->range - 1));        /* T.Tazaki 2002.02.27 */
+
+                    if (lval < min || lval > max)
+                    {
+                        const char * err = _("operand out of range (%s not between %ld and %ld)");
+                        char         buf[100];
+
+                        if (str)
+                        {
+                          sprintf (buf, "%s: ", str);
+                          
+                          sprint_value (buf + strlen (buf), lval);
+                        }
+                        else
+                            sprint_value (buf, lval);
+                  
+                        if (file == (char *) NULL)
+                            as_warn (err, buf, min, max);
+                        else
+                            as_warn_where (file, line, err, buf, min, max);
+                    }
+                }
+            }
+            else {
+                /* It asks for the range of effective value. */
+                max = (1 << operand->bits) - 1;
+                min = 0;
+
+                /* Value is range outside. */
+                if (lval < (offsetT) min || lval > (offsetT) max)
+                {
+                    /* xgettext:c-format */
+                    const char * err = _("operand out of range (%s not between %ld and %ld)");
+                    char         buf[100];
+
+                    if (str)
+                    {
+                      sprintf (buf, "%s: ", str);
+                      
+                      sprint_value (buf + strlen (buf), lval);
+                    }
+                    else
+                        sprint_value (buf, lval);
+
+                    if (file == (char *) NULL)
+                        as_warn (err, buf, min, max);
+                    else
+                        as_warn_where (file, line, err, buf, min, max);
+                }
+            }
+        }
+
+        /* An operand and an operation code are made into a command code. */
+//      insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
+        insn |= (((long) lval & ((1 << operand->bits) - 1)) << operand->shift); /* T.Tazaki 2002.02.27 */
+/* >>>> add tazaki advanced macro */
+        if (flags & C33_OPERAND_01) {
+            insn |= 0x0010; /* bit 5,4 = 0,1 set */
+        }
+        if (flags & C33_OPERAND_OP3_01) {
+            insn |= 0x0040; /* bit 7,6 = 0,1 set : psrset imm5 */
+        }
+        if (flags & C33_OPERAND_OP3_10){
+            insn |= 0x0080; /* bit 7,6 = 1,0 set : psrclr imm5 */
+        }
+/* <<<< add tazaki advanced macro */
+    }
+    return insn;
+}
+
+
+static char                 copy_of_instruction [128];
+
+void
+md_assemble (str) 
+     char * str;
+{
+    char *                  s;
+    char *                  start_of_operands;
+    struct c33_opcode *     opcode;
+    struct c33_opcode *     opcode2;    /* add tazaki 2001.08.10 */
+    struct c33_opcode *     next_opcode;
+    const unsigned char *   opindex_ptr;
+    int                     next_opindex;
+    int                     relaxable;
+    unsigned short          insn;
+    unsigned short          insn_wk;    /* add tazaki 2001.12.11 */
+    unsigned short          copy_insn;
+    char *                  f;      /* insn address */
+    char *                  where;      /* insn address */
+    int                     i;
+    int                     match;
+    boolean                 extra_data_befor_insn = false;
+    unsigned int            extra_data_len;
+    unsigned short          extraInsnBuf[10];
+    char *                  saved_input_line_pointer;
+    char *                  check_input_line_pointer;
+    char *                  temp_input_line_pointer;
+    unsigned short *        fromP;
+    int                     iNumber;
+    unsigned int            uiNumber;                       /* add tazaki 2002.03.11 */
+    
+    int                     i_ext_off;                      /* add tazaki 2001.08.07 */
+    int                     iMEM_IMM26_flag;                /* add tazaki 2001.10.11 */
+    char *                  pSymbolName ;                   /* for [imm26] add tazaki 2001.11.28 */
+    char                    szSymbolName[300];              /* for [imm26] add tazaki 2001.11.28 */
+    char *                  temp_pointer;                   /* for [imm26] add tazaki 2001.11.28 */
+
+	int						g_iBitTest = 0;					/* for Bit Test命令のオペランド imm3 用  add T.Tazaki 2004/07/30 */
+	int						g_iBitTest_range = 0;			/* for Bit Test命令のオペランド imm3 用  add T.Tazaki 2004/07/30 */
+	int						g_iXload = 0;					/* for xld.x [symbol+imm],%rs命令のオペランド %rs 用  add T.Tazaki 2004/07/30 */
+	int						g_iXload_range = 0;				/* for xld.x [symbol+imm],%rs命令のオペランド %rs 用  add T.Tazaki 2004/07/30 */
+
+    pSymbolName = &szSymbolName[0];                         /* Symbol name pointer domain initialization for [imm26] add tazaki 2001.11.28*/
+
+    /* The command character sequence for one line is copied. */
+    strncpy (copy_of_instruction, str, sizeof (copy_of_instruction) - 1);
+  
+    /* It is made a character sequence as an operation code. */
+    /* Get the opcode.  */
+    for (s = str; *s != '\0' && ! isspace (*s); s++)
+        continue;
+
+    if (*s != '\0')
+        *s++ = '\0';
+
+    /* find the first opcode with the proper name */
+    opcode = (struct c33_opcode *) hash_find (c33_hash, str);
+
+    /* not find operation code? */
+    if (opcode == NULL) {
+        /* xgettext:c-format */
+        as_bad (_("Unrecognized opcode: `%s'"), str);
+        ignore_rest_of_line ();
+        return;
+    }
+
+    /* The space from an operation code to an operand is skipped. */
+    str = s;
+    while (isspace (* str))
+        ++ str;
+
+    /* The start position of an operand is held. */
+    start_of_operands = str;
+
+    saved_input_line_pointer = input_line_pointer;
+
+    /* An interpretation of an operand */
+    for (;;) {
+        const char * errmsg = NULL;
+
+        match = 0;
+
+        relaxable = 0;
+        fc = 0;
+        next_opindex = 0;
+        insn = opcode->opcode;
+        extra_data_befor_insn = false;
+
+        iMEM_IMM26_flag = 0;    /* add tazaki 2001.10.11 */
+
+        /* The start position of an operand is held. */
+        input_line_pointer = str = start_of_operands;
+
+        /* Only the number of operands is repeated. */
+        for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr ++)
+        {
+            const struct c33_operand * operand;
+            char *                      hold;
+            expressionS                 ex;
+            expressionS                 ext_ex;
+            bfd_reloc_code_real_type    reloc;  
+            
+            int flags;
+            
+            if (next_opindex == 0)
+            {
+                /* An operand is acquired. */
+                operand = & c33_operands[ * opindex_ptr ];
+            }
+            else
+            {
+                operand      = & c33_operands[ next_opindex ];
+                next_opindex = 0;
+            }
+
+            flags = operand->flags;
+            errmsg = NULL;
+
+            while (*str == ' ' || *str == ',' || *str == ']')
+              ++ str;
+
+            /* Gather the operand. */
+            hold = input_line_pointer;
+            input_line_pointer = str;
+     
+            errmsg = NULL;
+
+            /*  tazaki 2002.01.11  >>>>>> */
+            i_ext_off = 0;
+            opcode2 = (struct c33_opcode *)c33_ext_opcodes;
+            if( opcode->opcode == opcode2->opcode ){
+                /* ext xoff_hi(sym),ext xoff_lo(sym),ext dpoff_h,m(sym) : analisys symbol offset */
+                reloc = c33_reloc_prefix_offset ();
+                if( reloc != BFD_RELOC_UNUSED ){
+                    i_ext_off = 1;
+                }
+            }
+            if( i_ext_off == 1 )
+            {
+                /* ext 命令 and xoff_hi(sym),ext xoff_lo(sym),dpoff_h,m(sym) ? */
+
+                /* read symbol , disp */
+
+                expression (& ex);
+
+                if (fc >= MAX_INSN_FIXUPS)
+                  as_fatal (_("too many fixups"));
+
+                fixups[ fc ].exp     = ex;
+                fixups[ fc ].opindex = * opcode->operands;
+                fixups[ fc ].reloc   = reloc;
+                ++fc;
+
+            }
+            else
+            {
+                /* >>>> add tazaki 2002.02.29 class1 : ext cond*/
+                if ((operand->flags & C33_OPERAND_COND) == C33_OPERAND_COND) 
+                {
+                    int iCond = c33_condition();    /* get operand code */
+                    if( iCond != 0 ){
+
+                        ex.X_op = O_cond;
+                        ex.X_add_number = iCond;
+
+                    }else{
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* >>>> add tazaki 2002.02.29 class1 : ext OP,imm2 | ext %rb,OP,imm2 */
+                else if ((operand->flags & C33_OPERAND_OP_SHIFT) == C33_OPERAND_OP_SHIFT) 
+                {
+                    int iShiftCode = c33_op_shift();    /* get operand code */
+                    if( iShiftCode != 0 ){
+
+                        ex.X_op = O_op_shift;
+                        ex.X_add_number = iShiftCode;
+
+                    }else{
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* >>>> add tazaki 2001.09.18 class7 : [%dp+imm6]*/
+                else if ((operand->flags & C33_OPERAND_DPMEM) == C33_OPERAND_DPMEM) 
+                {
+                    if (*str == '['){
+                        str++;
+                        while (isspace (*str))
+                            ++str;
+
+                        input_line_pointer = str;
+
+                        /* %dp ? */
+                        if ( ( strncmp(str,"%dp",3) != 0 ) && ( strncmp(str,"%DP",3) != 0 ))
+                        {
+                        /* YES  */
+                            errmsg = _("invalid system register name");
+                        }
+                        else {
+                            str+=3;
+                            while (isspace (*str))
+                                ++str;
+
+                            /* IF ']' */
+                            if (*str == ']'){
+                            /* YES only register */
+                                /* Support only"[%dp]"  */
+                                ex.X_op         = O_constant;
+                                ex.X_add_symbol = NULL;
+                                ex.X_op_symbol  = NULL;
+                                ex.X_add_number = 0;
+                                str++;
+                                input_line_pointer = str;
+                            }
+                            else if (*str == '+'){
+                                str++;
+                                input_line_pointer = str;
+
+                                reloc = c33_reloc_prefix_offset();
+                                if( reloc != BFD_RELOC_UNUSED ){    /* dpoff_l() ? */
+                                    errmsg = _("invalid operand");
+                                }
+                                else
+                                {
+                                    /* An operand is developed at a formula. */
+                                    expression (& ex);
+
+                                    iNumber = ex.X_add_number;
+
+                                    if (operand->range <= 6){
+                                        /* EMPTY */
+                                    }
+                                    else if (operand->range == 32) {
+                                        /* update tazaki 2002.03.08 >>> */
+                                        if (opcode->specialFlag == 1){
+                                            /* ld.b */
+                                            if ((unsigned int)iNumber <= 0x3f){
+                                                ex.X_add_number /= 1;
+                                                
+                                            }else if ((unsigned int)iNumber <= 0x7ffff){
+                                                /* 1 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 1;
+                                                extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                            else {
+                                                /* 2 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 2;
+                                                extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                                extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                        }
+                                        else if (opcode->specialFlag == 2){
+                                            /* ld.h */
+                                            if ((unsigned int)iNumber <= 0x7f){
+                                                ex.X_add_number /= 2;
+                                                
+                                            }else if ((unsigned int)iNumber <= 0x7ffff){
+                                                /* 1 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 1;
+                                                extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                            else {
+                                                /* 2 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 2;
+                                                extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                                extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                        }
+                                        else if (opcode->specialFlag == 4){
+                                            /* ld.w */
+                                            if ((unsigned int)iNumber <= 0xff){
+                                                ex.X_add_number /= 4;
+                                                
+                                            }else if ((unsigned int)iNumber <= 0x7ffff){
+                                                /* 1 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 1;
+                                                extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                            else {
+                                                /* 2 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 2;
+                                                extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                                extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                        }
+                                        /* update tazaki 2002.03.08 <<< */
+                                    }
+                                    else {
+                                        errmsg = _("constant too big to fit into instruction");
+                                    }
+                                }
+                            }
+                            else{
+                                /* YES  */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+
+                /* >>>> add tazaki 2002.01.15 class7 : [%dp+dpoff_l(symbol)]*/
+                else if ((operand->flags & C33_OPERAND_DPSYMBOL6) == C33_OPERAND_DPSYMBOL6) 
+                {
+                    if (*str == '['){
+                        str++;
+                        while (isspace (*str))
+                            ++str;
+
+                        input_line_pointer = str;
+
+                        /* %dp ? */
+                        if ( ( strncmp(str,"%dp",3) != 0 ) && ( strncmp(str,"%DP",3) != 0 ))
+                        {
+                        /* YES  */
+                            errmsg = _("invalid system register name");
+                        }
+                        else {
+                            str+=3;
+                            while (isspace (*str))
+                                ++str;
+
+                            /* IF ']' */
+                            if (*str == ']'){
+                            /* YES only register */
+                                /* Support only"[%dp]  */
+                                ex.X_op         = O_constant;
+                                ex.X_add_symbol = NULL;
+                                ex.X_op_symbol  = NULL;
+                                ex.X_add_number = 0;
+                                str++;
+                                input_line_pointer = str;
+                            }
+                            else
+                            {
+                                if (*str == '+'){
+                                    /* [%dp+dpoff_l(symbol)] */
+                                    str++;
+                                    input_line_pointer = str;
+
+                                    reloc = c33_reloc_prefix_offset();
+                                    if( reloc == BFD_RELOC_C33_DPL ){   /* dpoff_l() ? */
+
+                                        expression (& ex);
+
+                                        if (ex.X_op != O_symbol){   /* not symbol ? */
+                                            errmsg = _("invalid operand");
+                                        }
+                                    }else{
+                                        errmsg = _("invalid operand");
+                                    }
+                                }else{
+                                    errmsg = _("invalid operand");
+                                }
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                
+                /* >>>> add tazaki 2002.01.15 class7 : dpoff_l(symbol) */
+                else if ((operand->flags & C33_OPERAND_DPSYMBOL6_2) == C33_OPERAND_DPSYMBOL6_2) 
+                {
+                    reloc = c33_reloc_prefix_offset();
+                    if( reloc == BFD_RELOC_C33_DPL ){   /* dpoff_l() ? */
+
+                        expression (& ex);
+
+                        if (ex.X_op != O_symbol){   /* not symbol ? */
+                            errmsg = _("invalid operand");
+                        }
+                    }else{
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* >>>> add tazaki 2001.12.21 class0 : %dp */
+
+                else if ((operand->flags & C33_OPERAND_DP) == C33_OPERAND_DP) 
+                {
+                    /* check %dp ? */
+                    if ( ( strncmp(str,"%dp",3) != 0 ) && ( strncmp(str,"%DP",3) != 0 ))
+                    {
+                        /* NO  */
+                        errmsg = _("invalid system register name");
+                    }else{
+                        str+=3;
+                        while (isspace (*str))
+                            ++str;
+                        input_line_pointer = str;
+                            
+                        ex.X_op  = O_dpregister;
+                        /* In %dp, an operand is not inserted in a command code. */
+                    }
+                /* <<<< add tazaki 2001.12.21 class0 : %dp */
+                }
+                else if ((operand->flags & C33_OPERAND_REG) != 0) 
+                {
+                    if (!register_name (& ex))
+                    {
+                    /* YES  */
+                        errmsg = _("invalid register name");
+                    }
+                }
+                else if ((operand->flags & C33_OPERAND_LD_SREG) != 0)   /* add 2002.06.19 error : ld.w %pc,%rs */
+                {
+                    if (!load_system_register_name (& ex, true, false))
+                    {
+                        errmsg = _("invalid system register name");
+                    }
+                }
+                else if ((operand->flags & C33_OPERAND_PUSHS_SREG) != 0)    /* add 2002.06.19 : pushs %ss ,pops %sd */
+                {
+                    if (!pushs_system_register_name (& ex, true, false))
+                    {
+                        errmsg = _("invalid system register name");
+                    }
+                }
+                else if (((operand->flags & C33_OPERAND_SREG) != 0) ||
+                        ((operand->flags & C33_OPERAND_SP) != 0)) 
+                {
+                    if (!system_register_name (& ex, true, false))
+                    {
+                        errmsg = _("invalid system register name");
+                    }
+                    else {
+                        /* NO register OK */
+                        if ((operand->flags & C33_OPERAND_SP) != 0) 
+                        {
+                            ex.X_op  = O_spregister;
+                            /* In %sp, an operand is not inserted in a command code. */
+                        }
+                    }
+                }
+                /* ELSE IF Operand is immidiate ? */
+                else if ((operand->flags & C33_OPERAND_IMM) ||
+                        (operand->flags & C33_OPERAND_SIGNED))
+                {
+
+                    expression (& ex);
+
+                    /* IF Operand is constant ?*/
+                    if (ex.X_op == O_constant)
+                    {
+                        if (opcode->specialFlag == 5){
+
+                            /* shift/lotate */
+
+                            iNumber = ex.X_add_number;
+                            if( iNumber > 8 ){
+
+                                errmsg = _("operand out of range (not between 0 and 8)");
+                            }else{
+                                extra_data_len = 0;
+                                ex.X_add_number = iNumber;
+                            }
+                        }else if (opcode->specialFlag == 6){
+
+                            /* 拡張命令のshift/lotate */
+
+                            iNumber = ex.X_add_number;
+                            if( iNumber > 31 ){
+                                errmsg = _("operand out of range (not between 0 and 31)");
+                            }else{
+                                extra_data_len = 0;
+                                while(iNumber > 8){
+                                    extra_data_befor_insn = true;
+                                    copy_insn = c33_insert_operand (insn, operand,8,
+                                                  (char *) NULL, 0,
+                                                  copy_of_instruction,flags);
+                                    extraInsnBuf[extra_data_len] = copy_insn;
+                                    extra_data_len++;
+                                    ex.X_add_number =  8;
+                                    iNumber -= 8;
+                                }
+                                ex.X_add_number = iNumber;
+                            }
+                        }else if (opcode->specialFlag == 7){
+                            
+                            /* Advanced mode "X" Extended of shift/lotate */
+                            iNumber = ex.X_add_number;
+                            if( iNumber > 31 ){
+                                errmsg = _("operand out of range (not between 0 and 31)");
+                            }else{
+                                if( iNumber <= 15 ){
+
+                                }else{
+                                    ex.X_add_number -= 16;
+                                    
+                                    /* Convert Opecode */
+                                    insn_wk = insn & 0xff00;
+                                    
+                                    switch( insn_wk ){
+                                    case 0x8800: insn_wk = 0x2300;  break;  /* srl -->class 1 : srl */
+                                    case 0x8c00: insn_wk = 0x2700;  break;  /* sll -->class 1 : sll */
+                                    case 0x9000: insn_wk = 0x2b00;  break;  /* sra -->class 1 : sra */
+                                    case 0x9400: insn_wk = 0x2f00;  break;  /* sla -->class 1 : sla */
+                                    case 0x9800: insn_wk = 0x3300;  break;  /* rr  -->class 1 : rr  */
+                                    case 0x9c00: insn_wk = 0x3700;  break;  /* rl  -->class 1 : rl  */
+                                    default :   errmsg = _("invalid operand");  break;
+
+                                    }
+                                    insn = insn_wk | ( insn & 0x00ff );
+                                }
+                            }
+                        }
+                        else {
+                        /* shift/lotate命令以外 */
+                        
+                            /* Possible to sign32 */
+                            iNumber = ex.X_add_number;
+                            
+                            if (operand->flags & C33_OPERAND_SIGNED){
+                            /* YES signed */
+
+                                if ((operand->range == 19) && ((-262144 <= iNumber && iNumber < -32) ||
+                                        (31 < iNumber && iNumber <= 262143))){
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 1;
+                                    extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                    ex.X_add_number = iNumber & 0x3f;
+                                    flags = C33_OPERAND_IMM;    /* sign(5:0) is not signed */
+                                }
+                                else if (operand->range == 22) {
+                                    if (operand->flags & C33_OPERAND_PC){
+                                        if (-256 <= iNumber && iNumber <= 254){
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign22(8:1) */
+                                        }
+                                        else if ((-2097152 <= iNumber && iNumber < -256) ||
+                                                (254 < iNumber && iNumber <= 2097150)){
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 9) & 0x1fff); /* sign22(21:9) */
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;                     /* sign22(8:1) */
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }else{
+                                            errmsg = _("operand out of range (not between -2097152 and 2097150)");
+                                        }
+                                    }
+                                }
+                                else if (operand->range == 32){
+                                    /* jp,call */
+                                    if (operand->flags & C33_OPERAND_PC){
+                                        if (-256 <= iNumber && iNumber <= 254){
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign32(8:1) */
+                                        }
+                                        else if ((-2097152 <= iNumber && iNumber < -256) ||
+                                            (254 < iNumber && iNumber <= 2097150)){
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 9) & 0x1fff);
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign32(8:1) */
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1ff8);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 9) & 0x1fff);
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign32(8:1) */
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                    }
+                                    else {
+                                        if (-32 <= iNumber && iNumber <= 31){
+                                            /* EMPTY */
+                                        }
+                                        else if ((-262144 <= iNumber && iNumber < -32) ||
+                                            (31 < iNumber && iNumber <= 262143)){
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                        else {
+                                            /* ext命令　２つ */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                    }
+                                }
+                            }
+                            else {
+                            /* IMM */
+                                switch( operand->range ){
+                                case 19:
+                                    if ((unsigned int)iNumber <= 0x7ffff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 1;
+                                        extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                        ex.X_add_number = iNumber & 0x3f;
+                                    }
+                                    break;
+                                case 32:
+                                    if ((unsigned int)iNumber <= 0x3f){
+                                        /* EMPTY */
+                                    }
+                                    else if ((unsigned int)iNumber <= 0x7ffff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 1;
+                                        extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                        ex.X_add_number = iNumber & 0x3f;
+                                    }
+                                    else {
+                                        /* 2 ext */
+                                        
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 2;
+                                        
+                                        extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                        extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                        ex.X_add_number = iNumber & 0x3f;
+                                    }
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    /* ELSE IF Operand is LABEL & SYMBOL */
+
+                    else if ((ex.X_op == O_symbol) && (operand->flags & C33_OPERAND_LABEL)){
+                    /* YES jp/call only */
+
+                        if (operand->range == 13){      /* 2001.4.27 ide */
+                            /* YES ext */
+
+                            /* Get Symbol mask relocation  */
+                            reloc = c33_reloc_prefix ();
+                            /* Not symbol mask ?  : ERROR = ext label, OK = ext label@xx */
+                            if( reloc == BFD_RELOC_UNUSED ){    /* add tazaki 2002.03.04 */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else if (operand->range == 5){      /* add tazaki 2002.03.04 */
+                            /* YES loop */
+                            reloc = BFD_RELOC_C33_LOOP;     /* Adv : loop operand */
+                        }
+                        else if (operand->range == 8){
+                            /* YES jp,call */
+
+                            reloc = c33_reloc_prefix ();        /* add tazaki 2001.08.23 */
+                            /* Not symbol mask ? */
+                            if( reloc == BFD_RELOC_UNUSED ){    /* add tazaki 2001.08.23 */
+                                /* Set Symbol Mask Relocation */
+                                reloc = BFD_RELOC_C33_JP;       /* Modify BFD_RELOC_C33_RL -->BFD_RELOC_C33_JP 2002.04.22 */
+                            }
+                        }
+                        /* add 2001.08.06 tazaki >>>>> */
+                        else if (operand->range == 22){
+                            /* YES scall,sjp,sjrxx */
+                            /* 1 ext  */
+                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                            extra_data_befor_insn = true;
+                            extra_data_len  = 1;
+                            extraInsnBuf[0] = opcode->opcode;
+                            if (fc >= MAX_INSN_FIXUPS)
+                              as_fatal (_("too many fixups"));
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_S_RM;
+                            ++fc;
+
+                            reloc = BFD_RELOC_C33_S_RL;
+                        
+                        }
+                        /* add 2001.08.06 tazaki <<<<< */
+                        else {
+                            /* xjp,xcall */
+                            
+                            /* ext  label+imm32@rh */
+                            /* ext  label+imm32@rm */
+                            /* call label+imm32@rl */
+                            
+                            /* strにシンボル名が入っている。２パス　アセンブラのとき、これを比較する。 */
+
+                            /* 2 ext  */
+                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                            extra_data_befor_insn = true;
+                            extra_data_len  = 2;
+                            extraInsnBuf[0] = opcode->opcode;
+                            extraInsnBuf[1] = opcode->opcode;
+
+                            if (fc >= MAX_INSN_FIXUPS)
+                              as_fatal (_("too many fixups"));
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_S_RH;
+                            ++fc;
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_S_RM;
+                            ++fc;
+
+                            reloc = BFD_RELOC_C33_S_RL;
+                        }
+                    }
+                    else if ((ex.X_op == O_symbol) && (operand->flags & C33_OPERAND_SYMBOL)){
+                    /* YES ld.w only */
+                        if( *str == '[' ){
+                            errmsg = _("invalid operand");
+                        }
+                        else if (operand->range == 6){
+                            /*  ld.w %rd,LABEL@l */
+
+                            /* Get Symbol mask relocation  */
+                            reloc = c33_reloc_prefix ();
+                        }
+                        else if (operand->range == 19){
+                        /* xld.w rd,symbol+imm19 */
+
+                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                            extra_data_befor_insn = true;
+                            extra_data_len  = 1;
+                            extraInsnBuf[0] = opcode->opcode;
+
+                            if (fc >= MAX_INSN_FIXUPS)
+                              as_fatal (_("too many fixups"));
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+                            ++fc;
+
+                            reloc = BFD_RELOC_C33_L;
+
+                        }
+                        else{
+                            if (operand->range == 32){
+                                /* ext  label+imm32@h */
+                                /* ext  label+imm32@m */
+                                /* xld.w    label+imm32@l */
+                                    
+                                /* 2 ext */
+                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                extra_data_befor_insn = true;
+                                extra_data_len  = 2;
+                                extraInsnBuf[0] = opcode->opcode;
+                                extraInsnBuf[1] = opcode->opcode;
+
+                                if (fc >= MAX_INSN_FIXUPS)
+                                  as_fatal (_("too many fixups"));
+
+                                fixups[ fc ].exp     = ex;
+                                fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                                fixups[ fc ].reloc   = BFD_RELOC_C33_H;
+                                ++fc;
+
+                                fixups[ fc ].exp     = ex;
+                                fixups[ fc ].opindex = * opcode->operands;
+                                fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+                                ++fc;
+
+                                reloc = BFD_RELOC_C33_L;
+                            }
+                        }
+                    }
+                    else {
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* Operand is register indirectness (memory). */
+//              else if ((operand->flags & C33_OPERAND_RB) != 0) 																	/* del T.Tazaki 2004/07/30 */
+                else if ((operand->flags & C33_OPERAND_RB) != 0 && (operand->flags & C33_OPERAND_26) == 0 && g_iMedda32 == 1  )		/* add T.Tazaki 2004/07/30 */
+                {
+                    /* Pattern */
+                    /* [rb] */
+
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (register_name (& ex))
+                        {
+                        /* YES register */
+                            
+                            /* Skip space */
+                            while (isspace (*input_line_pointer))
+                                ++input_line_pointer;
+                            
+                            /* IF ']' */
+                            if (*input_line_pointer == ']'){
+                            /* YES pattern match */
+                                input_line_pointer++;
+                            }
+                            else {
+                            /* NO not match */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else {
+                        /* NO not register */
+                            errmsg = _("invalid operand");
+                        }
+
+                    }
+                    else
+                        errmsg = _("invalid operand");
+               }
+				/* add T.Tazaki 2004/07/30 >>> */
+                /* Operand is register indirectness (memory). */
+                else if ((operand->flags & C33_OPERAND_RB) != 0 && g_iMedda32 == 0 )	/* Use data area */
+                {
+                    /* Pattern */
+                    /* [rb] */
+
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (register_name (& ex))
+                        {
+                        /* YES register */
+                            
+                            /* Skip space */
+                            while (isspace (*input_line_pointer))
+                                ++input_line_pointer;
+                            
+                            /* IF ']' */
+                            if (*input_line_pointer == ']'){
+                            /* YES pattern match */
+                                input_line_pointer++;
+                            }
+                            else {
+                            /* NO not match */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else {
+                        /* NO not register */
+                            errmsg = _("invalid operand");
+                        }
+
+                    }
+                    else
+                        errmsg = _("invalid operand");
+               }
+               else if ((operand->flags & C33_OPERAND_RB) != 0 && (operand->flags & C33_OPERAND_26) != 0 && g_iMedda32 == 1 ) 
+               {
+                   /* Are there any symbol and IMM which follow a register? */
+                   /* Pattern */
+                   /* [rb+imm26] */
+                            
+                   if (*str == '['){
+                       str++;
+                       input_line_pointer = str;
+
+                       if (register_name (& ex))
+                       {
+		                   /* Skip Space */
+		                   while (isspace (*input_line_pointer))
+		                       ++input_line_pointer;
+		                            
+		                   /* IF ']' */
+		                   if (*input_line_pointer == ']'){
+		                   /* YES Register Only */
+		                       input_line_pointer++;
+		                   }
+		                   /* ELSE IF plus */
+		                   else if (*input_line_pointer == '+'){
+		                   /* YES plus */
+		                            
+		                       input_line_pointer++;
+		                       /* symbol,imm */
+		                       expression (& ext_ex);
+
+		                       if (ext_ex.X_op == O_constant){
+		                           /* [%rd+imm26] */
+		                                
+		                           uiNumber = ext_ex.X_add_number;
+		                                 
+		                           if (uiNumber == 0){
+		                               /* EMPTY */
+		                           }
+		                           else if (uiNumber <= 0x1fff){
+		                               opcode = (struct c33_opcode *)c33_ext_opcodes;
+		                               extra_data_befor_insn = true;
+		                               extra_data_len  = 1;
+		                               extraInsnBuf[0] = opcode->opcode| (uiNumber & 0x1fff);
+		                           }
+		                           else if (uiNumber <= 0x3ffffff){
+		                               opcode = (struct c33_opcode *)c33_ext_opcodes;
+		                               extra_data_befor_insn = true;
+		                               extra_data_len  = 2;
+		                               extraInsnBuf[0] = opcode->opcode| ((uiNumber >> 13) & 0x1fff);
+		                               extraInsnBuf[1] = opcode->opcode| (uiNumber & 0x1fff);
+		                           }
+		                           else {
+		                           /* NO more than 27bit ? */
+		                                    
+		                               /* tnot support */
+		                               errmsg = _("invalid operand");
+		                               iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+		                           }
+		                       }
+		                       else {
+		                       /* NO not immidiate */
+		                           errmsg = _("invalid operand");
+		                           iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+		                       }
+		                    }
+		                    else {
+		                    /* NO any other character  */
+		                        /* error */
+		                        errmsg = _("invalid operand");
+		                        iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+		                    }
+						}
+						else
+	                        errmsg = _("invalid operand");
+					}
+					else
+                        errmsg = _("invalid operand");
+                }
+                
+				/* add T.Tazaki 2004/07/30 <<< */
+
+/* >>> add tazaki 2001.11.20 */
+
+                else if( ( (operand->flags & C33_OPERAND_MEM) != 0 ) && 
+                         ( (operand->flags & C33_OPERAND_DP_SYMBOL) == C33_OPERAND_DP_SYMBOL ) )
+                {
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (!register_name (& ex))
+                        {
+                        /* YES not register */
+
+                            if (system_register_name (& ex, true, false)){
+                            /* system register */
+                                errmsg = _("invalid operand");
+                            }
+                            else {
+                                check_input_line_pointer = input_line_pointer;
+                                
+                                expression (& ex);
+
+                                /* if Minus "-", No Support! */
+                                while(check_input_line_pointer < input_line_pointer){
+                                    if (*check_input_line_pointer == '-'){
+                                        errmsg = _("invalid operand");
+                                        break;
+                                    }
+                                    check_input_line_pointer++;
+                                }
+                            }
+                            if (errmsg != NULL){
+                            }
+                            /* ELSE IF Operand is SYMBOL */
+                            else if (ex.X_op == O_symbol){
+                                /* Pattern */
+                                /* [symbol+imm32] */
+
+                                if( operand->range == 19 )
+                                {
+									if( g_iMedda32 == 0 )									/* add T.Tazaki 2004/07/30 */
+									{
+	                                    /* ext   (symbol+imm32-dp)@6-18  : ext  imm13 */
+	                                    /* ld.w  (symbol+imm32-dp)@0-5   : ld.w r0,[%dp+imm6] */
+
+	                                    /* 1 ext */
+	                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+	                                    extra_data_befor_insn = true;
+	                                    extra_data_len  = 1;
+	                                    extraInsnBuf[0] = opcode->opcode;
+
+	                                    if (fc >= MAX_INSN_FIXUPS)
+	                                      as_fatal (_("too many fixups"));
+
+	                                    fixups[ fc ].exp     = ex;
+	                                    fixups[ fc ].opindex = * opcode->operands;
+	                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DPM;
+	                                    ++fc;
+	                                    reloc = BFD_RELOC_C33_DPL;
+		                             }
+#if 0
+		                             else
+		                             {
+										/* add T.Tazaki 2004/08/19 >>> */
+										/* 0:pushn %r0         			*/
+		                                /* 1:ext  label+imm32@m 		*/
+		                                /* 2:ld.x %r0,label+imm32@l 	*/
+		                                /* 3:ld.x %rd,[%r0]   			*/
+		                                /* 4:popn %r0					*/
+		                                    
+	                                    extraInsnBuf[0] = 0x0200;	/* pushn %r0 */
+		                                /* 1ext */
+		                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+		                                extra_data_befor_insn = true;
+		                                extraInsnBuf[1] = opcode->opcode;
+
+		                                if (fc >= MAX_INSN_FIXUPS)
+		                                  as_fatal (_("too many fixups"));
+
+										/* これは、リンク後、pushn %rs の %rs が、BFD_RELOC_C33_M に設定されてしまうので新規にBFD_RELOC_C33_PUSHN_R0
+										   を追加して、リンカで "pushn %r0" を設定させるためにある。 */
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands; 
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_PUSHN_R0;	/* デフォルトの"pushn %r0" を設定 */
+		                                ++fc;
+
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands;
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+		                                ++fc;
+
+		                                reloc = BFD_RELOC_C33_L;
+
+	                                    extra_data_befor_insn = true;
+	                                    ulrd = insn & 0x000f;
+	                                    insn &= 0xfff0;
+	                                    extraInsnBuf[2] = insn;		/* ld.w %r0,sign6 */
+	                                    
+					                    if ((operand->flags & C33_XLDB_RD) != 0) 
+	                                    {
+	                                    	insn = 0x2000 + ulrd;		/* ld.b %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDB_WR) != 0) 
+	                                    {
+											g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+											g_iXload_range = operand->range;
+		                                    insn = 0x3400;		/* ld.b [%r0],%rs */
+		                                }
+					                    if ((operand->flags & C33_XLDH_RD) != 0) 
+	                                    {
+	                                    	insn = 0x2800 + ulrd;		/* ld.h %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDH_WR) != 0) 
+	                                    {
+											g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+											g_iXload_range = operand->range;
+		                                    insn = 0x3800;		/* ld.h [%r0],%rs */
+		                                }
+					                    if ((operand->flags & C33_XLDW_RD) != 0) 
+	                                    {
+	                                    	insn = 0x3000 + ulrd;		/* ld.w %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDW_WR) != 0) 
+	                                    {
+											g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+											g_iXload_range = operand->range;
+		                                    insn = 0x3c00;		/* ld.w [%r0],%rs */
+		                                }
+					                    if ((operand->flags & C33_XLDUB_RD) != 0) 
+	                                    {
+	                                    	insn = 0x2400 + ulrd;		/* ld.ub %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDUH_RD) != 0) 
+	                                    {
+		                                    insn = 0x2c00 + ulrd;		/* ld.uh %rd,[%r0] */
+		                                }
+	                                    extraInsnBuf[3] = insn;
+	                                    insn = 0x0240;				/* popn %r0 */
+	                                    extraInsnBuf[4] = insn;
+	                                    extra_data_len = 4;
+
+									}
+									/* add T.Tazaki 2004/08/19 <<< */
+#endif								
+                                }else if ( operand->range == 32 ){
+                                    /* ext   (symbol+imm32-%dp)@19-31 : ext  imm13 */
+                                    /* ext   (symbol+imm32-%dp)@6-18  : ext  imm13 */
+                                    /* ld.w  (symbol+imm32-%dp)@0-5   : ld.w r0,[%dp+imm6] */
+
+                                    /* 2 ext */
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 2;
+                                    extraInsnBuf[0] = opcode->opcode;
+                                    extraInsnBuf[1] = opcode->opcode;
+
+                                    if (fc >= MAX_INSN_FIXUPS)
+                                      as_fatal (_("too many fixups"));
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;  /* extのオペランド */
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DPH;
+                                    ++fc;
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DPM;
+                                    ++fc;
+                                    reloc = BFD_RELOC_C33_DPL;
+                                }
+                            }
+                        }
+                        else {
+                            errmsg = _("invalid operand");
+                        }
+                    }
+                    else {
+                        errmsg = _("invalid operand");
+                    }
+                }
+/* <<< add tazaki 2001.11.20 */
+                
+                /* An operand is register indirectness (memory). */
+                else if ((operand->flags & C33_OPERAND_MEM) != 0) 
+                {
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (!register_name (& ex))
+                        {
+                            /* YES not register */
+
+                            if (system_register_name (& ex, true, false)){
+                                /* system register */
+                                errmsg = _("invalid operand");
+                            }
+                            else {
+                                check_input_line_pointer = input_line_pointer;
+                                
+                                expression (& ex);
+
+                                /* if Minus "-", No Support! */
+                                while(check_input_line_pointer < input_line_pointer){
+                                    if (*check_input_line_pointer == '-'){
+                                        errmsg = _("invalid operand");
+                                        break;
+                                    }
+                                    check_input_line_pointer++;
+                                }
+                            }
+                            
+                            if (errmsg != NULL){
+                            }
+                            /* ELSE IF Operand is Immidiate ? */
+                            else if (ex.X_op == O_constant){
+                                errmsg = _("invalid operand");  /* [imm26] patter : Error! 2001.11.28 */
+                            }
+                            /* ELSE IF Operand is SYMBOL ? */
+                            else if (ex.X_op == O_symbol){
+
+                                /* Pattern */
+                                /* [symbol+imm32] */
+
+                                
+                                /* ext goff_hi(symbol+imm32) */
+                                /* ext goff_lo(symbol+imm32) */
+                                /* [r15] */
+
+                                if (operand->range == 13){
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 1;
+                                    extraInsnBuf[0] = opcode->opcode;
+
+                                    if (fc >= MAX_INSN_FIXUPS)
+                                      as_fatal (_("too many fixups"));
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_GL;
+                                    ++fc;
+                                    
+                                        
+                                    /* Save Register Number. */
+                                    ex.X_op         = O_register;
+                                    ex.X_add_number = GP_REG;
+                                    ex.X_add_symbol = NULL;
+                                    ex.X_op_symbol  = NULL;
+                                
+                                }
+                                else if (operand->range == 26 && g_iMedda32 == 0 ){		/* use data area */
+                                    /* 2 ext */
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 2;
+                                    extraInsnBuf[0] = opcode->opcode;
+                                    extraInsnBuf[1] = opcode->opcode;
+
+                                    if (fc >= MAX_INSN_FIXUPS)
+                                      as_fatal (_("too many fixups"));
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DH;
+                                    ++fc;
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DL;
+                                    ++fc;
+                                    
+                                        
+                                    /* Save Register Number. */
+                                    ex.X_op         = O_register;
+                                    ex.X_add_number = GP_REG;
+                                    ex.X_add_symbol = NULL;
+                                    ex.X_op_symbol  = NULL;
+								}
+								/* add T.Tazaki 2004/08/19 >>> */
+                                else if ((operand->range == 19 || operand->range == 26) && g_iMedda32 == 1 ){	/* xld と ald 兼用  : no use data area */
+                                	/* スクラッチは%r0だが、%rs = %r0のときは後で、スクラッチを%r1に変更される。 */
+									/* 0:pushn %r0         			*/
+	                                /* 1:ext  label+imm32@m 		*/
+	                                /* 2:ext  label+imm32@m 		*/
+	                                /* 3:ld.x %r0,label+imm32@l 	*/
+	                                /* 4:ld.x [%r0],%rs   			*/
+	                                /* 5:popn %r0					*/
+
+                                    extraInsnBuf[0] = 0x0200;	/* pushn %r0 */ 
+
+	                                /* 1 or 2 ext */
+	                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+	                                extra_data_befor_insn = true;
+				                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+				                    {
+		                                extraInsnBuf[0] = opcode->opcode;
+									}
+									else
+									{
+		                                extraInsnBuf[1] = opcode->opcode;
+		                            }
+									if( operand->range == 26 )
+									{
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+			                                extraInsnBuf[1] = opcode->opcode;
+										}
+										else
+										{
+			                                extraInsnBuf[2] = opcode->opcode;
+			                            }
+									}
+	                                if (fc >= MAX_INSN_FIXUPS)
+	                                  as_fatal (_("too many fixups"));
+
+									/* これは、リンク後、pushn %rs の %rs が、BFD_RELOC_C33_H に設定されてしまうので新規にBFD_RELOC_C33_PUSHN_R0
+									   を追加して、リンカで "pushn %r0" を設定させるためにある。 
+									   xld.x %rd,[symbol+imm] は、push/pop を行わない。 */
+				                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) == 0 )
+									{
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands; 
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_PUSHN_R0;
+		                                ++fc;
+		                            }
+
+									if( operand->range == 26 )
+									{
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_H;
+		                                ++fc;
+									}
+	                                fixups[ fc ].exp     = ex;
+	                                fixups[ fc ].opindex = * opcode->operands;
+	                                fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+	                                ++fc;
+
+	                                reloc = BFD_RELOC_C33_L;
+
+                                    extra_data_befor_insn = true;
+                                    ulrd = insn & 0x000f;
+									if( operand->range == 26 )
+									{
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+		                                    extraInsnBuf[2] = insn;		/* ld.w %rd,sign6 */
+										}
+										else
+										{
+		                                    insn &= 0xfff0;
+		                                    extraInsnBuf[3] = insn;		/* ld.w %r0,sign6 */
+		                                }
+                                    }
+                                    else
+                                    {
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+											/* xld.x %rd,[symbol+imm] */
+		                                    extraInsnBuf[1] = insn;		/* ld.w %rd,sign6 */
+										}
+										else
+										{
+											/* xld.x [symbol+imm],%rs */
+		                                    insn &= 0xfff0;
+		                                    extraInsnBuf[2] = insn;		/* ld.w %r0,sign6 */
+										}
+	                                }
+				                    if ((operand->flags & C33_XLDB_RD) != 0) 
+                                    {
+                                    	insn = 0x2000 + ulrd + ulrd * 16;		/* ld.b %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDB_WR) != 0) 
+                                    {
+										g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+	                                    insn = 0x3400;							/* ld.b [%r0],%rs */
+	                                }
+				                    if ((operand->flags & C33_XLDH_RD) != 0) 
+                                    {
+                                    	insn = 0x2800 + ulrd + ulrd * 16;		/* ld.h %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDH_WR) != 0) 
+                                    {
+										g_iXload = 1;				/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+	                                    insn = 0x3800;							/* ld.h [%r0],%rs */
+	                                }
+				                    if ((operand->flags & C33_XLDW_RD) != 0) 
+                                    {
+                                    	insn = 0x3000 + ulrd + ulrd * 16;		/* ld.w %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDW_WR) != 0) 
+                                    {
+										g_iXload = 1;				/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+	                                    insn = 0x3c00;							/* ld.w [%r0],%rs */
+	                                }
+				                    if ((operand->flags & C33_XLDUB_RD) != 0) 
+                                    {
+                                    	insn = 0x2400 + ulrd + ulrd * 16;		/* ld.ub %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDUH_RD) != 0) 
+                                    {
+	                                    insn = 0x2c00 + ulrd + ulrd * 16;		/* ld.uh %rd,[%r0] */
+	                                }
+                                    else if((operand->flags & C33_XBTST) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xa800;				/* btst [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+                                    else if((operand->flags & C33_XBCLR) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xac00;				/* bclr [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+                                    else if((operand->flags & C33_XBSET) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xb000;				/* bset [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+                                    else if((operand->flags & C33_XBNOT) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xb400;				/* bnot [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+									if( operand->range == 26 )
+									{
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+		                                    extraInsnBuf[3] = insn;
+		                                    extra_data_len = 3;
+		                                }
+		                                else
+		                                {
+		                                    extraInsnBuf[4] = insn;
+		                                    insn = 0x0240;				/* popn %r0 */
+		                                    extraInsnBuf[5] = insn;
+		                                    extra_data_len = 5;
+		                                }
+	                                }
+	                                else
+	                                {
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+		                                    extraInsnBuf[2] = insn;
+		                                    extra_data_len = 2;
+		                                }
+		                                else
+		                                {
+		                                    extraInsnBuf[3] = insn;
+		                                    insn = 0x0240;				/* popn %r0 */
+		                                    extraInsnBuf[4] = insn;
+		                                    extra_data_len = 4;
+		                                }
+									}
+
+
+								/* add T.Tazaki 2004/08/19 <<< */
+
+                                }
+                                else {
+                                    errmsg = _("invalid operand");
+                                }
+                            }
+                            else {
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else {
+                        /* NO Register */
+                            /* Are there any symbol and IMM which follow a register? */
+                            
+                            /* Pattern */
+                            /* [rb+imm32] */
+                            
+                            /* Skip Space */
+                            while (isspace (*input_line_pointer))
+                                ++input_line_pointer;
+                            
+                            /* IF ']' */
+                            if (*input_line_pointer == ']'){
+                            /* YES Register Only */
+    #if 0
+                                errmsg = _("invalid operand");
+    #else
+                                input_line_pointer++;
+    #endif
+                            }
+                            /* ELSE IF plus */
+                            else if (*input_line_pointer == '+'){
+                            /* YES plus */
+                            
+                                input_line_pointer++;
+                                /* symbol,imm */
+                                expression (& ext_ex);
+
+                                if (ext_ex.X_op == O_constant){
+                                    /* [%rd+imm26] */
+                                
+                                    uiNumber = ext_ex.X_add_number;
+                                    
+                                    if (uiNumber == 0){
+                                        /* EMPTY */
+                                    }
+                                    else if (uiNumber <= 0x1fff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 1;
+                                        extraInsnBuf[0] = opcode->opcode| (uiNumber & 0x1fff);
+                                    }
+                                    else if (uiNumber <= 0x3ffffff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 2;
+                                        extraInsnBuf[0] = opcode->opcode| ((uiNumber >> 13) & 0x1fff);
+                                        extraInsnBuf[1] = opcode->opcode| (uiNumber & 0x1fff);
+                                    }
+                                    else {
+                                    /* NO more than 27bit ? */
+                                    
+                                        /* tnot support */
+                                        errmsg = _("invalid operand");
+                                        iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+                                    }
+                                }
+                                else {
+                                /* NO not immidiate */
+                                    errmsg = _("invalid operand");
+                                    iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+                                }
+                            }
+                            else {
+                            /* NO any other character  */
+                                /* error */
+                                errmsg = _("invalid operand");
+                                iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                /* an operand -- the register with a post increment -- or [ being indirect ] */
+                else if ((operand->flags & C33_OPERAND_REGINC) != 0) 
+                {
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (!register_name (& ex))
+                        {
+                            errmsg = _("invalid register name");
+                        }
+                        else {
+                            str = input_line_pointer;
+
+                            /* Skip space */
+                            while (isspace (*str))
+                                ++str;
+
+                            if (*str == ']'){
+                                ++str;
+
+                                while (isspace (*str))
+                                    ++str;
+                                
+                                if (*str == '+'){
+                                    /* normal end */
+                                    str++;
+                                    input_line_pointer = str;
+                                    
+                                }
+                                else {
+                                    errmsg = _("invalid operand");
+                                }
+                            }
+                            else {
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                
+                
+                /* Register indirectness with the De Dis placement */
+                else if ((operand->flags & C33_OPERAND_SPMEM) != 0) 
+                {
+                    if (*str == '['){
+                        str++;
+                        /* Skip space */
+                        while (isspace (*str))
+                            ++str;
+
+                        input_line_pointer = str;
+
+                        /* check %sp */
+                        if ( ( strncmp(str,"%sp",3) != 0 ) && ( strncmp(str,"%SP",3) != 0 ))
+                        {
+                            /* YES  */
+                            errmsg = _("invalid system register name");
+                        }
+                        else {
+                            str+=3;
+                            while (isspace (*str))
+                                ++str;
+
+                            /* IF ']' */
+                            if (*str == ']'){
+                            /* YES only register */
+                                /* Support "[%sp]"  2001.3.29 ide */
+                                ex.X_op         = O_constant;
+                                ex.X_add_symbol = NULL;
+                                ex.X_op_symbol  = NULL;
+                                ex.X_add_number = 0;
+                                str++;
+                                input_line_pointer = str;
+                            }
+                            else if (*str == '+'){
+                            /* [sp+imm] */
+                                str++;
+                                input_line_pointer = str;
+
+                                expression (& ex);
+
+                                iNumber = ex.X_add_number;
+                                    
+                                if (operand->range <= 6){
+                                    /* EMPTY */
+                                }
+                                else if (operand->range == 32) {
+                                    /* update tazaki 2002.03.08 >>> */
+                                    if (opcode->specialFlag == 1){
+                                        /* ld.b */
+                                        if ((unsigned int)iNumber <= 0x3f){
+                                            ex.X_add_number /= 1;
+                                            
+                                        }else if ((unsigned int)iNumber <= 0x7ffff){
+                                            /* 1 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                    }
+                                    else if (opcode->specialFlag == 2){
+                                        /* ld.h */
+                                        if ((unsigned int)iNumber <= 0x7f){
+                                            ex.X_add_number /= 2;
+                                             
+                                        }else if ((unsigned int)iNumber <= 0x7ffff){
+                                            /* 1 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                    }
+                                    else if (opcode->specialFlag == 4){
+                                        /* ld.w */
+                                        if ((unsigned int)iNumber <= 0xff){
+                                            ex.X_add_number /= 4;
+                                            
+                                        }else if ((unsigned int)iNumber <= 0x7ffff){
+                                            /* 1 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                    }
+                                    /* update tazaki 2002.03.08 <<< */
+                                }
+                                else {
+                                    errmsg = _("constant too big to fit into instruction");
+                                }
+                            }
+                            else{
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                
+                if (errmsg)
+                    goto error;
+
+                switch (ex.X_op) 
+                {
+                    case O_cond:
+                        /* An operand and an operation code are made into a command code. */
+                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+                                      (char *) NULL, 0,
+                                      copy_of_instruction,flags);
+                        break;
+                    case O_op_shift:
+                        /* An operand and an operation code are made into a command code. */
+                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+                                      (char *) NULL, 0,
+                                      copy_of_instruction,flags);
+                        break;
+                    case O_spregister :
+                        /* Don't add %sp to a formula as an operand. */
+                        break;
+                    case O_dpregister :
+                        /* Don't add %sp to a formula as an operand. */
+                        break;
+                    case O_illegal:
+                        errmsg = _("illegal operand");
+                        goto error;
+                    case O_absent:
+                        errmsg = _("missing operand");
+                        goto error;
+                    case O_register:
+                        /* An operand and an operation code are made into a command code. */
+                        /* add T.Tazaki 2004/08/19 >>> */
+				        if (g_iXload == 1)		/* xld.x [symbol+imm],%rs ? */
+				        {
+							if( g_iXload_range == 26 )	/* xld.x */
+							{
+								if( ex.X_add_number == 0 )	/* xld.x [symbol+imm],%rs  : %rs = %r0 ? */
+								{
+									/* change %r0 --> %r1 */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[0] = 0x0201;								/* pushn %r1 */
+		                                fixups[ fc-4 ].reloc   = BFD_RELOC_C33_PUSHN_R1;		/* pushn %r1 */
+		                            }
+		                            else
+		                            {
+										/* ADV or PE */
+										extraInsnBuf[0] = 0x0011;								/* push %r1 */
+		                                fixups[ fc-4 ].reloc   = BFD_RELOC_C33_PUSH_R1;			/* push %r1 */
+									}
+									extraInsnBuf[3] = 0x6c01;								/* ld.w %r1,symbol+imm */
+									extraInsnBuf[4] = (extraInsnBuf[4] & 0xff0f) | 0x0010;	/* ld.x [%r1],%rs      */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[5] = 0x0241;								/* popn  %r1           */
+										insn = 0x0241;
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[5] = 0x0051;								/* pop   %r1           */
+										insn = 0x0051;
+									}
+								}
+		                        extraInsnBuf[4] = c33_insert_operand (extraInsnBuf[4], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							else
+							{
+								/* g_iXload_range = 19 : ald.x */
+								if( ex.X_add_number == 0 )	/* ald.x [symbol+imm],%rs  : %rs = %r0 ? */
+								{
+									/* change %r0 --> %r1 */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[0] = 0x0201;								/* pushn %r1 */
+		                                fixups[ fc-3 ].reloc   = BFD_RELOC_C33_PUSHN_R1;		/* pushn %r1 */
+		                            }
+		                            else
+		                            {
+										/* ADV or PE */
+										extraInsnBuf[0] = 0x0011;								/* push %r1 */
+		                                fixups[ fc-3 ].reloc   = BFD_RELOC_C33_PUSH_R1;			/* push %r1 */
+									}
+									extraInsnBuf[2] = 0x6c01;								/* ld.w %r1,symbol+imm */
+									extraInsnBuf[3] = (extraInsnBuf[3] & 0xff0f) | 0x0010;	/* ld.x [%r1],%rs      */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[4] = 0x0241;								/* popn  %r1           */
+										insn = 0x0241;
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[4] = 0x0051;								/* pop   %r1           */
+										insn = 0x0051;
+									}
+								}
+		                        extraInsnBuf[3] = c33_insert_operand (extraInsnBuf[3], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							g_iXload = 0;
+							g_iXload_range = 0;
+						}
+                        /* add T.Tazaki 2004/08/19 <<< */
+						else
+						{
+	                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+                                      (char *) NULL, 0,
+                                      copy_of_instruction,flags);
+						}
+                        break;
+                        
+                    case O_constant:
+                        /* An operand and an operation code are made into a command code. */
+                        
+                        /* add T.Tazaki 2004/07/30 >>> */
+				        if (g_iBitTest == 1)		/* bit test inst ? */
+				        {
+							if( g_iBitTest_range == 26 )
+							{
+		                        extraInsnBuf[4] = c33_insert_operand (extraInsnBuf[4], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							else
+							{
+		                        extraInsnBuf[3] = c33_insert_operand (extraInsnBuf[3], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							g_iBitTest = 0;
+							g_iBitTest_range = 0;
+						}
+                        /* add T.Tazaki 2004/07/30 <<< */
+						else
+						{
+	                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+	                                      (char *) NULL, 0,
+	                                      copy_of_instruction,flags);
+						}
+                        break;
+
+                    case O_symbol:
+                        /* We need to generate a fixup for this expression.  */
+                        if (fc >= MAX_INSN_FIXUPS)
+                          as_fatal (_("too many fixups"));
+
+                        fixups[ fc ].exp     = ex;
+                        fixups[ fc ].opindex = * opindex_ptr;
+                        fixups[ fc ].reloc   = reloc;
+                        ++fc;
+                        break;
+
+                    default:
+                        /* We need to generate a fixup for this expression.  */
+                        if (fc >= MAX_INSN_FIXUPS)
+                          as_fatal (_("too many fixups"));
+
+                        fixups[ fc ].exp     = ex;
+                        fixups[ fc ].opindex = * opindex_ptr;
+                        fixups[ fc ].reloc   = BFD_RELOC_UNUSED;
+                        ++fc;
+                        break;
+                }
+            }
+            str = input_line_pointer;
+            input_line_pointer = hold;
+
+            while (*str == ' ' || *str == ',' || *str == ']' )
+                ++str;
+        }
+        match = 1;
+
+        error:
+        if (match == 0)
+        {
+
+            /* xld.w rd,[rs+imm26] : imm26 > 0x3ffffff ?    add tazaki 2001.10.11 */
+            if( iMEM_IMM26_flag == 0 ){ /* The following operand form is not seen at the time of range over.。*/
+                next_opcode = opcode + 1;
+                if (next_opcode->name != NULL
+                    && strcmp (next_opcode->name, opcode->name) == 0)
+                {
+                    opcode = next_opcode;
+                    continue;   
+                }
+            }
+            as_bad (_("%s: %s"), copy_of_instruction, errmsg);
+/*          as_bad ("%s: %s", copy_of_instruction, errmsg); Modify tazaki 2001.10.11 */
+
+            if (* input_line_pointer == ']')
+                ++ input_line_pointer;
+
+            ignore_rest_of_line ();
+            input_line_pointer = saved_input_line_pointer;
+            return;
+        }
+        break;
+    }
+      
+    while (isspace (*str))
+      ++str;
+
+    if (*str != '\0')
+    /* xgettext:c-format */
+        as_bad (_("junk at end of line: `%s'"), str);
+
+    input_line_pointer = str;
+
+    /* Write out the instruction. */
+
+    if (relaxable && fc > 0)
+    {
+
+        fc = 0;
+
+        if (!strcmp (opcode->name, "br"))
+        {
+            f = frag_var (rs_machine_dependent, 4, 2, 2,
+            fixups[0].exp.X_add_symbol,
+            fixups[0].exp.X_add_number,
+            (char *)fixups[0].opindex);
+            md_number_to_chars (f, insn, 2);
+            md_number_to_chars (f + 2, 0, 2);
+        }
+        else
+        {
+            f = frag_var (rs_machine_dependent, 6, 4, 0,
+                fixups[0].exp.X_add_symbol,
+                fixups[0].exp.X_add_number,
+                (char *)fixups[0].opindex);
+            md_number_to_chars (f, insn, 2);
+            md_number_to_chars (f + 2, 0, 4);
+        }
+    }
+    else 
+    {
+        /* ext command is set before a command code formula.   . */
+        if (extra_data_befor_insn)
+        {
+            /* Domain reservation */
+            f = where = frag_more (extra_data_len*2+2); /* 2byte length instruction */
+
+            /* The command code for extension (ext command) is acquired. */
+            fromP = &extraInsnBuf[0];
+
+            /* Only a part for the command code for FOR extensio */
+            for (i = extra_data_len; i; --i)
+            {
+                /* The command code is stored in the buffer in order. */
+                md_number_to_chars (where, (long) (*fromP), 2);
+                where += 2;
+                fromP++;
+            }
+
+            extra_data_befor_insn = false;
+        }
+        else {
+            /* Domain reservation */
+            f = where = frag_more (2);  /* 2byte length instruction */
+        }
+
+        /* >>> add tazaki 2001.09.13 */
+        /* macclr,ld.cf ? */
+        if (opcode->specialFlag == 10){ 
+            insn |= 0x0010; /* bit 5,4 = 0,1 set */
+        }
+        /* <<< add tazaki 2001.09.13 */
+
+        /* The command code of 2 byte length is stored in a buffer. */
+        md_number_to_chars (where, insn, 2);
+    }
+
+    /* Create any fixups.  At this point we do not use a
+         bfd_reloc_code_real_type, but instead just use the
+         BFD_RELOC_UNUSED plus the operand index.  This lets us easily
+         handle fixups for any operand type, although that is admittedly
+         not a very exciting feature.  We pick a BFD reloc type in
+         md_apply_fix.  */  
+    for (i = 0; i < fc; i++)
+    {
+        const struct c33_operand * operand;
+        bfd_reloc_code_real_type    reloc;
+
+        operand = & c33_operands[ fixups[i].opindex ];
+
+        reloc = fixups[i].reloc;
+
+        if (reloc != BFD_RELOC_UNUSED)
+        {
+            reloc_howto_type * reloc_howto = bfd_reloc_type_lookup (stdoutput,
+                                      reloc);
+            int                size;
+            int                address;
+            fixS *             fixP;
+
+            if (!reloc_howto){
+                    ;
+            /*  abort();    */  /* del tazaki 2001.10.11 */
+            }else{
+
+                size = bfd_get_reloc_size (reloc_howto);
+            
+                if (size != 2) {
+                    ;
+                /*  abort ();   */  /* del tazaki 2001.10.11 */
+                }else{
+    
+                    address = (f - frag_now->fr_literal) + 2 - size;
+        
+                    f += 2;
+                    
+                    fixP = fix_new_exp (frag_now, address, size,
+                              & fixups[i].exp, 
+                              reloc_howto->pc_relative,
+                              reloc);
+        
+                    switch (reloc)
+                    {
+                        case BFD_RELOC_C33_RH:
+                        case BFD_RELOC_C33_RM:
+                        case BFD_RELOC_C33_RL:
+                        case BFD_RELOC_C33_S_RH:    /* add T.Tazaki 2002.05.02 */
+                        case BFD_RELOC_C33_S_RM:    /* add T.Tazaki 2002.05.02 */
+                        case BFD_RELOC_C33_S_RL:    /* add T.Tazaki 2002.05.02 */
+                        case BFD_RELOC_C33_JP:      /* add T.Tazaki 2002.04.22 */
+                        case BFD_RELOC_C33_AH:
+                        case BFD_RELOC_C33_AL:
+                        case BFD_RELOC_C33_H:
+                        case BFD_RELOC_C33_M:
+                        case BFD_RELOC_C33_L:
+                        /* >>>> add 2002.03.05 tazaki */
+                        case BFD_RELOC_C33_DH:
+                        case BFD_RELOC_C33_DL:
+                        case BFD_RELOC_C33_GL:
+                        case BFD_RELOC_C33_SH:
+                        case BFD_RELOC_C33_SL:
+                        case BFD_RELOC_C33_TH:
+                        case BFD_RELOC_C33_TL:
+                        case BFD_RELOC_C33_ZH:
+                        case BFD_RELOC_C33_ZL:
+                        case BFD_RELOC_C33_DPH:
+                        case BFD_RELOC_C33_DPM:
+                        case BFD_RELOC_C33_DPL:
+                        case BFD_RELOC_C33_LOOP:
+                        /* <<<< add 2002.03.05 tazaki */
+                        case BFD_RELOC_C33_PUSHN_R0:	/*  add T.Tazaki 2004/08/19 */
+                        case BFD_RELOC_C33_PUSHN_R1:	/*  add T.Tazaki 2004/08/19 */
+                        case BFD_RELOC_C33_PUSH_R1:		/*  add T.Tazaki 2004/08/19 */
+                            fixP->fx_no_overflow = 1;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+        }
+        else
+        {
+            fix_new_exp (
+                   frag_now,
+                   f - frag_now->fr_literal, 4,
+                   & fixups[i].exp,
+                   1 /* FIXME: C33_OPERAND_RELATIVE ??? */,
+                   (bfd_reloc_code_real_type) (fixups[i].opindex
+                               + (int) BFD_RELOC_UNUSED)
+                   );
+        }
+    }
+
+    input_line_pointer = saved_input_line_pointer;
+}
+
+
+/* If while processing a fixup, a reloc really needs to be created */
+/* then it is done here.  */
+                 
+arelent *
+tc_gen_reloc (seg, fixp)
+     asection * seg;
+     fixS *     fixp;
+{
+  arelent * reloc;
+  
+  reloc              = (arelent *) xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr= symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address     = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->howto       = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+
+  if (reloc->howto == (reloc_howto_type *) NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+            /* xgettext:c-format */
+                    _("reloc %d not supported by object file format"),
+            (int) fixp->fx_r_type);
+
+      xfree (reloc);
+      
+      return NULL;
+    }
+  
+    reloc->addend = fixp->fx_addnumber;
+  
+  return reloc;
+}
+
+/* Assume everything will fit in two bytes, then expand as necessary.  */
+int
+md_estimate_size_before_relax (fragp, seg)
+     fragS * fragp;
+     asection * seg;
+{
+  if (fragp->fr_subtype == 0)
+    fragp->fr_var = 4;
+  else if (fragp->fr_subtype == 2)
+    fragp->fr_var = 2;
+  else
+    abort ();
+  return 2;
+} 
+
+long
+c33_pcrel_from_section (fixp, section)
+     fixS * fixp;
+     segT   section;
+{
+  /* If the symbol is undefined, or in a section other than our own,
+     or it is weak (in which case it may well be in another section,
+     then let the linker figure it out.  */
+  if (fixp->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixp->fx_addsy)
+      || S_IS_WEAK (fixp->fx_addsy)
+      || (S_GET_SEGMENT (fixp->fx_addsy) != section)))
+    return 0;
+  
+  return fixp->fx_frag->fr_address + fixp->fx_where;
+}
+
+/*
+The symbol which can be decided inside a file is decided here.
+
+The tc_gen_reloc function which is in bfd library further is passed,
+ and, finally the symbol changed by referring to the exterior, the link,
+  and relocation is on HOWTO broad view of bfd.
+  It is processed by the defined method. 
+*/
+
+/* add T.Tazaki 2002.04.25 >>> */
+long    g_where_rh = 0xffffffff;
+long    g_where_rm = 0xffffffff;
+
+char    *g_pwhere_rh = 0;
+char    *g_pwhere_rm = 0;
+
+/* add T.Tazaki 2002.04.25 <<< */
+
+int
+md_apply_fix3 (fixp, valuep, seg)
+     fixS *   fixp;
+     valueT * valuep;
+     segT     seg;
+{
+  valueT value;
+  char * where;
+    long    insn;
+    int     iNumber;    /* add T.Tazaki 2002.04.25 */
+    long    lNumber;    /* add T.Tazaki 2002.04.25 */
+    
+    if (fixp->fx_addsy == (symbolS *) NULL)
+    {
+        value = * valuep;
+        fixp->fx_done = 1;
+    }
+    else if (fixp->fx_pcrel)
+        value = * valuep;
+    else
+    {
+        value = fixp->fx_offset;
+        if (fixp->fx_subsy != (symbolS *) NULL)
+        {
+            if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
+                value -= S_GET_VALUE (fixp->fx_subsy);
+            else
+            {
+                 /* We don't actually support subtracting a symbol.  */
+                 as_bad_where (fixp->fx_file, fixp->fx_line,
+                    _("expression too complex"));
+            }
+        }
+    }
+
+    if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
+    {
+      int                         opindex;
+      const struct c33_operand * operand;
+      unsigned long               insn;
+
+      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
+      operand = & c33_operands[ opindex ];
+
+      /* Fetch the instruction, insert the fully resolved operand
+         value, and stuff the instruction back again.
+
+     Note the instruction has been stored in little endian
+     format!  */
+      where = fixp->fx_frag->fr_literal + fixp->fx_where;
+
+      insn = bfd_getl16 ((unsigned char *) where);
+      insn = c33_insert_operand (insn, operand, (offsetT) value,
+                  fixp->fx_file, fixp->fx_line, NULL);
+      bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
+
+        if (fixp->fx_done)
+        {
+          /* Nothing else to do here. */
+          return 1;
+        }
+    }
+    else if (fixp->fx_done)
+    {
+        /* We still have to insert the value into memory!  */
+        where = fixp->fx_frag->fr_literal + fixp->fx_where;
+
+        if (fixp->fx_size == 1)
+            * where = value & 0xff;
+        else if (fixp->fx_size == 2){
+
+            /* An address when a symbol is decided is buried here
+             and crowded with the inside of a file. */
+
+            /* A command code is acquired. */
+            insn = bfd_getl16 ((unsigned char *) where);
+
+            switch (fixp->fx_r_type)
+            {
+            case BFD_RELOC_C33_AH:  /* @ah (25:13) */   /* NO USE : Absolute symbol */
+                
+                insn += ((value >> 13) & 0x1fff);
+                break;
+                
+                case BFD_RELOC_C33_AL:  /* @ah (12:0) */    /* NO USE : Absolute symbol */
+                insn += (value & 0x1fff);
+                break;
+
+            case BFD_RELOC_C33_RH:  /* LABEL-PC(31:22) */
+//              if( g_listing == 0 ){       /* No -a option ? */
+//                  g_where_rh = fixp->fx_where;
+//              }
+//              else{
+//                  g_pwhere_rh = where;
+//              }
+//
+                insn += (((value - 4) >> 19) & 0x1ff8);
+                break;
+                
+            case BFD_RELOC_C33_RM:  /* LABEL-PC(21:9)  */
+
+//              if( g_listing == 0 ){       /* No -a option ? */
+//
+//                  g_where_rm = fixp->fx_where;
+//                  if( g_where_rh != ( fixp->fx_where - 2 ) ){ /* add T.Tazaki 2002.04.25 */
+//                      
+//                      lNumber = value;
+//                      /* over signed 22bit ? */
+//                          if ((lNumber - 2) > 0x1ffffe || (lNumber - 2 ) < -0x200000 ) 
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_where_rh = 0xffffffff;
+//              }
+//              else
+//              {
+//                  g_pwhere_rm = where;
+//                  if( g_pwhere_rh != ( where - 100 ) ){   /* add T.Tazaki 2002.05.02 */
+//                      
+//                      lNumber = value;
+//                      /* over signed 22bit ? */
+//                          if ((lNumber - 2) > 0x1ffffe || (lNumber - 2 ) < -0x200000 ) 
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_pwhere_rh = 0;
+//              }
+                insn += (((value - 2) >> 9) & 0x1fff);
+                break;
+
+            case BFD_RELOC_C33_RL:  /* LABEL-PC(8:0)   */
+
+// -al オプション付きのとき、where値が必ずしも@rm のＰＣ+100とは限らないため、不採用。
+// -al無し( fixp->fx_where )ではＯＫだが、-alの有無でワーニング表示が異なるのは変なので両方削除した。
+
+//              if( g_listing == 0 ){       /* No -a option ? */
+//
+//                  if( g_where_rm != ( fixp->fx_where - 2 ) ){ /* add T.Tazaki 2002.04.25 */
+//
+//                      lNumber = value;
+//                      /* over signed 8bit ? */
+//                          if (lNumber > 254 || lNumber < -256)
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_where_rh = 0xffffffff;
+//                  g_where_rm = 0xffffffff;
+//              }
+//              else
+//              {
+//
+//                  if( g_pwhere_rm != ( where - 100 ) ){   /* add T.Tazaki 2002.05.02 */
+//
+//                      lNumber = value;
+//                      /* over signed 8bit ? */
+//                          if (lNumber > 254 || lNumber < -256)
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_pwhere_rh = 0;
+//                  g_pwhere_rm = 0;
+//              }
+                
+                insn += ((value >> 1) & 0xff);
+                break;
+
+/* add T.Tazaki 2002.05.02 >>> */
+
+            case BFD_RELOC_C33_S_RH:    /* LABEL-PC(31:22) */   /* sjp,scall, xjp,xcall */
+                g_where_rh = fixp->fx_where;
+
+                insn += (((value - 4) >> 19) & 0x1ff8);
+                break;
+                
+            case BFD_RELOC_C33_S_RM:    /* LABEL-PC(21:9)  */   /* sjp,scall, xjp,xcall */
+
+                g_where_rm = fixp->fx_where;
+                if( g_where_rh != ( fixp->fx_where - 2 ) ){
+                    
+                    lNumber = value;
+                    /* over signed 22bit ? */
+                        if ((lNumber - 2) > 0x1ffffe || (lNumber - 2 ) < -0x200000 ) 
+                        as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+                        /* as_bad_where = ERROR */
+                }
+                g_where_rh = 0xffffffff;
+                insn += (((value - 2) >> 9) & 0x1fff);
+                break;
+
+            case BFD_RELOC_C33_S_RL:    /* LABEL-PC(8:0)   */   /* sjp,scall, xjp,xcall */
+
+                if( g_where_rm != ( fixp->fx_where - 2 ) ){
+
+                    lNumber = value;
+                    /* over signed 8bit ? */
+                        if (lNumber > 254 || lNumber < -256)
+                        as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+                        /* as_bad_where = ERROR */
+                }
+                g_where_rh = 0xffffffff;
+                g_where_rm = 0xffffffff;
+                
+                insn += ((value >> 1) & 0xff);
+                break;
+
+/* add T.Tazaki 2002.05.02 <<< */
+                    
+            case BFD_RELOC_C33_JP:  /* LABEL-PC(8:0)   */   /* add T.Tazaki 2002.04.22 */
+                /* jp label */
+
+                /* over signed 8bit ? */
+                iNumber = value;
+
+                if (iNumber > 254 || iNumber < -256)
+                     as_bad_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+
+                insn += ((value >> 1) & 0xff);
+                break;
+                    
+            case BFD_RELOC_C33_H:   /* LABEL(31:19) */  /* NO USE : Absolute symbol */
+                insn += ((value >> 19) & 0x1fff);
+                break;
+            
+            case BFD_RELOC_C33_M:   /* LABEL(18:6)  */  /* NO USE : Absolute symbol */
+                insn += ((value >> 6) & 0x1fff);
+                break;
+            
+            case BFD_RELOC_C33_L:   /* LABEL(5:0)   */  /* NO USE : Absolute symbol */
+                            /* ld.w rd,LABEL@l */
+                insn += (value & 0x3f) << 4;
+                break;
+
+            case BFD_RELOC_C33_LOOP:    /* LABEL-PC(4:0)   */
+
+                /* over imm 5bit ? */
+                iNumber = value;
+
+                if (iNumber > 30 || iNumber < 0)
+                     as_bad_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+
+				/* "   loop %rc,Label-2 " 表現は使用し辛いので、 "loop %rc,Label" を可能とするため-１する。 add T.Tazaki 2004/09/22 >>> */
+				/* "   nop              " */
+				/* "   nop              " */
+				/* "Label:              " */
+				
+				--value;
+
+				/* add T.Tazaki 2004/09/22 <<< */
+
+                /* imm5=imm(4:1) imm5(0)=0 */
+                insn += (value & 0x1e) << 3;
+                break;
+                    
+            default:
+                break;
+            }
+
+            bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
+        }
+        else if (fixp->fx_size == 4)
+            bfd_putl32 (value, (unsigned char *) where);
+    }
+
+    fixp->fx_addnumber = value;
+    
+    return 1;
+}
+
+
+/* Parse a cons expression.  */
+void
+parse_cons_expression_c33 (exp)
+  expressionS * exp;
+{
+  /* See if there's a reloc prefix like hi() we have to handle.  */
+  hold_cons_reloc = c33_reloc_prefix ();
+
+  /* Do normal expression parsing.  */
+  expression (exp);
+}
+
+/* Create a fixup for a cons expression.  If parse_cons_expression_c33
+   found a reloc prefix, then we use that reloc, else we choose an
+   appropriate one based on the size of the expression.  */
+void
+cons_fix_new_c33 (frag, where, size, exp)
+     fragS * frag;
+     int where;
+     int size;
+     expressionS *exp;
+{
+  if (hold_cons_reloc == BFD_RELOC_UNUSED)
+    {
+      if (size == 4)
+    hold_cons_reloc = BFD_RELOC_32;
+      if (size == 2)
+    hold_cons_reloc = BFD_RELOC_16;
+      if (size == 1)
+    hold_cons_reloc = BFD_RELOC_8;
+    }
+
+  if (exp != NULL)
+    fix_new_exp (frag, where, size, exp, 0, hold_cons_reloc);
+  else
+    fix_new (frag, where, size, NULL, 0, 0, hold_cons_reloc);
+}
+
+boolean
+c33_fix_adjustable (fixP)
+    fixS * fixP;
+{
+  if (fixP->fx_addsy == NULL)
+    return 1;
+ 
+  /* Prevent all adjustments to global symbols. */
+  if (S_IS_EXTERN (fixP->fx_addsy))
+    return 0;
+  
+  if (S_IS_WEAK (fixP->fx_addsy))
+    return 0;
+  
+  /* Don't adjust function names */
+  if (S_IS_FUNCTION (fixP->fx_addsy))
+    return 0;
+
+  return 1;
+}
+ 
+int
+c33_force_relocation (fixP)
+      struct fix * fixP;
+{
+  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
+    return 1;
+  
+  return 0;
+}
diff --git a/gas/config/tc-c33.c b/gas/config/tc-c33.c
new file mode 100644
index 0000000..3dd3b44
--- /dev/null
+++ b/gas/config/tc-c33.c
@@ -0,0 +1,5098 @@
+/* tc-c33.c -- Assembler code for the EPSON EOC33
+   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <stdio.h>
+#include <ctype.h>
+#include "as.h"
+#include "subsegs.h"     
+#include "opcode/c33.h"
+#include "ext_remove.h"				// add D.Fujimoto 2007/06/21
+
+#define AREA_CDA 0
+#define AREA_GDA 1
+#define AREA_ZDA 2
+#define AREA_SDA 3
+#define AREA_TDA 4
+#define AREA_LCDA 5
+#define AREA_LGDA 6
+#define AREA_LZDA 7
+#define AREA_LSDA 8
+#define AREA_LTDA 9
+
+
+#define O_spregister    O_md1   /* for c33 %sp */
+#define O_dpregister    O_md2   /* for c33 %dp */
+#define O_cond          O_md3   /* for c33 ext cond */
+#define O_op_shift      O_md4   /* for c33 ext OP */
+
+#define SGP_REG     12      /* GP register */
+#define TGP_REG     13      /* GP register */
+#define ZGP_REG     14      /* GP register */
+#define GP_REG      15      /* GP register */
+
+/* Temporarily holds the reloc in a cons expression.  */
+static bfd_reloc_code_real_type hold_cons_reloc;
+
+
+
+/* Structure to hold information about predefined registers.  */
+struct reg_name
+{
+  const char * name;
+  int          value;
+};
+
+/* Generic assembler global variables which must be defined by all targets. */
+
+/* Characters which always start a comment. */
+const char comment_chars[] = ";";
+
+/* Characters which start a comment at the beginning of a line.  */
+const char line_comment_chars[] = "";
+
+/* Characters which may be used to separate multiple commands on a 
+   single line.  */
+const char line_separator_chars[] = "";
+
+/* Characters which are used to indicate an exponent in a floating 
+   point number.  */
+const char EXP_CHARS[] = "eE";
+
+/* Characters which mean that a number is a floating point constant, 
+   as in 0d1.0.  */
+const char FLT_CHARS[] = "dD";
+
+
+const relax_typeS md_relax_table[] =
+{
+  /* Conditional branches.  */
+  {0xff,     -0x100,    2, 1},
+  {0x1fffff, -0x200000, 6, 0},
+  /* Unconditional branches.  */
+  {0xff,     -0x100,    2, 3},
+  {0x1fffff, -0x200000, 4, 0},
+};
+
+/* add tazaki 2001.12.03 */
+static segT comm_section = NULL;
+static segT gcomm_section = NULL;
+static segT scomm_section = NULL;
+static segT tcomm_section = NULL;
+static segT zcomm_section = NULL;
+static segT gbss_section = NULL;
+static segT sbss_section = NULL;
+static segT tbss_section = NULL;
+static segT zbss_section = NULL;
+/* add tazaki 2001.12.03 */
+
+/* add T.Tazaki 2002.04.26 >>> */
+extern int g_listing;
+/* add T.Tazaki 2002.04.26 <<< */
+
+/* fixups */
+#define MAX_INSN_FIXUPS (5)
+struct c33_fixup
+{
+  expressionS              exp;
+  int                      opindex;
+  bfd_reloc_code_real_type reloc;
+};
+
+struct c33_fixup fixups [MAX_INSN_FIXUPS];
+static int fc;
+
+
+
+/******************************************************************************
+    INPUT   int     area of symbol
+    RETURN  void
+    Explanation assembler false instruction(.gcomm/.scomm/.tcomm/.zcomm) Evaluation
+******************************************************************************/
+/* Copied from obj_elf_common() in gas/config/obj-elf.c */
+static void
+c33_comm (area)
+     int area;
+{
+    char *    name;
+    char      c;
+    char *    p;
+    int       temp;
+    int       size;
+    symbolS * symbolP;
+    int       have_align;
+     char * pfrag;
+
+    name = input_line_pointer;
+    c = get_symbol_end ();
+  
+    /* just after name is now '\0' */
+    p = input_line_pointer;
+    *p = c;
+  
+    /* skip space */
+    SKIP_WHITESPACE ();
+  
+    /* Is the character after ".comm" a pause character? */
+    if (*input_line_pointer != ',')
+    {
+        as_bad (_("Expected comma after symbol-name"));
+        ignore_rest_of_line ();
+        return;
+    }
+  
+    input_line_pointer ++;      /* skip ',' */
+  
+    if ((temp = get_absolute_expression ()) < 0)
+    {
+        /* xgettext:c-format */
+        as_bad (_(".COMMon length (%d.) < 0! Ignored."), temp);
+        ignore_rest_of_line ();
+        return;
+    }
+  
+    size = temp;
+    *p = 0;
+    symbolP = symbol_find_or_make (name);
+    *p = c;
+  
+/*  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))  */
+    if (S_IS_DEFINED (symbolP) )
+    {
+        as_bad (_("Ignoring attempt to re-define symbol"));
+        ignore_rest_of_line ();
+        return;
+    }
+  
+    if (S_GET_VALUE (symbolP) != 0)
+    {
+        if (S_GET_VALUE (symbolP) != size)
+        {
+            /* xgettext:c-format */
+            as_warn (_("Length of .comm \"%s\" is already %ld. Not changed to %d."),
+            S_GET_NAME (symbolP), (long) S_GET_VALUE (symbolP), size);
+        }
+    }
+  
+    know (symbol_get_frag (symbolP) == & zero_address_frag);
+  
+    if (*input_line_pointer != ',')
+        have_align = 0;
+    else
+    {
+        have_align = 1;
+        input_line_pointer++;
+        SKIP_WHITESPACE ();
+    }
+  
+    if (! have_align || *input_line_pointer != '"')
+    {
+        if (! have_align)
+            temp = 0;
+        else
+        {
+            temp = get_absolute_expression ();
+      
+        if (temp < 0)
+        {
+            temp = 0;
+            as_warn (_("Common alignment negative; 0 assumed"));
+        }
+    }
+ 
+
+/*  if (symbol_get_obj (symbolP)->local)*/
+    if (!(area == AREA_CDA || area == AREA_GDA || area == AREA_SDA || area == AREA_TDA || area == AREA_ZDA ))
+    {
+        /* NOT EXIST ROUTINE */
+        
+        segT   old_sec;
+        int    old_subsec;
+        int    align;
+        flagword    applicable;
+
+        old_sec = now_seg;
+        old_subsec = now_subseg;
+      
+        applicable = bfd_applicable_section_flags (stdoutput);
+          
+        applicable &= SEC_ALLOC;
+      
+        switch (area)
+        {
+        case AREA_CDA:
+          if (comm_section == NULL)
+          {
+
+              comm_section = subseg_new (".comm", 0);
+              
+              bfd_set_section_flags (stdoutput, comm_section, applicable);
+              
+              seg_info (comm_section)->bss = 1;
+          }
+          break;
+      
+        case AREA_GDA:
+          if (gcomm_section == NULL)
+          {
+              gcomm_section = subseg_new (".gcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, gcomm_section, applicable);
+              
+              seg_info (gcomm_section)->bss = 1;
+          }
+          break;
+      
+        case AREA_SDA:
+          if (scomm_section == NULL)
+          {
+              scomm_section = subseg_new (".scomm", 0);
+              
+              bfd_set_section_flags (stdoutput, scomm_section, applicable);
+              
+              seg_info (scomm_section)->bss = 1;
+          }
+          break;
+      
+        case AREA_TDA:
+          if (tcomm_section == NULL)
+          {
+              tcomm_section = subseg_new (".tcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, tcomm_section, applicable);
+              
+              seg_info (tcomm_section)->bss = 1;
+          }
+          break;
+
+        case AREA_ZDA:
+          if (zcomm_section == NULL)
+          {
+              zcomm_section = subseg_new (".zcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, zcomm_section, applicable);
+              
+              seg_info (zcomm_section)->bss = 1;
+          }
+          break;
+      
+        }
+
+        if (temp)
+        {
+            /* convert to a power of 2 alignment */
+            for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
+            ;
+              
+            if (temp != 1)
+            {
+                as_bad (_("Common alignment not a power of 2"));
+                ignore_rest_of_line ();
+                return;
+            }
+        }
+        else
+            align = 0;
+          
+        switch (area)
+        {
+        case AREA_CDA:
+            record_alignment (comm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (comm_section, 0);
+            break;
+
+        case AREA_GDA:
+            record_alignment (gcomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (gcomm_section, 0);
+            break;
+
+        case AREA_SDA:
+            record_alignment (scomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (scomm_section, 0);
+            break;
+
+        case AREA_TDA:
+            record_alignment (tcomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (tcomm_section, 0);
+            break;
+
+        case AREA_ZDA:
+            record_alignment (zcomm_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (zcomm_section, 0);
+            break;
+
+        default:
+            abort();
+        }
+          
+        if (align)
+            frag_align (align, 0, 0);
+
+        switch (area)
+        {
+        case AREA_CDA:
+          if (S_GET_SEGMENT (symbolP) == comm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_GDA:
+          if (S_GET_SEGMENT (symbolP) == gcomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_SDA:
+          if (S_GET_SEGMENT (symbolP) == scomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_TDA:
+          if (S_GET_SEGMENT (symbolP) == tcomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        case AREA_ZDA:
+          if (S_GET_SEGMENT (symbolP) == zcomm_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+          break;
+
+        default:
+          abort ();
+        }
+      
+        symbol_set_frag (symbolP, frag_now);
+        pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                (offsetT) size, (char *) 0);
+        *pfrag = 0;
+        S_SET_SIZE (symbolP, size);
+      
+        switch (area)
+        {
+        case AREA_CDA:
+          S_SET_SEGMENT (symbolP, comm_section);
+          break;
+          
+        case AREA_GDA:
+          S_SET_SEGMENT (symbolP, gcomm_section);
+          break;
+          
+        case AREA_SDA:
+          S_SET_SEGMENT (symbolP, scomm_section);
+          break;
+          
+        case AREA_TDA:
+          S_SET_SEGMENT (symbolP, tcomm_section);
+          break;
+          
+        case AREA_ZDA:
+          S_SET_SEGMENT (symbolP, zcomm_section);
+          break;
+          
+        default:
+          abort();
+        }
+            
+        if (symbol_get_obj (symbolP)->local)
+            S_CLEAR_EXTERNAL (symbolP);
+        else
+            S_SET_EXTERNAL (symbolP);
+        
+        obj_elf_section_change_hook();
+        subseg_set (old_sec, old_subsec);
+    }
+    else
+    {
+        /*==========================================================================*/
+        /* Evaluation of .comm                                                      */
+        /*==========================================================================*/
+        segT   old_sec;
+        int    old_subsec;
+        int    align;
+        int    i_now_align; /* add 2002.01.21 */
+        i_now_align = temp; /* add 2002.01.21 */
+
+        /* computing of alignment */
+        if (temp)
+        {
+            /* convert to a power of 2 alignment */
+            for (align = 0; (temp & 1) == 0; temp >>= 1, ++align)
+            ;
+              
+            if (temp != 1)
+            {
+                as_bad (_("Common alignment not a power of 2"));
+                ignore_rest_of_line ();
+                return;
+            }
+        }
+        else
+            align = 0;
+
+        old_sec = now_seg;
+        old_subsec = now_subseg;
+
+        allocate_common:
+        
+        /* Convert .local + .xcomm to local section. */
+
+        if (symbol_get_obj (symbolP)->local){
+            switch (area)
+            {
+            case AREA_CDA:
+                    area = AREA_LCDA;
+                    break;
+            case AREA_GDA:
+                    area = AREA_LGDA;
+                    break;
+            case AREA_SDA:
+                    area = AREA_LSDA;
+                    break;
+            case AREA_TDA:
+                    area = AREA_LTDA;
+                    break;
+            case AREA_ZDA:
+                    area = AREA_LZDA;
+                    break;
+            }
+        }
+      
+        switch (area)
+        {
+        case AREA_CDA:
+          if (comm_section == NULL)
+            {
+                flagword    applicable;
+                  
+                applicable = bfd_applicable_section_flags (stdoutput);
+
+                comm_section = subseg_new (".comm", 0);
+
+                bfd_set_section_flags (stdoutput, comm_section, applicable
+                   & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                  | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, comm_section);
+            record_alignment (comm_section, align);
+
+          break;
+          
+        case AREA_GDA:
+          if (gcomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              gcomm_section = subseg_new (".gcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, gcomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, gcomm_section);
+            record_alignment (gcomm_section, align);
+          break;
+          
+        case AREA_SDA:
+          if (scomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              scomm_section = subseg_new (".scomm", 0);
+              
+              bfd_set_section_flags (stdoutput, scomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, scomm_section);
+            record_alignment (scomm_section, align);
+          break;
+          
+        case AREA_TDA:
+          if (tcomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              tcomm_section = subseg_new (".tcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, tcomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, tcomm_section);
+            record_alignment (tcomm_section, align);
+          break;
+          
+        case AREA_ZDA:
+          if (zcomm_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              zcomm_section = subseg_new (".zcomm", 0);
+              
+              bfd_set_section_flags (stdoutput, zcomm_section, applicable
+                 & (SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA
+                | SEC_HAS_CONTENTS) | SEC_IS_COMMON);
+            }
+            S_SET_SEGMENT (symbolP, zcomm_section);
+            record_alignment (zcomm_section, align);
+          break;
+          
+          
+        case AREA_LCDA:
+            /* Convert local comm to .bss section. */
+            obj_elf_section_change_hook();
+            subseg_set (bss_section, 0);
+
+            if (S_GET_SEGMENT (symbolP) == bss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, bss_section);
+            record_alignment (bss_section, align);
+
+            break;
+          
+        case AREA_LGDA:
+          if (gbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              gbss_section = subseg_new (".gbss", 0);
+              
+              bfd_set_section_flags (stdoutput, gbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (gbss_section)->bss = 1;
+            }
+
+            record_alignment (gbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (gbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == gbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, gbss_section);
+
+            break;
+          
+        case AREA_LSDA:
+          if (sbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              sbss_section = subseg_new (".sbss", 0);
+              
+              bfd_set_section_flags (stdoutput, sbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (sbss_section)->bss = 1;
+            }
+
+            record_alignment (sbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (sbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == sbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, sbss_section);
+
+            break;
+          
+        case AREA_LTDA:
+          if (tbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              tbss_section = subseg_new (".tbss", 0);
+              
+              bfd_set_section_flags (stdoutput, tbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (tbss_section)->bss = 1;
+            }
+
+            record_alignment (tbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (tbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == tbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, tbss_section);
+
+            break;
+
+        case AREA_LZDA:
+          if (zbss_section == NULL)
+            {
+              flagword  applicable;
+              
+              applicable = bfd_applicable_section_flags (stdoutput);
+              
+              zbss_section = subseg_new (".zbss", 0);
+              
+              bfd_set_section_flags (stdoutput, zbss_section, applicable & SEC_ALLOC);
+              
+              seg_info (zbss_section)->bss = 1;
+            }
+
+            record_alignment (zbss_section, align);
+            obj_elf_section_change_hook();
+            subseg_set (zbss_section, 0);
+
+            if (align)
+                frag_align (align, 0, 0);
+
+            if (S_GET_SEGMENT (symbolP) == zbss_section)
+                symbol_get_frag (symbolP)->fr_symbol = 0;
+
+            symbol_set_frag (symbolP, frag_now);
+            pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
+                    (offsetT) size, (char *) 0);
+            *pfrag = 0;
+            S_SET_SIZE (symbolP, size);
+            S_SET_SEGMENT (symbolP, zbss_section);
+
+            break;
+
+        default:
+          abort();
+        }
+
+        if (area == AREA_LCDA || area == AREA_LGDA || area == AREA_LSDA || area == AREA_LTDA || area == AREA_LZDA) /* ローカル？ */
+        {
+            S_CLEAR_EXTERNAL (symbolP);
+        }else{
+            S_SET_VALUE (symbolP, (valueT) size);
+//          S_SET_ALIGN (symbolP, temp);
+            if( i_now_align )
+                S_SET_ALIGN (symbolP, i_now_align);
+            S_SET_EXTERNAL (symbolP);
+        }
+
+        obj_elf_section_change_hook();
+        subseg_set (old_sec, old_subsec);
+
+    }
+}
+  else
+    {
+      input_line_pointer++;
+      /* @@ Some use the dot, some don't.  Can we get some consistency??  */
+      if (*input_line_pointer == '.')
+    input_line_pointer++;
+      /* @@ Some say data, some say bss.  */
+      if (strncmp (input_line_pointer, "bss\"", 4)
+      && strncmp (input_line_pointer, "data\"", 5))
+    {
+      while (*--input_line_pointer != '"')
+        ;
+      input_line_pointer--;
+      goto bad_common_segment;
+    }
+      while (*input_line_pointer++ != '"')
+    ;
+      goto allocate_common;
+    }
+
+  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;
+
+  demand_empty_rest_of_line ();
+  return;
+
+  {
+  bad_common_segment:
+    p = input_line_pointer;
+    while (*p && *p != '\n')
+      p++;
+    c = *p;
+    *p = '\0';
+    as_bad (_("bad .common segment %s"), input_line_pointer + 1);
+    *p = c;
+    input_line_pointer = p;
+    ignore_rest_of_line ();
+    return;
+  }
+}
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  {"comm",    c33_comm,    AREA_CDA},
+  {"gcomm",   c33_comm,    AREA_GDA},
+  {"scomm",   c33_comm,    AREA_SDA},
+  {"tcomm",   c33_comm,    AREA_TDA},
+  {"zcomm",   c33_comm,    AREA_ZDA},
+  { NULL,     NULL,        0}
+};
+
+/*****************************************************************************/
+
+
+
+/* Opcode hash table.  */
+static struct hash_control *c33_hash;
+
+/* This table is sorted. Suitable for searching by a binary search. */
+static const struct reg_name pre_defined_registers[] =
+{
+  { "%r0",   0 },
+  { "%r1",   1 },
+  { "%r10", 10 },
+  { "%r11", 11 },
+  { "%r12", 12 },
+  { "%r13", 13 },
+  { "%r14", 14 },
+  { "%r15", 15 },
+  { "%r2",   2 },
+  { "%r3",   3 },
+  { "%r4",   4 },
+  { "%r5",   5 },
+  { "%r6",   6 },
+  { "%r7",   7 },
+  { "%r8",   8 },
+  { "%r9",   9 },
+};
+#define REG_NAME_CNT    (sizeof (pre_defined_registers) / sizeof (struct reg_name))
+
+/* standard macro spesial registers */
+static const struct reg_name system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%psr",   0 },
+    { "%sp",    1 },
+};
+
+/* advanced macro spesial registers */
+static const struct reg_name adv_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%dp",    9 },        /* Adv */
+    { "%idir",  10 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%lco",   4 },        /* Adv */
+    { "%lea",   6 },        /* Adv */
+    { "%lsa",   5 },        /* Adv */
+    { "%pc",    15},
+    { "%psr",   0 },
+    { "%sor",   7 },        /* Adv */
+    { "%sp",    1 },
+    { "%ssp",   14 },       /* Adv */
+    { "%ttbr",  8 },        /* Adv */
+    { "%usp",   13 },       /* Adv */
+};
+
+/* ld.w %sd,%rs special registers */
+static const struct reg_name adv_load_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%dp",    9 },        /* Adv */
+    { "%idir",  10 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%lco",   4 },        /* Adv */
+    { "%lea",   6 },        /* Adv */
+    { "%lsa",   5 },        /* Adv */
+    { "%psr",   0 },
+    { "%sor",   7 },        /* Adv */
+    { "%sp",    1 },
+    { "%ssp",   14 },       /* Adv */
+    { "%ttbr",  8 },        /* Adv */
+    { "%usp",   13 },       /* Adv */
+};
+
+/* pushs , pops special registers */
+static const struct reg_name adv_pushs_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%dp",    9 },        /* Adv */
+    { "%idir",  10 },		/* Adv 	add T.Tazaki 2003/11/18 */
+    { "%lco",   4 },        /* Adv */
+    { "%lea",   6 },        /* Adv */
+    { "%lsa",   5 },        /* Adv */
+    { "%pc",    15 },
+    { "%psr",   0 },
+    { "%sor",   7 },        /* Adv */
+    { "%sp",    1 },
+    { "%ssp",   14 },       /* Adv */
+    { "%ttbr",  8 },        /* Adv */
+    { "%usp",   13 },       /* Adv */
+};
+
+/* PE  add T.Tazaki 2003/11/18 >>> */
+
+/* PE macro spesial registers */
+static const struct reg_name pe_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%dbbr",  11 },
+    { "%idir",  10 },
+    { "%pc",    15},
+    { "%psr",   0 },
+    { "%sp",    1 },
+    { "%ttbr",  8 },
+};
+
+/* ld.w %sd,%rs special registers */
+static const struct reg_name pe_load_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+    { "%psr",   0 },
+    { "%sp",    1 },
+    { "%ttbr",  8 },
+};
+
+/* pushs , pops special registers */
+static const struct reg_name pe_pushs_system_registers[] = 
+{
+    { "%ahr",   3 },
+    { "%alr",   2 },
+};
+
+/* PE  add T.Tazaki 2003/11/18 <<< */
+
+#define SYSREG_NAME_CNT             (sizeof (system_registers) / sizeof (struct reg_name))
+#define ADV_SYSREG_NAME_CNT         (sizeof (adv_system_registers) / sizeof (struct reg_name))
+#define ADV_LOAD_SYSREG_NAME_CNT    (sizeof (adv_load_system_registers) / sizeof (struct reg_name))
+#define ADV_PUSHS_SYSREG_NAME_CNT   (sizeof (adv_pushs_system_registers) / sizeof (struct reg_name))
+
+/* PE  add T.Tazaki 2003/11/18 >>> */
+#define PE_SYSREG_NAME_CNT         (sizeof (pe_system_registers) / sizeof (struct reg_name))
+#define PE_LOAD_SYSREG_NAME_CNT    (sizeof (pe_load_system_registers) / sizeof (struct reg_name))
+#define PE_PUSHS_SYSREG_NAME_CNT   (sizeof (pe_pushs_system_registers) / sizeof (struct reg_name))
+/* PE  add T.Tazaki 2003/11/18 <<< */
+
+/******************************************************************************
+    INPUT   const struct reg_name * register name
+            int                     register string size
+            const char *            check register string
+            boolean                 not used
+    RETURN  int                     register number
+    Explanation Get register number
+******************************************************************************/
+/* reg_name_search does a binary search of the given register table
+   to see if "name" is a valid regiter name.  Returns the register
+   number from the array on success, or -1 on failure. */
+
+static int
+reg_name_search (regs, regcount, name, accept_numbers)
+     const struct reg_name * regs;
+     int                     regcount;
+     const char *            name;
+     boolean                 accept_numbers;
+{
+  int middle, low, high;
+  int cmp;
+  symbolS * symbolP;
+#if 0
+  /* If the register name is a symbol, then evaluate it.  */
+  if ((symbolP = symbol_find (name)) != NULL)
+    {
+      /* If the symbol is an alias for another name then use that.
+     If the symbol is an alias for a number, then return the number.  */
+      if (symbol_equated_p (symbolP))
+    {
+      name = S_GET_NAME (symbol_get_value_expression (symbolP)->X_add_symbol);
+    }
+      else if (accept_numbers)
+    {
+      int reg = S_GET_VALUE (symbolP);
+      
+      if (reg >= 0 && reg <= 31)
+        return reg;
+    }
+#endif
+
+    low = 0;
+    high = regcount - 1;
+
+    do
+    {
+        middle = (low + high) / 2;
+        cmp = strcasecmp (name, regs[middle].name);
+        if (cmp < 0)
+            high = middle - 1;
+        else if (cmp > 0)
+            low = middle + 1;
+        else
+            return regs[middle].value;
+    }
+    while (low <= high);
+
+    return -1;
+}
+
+
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation A register operand is changed into a command code.
+******************************************************************************/
+/* Summary of register_name().
+ *
+ * in: Input_line_pointer points to 1st char of operand.
+ *
+ * out: A expressionS.
+ *  The operand may have been a register: in this case, X_op == O_register,
+ *  X_add_number is set to the register number, and truth is returned.
+ *  Input_line_pointer->(next non-blank) char after operand, or is in
+ *  its original state.
+ */
+static boolean
+register_name (expressionP)
+     expressionS * expressionP;
+{
+  int    reg_number;
+  char * name;
+  char * start;
+  char   c;
+    char *pNameEnd;
+    
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* Get register number */
+    reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT,
+                name, FALSE);
+
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+    /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+    /* YES The right register number was acquirable. */
+
+        /* That it is a register and a register number are saved. */
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+    /* 不正 */
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+         
+        return false;
+    }
+}
+
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+            boolean
+            boolean
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation     A system register operand is changed into a command code.
+******************************************************************************/
+/* Summary of system_register_name().
+ *
+ * in:  Input_line_pointer points to 1st char of operand.
+ *      expressionP points to an expression structure to be filled in.
+ *      accept_numbers is true iff numerical register names may be used.
+ *      accept_list_names is true iff the special names PS and SR may be 
+ *      accepted.
+ *
+ * out: A expressionS structure in expressionP.
+ *  The operand may have been a register: in this case, X_op == O_register,
+ *  X_add_number is set to the register number, and truth is returned.
+ *  Input_line_pointer->(next non-blank) char after operand, or is in
+ *  its original state.
+ */
+static boolean
+system_register_name (expressionP, accept_numbers, accept_list_names)
+     expressionS * expressionP;
+     boolean       accept_numbers;
+     boolean       accept_list_names;
+{
+    int    reg_number;
+    char * name;
+    char * start;
+    char   c;
+
+
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* get register number */
+    if( g_iAdvance == 0 )
+    {
+	    if( g_iPE == 0 )
+	    {
+			/* STD */
+	        reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+	    else
+	    {
+			/* PE */	/* add T.Tazaki 2003/11/18 */
+	        reg_number = reg_name_search (pe_system_registers, PE_SYSREG_NAME_CNT, name,
+	                accept_numbers);
+		}
+    }else{
+        /* add tazaki 2001.11.12 */
+        /* ADV */
+        reg_number = reg_name_search (adv_system_registers, ADV_SYSREG_NAME_CNT, name,
+                accept_numbers);
+    }
+    
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+#if 0
+    if (reg_number < 0 && accept_numbers)
+    {
+        input_line_pointer   = start; /* reset input_line pointer */
+
+        if (isdigit (* input_line_pointer))
+        {
+            reg_number = strtol (input_line_pointer, & input_line_pointer, 10);
+
+            /* Make sure that the register number is allowable. */
+            if (   reg_number < 0
+                 || reg_number > 5
+                 && reg_number < 16
+                 || reg_number > 20
+                 )
+                {
+                reg_number = -1;
+            }
+        }
+        else if (accept_list_names)
+        {
+            c = get_symbol_end ();
+
+#if 0   /* c33 */
+            reg_number = reg_name_search (system_list_registers,
+                    SYSREGLIST_NAME_CNT, name, FALSE);
+#endif
+            * input_line_pointer = c;   /* put back the delimiting char */
+
+        }
+    }
+#endif
+      /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+
+        return false;
+    }
+}
+
+
+CONST char * md_shortopts = "m:";
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof md_longopts; 
+
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+            boolean
+            boolean
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation     A system register operand is changed into a command code.
+                    false : ld.w %pc,%rs
+******************************************************************************/
+static boolean
+load_system_register_name (expressionP, accept_numbers, accept_list_names)
+     expressionS * expressionP;
+     boolean       accept_numbers;
+     boolean       accept_list_names;
+{
+    int    reg_number;
+    char * name;
+    char * start;
+    char   c;
+
+
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* get register number */
+    if( g_iAdvance == 0 )
+    {
+	    if( g_iPE == 0 )
+	    {
+			/* STD */
+	        reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+	    else
+	    {
+			/* PE 	add T.Tazaki 2003/11/18 */
+	        reg_number = reg_name_search (pe_load_system_registers, PE_LOAD_SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+    }else{
+		/* ADV */
+        reg_number = reg_name_search (adv_load_system_registers, ADV_LOAD_SYSREG_NAME_CNT, name,
+                accept_numbers);
+    }
+    
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+    /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+
+        return false;
+    }
+}
+/******************************************************************************
+    INPUT   expressionS *   The pointer to a command code information structure object
+            boolean
+            boolean
+    RETURN  boolean     TRUE    ok
+                        FALSE   error
+    Explanation     A system register operand is changed into a command code.
+                    true : pushs %psr,%sp,%alr,%ahr,%lco,%lsa,%lea,%sor,%ttbr,%dp,%usp,%ssp,%pc
+******************************************************************************/
+static boolean
+pushs_system_register_name (expressionP, accept_numbers, accept_list_names)
+     expressionS * expressionP;
+     boolean       accept_numbers;
+     boolean       accept_list_names;
+{
+    int    reg_number;
+    char * name;
+    char * start;
+    char   c;
+
+
+    /* Find the spelling of the operand */
+    start = name = input_line_pointer;
+
+    c = get_symbol_end ();
+
+    /* get register number */
+    if( g_iAdvance == 0 )
+    {
+	    if( g_iPE == 0 )
+	    {
+			/* STD */
+	        reg_number = reg_name_search (system_registers, SYSREG_NAME_CNT, name,
+	                accept_numbers);
+		}
+		else
+		{
+			/* PE	add T.Tazaki 2003/11/18 */
+	        reg_number = reg_name_search (pe_pushs_system_registers, PE_PUSHS_SYSREG_NAME_CNT, name,
+	                accept_numbers);
+	    }
+    }else{
+		/* ADV */
+        reg_number = reg_name_search (adv_pushs_system_registers, ADV_PUSHS_SYSREG_NAME_CNT, name,
+                accept_numbers);
+    }
+    
+    * input_line_pointer = c;   /* put back the delimiting char */
+
+    /* look to see if it's in the register table */
+    if (reg_number >= 0) 
+    {
+        expressionP->X_op         = O_register;
+        expressionP->X_add_number = reg_number;
+
+        /* make the rest nice */
+        expressionP->X_add_symbol = NULL;
+        expressionP->X_op_symbol  = NULL;
+
+        return true;
+    }
+    else
+    {
+        /* reset the line as if we had not done anything */
+        input_line_pointer = start;
+
+        return false;
+    }
+}
+
+/******************************************************************************
+    INPUT   FILE*   not used
+    RETURN  void
+    Explanation display option
+******************************************************************************/
+void
+md_show_usage (stream)
+  FILE * stream;
+{
+    /* The special option for c33 is nothing. */
+}
+
+/******************************************************************************
+    INPUT   int     not used
+            char*   not used
+    RETURN  int     TRUE    ok
+    Explanation     Argument (option) analysis
+******************************************************************************/
+int
+md_parse_option (c, arg)
+     int    c;
+     char * arg;
+{
+#if 0
+    int Num;
+    int i;
+    if (c != 'm')
+    {
+      /* xgettext:c-format */
+      fprintf (stderr, _("unknown command line option: -%c%s\n"), c, arg);
+      return 0;
+    }
+
+#endif
+  return 1;
+}
+
+/******************************************************************************
+    INPUT   char*       not used
+    RETURN  symbolS*    NULL
+    Explanation Treatment of the symbol which is not defined
+******************************************************************************/
+symbolS *
+md_undefined_symbol (name)
+  char * name;
+{
+  return 0;
+}
+
+char *
+md_atof (type, litp, sizep)
+  int    type;
+  char * litp;
+  int *  sizep;
+{
+  int            prec;
+  LITTLENUM_TYPE words[4];
+  char *         t;
+  int            i;
+
+  switch (type)
+    {
+    case 'f':
+      prec = 2;
+      break;
+
+    case 'd':
+      prec = 4;
+      break;
+
+    default:
+      *sizep = 0;
+      return _("bad call to md_atof");
+    }
+  
+  t = atof_ieee (input_line_pointer, type, words);
+  if (t)
+    input_line_pointer = t;
+
+  *sizep = prec * 2;
+
+  for (i = prec - 1; i >= 0; i--)
+    {
+      md_number_to_chars (litp, (valueT) words[i], 2);
+      litp += 2;
+    }
+
+  return NULL;
+}
+
+
+/* Very gross.  */
+void
+md_convert_frag (abfd, sec, fragP)
+  bfd *      abfd;
+  asection * sec;
+  fragS *    fragP;
+{
+  subseg_change (sec, 0);
+  
+  /* In range conditional or unconditional branch.  */
+  if (fragP->fr_subtype == 0 || fragP->fr_subtype == 2)
+    {
+      fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol,
+           fragP->fr_offset, 1, BFD_RELOC_UNUSED + (int)fragP->fr_opcode);
+      fragP->fr_var = 0;
+      fragP->fr_fix += 2;
+    }
+  /* Out of range conditional branch.  Emit a branch around a jump.  */
+  else if (fragP->fr_subtype == 1)
+    {
+      unsigned char *buffer = 
+    (unsigned char *) (fragP->fr_fix + fragP->fr_literal);
+
+      /* Reverse the condition of the first branch.  */
+      buffer[0] ^= 0x08;
+      /* Mask off all the displacement bits.  */
+      buffer[0] &= 0x8f;
+      buffer[1] &= 0x07;
+      /* Now set the displacement bits so that we branch
+     around the unconditional branch.  */
+      buffer[0] |= 0x30;
+
+      /* Now create the unconditional branch + fixup to the final
+     target.  */
+      md_number_to_chars (buffer + 2, 0x00000780, 4);
+      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
+           fragP->fr_offset, 1, BFD_RELOC_UNUSED +
+           (int) fragP->fr_opcode + 1);
+      fragP->fr_var = 0;
+      fragP->fr_fix += 6;
+    }
+  /* Out of range unconditional branch.  Emit a jump.  */
+  else if (fragP->fr_subtype == 3)
+    {
+      md_number_to_chars (fragP->fr_fix + fragP->fr_literal, 0x00000780, 4);
+      fix_new (fragP, fragP->fr_fix, 4, fragP->fr_symbol,
+           fragP->fr_offset, 1, BFD_RELOC_UNUSED +
+           (int) fragP->fr_opcode + 1);
+      fragP->fr_var = 0;
+      fragP->fr_fix += 4;
+    }
+  else
+    abort ();
+}
+
+valueT
+md_section_align (seg, addr)
+     asection * seg;
+     valueT     addr;
+{
+  int align = bfd_get_section_alignment (stdoutput, seg);
+  return ((addr + (1 << align) - 1) & (-1 << align));
+}
+
+/******************************************************************************
+    INPUT   NONE
+    RETURN  void
+    Explanation An assembler initial cofiguration peculiar to a model
+******************************************************************************/
+void
+md_begin ()
+{
+  char *                              prev_name = "";
+  register const struct c33_opcode * op;
+  flagword                            applicable;
+
+    /* Create hash table */
+  c33_hash = hash_new();
+
+  /* Insert unique names into hash table.  The C33 instruction set
+     has many identical opcode names that have different opcodes based
+     on the operands.  This hash table then provides a quick index to
+     the first opcode with a particular name in the opcode table.  */
+
+    /* nemonic registered into the operation code table is registered into a hash table.*/
+    
+    /* >>>>>> tazaki 2001.11.07 */
+    if( g_iAdvance == 0 )		/* cpu = standard ? */
+    {  
+    	if( g_iPE == 0 )
+    	{
+			if( g_iMedda32 == 0 )
+			{
+		        op = c33_opcodes;           /* STANDARD table */
+		    }
+		    else
+		    {
+		        op = c33_opcodes32;         /* STANDARD table : No use default data area  add T.Tazaki 2004/07/30 */
+		    }
+	    }
+	    else
+	    {
+			if( g_iMedda32 == 0 )
+			{
+		        op = c33_pe_opcodes;  	    /* PE table 	add T.Tazaki 2003/11/18 */
+			}
+			else
+			{
+		        op = c33_pe_opcodes32;      /* PE table : No use default data area  add T.Tazaki 2004/07/30 */
+		    }
+		}
+    }
+    else
+    {
+		if( g_iMedda32 == 0 )
+		{
+	        op = c33_advance_opcodes;       /* ADVANCE table */
+	    }
+	    else
+	    {
+	        op = c33_advance_opcodes32;     /* ADVANCE table : No use default data area  add T.Tazaki 2004/07/30 */
+		}
+    }
+    /* <<<<<< tazaki 2001.11.07 */
+    
+    while (op->name)
+    {
+        if (strcmp (prev_name, op->name)) 
+        {
+            prev_name = (char *) op->name;
+            hash_insert (c33_hash, op->name, (char *) op);
+        }
+        op++;
+    }
+#if 0   /* c33 */
+  bfd_set_arch_mach (stdoutput, TARGET_ARCH, machine);
+#endif  /* c33 */
+
+    applicable = bfd_applicable_section_flags (stdoutput);
+}
+
+/******************************************************************************
+    INPUT   int     NONE
+    RETURN  bfd_reloc_code_real_type
+    Explanation analysys symbol mask
+******************************************************************************/
+/* Warning: The code in this function relies upon the definitions
+   in the c33_operands[] array (defined in opcodes/c33-opc.c)
+   matching the hard coded values contained herein.  */
+
+static bfd_reloc_code_real_type
+c33_reloc_prefix ()
+{
+    
+    /* Is it the prefix of a symbol mask? */
+    if (*input_line_pointer == '@'){
+        input_line_pointer++;
+    }else{
+
+        /* NO  */
+        return BFD_RELOC_UNUSED;
+    }
+#define CHECK_(name, reloc)                                             \
+    if (strncmp (input_line_pointer, name, strlen (name) ) == 0)    \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+        return reloc;                                           \
+    }
+        
+    CHECK_ ("ah",   BFD_RELOC_C33_AH);      /* LABEL(25:13) */
+    CHECK_ ("al",   BFD_RELOC_C33_AL);      /* LABEL(12:0)  */
+    CHECK_ ("rh",   BFD_RELOC_C33_RH);      /* <LABEL-PC>(32:22)    */
+    CHECK_ ("rm",   BFD_RELOC_C33_RM);      /* <LABEL-PC>(21:9) */
+    CHECK_ ("rl",   BFD_RELOC_C33_RL);      /* <LABEL-PC>(8:0)  */
+    CHECK_ ("h",    BFD_RELOC_C33_H);       /* LABEL(31:19) */
+    CHECK_ ("m",    BFD_RELOC_C33_M);       /* LABEL(18:6)  */
+    CHECK_ ("l",    BFD_RELOC_C33_L);       /* LABEL(5:0)   */
+
+    CHECK_ ("AH",   BFD_RELOC_C33_AH);      /* LABEL(25:13) */
+    CHECK_ ("AL",   BFD_RELOC_C33_AL);      /* LABEL(12:0)  */
+    CHECK_ ("RH",   BFD_RELOC_C33_RH);      /* <LABEL-PC>(32:22)    */
+    CHECK_ ("RM",   BFD_RELOC_C33_RM);      /* <LABEL-PC>(21:9) */
+    CHECK_ ("RL",   BFD_RELOC_C33_RL);      /* <LABEL-PC>(8:0)  */
+    CHECK_ ("H",    BFD_RELOC_C33_H);       /* LABEL(31:19) */
+    CHECK_ ("M",    BFD_RELOC_C33_M);       /* LABEL(18:6)  */
+    CHECK_ ("L",    BFD_RELOC_C33_L);       /* LABEL(5:0)   */
+
+    return BFD_RELOC_UNUSED;
+}
+
+/* add tazaki 2001.12.03 >>>>> */
+
+/* Warning: The code in this function relies upon the definitions
+   in the c33_operands[] array (defined in opcodes/c33-opc.c)
+   matching the hard coded values contained herein.  */
+
+/******************************************************************************
+    INPUT   int     NONE
+    RETURN  bfd_reloc_code_real_type
+    Explanation analisys symbol offset
+******************************************************************************/
+static bfd_reloc_code_real_type
+c33_reloc_prefix_offset ()
+{
+  boolean paren_skipped = false;
+
+
+
+/* Modify name## --> name : for gcc-3.3.6  T.Tazaki 2005/08/04 */
+#define CHECK2_(name, reloc)                                            \
+    if (strncmp (input_line_pointer, name"(", strlen (name) + 1 ) == 0)   \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+            return reloc;                                           \
+    }
+
+    CHECK2_ ("doff_hi",   BFD_RELOC_C33_DH);        /* (symbol - default data pointer)  */
+    CHECK2_ ("doff_lo",   BFD_RELOC_C33_DL);        /* (symbol - default data pointer)  */
+    CHECK2_ ("goff_lo",   BFD_RELOC_C33_GL);        /* (symbol - g data pointer)    */
+    CHECK2_ ("soff_hi",   BFD_RELOC_C33_SH);        /* (symbol - s data pointer)    */
+    CHECK2_ ("soff_lo",   BFD_RELOC_C33_SL);        /* (symbol - s data pointer)    */
+    CHECK2_ ("toff_hi",   BFD_RELOC_C33_TH);        /* (symbol - t data pointer)    */
+    CHECK2_ ("toff_lo",   BFD_RELOC_C33_TL);        /* (symbol - t data pointer)    */
+    CHECK2_ ("zoff_hi",   BFD_RELOC_C33_ZH);        /* (symbol - z data pointer)    */
+    CHECK2_ ("zoff_lo",   BFD_RELOC_C33_ZL);        /* (symbol - z data pointer)    */
+    CHECK2_ ("dpoff_h",   BFD_RELOC_C33_DPH);       /* (symbol - default data pointer)  */
+    CHECK2_ ("dpoff_m",   BFD_RELOC_C33_DPM);       /* (symbol - default data pointer)  */
+    CHECK2_ ("dpoff_l",   BFD_RELOC_C33_DPL);       /* (symbol - default data pointer)  */
+
+    CHECK2_ ("DOFF_HI",   BFD_RELOC_C33_DH);        /* (symbol - default data pointer)  */
+    CHECK2_ ("DOFF_LO",   BFD_RELOC_C33_DL);        /* (symbol - default data pointer)  */
+    CHECK2_ ("GOFF_LO",   BFD_RELOC_C33_GL);        /* (symbol - g data pointer)    */
+    CHECK2_ ("SOFF_HI",   BFD_RELOC_C33_SH);        /* (symbol - s data pointer)    */
+    CHECK2_ ("SOFF_LO",   BFD_RELOC_C33_SL);        /* (symbol - s data pointer)    */
+    CHECK2_ ("TOFF_HI",   BFD_RELOC_C33_TH);        /* (symbol - t data pointer)    */
+    CHECK2_ ("TOFF_LO",   BFD_RELOC_C33_TL);        /* (symbol - t data pointer)    */
+    CHECK2_ ("ZOFF_HI",   BFD_RELOC_C33_ZH);        /* (symbol - z data pointer)    */
+    CHECK2_ ("ZOFF_LO",   BFD_RELOC_C33_ZL);        /* (symbol - z data pointer)    */
+    CHECK2_ ("DPOFF_H",   BFD_RELOC_C33_DPH);       /* (symbol - default data pointer)  */
+    CHECK2_ ("DPOFF_M",   BFD_RELOC_C33_DPM);       /* (symbol - default data pointer)  */
+    CHECK2_ ("DPOFF_L",   BFD_RELOC_C33_DPL);       /* (symbol - default data pointer)  */
+
+    return BFD_RELOC_UNUSED;
+
+}
+
+/* add tazaki 2002.02.29 >>>>> */
+/******************************************************************************
+    INPUT   NONE
+    RETURN  operand code
+    advanced macro "EXT COND" instruction operand analysis
+******************************************************************************/
+static int
+c33_condition ()
+{
+  boolean paren_skipped = false;
+
+
+#define CHECK3_(name, cond)                                         \
+    if (strncmp (input_line_pointer, name, strlen (name) ) == 0)    \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+            return cond;                                            \
+    }
+
+    CHECK3_ ("gt",   0x04);
+    CHECK3_ ("ge",   0x05);
+    CHECK3_ ("lt",   0x06);
+    CHECK3_ ("le",   0x07);
+    CHECK3_ ("ugt",  0x08);
+    CHECK3_ ("uge",  0x09);
+    CHECK3_ ("ult",  0x0a);
+    CHECK3_ ("ule",  0x0b);
+    CHECK3_ ("eq",   0x0c);
+    CHECK3_ ("ne",   0x0d);
+
+    return 0;
+
+}
+/* add tazaki 2002.02.29 >>>>> */
+/******************************************************************************
+    INPUT   NONE
+    RETURN  operand code
+    advanced macro "EXT OP,imm2" or "EXT %RB,OP,imm2" instruction operand analysis
+******************************************************************************/
+static int
+c33_op_shift ()
+{
+  boolean paren_skipped = false;
+
+
+#define CHECK4_(name, op_shift_code)                                \
+    if (strncmp (input_line_pointer, name, strlen (name) ) == 0)    \
+    {                                                               \
+        input_line_pointer += strlen (name);                        \
+            return op_shift_code;                                   \
+    }
+
+    CHECK4_ ("sra",   0x01);
+    CHECK4_ ("srl",   0x02);
+    CHECK4_ ("sll",   0x03);
+
+    return 0;
+
+}
+
+/******************************************************************************
+    INPUT   unsigned long
+            const struct c33_operand*   operand
+            offsetT
+            char*
+            unsigned int
+            char*
+            int
+    RETURN  unsigned long
+    Explanation An operand and an operation code are made into a command code.
+******************************************************************************/
+ unsigned long               ulrd;		/* add T.Tazaki 2004/07/23 */
+
+/* Insert an operand value into an instruction.  */
+static unsigned long
+c33_insert_operand (insn, operand, val, file, line, str,flags)
+     unsigned long               insn;
+     const struct c33_operand * operand;
+     offsetT                     val;
+     char *                      file;
+     unsigned int                line;
+     char *                      str;
+     int                        flags;
+{
+
+    long    min, max, lval;
+    unsigned long   ulValue, ulMask;
+    int     iSign;
+
+    /* Does a function exist? */
+    if (operand->insert)
+    {
+    /* YES */
+    
+        const char * message = NULL;
+
+        insn = operand->insert (insn, val, & message);
+        if (message != NULL)
+        {
+            if (str)
+            {
+                if (file == (char *) NULL)
+                    as_warn ("%s: %s", str, message);
+                else
+                    as_warn_where (file, line, "%s: %s", str, message);
+            }
+            else
+            {
+                if (file == (char *) NULL)
+                    as_warn (message);
+                else
+                    as_warn_where (file, line, message);
+            }
+        }
+    }
+    else
+    {
+    /* NO  */
+    
+//      long    min, max, lval;
+//      unsigned long   ulValue, ulMask;
+//      int     iSign;
+
+        lval = val; /* T.Tazaki 2002.02.27 */
+
+        if( operand->range < 32 ){
+
+            /* Restore min and mix to expected values for decimal ranges.  */
+
+            if (flags & C33_OPERAND_SIGNED){
+
+                ulValue = val;
+
+                ulMask = 0xffffffff >> ( operand->range - 1 );
+                ulMask <<= ( operand->range - 1 );
+                if(( ulValue & ulMask ) == ulMask ){
+                    iSign = 1;  /* (-) */       /* "jp 0xffffff81" */
+                }else{
+                    if( ( ulValue & ulMask ) == (1 << ( operand->range - 1 )) ){    /* only sign bit = 1 ? */
+                        iSign = 1;      /* (-) */   /* "jp 0x81" */
+                    }else{
+                        if(( ulValue & ulMask ) == 0 ){ /* sign bit = 0 ? */
+                            iSign = 0;  /* (+) */   /* "jp 0x40" */
+                        }else{
+                            iSign = 2;  /* Warninng */
+                        }
+                    }
+                }
+
+                if( iSign == 2 ){   /* Invalid range ?  "jp 0x102" */
+                    const char * err = _("operand out of range (%s not between %ld and %ld)");
+                    char         buf[100];
+
+                    max = (1 << ( operand->range - 1 )) - 1;    /* T.Tazaki 2002.02.27 */
+                    min = - (1 << (operand->range - 1));        /* T.Tazaki 2002.02.27 */
+                    if (str)
+                    {
+                      sprintf (buf, "%s: ", str);
+                      
+                      sprint_value (buf + strlen (buf), val);
+                    }
+                    else
+                        sprint_value (buf, lval);
+              
+                    if (file == (char *) NULL)
+                        as_warn (err, buf, min, max);
+                    else
+                        as_warn_where (file, line, err, buf, min, max);
+                }
+                else
+                {
+                    if( iSign == 0 ){   /* (+) ? */
+                        lval = val;
+                    }else{
+                        if( iSign == 1 ){ /* (-) ? */
+                            lval = ulValue | ulMask;    /* sign extend */
+                        }
+                    }
+                    
+        /*          max = (1 << ( operand->bits - 1 )) - 1;
+                    min = - (1 << (operand->bits - 1));         */
+                    max = (1 << ( operand->range - 1 )) - 1;    /* T.Tazaki 2002.02.27 */
+                    min = - (1 << (operand->range - 1));        /* T.Tazaki 2002.02.27 */
+
+                    if (lval < min || lval > max)
+                    {
+                        const char * err = _("operand out of range (%s not between %ld and %ld)");
+                        char         buf[100];
+
+                        if (str)
+                        {
+                          sprintf (buf, "%s: ", str);
+                          
+                          sprint_value (buf + strlen (buf), lval);
+                        }
+                        else
+                            sprint_value (buf, lval);
+                  
+                        if (file == (char *) NULL)
+                            as_warn (err, buf, min, max);
+                        else
+                            as_warn_where (file, line, err, buf, min, max);
+                    }
+                }
+            }
+            else {
+                /* It asks for the range of effective value. */
+                max = (1 << operand->bits) - 1;
+                min = 0;
+
+                /* Value is range outside. */
+                if (lval < (offsetT) min || lval > (offsetT) max)
+                {
+                    /* xgettext:c-format */
+                    const char * err = _("operand out of range (%s not between %ld and %ld)");
+                    char         buf[100];
+
+                    if (str)
+                    {
+                      sprintf (buf, "%s: ", str);
+                      
+                      sprint_value (buf + strlen (buf), lval);
+                    }
+                    else
+                        sprint_value (buf, lval);
+
+                    if (file == (char *) NULL)
+                        as_warn (err, buf, min, max);
+                    else
+                        as_warn_where (file, line, err, buf, min, max);
+                }
+            }
+        }
+
+        /* An operand and an operation code are made into a command code. */
+//      insn |= (((long) val & ((1 << operand->bits) - 1)) << operand->shift);
+        insn |= (((long) lval & ((1 << operand->bits) - 1)) << operand->shift); /* T.Tazaki 2002.02.27 */
+/* >>>> add tazaki advanced macro */
+        if (flags & C33_OPERAND_01) {
+            insn |= 0x0010; /* bit 5,4 = 0,1 set */
+        }
+        if (flags & C33_OPERAND_OP3_01) {
+            insn |= 0x0040; /* bit 7,6 = 0,1 set : psrset imm5 */
+        }
+        if (flags & C33_OPERAND_OP3_10){
+            insn |= 0x0080; /* bit 7,6 = 1,0 set : psrclr imm5 */
+        }
+/* <<<< add tazaki advanced macro */
+    }
+    return insn;
+}
+
+
+static char                 copy_of_instruction [128];
+
+void
+md_assemble (str) 
+     char * str;
+{
+    char *                  s;
+    char *                  start_of_operands;
+    struct c33_opcode *     opcode;
+    struct c33_opcode *     opcode2;    /* add tazaki 2001.08.10 */
+    struct c33_opcode *     next_opcode;
+    const unsigned char *   opindex_ptr;
+    int                     next_opindex;
+    int                     relaxable;
+    unsigned short          insn;
+    unsigned short          insn_wk;    /* add tazaki 2001.12.11 */
+    unsigned short          copy_insn;
+    char *                  f;      /* insn address */
+    char *                  where;      /* insn address */
+    int                     i;
+    int                     match;
+    boolean                 extra_data_befor_insn = false;
+    unsigned int            extra_data_len;
+    unsigned short          extraInsnBuf[10];
+    char *                  saved_input_line_pointer;
+    char *                  check_input_line_pointer;
+    char *                  temp_input_line_pointer;
+    unsigned short *        fromP;
+    int                     iNumber;
+    unsigned int            uiNumber;                       /* add tazaki 2002.03.11 */
+    
+    int                     i_ext_off;                      /* add tazaki 2001.08.07 */
+    int                     iMEM_IMM26_flag;                /* add tazaki 2001.10.11 */
+    char *                  pSymbolName ;                   /* for [imm26] add tazaki 2001.11.28 */
+    char                    szSymbolName[300];              /* for [imm26] add tazaki 2001.11.28 */
+    char *                  temp_pointer;                   /* for [imm26] add tazaki 2001.11.28 */
+
+	int						g_iBitTest = 0;					/* for Bit Test命令のオペランド imm3 用  add T.Tazaki 2004/07/30 */
+	int						g_iBitTest_range = 0;			/* for Bit Test命令のオペランド imm3 用  add T.Tazaki 2004/07/30 */
+	int						g_iXload = 0;					/* for xld.x [symbol+imm],%rs命令のオペランド %rs 用  add T.Tazaki 2004/07/30 */
+	int						g_iXload_range = 0;				/* for xld.x [symbol+imm],%rs命令のオペランド %rs 用  add T.Tazaki 2004/07/30 */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+	int						i_ext_cnt = -1;					// numbers of ext to add (default when -1)
+
+	// indices for extraInsnBuf
+	unsigned int			insn_idx_high = 0;				// for ext @h
+	unsigned int			insn_idx_mid  = 0;				// for ext @m
+	unsigned int			insn_idx_low  = 0;				// for ld  @l	(always present)
+	unsigned int			insn_idx_load = 0;				// for ld.*		(always present)
+	unsigned int			insn_idx_pop  = 0;				// for mem write
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+
+// ADD D.Fujimoto 2007/06/21 >>>>>>>
+#ifdef EXT_REMOVE
+	if( g_c33_ext == 1 ){
+		// get the offset from the nearest symbol
+		evaluate_offset_from_symbol();
+	}
+#endif
+// ADD D.Fujimoto 2007/06/21 <<<<<<<
+
+    pSymbolName = &szSymbolName[0];                         /* Symbol name pointer domain initialization for [imm26] add tazaki 2001.11.28*/
+
+    /* The command character sequence for one line is copied. */
+    strncpy (copy_of_instruction, str, sizeof (copy_of_instruction) - 1);
+  
+    /* It is made a character sequence as an operation code. */
+    /* Get the opcode.  */
+    for (s = str; *s != '\0' && ! isspace (*s); s++)
+        continue;
+
+    if (*s != '\0')
+        *s++ = '\0';
+
+    /* find the first opcode with the proper name */
+    opcode = (struct c33_opcode *) hash_find (c33_hash, str);
+
+    /* not find operation code? */
+    if (opcode == NULL) {
+        /* xgettext:c-format */
+        as_bad (_("Unrecognized opcode: `%s'"), str);
+        ignore_rest_of_line ();
+        return;
+    }
+
+    /* The space from an operation code to an operand is skipped. */
+    str = s;
+    while (isspace (* str))
+        ++ str;
+
+    /* The start position of an operand is held. */
+    start_of_operands = str;
+
+    saved_input_line_pointer = input_line_pointer;
+
+    /* An interpretation of an operand */
+    for (;;) {
+        const char * errmsg = NULL;
+
+        match = 0;
+
+        relaxable = 0;
+        fc = 0;
+        next_opindex = 0;
+        insn = opcode->opcode;
+        extra_data_befor_insn = false;
+
+        iMEM_IMM26_flag = 0;    /* add tazaki 2001.10.11 */
+
+        /* The start position of an operand is held. */
+        input_line_pointer = str = start_of_operands;
+
+        /* Only the number of operands is repeated. */
+        for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr ++)
+        {
+            const struct c33_operand * operand;
+            char *                      hold;
+            expressionS                 ex;
+            expressionS                 ext_ex;
+            bfd_reloc_code_real_type    reloc;  
+            
+            int flags;
+            
+            if (next_opindex == 0)
+            {
+                /* An operand is acquired. */
+                operand = & c33_operands[ * opindex_ptr ];
+            }
+            else
+            {
+                operand      = & c33_operands[ next_opindex ];
+                next_opindex = 0;
+            }
+
+            flags = operand->flags;
+            errmsg = NULL;
+
+            while (*str == ' ' || *str == ',' || *str == ']')
+              ++ str;
+
+            /* Gather the operand. */
+            hold = input_line_pointer;
+            input_line_pointer = str;
+     
+            errmsg = NULL;
+
+            /*  tazaki 2002.01.11  >>>>>> */
+            i_ext_off = 0;
+            opcode2 = (struct c33_opcode *)c33_ext_opcodes;
+            if( opcode->opcode == opcode2->opcode ){
+                /* ext xoff_hi(sym),ext xoff_lo(sym),ext dpoff_h,m(sym) : analisys symbol offset */
+                reloc = c33_reloc_prefix_offset ();
+                if( reloc != BFD_RELOC_UNUSED ){
+                    i_ext_off = 1;
+                }
+            }
+            if( i_ext_off == 1 )
+            {
+                /* ext 命令 and xoff_hi(sym),ext xoff_lo(sym),dpoff_h,m(sym) ? */
+
+                /* read symbol , disp */
+
+                expression (& ex);
+
+                if (fc >= MAX_INSN_FIXUPS)
+                  as_fatal (_("too many fixups"));
+
+                fixups[ fc ].exp     = ex;
+                fixups[ fc ].opindex = * opcode->operands;
+                fixups[ fc ].reloc   = reloc;
+                ++fc;
+
+            }
+            else
+            {
+                /* >>>> add tazaki 2002.02.29 class1 : ext cond*/
+                if ((operand->flags & C33_OPERAND_COND) == C33_OPERAND_COND) 
+                {
+                    int iCond = c33_condition();    /* get operand code */
+                    if( iCond != 0 ){
+
+                        ex.X_op = O_cond;
+                        ex.X_add_number = iCond;
+
+                    }else{
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* >>>> add tazaki 2002.02.29 class1 : ext OP,imm2 | ext %rb,OP,imm2 */
+                else if ((operand->flags & C33_OPERAND_OP_SHIFT) == C33_OPERAND_OP_SHIFT) 
+                {
+                    int iShiftCode = c33_op_shift();    /* get operand code */
+                    if( iShiftCode != 0 ){
+
+                        ex.X_op = O_op_shift;
+                        ex.X_add_number = iShiftCode;
+
+                    }else{
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* >>>> add tazaki 2001.09.18 class7 : [%dp+imm6]*/
+                else if ((operand->flags & C33_OPERAND_DPMEM) == C33_OPERAND_DPMEM) 
+                {
+                    if (*str == '['){
+                        str++;
+                        while (isspace (*str))
+                            ++str;
+
+                        input_line_pointer = str;
+
+                        /* %dp ? */
+                        if ( ( strncmp(str,"%dp",3) != 0 ) && ( strncmp(str,"%DP",3) != 0 ))
+                        {
+                        /* YES  */
+                            errmsg = _("invalid system register name");
+                        }
+                        else {
+                            str+=3;
+                            while (isspace (*str))
+                                ++str;
+
+                            /* IF ']' */
+                            if (*str == ']'){
+                            /* YES only register */
+                                /* Support only"[%dp]"  */
+                                ex.X_op         = O_constant;
+                                ex.X_add_symbol = NULL;
+                                ex.X_op_symbol  = NULL;
+                                ex.X_add_number = 0;
+                                str++;
+                                input_line_pointer = str;
+                            }
+                            else if (*str == '+'){
+                                str++;
+                                input_line_pointer = str;
+
+                                reloc = c33_reloc_prefix_offset();
+                                if( reloc != BFD_RELOC_UNUSED ){    /* dpoff_l() ? */
+                                    errmsg = _("invalid operand");
+                                }
+                                else
+                                {
+                                    /* An operand is developed at a formula. */
+                                    expression (& ex);
+
+                                    iNumber = ex.X_add_number;
+
+                                    if (operand->range <= 6){
+                                        /* EMPTY */
+                                    }
+                                    else if (operand->range == 32) {
+                                        /* update tazaki 2002.03.08 >>> */
+                                        if (opcode->specialFlag == 1){
+                                            /* ld.b */
+                                            if ((unsigned int)iNumber <= 0x3f){
+                                                ex.X_add_number /= 1;
+                                                
+                                            }else if ((unsigned int)iNumber <= 0x7ffff){
+                                                /* 1 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 1;
+                                                extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                            else {
+                                                /* 2 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 2;
+                                                extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                                extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                        }
+                                        else if (opcode->specialFlag == 2){
+                                            /* ld.h */
+                                            if ((unsigned int)iNumber <= 0x7f){
+                                                ex.X_add_number /= 2;
+                                                
+                                            }else if ((unsigned int)iNumber <= 0x7ffff){
+                                                /* 1 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 1;
+                                                extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                            else {
+                                                /* 2 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 2;
+                                                extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                                extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                        }
+                                        else if (opcode->specialFlag == 4){
+                                            /* ld.w */
+                                            if ((unsigned int)iNumber <= 0xff){
+                                                ex.X_add_number /= 4;
+                                                
+                                            }else if ((unsigned int)iNumber <= 0x7ffff){
+                                                /* 1 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 1;
+                                                extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                            else {
+                                                /* 2 ext */
+                                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                                extra_data_befor_insn = true;
+                                                extra_data_len  = 2;
+                                                extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                                extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                                ex.X_add_number = iNumber & 0x3f;
+                                            }
+                                        }
+                                        /* update tazaki 2002.03.08 <<< */
+                                    }
+                                    else {
+                                        errmsg = _("constant too big to fit into instruction");
+                                    }
+                                }
+                            }
+                            else{
+                                /* YES  */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+
+                /* >>>> add tazaki 2002.01.15 class7 : [%dp+dpoff_l(symbol)]*/
+                else if ((operand->flags & C33_OPERAND_DPSYMBOL6) == C33_OPERAND_DPSYMBOL6) 
+                {
+                    if (*str == '['){
+                        str++;
+                        while (isspace (*str))
+                            ++str;
+
+                        input_line_pointer = str;
+
+                        /* %dp ? */
+                        if ( ( strncmp(str,"%dp",3) != 0 ) && ( strncmp(str,"%DP",3) != 0 ))
+                        {
+                        /* YES  */
+                            errmsg = _("invalid system register name");
+                        }
+                        else {
+                            str+=3;
+                            while (isspace (*str))
+                                ++str;
+
+                            /* IF ']' */
+                            if (*str == ']'){
+                            /* YES only register */
+                                /* Support only"[%dp]  */
+                                ex.X_op         = O_constant;
+                                ex.X_add_symbol = NULL;
+                                ex.X_op_symbol  = NULL;
+                                ex.X_add_number = 0;
+                                str++;
+                                input_line_pointer = str;
+                            }
+                            else
+                            {
+                                if (*str == '+'){
+                                    /* [%dp+dpoff_l(symbol)] */
+                                    str++;
+                                    input_line_pointer = str;
+
+                                    reloc = c33_reloc_prefix_offset();
+                                    if( reloc == BFD_RELOC_C33_DPL ){   /* dpoff_l() ? */
+
+                                        expression (& ex);
+
+                                        if (ex.X_op != O_symbol){   /* not symbol ? */
+                                            errmsg = _("invalid operand");
+                                        }
+                                    }else{
+                                        errmsg = _("invalid operand");
+                                    }
+                                }else{
+                                    errmsg = _("invalid operand");
+                                }
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                
+                /* >>>> add tazaki 2002.01.15 class7 : dpoff_l(symbol) */
+                else if ((operand->flags & C33_OPERAND_DPSYMBOL6_2) == C33_OPERAND_DPSYMBOL6_2) 
+                {
+                    reloc = c33_reloc_prefix_offset();
+                    if( reloc == BFD_RELOC_C33_DPL ){   /* dpoff_l() ? */
+
+                        expression (& ex);
+
+                        if (ex.X_op != O_symbol){   /* not symbol ? */
+                            errmsg = _("invalid operand");
+                        }
+                    }else{
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* >>>> add tazaki 2001.12.21 class0 : %dp */
+
+                else if ((operand->flags & C33_OPERAND_DP) == C33_OPERAND_DP) 
+                {
+                    /* check %dp ? */
+                    if ( ( strncmp(str,"%dp",3) != 0 ) && ( strncmp(str,"%DP",3) != 0 ))
+                    {
+                        /* NO  */
+                        errmsg = _("invalid system register name");
+                    }else{
+                        str+=3;
+                        while (isspace (*str))
+                            ++str;
+                        input_line_pointer = str;
+                            
+                        ex.X_op  = O_dpregister;
+                        /* In %dp, an operand is not inserted in a command code. */
+                    }
+                /* <<<< add tazaki 2001.12.21 class0 : %dp */
+                }
+                else if ((operand->flags & C33_OPERAND_REG) != 0) 
+                {
+                    if (!register_name (& ex))
+                    {
+                    /* YES  */
+                        errmsg = _("invalid register name");
+                    }
+                }
+                else if ((operand->flags & C33_OPERAND_LD_SREG) != 0)   /* add 2002.06.19 error : ld.w %pc,%rs */
+                {
+                    if (!load_system_register_name (& ex, true, false))
+                    {
+                        errmsg = _("invalid system register name");
+                    }
+                }
+                else if ((operand->flags & C33_OPERAND_PUSHS_SREG) != 0)    /* add 2002.06.19 : pushs %ss ,pops %sd */
+                {
+                    if (!pushs_system_register_name (& ex, true, false))
+                    {
+                        errmsg = _("invalid system register name");
+                    }
+                }
+                else if (((operand->flags & C33_OPERAND_SREG) != 0) ||
+                        ((operand->flags & C33_OPERAND_SP) != 0)) 
+                {
+                    if (!system_register_name (& ex, true, false))
+                    {
+                        errmsg = _("invalid system register name");
+                    }
+                    else {
+                        /* NO register OK */
+                        if ((operand->flags & C33_OPERAND_SP) != 0) 
+                        {
+                            ex.X_op  = O_spregister;
+                            /* In %sp, an operand is not inserted in a command code. */
+                        }
+                    }
+                }
+                /* ELSE IF Operand is immidiate ? */
+                else if ((operand->flags & C33_OPERAND_IMM) ||
+                        (operand->flags & C33_OPERAND_SIGNED))
+                {
+
+                    expression (& ex);
+
+                    /* IF Operand is constant ?*/
+                    if (ex.X_op == O_constant)
+                    {
+                        if (opcode->specialFlag == 5){
+
+                            /* shift/lotate */
+
+                            iNumber = ex.X_add_number;
+                            if( iNumber > 8 ){
+
+                                errmsg = _("operand out of range (not between 0 and 8)");
+                            }else{
+                                extra_data_len = 0;
+                                ex.X_add_number = iNumber;
+                            }
+                        }else if (opcode->specialFlag == 6){
+
+                            /* 拡張命令のshift/lotate */
+
+                            iNumber = ex.X_add_number;
+                            if( iNumber > 31 ){
+                                errmsg = _("operand out of range (not between 0 and 31)");
+                            }else{
+                                extra_data_len = 0;
+                                while(iNumber > 8){
+                                    extra_data_befor_insn = true;
+                                    copy_insn = c33_insert_operand (insn, operand,8,
+                                                  (char *) NULL, 0,
+                                                  copy_of_instruction,flags);
+                                    extraInsnBuf[extra_data_len] = copy_insn;
+                                    extra_data_len++;
+                                    ex.X_add_number =  8;
+                                    iNumber -= 8;
+                                }
+                                ex.X_add_number = iNumber;
+                            }
+                        }else if (opcode->specialFlag == 7){
+                            
+                            /* Advanced mode "X" Extended of shift/lotate */
+                            iNumber = ex.X_add_number;
+                            if( iNumber > 31 ){
+                                errmsg = _("operand out of range (not between 0 and 31)");
+                            }else{
+                                if( iNumber <= 15 ){
+
+                                }else{
+                                    ex.X_add_number -= 16;
+                                    
+                                    /* Convert Opecode */
+                                    insn_wk = insn & 0xff00;
+                                    
+                                    switch( insn_wk ){
+                                    case 0x8800: insn_wk = 0x2300;  break;  /* srl -->class 1 : srl */
+                                    case 0x8c00: insn_wk = 0x2700;  break;  /* sll -->class 1 : sll */
+                                    case 0x9000: insn_wk = 0x2b00;  break;  /* sra -->class 1 : sra */
+                                    case 0x9400: insn_wk = 0x2f00;  break;  /* sla -->class 1 : sla */
+                                    case 0x9800: insn_wk = 0x3300;  break;  /* rr  -->class 1 : rr  */
+                                    case 0x9c00: insn_wk = 0x3700;  break;  /* rl  -->class 1 : rl  */
+                                    default :   errmsg = _("invalid operand");  break;
+
+                                    }
+                                    insn = insn_wk | ( insn & 0x00ff );
+                                }
+                            }
+                        }
+                        else {
+                        /* shift/lotate命令以外 */
+                        
+                            /* Possible to sign32 */
+                            iNumber = ex.X_add_number;
+                            
+                            if (operand->flags & C33_OPERAND_SIGNED){
+                            /* YES signed */
+
+                                if ((operand->range == 19) && ((-262144 <= iNumber && iNumber < -32) ||
+                                        (31 < iNumber && iNumber <= 262143))){
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 1;
+                                    extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                    ex.X_add_number = iNumber & 0x3f;
+                                    flags = C33_OPERAND_IMM;    /* sign(5:0) is not signed */
+                                }
+                                else if (operand->range == 22) {
+                                    if (operand->flags & C33_OPERAND_PC){
+                                        if (-256 <= iNumber && iNumber <= 254){
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign22(8:1) */
+                                        }
+                                        else if ((-2097152 <= iNumber && iNumber < -256) ||
+                                                (254 < iNumber && iNumber <= 2097150)){
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 9) & 0x1fff); /* sign22(21:9) */
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;                     /* sign22(8:1) */
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }else{
+                                            errmsg = _("operand out of range (not between -2097152 and 2097150)");
+                                        }
+                                    }
+                                }
+                                else if (operand->range == 32){
+                                    /* jp,call */
+                                    if (operand->flags & C33_OPERAND_PC){
+                                        if (-256 <= iNumber && iNumber <= 254){
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign32(8:1) */
+                                        }
+                                        else if ((-2097152 <= iNumber && iNumber < -256) ||
+                                            (254 < iNumber && iNumber <= 2097150)){
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 9) & 0x1fff);
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign32(8:1) */
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1ff8);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 9) & 0x1fff);
+                                            ex.X_add_number = (iNumber >> 1) & 0xff;    /* sign32(8:1) */
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                    }
+                                    else {
+                                        if (-32 <= iNumber && iNumber <= 31){
+                                            /* EMPTY */
+                                        }
+                                        else if ((-262144 <= iNumber && iNumber < -32) ||
+                                            (31 < iNumber && iNumber <= 262143)){
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                        else {
+                                            /* ext命令　２つ */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                            flags = C33_OPERAND_IMM;    /* sign(5:0)is not signed */
+                                        }
+                                    }
+                                }
+                            }
+                            else {
+                            /* IMM */
+                                switch( operand->range ){
+                                case 19:
+                                    if ((unsigned int)iNumber <= 0x7ffff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 1;
+                                        extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                        ex.X_add_number = iNumber & 0x3f;
+                                    }
+                                    break;
+                                case 32:
+                                    if ((unsigned int)iNumber <= 0x3f){
+                                        /* EMPTY */
+                                    }
+                                    else if ((unsigned int)iNumber <= 0x7ffff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 1;
+                                        extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                        ex.X_add_number = iNumber & 0x3f;
+                                    }
+                                    else {
+                                        /* 2 ext */
+                                        
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 2;
+                                        
+                                        extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                        extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                        ex.X_add_number = iNumber & 0x3f;
+                                    }
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    /* ELSE IF Operand is LABEL & SYMBOL */
+
+                    else if ((ex.X_op == O_symbol) && (operand->flags & C33_OPERAND_LABEL)){
+                    /* YES jp/call only */
+
+                        if (operand->range == 13){      /* 2001.4.27 ide */
+                            /* YES ext */
+
+                            /* Get Symbol mask relocation  */
+                            reloc = c33_reloc_prefix ();
+                            /* Not symbol mask ?  : ERROR = ext label, OK = ext label@xx */
+                            if( reloc == BFD_RELOC_UNUSED ){    /* add tazaki 2002.03.04 */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else if (operand->range == 5){      /* add tazaki 2002.03.04 */
+                            /* YES loop */
+                            reloc = BFD_RELOC_C33_LOOP;     /* Adv : loop operand */
+                        }
+                        else if (operand->range == 8){
+                            /* YES jp,call */
+
+                            reloc = c33_reloc_prefix ();        /* add tazaki 2001.08.23 */
+                            /* Not symbol mask ? */
+                            if( reloc == BFD_RELOC_UNUSED ){    /* add tazaki 2001.08.23 */
+                                /* Set Symbol Mask Relocation */
+                                reloc = BFD_RELOC_C33_JP;       /* Modify BFD_RELOC_C33_RL -->BFD_RELOC_C33_JP 2002.04.22 */
+                            }
+                        }
+                        /* add 2001.08.06 tazaki >>>>> */
+                        else if (operand->range == 22){
+                            /* YES scall,sjp,sjrxx */
+                            
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+							// optimizing ext inst
+							if (g_c33_ext == 1) {
+								i_ext_cnt = evaluate_ext_count_for_jumps(ex, 1, count_ext_for_jumps);
+							}
+
+							if (i_ext_cnt == 0) {
+								// no ext
+								reloc = BFD_RELOC_C33_S_RL;
+
+							} else {
+
+								/* 1 ext  */
+								opcode = (struct c33_opcode *)c33_ext_opcodes;
+								extra_data_befor_insn = true;
+								extra_data_len	= 1;
+								extraInsnBuf[0] = opcode->opcode;
+								if (fc >= MAX_INSN_FIXUPS)
+								  as_fatal (_("too many fixups"));
+
+								fixups[ fc ].exp	 = ex;
+								fixups[ fc ].opindex = * opcode->operands;
+								fixups[ fc ].reloc	 = BFD_RELOC_C33_S_RM;
+								++fc;
+
+								reloc = BFD_RELOC_C33_S_RL;
+							}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+                            /* 1 ext  */
+                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                            extra_data_befor_insn = true;
+                            extra_data_len  = 1;
+                            extraInsnBuf[0] = opcode->opcode;
+                            if (fc >= MAX_INSN_FIXUPS)
+                              as_fatal (_("too many fixups"));
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_S_RM;
+                            ++fc;
+
+                            reloc = BFD_RELOC_C33_S_RL;
+#endif	/* EXT_REMOVE */
+
+                        
+                        }
+                        /* add 2001.08.06 tazaki <<<<< */
+                        else {
+                            /* xjp,xcall */
+                            
+                            /* ext  label+imm32@rh */
+                            /* ext  label+imm32@rm */
+                            /* call label+imm32@rl */
+                            
+                            /* strにシンボル名が入っている。２パス　アセンブラのとき、これを比較する。 */
+                            
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+							// optimizing ext inst
+							if (g_c33_ext == 1) {
+								i_ext_cnt = evaluate_ext_count_for_jumps(ex, 2, count_ext_for_jumps);
+							}
+
+							if (i_ext_cnt == 0) {
+								// no ext
+								reloc = BFD_RELOC_C33_S_RL;
+
+							} else if (i_ext_cnt == 1) {
+								// 1 ext
+								opcode = (struct c33_opcode *)c33_ext_opcodes;
+								extra_data_befor_insn = true;
+								extra_data_len	= 1;
+								extraInsnBuf[0] = opcode->opcode;
+
+								if (fc >= MAX_INSN_FIXUPS)
+								  as_fatal (_("too many fixups"));
+
+								fixups[ fc ].exp	 = ex;
+								fixups[ fc ].opindex = * opcode->operands;
+								fixups[ fc ].reloc	 = BFD_RELOC_C33_S_RM;
+								++fc;
+
+								reloc = BFD_RELOC_C33_S_RL;
+
+							} else {
+
+								/* 2 ext  */
+								opcode = (struct c33_opcode *)c33_ext_opcodes;
+								extra_data_befor_insn = true;
+								extra_data_len	= 2;
+								extraInsnBuf[0] = opcode->opcode;
+								extraInsnBuf[1] = opcode->opcode;
+
+								if (fc >= MAX_INSN_FIXUPS)
+								  as_fatal (_("too many fixups"));
+
+								fixups[ fc ].exp	 = ex;
+								fixups[ fc ].opindex = * opcode->operands;	/* operand of ext */
+								fixups[ fc ].reloc	 = BFD_RELOC_C33_S_RH;
+								++fc;
+
+								fixups[ fc ].exp	 = ex;
+								fixups[ fc ].opindex = * opcode->operands;
+								fixups[ fc ].reloc	 = BFD_RELOC_C33_S_RM;
+								++fc;
+
+								reloc = BFD_RELOC_C33_S_RL;
+							}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+                            /* 2 ext  */
+                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                            extra_data_befor_insn = true;
+                            extra_data_len  = 2;
+                            extraInsnBuf[0] = opcode->opcode;
+                            extraInsnBuf[1] = opcode->opcode;
+
+                            if (fc >= MAX_INSN_FIXUPS)
+                              as_fatal (_("too many fixups"));
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_S_RH;
+                            ++fc;
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_S_RM;
+                            ++fc;
+
+                            reloc = BFD_RELOC_C33_S_RL;
+
+#endif	/* EXT_REMOVE */
+                        }
+                    }
+                    else if ((ex.X_op == O_symbol) && (operand->flags & C33_OPERAND_SYMBOL)){
+                    /* YES ld.w only */
+                        if( *str == '[' ){
+                            errmsg = _("invalid operand");
+                        }
+                        else if (operand->range == 6){
+                            /*  ld.w %rd,LABEL@l */
+
+                            /* Get Symbol mask relocation  */
+                            reloc = c33_reloc_prefix ();
+                        }
+                        else if (operand->range == 19){
+                        /* xld.w rd,symbol+imm19 */
+
+                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                            extra_data_befor_insn = true;
+                            extra_data_len  = 1;
+                            extraInsnBuf[0] = opcode->opcode;
+
+                            if (fc >= MAX_INSN_FIXUPS)
+                              as_fatal (_("too many fixups"));
+
+                            fixups[ fc ].exp     = ex;
+                            fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                            fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+                            ++fc;
+
+                            reloc = BFD_RELOC_C33_L;
+
+                        }
+                        else{
+                            if (operand->range == 32){
+                                /* ext  label+imm32@h */
+                                /* ext  label+imm32@m */
+                                /* xld.w    label+imm32@l */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+								// optimizing ext inst
+								// pattern	xld.w %rd, LABEL
+								if (g_c33_ext == 1) {
+									i_ext_cnt = evaluate_ext_count(ex, 0, count_ext_for_xld_rd_symbol);
+								}
+
+								if (i_ext_cnt == 0) {
+									// no ext
+									reloc = BFD_RELOC_C33_L;
+
+								} else if (i_ext_cnt == 1) {
+									// 1 ext
+									opcode = (struct c33_opcode *)c33_ext_opcodes;
+									extra_data_befor_insn = true;
+									extra_data_len	= 1;
+									extraInsnBuf[0] = opcode->opcode;
+
+									if (fc >= MAX_INSN_FIXUPS)
+									  as_fatal (_("too many fixups"));
+
+									fixups[ fc ].exp	 = ex;
+									fixups[ fc ].opindex = * opcode->operands;
+									fixups[ fc ].reloc	 = BFD_RELOC_C33_M;
+									++fc;
+
+									reloc = BFD_RELOC_C33_L;
+
+
+								} else {
+
+									/* 2 ext */
+									opcode = (struct c33_opcode *)c33_ext_opcodes;
+									extra_data_befor_insn = true;
+									extra_data_len	= 2;
+									extraInsnBuf[0] = opcode->opcode;
+									extraInsnBuf[1] = opcode->opcode;
+
+									if (fc >= MAX_INSN_FIXUPS)
+									  as_fatal (_("too many fixups"));
+
+									fixups[ fc ].exp	 = ex;
+									fixups[ fc ].opindex = * opcode->operands;	/* operand of ext */
+									fixups[ fc ].reloc	 = BFD_RELOC_C33_H;
+									++fc;
+
+									fixups[ fc ].exp	 = ex;
+									fixups[ fc ].opindex = * opcode->operands;
+									fixups[ fc ].reloc	 = BFD_RELOC_C33_M;
+									++fc;
+
+									reloc = BFD_RELOC_C33_L;
+
+								}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+                                    
+                                /* 2 ext */
+                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                extra_data_befor_insn = true;
+                                extra_data_len  = 2;
+                                extraInsnBuf[0] = opcode->opcode;
+                                extraInsnBuf[1] = opcode->opcode;
+
+                                if (fc >= MAX_INSN_FIXUPS)
+                                  as_fatal (_("too many fixups"));
+
+                                fixups[ fc ].exp     = ex;
+                                fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                                fixups[ fc ].reloc   = BFD_RELOC_C33_H;
+                                ++fc;
+
+                                fixups[ fc ].exp     = ex;
+                                fixups[ fc ].opindex = * opcode->operands;
+                                fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+                                ++fc;
+
+                                reloc = BFD_RELOC_C33_L;
+#endif	/* EXT_REMOVE */
+                            }
+                        }
+                    }
+                    else {
+                        errmsg = _("invalid operand");
+                    }
+                }
+                /* Operand is register indirectness (memory). */
+//              else if ((operand->flags & C33_OPERAND_RB) != 0) 																	/* del T.Tazaki 2004/07/30 */
+                else if ((operand->flags & C33_OPERAND_RB) != 0 && (operand->flags & C33_OPERAND_26) == 0 && g_iMedda32 == 1  )		/* add T.Tazaki 2004/07/30 */
+                {
+                    /* Pattern */
+                    /* [rb] */
+
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (register_name (& ex))
+                        {
+                        /* YES register */
+                            
+                            /* Skip space */
+                            while (isspace (*input_line_pointer))
+                                ++input_line_pointer;
+                            
+                            /* IF ']' */
+                            if (*input_line_pointer == ']'){
+                            /* YES pattern match */
+                                input_line_pointer++;
+                            }
+                            else {
+                            /* NO not match */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else {
+                        /* NO not register */
+                            errmsg = _("invalid operand");
+                        }
+
+                    }
+                    else
+                        errmsg = _("invalid operand");
+               }
+				/* add T.Tazaki 2004/07/30 >>> */
+                /* Operand is register indirectness (memory). */
+                else if ((operand->flags & C33_OPERAND_RB) != 0 && g_iMedda32 == 0 )	/* Use data area */
+                {
+                    /* Pattern */
+                    /* [rb] */
+
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (register_name (& ex))
+                        {
+                        /* YES register */
+                            
+                            /* Skip space */
+                            while (isspace (*input_line_pointer))
+                                ++input_line_pointer;
+                            
+                            /* IF ']' */
+                            if (*input_line_pointer == ']'){
+                            /* YES pattern match */
+                                input_line_pointer++;
+                            }
+                            else {
+                            /* NO not match */
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else {
+                        /* NO not register */
+                            errmsg = _("invalid operand");
+                        }
+
+                    }
+                    else
+                        errmsg = _("invalid operand");
+               }
+               else if ((operand->flags & C33_OPERAND_RB) != 0 && (operand->flags & C33_OPERAND_26) != 0 && g_iMedda32 == 1 ) 
+               {
+                   /* Are there any symbol and IMM which follow a register? */
+                   /* Pattern */
+                   /* [rb+imm26] */
+                            
+                   if (*str == '['){
+                       str++;
+                       input_line_pointer = str;
+
+                       if (register_name (& ex))
+                       {
+		                   /* Skip Space */
+		                   while (isspace (*input_line_pointer))
+		                       ++input_line_pointer;
+		                            
+		                   /* IF ']' */
+		                   if (*input_line_pointer == ']'){
+		                   /* YES Register Only */
+		                       input_line_pointer++;
+		                   }
+		                   /* ELSE IF plus */
+		                   else if (*input_line_pointer == '+'){
+		                   /* YES plus */
+		                            
+		                       input_line_pointer++;
+		                       /* symbol,imm */
+		                       expression (& ext_ex);
+
+		                       if (ext_ex.X_op == O_constant){
+		                           /* [%rd+imm26] */
+		                                
+		                           uiNumber = ext_ex.X_add_number;
+		                                 
+		                           if (uiNumber == 0){
+		                               /* EMPTY */
+		                           }
+		                           else if (uiNumber <= 0x1fff){
+		                               opcode = (struct c33_opcode *)c33_ext_opcodes;
+		                               extra_data_befor_insn = true;
+		                               extra_data_len  = 1;
+		                               extraInsnBuf[0] = opcode->opcode| (uiNumber & 0x1fff);
+		                           }
+		                           else if (uiNumber <= 0x3ffffff){
+		                               opcode = (struct c33_opcode *)c33_ext_opcodes;
+		                               extra_data_befor_insn = true;
+		                               extra_data_len  = 2;
+		                               extraInsnBuf[0] = opcode->opcode| ((uiNumber >> 13) & 0x1fff);
+		                               extraInsnBuf[1] = opcode->opcode| (uiNumber & 0x1fff);
+		                           }
+		                           else {
+		                           /* NO more than 27bit ? */
+		                                    
+		                               /* tnot support */
+		                               errmsg = _("invalid operand");
+		                               iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+		                           }
+		                       }
+		                       else {
+		                       /* NO not immidiate */
+		                           errmsg = _("invalid operand");
+		                           iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+		                       }
+		                    }
+		                    else {
+		                    /* NO any other character  */
+		                        /* error */
+		                        errmsg = _("invalid operand");
+		                        iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+		                    }
+						}
+						else
+	                        errmsg = _("invalid operand");
+					}
+					else
+                        errmsg = _("invalid operand");
+                }
+                
+				/* add T.Tazaki 2004/07/30 <<< */
+
+/* >>> add tazaki 2001.11.20 */
+
+                else if( ( (operand->flags & C33_OPERAND_MEM) != 0 ) && 
+                         ( (operand->flags & C33_OPERAND_DP_SYMBOL) == C33_OPERAND_DP_SYMBOL ) )
+                {
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (!register_name (& ex))
+                        {
+                        /* YES not register */
+
+                            if (system_register_name (& ex, true, false)){
+                            /* system register */
+                                errmsg = _("invalid operand");
+                            }
+                            else {
+                                check_input_line_pointer = input_line_pointer;
+                                
+                                expression (& ex);
+
+                                /* if Minus "-", No Support! */
+                                while(check_input_line_pointer < input_line_pointer){
+                                    if (*check_input_line_pointer == '-'){
+                                        errmsg = _("invalid operand");
+                                        break;
+                                    }
+                                    check_input_line_pointer++;
+                                }
+                            }
+                            if (errmsg != NULL){
+                            }
+                            /* ELSE IF Operand is SYMBOL */
+                            else if (ex.X_op == O_symbol){
+                                /* Pattern */
+                                /* [symbol+imm32] */
+
+                                if( operand->range == 19 )
+                                {
+									if( g_iMedda32 == 0 )									/* add T.Tazaki 2004/07/30 */
+									{
+	                                    /* ext   (symbol+imm32-dp)@6-18  : ext  imm13 */
+	                                    /* ld.w  (symbol+imm32-dp)@0-5   : ld.w r0,[%dp+imm6] */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+										// optimizing ext inst
+										// for following patterns 
+										// 
+										// ald.* %rd, [LABEL]	(mem read)	(without medda32)
+										// ald.* [LABEL], %rd 	(mem write)	(without medda32)
+										if (g_c33_ext == 1) {
+											i_ext_cnt = evaluate_ext_count(ex, g_dpAddress, count_ext_for_ald_mem_rw);
+										}
+
+										if (i_ext_cnt == 0) {
+											// no ext
+											reloc = BFD_RELOC_C33_DPL;
+
+										} else {
+											/* 1 ext */
+											opcode = (struct c33_opcode *)c33_ext_opcodes;
+											extra_data_befor_insn = true;
+											extra_data_len	= 1;
+											extraInsnBuf[0] = opcode->opcode;
+
+											if (fc >= MAX_INSN_FIXUPS)
+											  as_fatal (_("too many fixups"));
+
+											fixups[ fc ].exp	 = ex;
+											fixups[ fc ].opindex = * opcode->operands;
+											fixups[ fc ].reloc	 = BFD_RELOC_C33_DPM;
+											++fc;
+											reloc = BFD_RELOC_C33_DPL;
+
+										}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+	                                    /* 1 ext */
+	                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+	                                    extra_data_befor_insn = true;
+	                                    extra_data_len  = 1;
+	                                    extraInsnBuf[0] = opcode->opcode;
+
+	                                    if (fc >= MAX_INSN_FIXUPS)
+	                                      as_fatal (_("too many fixups"));
+
+	                                    fixups[ fc ].exp     = ex;
+	                                    fixups[ fc ].opindex = * opcode->operands;
+	                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DPM;
+	                                    ++fc;
+	                                    reloc = BFD_RELOC_C33_DPL;
+#endif	/* EXT_REMOVE */
+		                             }
+#if 0
+		                             else
+		                             {
+										/* add T.Tazaki 2004/08/19 >>> */
+										/* 0:pushn %r0         			*/
+		                                /* 1:ext  label+imm32@m 		*/
+		                                /* 2:ld.x %r0,label+imm32@l 	*/
+		                                /* 3:ld.x %rd,[%r0]   			*/
+		                                /* 4:popn %r0					*/
+		                                    
+	                                    extraInsnBuf[0] = 0x0200;	/* pushn %r0 */
+		                                /* 1ext */
+		                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+		                                extra_data_befor_insn = true;
+		                                extraInsnBuf[1] = opcode->opcode;
+
+		                                if (fc >= MAX_INSN_FIXUPS)
+		                                  as_fatal (_("too many fixups"));
+
+										/* これは、リンク後、pushn %rs の %rs が、BFD_RELOC_C33_M に設定されてしまうので新規にBFD_RELOC_C33_PUSHN_R0
+										   を追加して、リンカで "pushn %r0" を設定させるためにある。 */
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands; 
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_PUSHN_R0;	/* デフォルトの"pushn %r0" を設定 */
+		                                ++fc;
+
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands;
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+		                                ++fc;
+
+		                                reloc = BFD_RELOC_C33_L;
+
+	                                    extra_data_befor_insn = true;
+	                                    ulrd = insn & 0x000f;
+	                                    insn &= 0xfff0;
+	                                    extraInsnBuf[2] = insn;		/* ld.w %r0,sign6 */
+	                                    
+					                    if ((operand->flags & C33_XLDB_RD) != 0) 
+	                                    {
+	                                    	insn = 0x2000 + ulrd;		/* ld.b %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDB_WR) != 0) 
+	                                    {
+											g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+											g_iXload_range = operand->range;
+		                                    insn = 0x3400;		/* ld.b [%r0],%rs */
+		                                }
+					                    if ((operand->flags & C33_XLDH_RD) != 0) 
+	                                    {
+	                                    	insn = 0x2800 + ulrd;		/* ld.h %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDH_WR) != 0) 
+	                                    {
+											g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+											g_iXload_range = operand->range;
+		                                    insn = 0x3800;		/* ld.h [%r0],%rs */
+		                                }
+					                    if ((operand->flags & C33_XLDW_RD) != 0) 
+	                                    {
+	                                    	insn = 0x3000 + ulrd;		/* ld.w %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDW_WR) != 0) 
+	                                    {
+											g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+											g_iXload_range = operand->range;
+		                                    insn = 0x3c00;		/* ld.w [%r0],%rs */
+		                                }
+					                    if ((operand->flags & C33_XLDUB_RD) != 0) 
+	                                    {
+	                                    	insn = 0x2400 + ulrd;		/* ld.ub %rd,[%r0] */
+	                                    }
+	                                    else if((operand->flags & C33_XLDUH_RD) != 0) 
+	                                    {
+		                                    insn = 0x2c00 + ulrd;		/* ld.uh %rd,[%r0] */
+		                                }
+	                                    extraInsnBuf[3] = insn;
+	                                    insn = 0x0240;				/* popn %r0 */
+	                                    extraInsnBuf[4] = insn;
+	                                    extra_data_len = 4;
+
+									}
+									/* add T.Tazaki 2004/08/19 <<< */
+#endif								
+                                }else if ( operand->range == 32 ){
+                                    /* ext   (symbol+imm32-%dp)@19-31 : ext  imm13 */
+                                    /* ext   (symbol+imm32-%dp)@6-18  : ext  imm13 */
+                                    /* ld.w  (symbol+imm32-%dp)@0-5   : ld.w r0,[%dp+imm6] */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+									//  optimizing ext inst
+									// for following patterns 
+									// 
+									// xld.* %rd, [LABEL]	(mem read)	(without medda32 and is ADV)
+									// xld.* [LABEL], %rd 	(mem write)	(without medda32 and is ADV)
+									if (g_c33_ext == 1) {
+										i_ext_cnt = evaluate_ext_count(ex, g_dpAddress, count_ext_for_xld_mem_rw_adv);
+									}
+
+									if (i_ext_cnt == 0) {
+										// no ext
+										reloc = BFD_RELOC_C33_DPL;
+
+									} else if (i_ext_cnt == 1) {
+										// 1 ext
+										opcode = (struct c33_opcode *)c33_ext_opcodes;
+										extra_data_befor_insn = true;
+										extra_data_len	= 1;
+										extraInsnBuf[0] = opcode->opcode;
+
+										if (fc >= MAX_INSN_FIXUPS)
+										  as_fatal (_("too many fixups"));
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_DPM;
+										++fc;
+										reloc = BFD_RELOC_C33_DPL;
+
+									} else {
+										/* 2 ext */
+										opcode = (struct c33_opcode *)c33_ext_opcodes;
+										extra_data_befor_insn = true;
+										extra_data_len	= 2;
+										extraInsnBuf[0] = opcode->opcode;
+										extraInsnBuf[1] = opcode->opcode;
+
+										if (fc >= MAX_INSN_FIXUPS)
+										  as_fatal (_("too many fixups"));
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;	/* extのオペランド */
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_DPH;
+										++fc;
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_DPM;
+										++fc;
+										reloc = BFD_RELOC_C33_DPL;
+
+									}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+                                    /* 2 ext */
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 2;
+                                    extraInsnBuf[0] = opcode->opcode;
+                                    extraInsnBuf[1] = opcode->opcode;
+
+                                    if (fc >= MAX_INSN_FIXUPS)
+                                      as_fatal (_("too many fixups"));
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;  /* extのオペランド */
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DPH;
+                                    ++fc;
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DPM;
+                                    ++fc;
+                                    reloc = BFD_RELOC_C33_DPL;
+#endif	/* EXT_REMOVE */
+
+                                }
+                            }
+                        }
+                        else {
+                            errmsg = _("invalid operand");
+                        }
+                    }
+                    else {
+                        errmsg = _("invalid operand");
+                    }
+                }
+/* <<< add tazaki 2001.11.20 */
+                
+                /* An operand is register indirectness (memory). */
+                else if ((operand->flags & C33_OPERAND_MEM) != 0) 
+                {
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (!register_name (& ex))
+                        {
+                            /* YES not register */
+
+                            if (system_register_name (& ex, true, false)){
+                                /* system register */
+                                errmsg = _("invalid operand");
+                            }
+                            else {
+                                check_input_line_pointer = input_line_pointer;
+                                
+                                expression (& ex);
+
+                                /* if Minus "-", No Support! */
+                                while(check_input_line_pointer < input_line_pointer){
+                                    if (*check_input_line_pointer == '-'){
+                                        errmsg = _("invalid operand");
+                                        break;
+                                    }
+                                    check_input_line_pointer++;
+                                }
+                            }
+                            
+                            if (errmsg != NULL){
+                            }
+                            /* ELSE IF Operand is Immidiate ? */
+                            else if (ex.X_op == O_constant){
+                                errmsg = _("invalid operand");  /* [imm26] patter : Error! 2001.11.28 */
+                            }
+                            /* ELSE IF Operand is SYMBOL ? */
+                            else if (ex.X_op == O_symbol){
+
+                                /* Pattern */
+                                /* [symbol+imm32] */
+
+                                
+                                /* ext goff_hi(symbol+imm32) */
+                                /* ext goff_lo(symbol+imm32) */
+                                /* [r15] */
+
+                                if (operand->range == 13){
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 1;
+                                    extraInsnBuf[0] = opcode->opcode;
+
+                                    if (fc >= MAX_INSN_FIXUPS)
+                                      as_fatal (_("too many fixups"));
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_GL;
+                                    ++fc;
+                                    
+                                        
+                                    /* Save Register Number. */
+                                    ex.X_op         = O_register;
+                                    ex.X_add_number = GP_REG;
+                                    ex.X_add_symbol = NULL;
+                                    ex.X_op_symbol  = NULL;
+                                
+                                }
+                                else if (operand->range == 26 && g_iMedda32 == 0 ){		/* use data area */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+									// optimizing ext inst
+									// for following patterns 
+									// 
+									// xld.* %rd, [LABEL]	(mem read)	(without medda32 and not ADV)
+									// xld.* [LABEL], %rd 	(mem write)	(without medda32 and not ADV)
+									// xb*	 [LABEL], imm3				(without medda32)
+									if (g_c33_ext == 1) {
+										i_ext_cnt = evaluate_ext_count(ex, g_dpAddress, count_ext_for_xld_mem_rw);
+									}
+
+									if (i_ext_cnt == 1) {
+										// 1 ext
+										// at least 1 ext will be appended
+										opcode = (struct c33_opcode *)c33_ext_opcodes;
+										extra_data_befor_insn = true;
+										extra_data_len	= 1;
+										extraInsnBuf[0] = opcode->opcode;
+
+										if (fc >= MAX_INSN_FIXUPS)
+										  as_fatal (_("too many fixups"));
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_DL;
+										++fc;
+
+										/* Save Register Number. */
+										ex.X_op 		= O_register;
+										ex.X_add_number = GP_REG;
+										ex.X_add_symbol = NULL;
+										ex.X_op_symbol	= NULL;
+
+
+									} else {
+
+										/* 2 ext */
+										opcode = (struct c33_opcode *)c33_ext_opcodes;
+										extra_data_befor_insn = true;
+										extra_data_len	= 2;
+										extraInsnBuf[0] = opcode->opcode;
+										extraInsnBuf[1] = opcode->opcode;
+
+										if (fc >= MAX_INSN_FIXUPS)
+										  as_fatal (_("too many fixups"));
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;	/* operand of ext */
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_DH;
+										++fc;
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_DL;
+										++fc;
+										
+											
+										/* Save Register Number. */
+										ex.X_op 		= O_register;
+										ex.X_add_number = GP_REG;
+										ex.X_add_symbol = NULL;
+										ex.X_op_symbol	= NULL;
+
+									}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+                                    /* 2 ext */
+                                    opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                    extra_data_befor_insn = true;
+                                    extra_data_len  = 2;
+                                    extraInsnBuf[0] = opcode->opcode;
+                                    extraInsnBuf[1] = opcode->opcode;
+
+                                    if (fc >= MAX_INSN_FIXUPS)
+                                      as_fatal (_("too many fixups"));
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DH;
+                                    ++fc;
+
+                                    fixups[ fc ].exp     = ex;
+                                    fixups[ fc ].opindex = * opcode->operands;
+                                    fixups[ fc ].reloc   = BFD_RELOC_C33_DL;
+                                    ++fc;
+                                    
+                                        
+                                    /* Save Register Number. */
+                                    ex.X_op         = O_register;
+                                    ex.X_add_number = GP_REG;
+                                    ex.X_add_symbol = NULL;
+                                    ex.X_op_symbol  = NULL;
+
+#endif	/* EXT_REMOVE */
+								}
+								/* add T.Tazaki 2004/08/19 >>> */
+                                else if ((operand->range == 19 || operand->range == 26) && g_iMedda32 == 1 ){	/* xld と ald 兼用  : no use data area */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+									// optimizing ext inst
+									// for following patterns 
+									// 
+									// xld.* %rd, [LABEL]	(mem read)	(with medda32)
+									// xld.* [LABEL], %rd 	(mem write)	(with medda32)
+									// ald.* %rd, [LABEL]	(mem read)	(with medda32)
+									// ald.* [LABEL], %rd 	(mem write)	(with medda32)
+									// xb*	 [LABEL], imm3				(with medda32)
+
+									/* スクラッチは%r0だが、%rs = %r0のときは後で、スクラッチを%r1に変更される。 */
+									/* 0:pushn %r0		   			*/
+									/* 1:ext  label+imm32@m 		*/
+									/* 2:ext  label+imm32@m 		*/
+									/* 3:ld.x %r0,label+imm32@l 	*/
+									/* 4:ld.x [%r0],%rs   			*/
+									/* 5:popn %r0					*/
+
+// macro which means that we are now dealing with a memory read (*ld.* %rd, [LABEL]) operation
+// and not memory write or bit operation
+#define IS_MEM_READ ( (operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+
+
+									if (g_c33_ext == 1) {
+										// for ald
+										if (operand->range == 19) {
+											i_ext_cnt = evaluate_ext_count(ex, 0, count_ext_for_ald_mem_rw32);
+										} else {
+											i_ext_cnt = evaluate_ext_count(ex, 0, count_ext_for_xld_mem_rw32);
+										}
+									}
+
+									// determine extraInsnBuf indices from ext counts
+									if (i_ext_cnt == 0) {
+										// no ext
+										if (IS_MEM_READ) {
+											insn_idx_low  = 0;
+										} else {
+											insn_idx_low  = 1;
+										}
+									} else if (i_ext_cnt == 1) {
+										// 1 ext
+										if (IS_MEM_READ) {
+											insn_idx_low  = 1;
+										} else {
+											insn_idx_low  = 2;
+										}
+									} else {
+										// 2 ext
+										if (IS_MEM_READ) {
+											if (operand->range == 26) {
+												insn_idx_low  = 2;
+											} else {
+												insn_idx_low  = 1;		// ald
+											}
+										} else {
+											if (operand->range == 26) {
+												insn_idx_low  = 3;
+											} else {
+												insn_idx_low  = 2;		// ald
+											}
+										}
+									}
+
+									// set all indices
+									insn_idx_high = (insn_idx_low < 2) ? 0 : insn_idx_low - 2;	// negative -> 0
+									insn_idx_mid  = (insn_idx_low < 1) ? 0 : insn_idx_low - 1;	// negative -> 0
+									insn_idx_low  = insn_idx_low;
+									insn_idx_load = insn_idx_low + 1;
+									insn_idx_pop  = insn_idx_low + 2;	// only for mem write
+
+
+									// push insn
+									extraInsnBuf[0] = 0x0200;	/* pushn %r0 */ 
+
+									// ext insn
+									opcode = (struct c33_opcode *)c33_ext_opcodes;
+									extra_data_befor_insn = true;
+
+									if (i_ext_cnt == 0) {
+										; // do nothing
+									} else if (i_ext_cnt == 1) {
+										extraInsnBuf[insn_idx_mid] = opcode->opcode;
+									} else {
+										// ald.* does not have ext @h
+										if (operand->range == 26) {
+											extraInsnBuf[insn_idx_high] = opcode->opcode;
+										}
+										extraInsnBuf[insn_idx_mid]  = opcode->opcode;
+									}
+
+
+									// fill fixup array
+									if (fc >= MAX_INSN_FIXUPS)
+									  as_fatal (_("too many fixups"));
+
+									/* これは、リンク後、pushn %rs の %rs が、BFD_RELOC_C33_H に設定されてしまうので新規にBFD_RELOC_C33_PUSHN_R0
+									   を追加して、リンカで "pushn %r0" を設定させるためにある。 
+									   xld.x %rd,[symbol+imm] は、push/pop を行わない。 */
+									if (!IS_MEM_READ)
+									{
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands; 
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_PUSHN_R0;
+										++fc;
+									}
+
+									if (i_ext_cnt == 0) {
+										// 
+										reloc = BFD_RELOC_C33_L;
+                                	} else if (i_ext_cnt == 1) {
+
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_M;
+										++fc;
+
+										reloc = BFD_RELOC_C33_L;
+
+									} else {
+										
+										// ald.* has only 1 ext
+										if ( operand->range == 26 ) {
+											fixups[ fc ].exp	 = ex;
+											fixups[ fc ].opindex = * opcode->operands;	/* operand of ext */
+											fixups[ fc ].reloc	 = BFD_RELOC_C33_H;
+											++fc;
+										}
+										fixups[ fc ].exp	 = ex;
+										fixups[ fc ].opindex = * opcode->operands;
+										fixups[ fc ].reloc	 = BFD_RELOC_C33_M;
+										++fc;
+
+										reloc = BFD_RELOC_C33_L;
+
+									} 
+
+
+									// low insn (ld.w %rd, @l)
+									ulrd = insn & 0x000f;
+									if( operand->range == 26 )
+									{
+										if (IS_MEM_READ)
+										{
+											extraInsnBuf[insn_idx_low] = insn;		/* ld.w %rd,sign6 */
+										}
+										else
+										{
+											insn &= 0xfff0;
+											extraInsnBuf[insn_idx_low] = insn;		/* ld.w %r0,sign6 */
+										}
+									}
+									else
+									{
+										if (IS_MEM_READ)
+										{
+											/* ald.x %rd,[symbol+imm] */
+											extraInsnBuf[insn_idx_low] = insn;		/* ld.w %rd,sign6 */
+										}
+										else
+										{
+											/* ald.x [symbol+imm],%rs */
+											insn &= 0xfff0;
+											extraInsnBuf[insn_idx_low] = insn;		/* ld.w %r0,sign6 */
+										}
+									}
+
+									// load insn
+									if ((operand->flags & C33_XLDB_RD) != 0) 
+									{
+										insn = 0x2000 + ulrd + ulrd * 16;		/* ld.b %rd,[%rd] */
+									}
+									else if((operand->flags & C33_XLDB_WR) != 0) 
+									{
+										g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+										insn = 0x3400;							/* ld.b [%r0],%rs */
+									}
+									if ((operand->flags & C33_XLDH_RD) != 0) 
+									{
+										insn = 0x2800 + ulrd + ulrd * 16;		/* ld.h %rd,[%rd] */
+									}
+									else if((operand->flags & C33_XLDH_WR) != 0) 
+									{
+										g_iXload = 1;				/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+										insn = 0x3800;							/* ld.h [%r0],%rs */
+									}
+									if ((operand->flags & C33_XLDW_RD) != 0) 
+									{
+										insn = 0x3000 + ulrd + ulrd * 16;		/* ld.w %rd,[%rd] */
+									}
+									else if((operand->flags & C33_XLDW_WR) != 0) 
+									{
+										g_iXload = 1;				/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+										insn = 0x3c00;							/* ld.w [%r0],%rs */
+									}
+									if ((operand->flags & C33_XLDUB_RD) != 0) 
+									{
+										insn = 0x2400 + ulrd + ulrd * 16;		/* ld.ub %rd,[%rd] */
+									}
+									else if((operand->flags & C33_XLDUH_RD) != 0) 
+									{
+										insn = 0x2c00 + ulrd + ulrd * 16;		/* ld.uh %rd,[%r0] */
+									}
+									else if((operand->flags & C33_XBTST) != 0) 
+									{
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+										insn = 0xa800;				/* btst [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+									}
+									else if((operand->flags & C33_XBCLR) != 0) 
+									{
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+										insn = 0xac00;				/* bclr [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+									}
+									else if((operand->flags & C33_XBSET) != 0) 
+									{
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+										insn = 0xb000;				/* bset [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+									}
+									else if((operand->flags & C33_XBNOT) != 0) 
+									{
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+										insn = 0xb400;				/* bnot [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+									}
+									if( operand->range == 26 )
+									{
+										if (IS_MEM_READ)
+										{
+											extraInsnBuf[insn_idx_load] = insn;
+											extra_data_len = insn_idx_load;
+										}
+										else
+										{
+											extraInsnBuf[insn_idx_load] = insn;
+											insn = 0x0240;				/* popn %r0 */
+											extraInsnBuf[insn_idx_pop] = insn;
+											extra_data_len = insn_idx_pop;
+										}
+									}
+									else
+									{
+										if (IS_MEM_READ)
+										{
+											extraInsnBuf[insn_idx_load] = insn;
+											extra_data_len = insn_idx_load;
+										}
+										else
+										{
+											extraInsnBuf[insn_idx_load] = insn;
+											insn = 0x0240;				/* popn %r0 */
+											extraInsnBuf[insn_idx_pop] = insn;
+											extra_data_len = insn_idx_pop;
+										}
+									}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+                                	/* スクラッチは%r0だが、%rs = %r0のときは後で、スクラッチを%r1に変更される。 */
+									/* 0:pushn %r0         			*/
+	                                /* 1:ext  label+imm32@m 		*/
+	                                /* 2:ext  label+imm32@m 		*/
+	                                /* 3:ld.x %r0,label+imm32@l 	*/
+	                                /* 4:ld.x [%r0],%rs   			*/
+	                                /* 5:popn %r0					*/
+
+                                    extraInsnBuf[0] = 0x0200;	/* pushn %r0 */ 
+
+	                                /* 1 or 2 ext */
+	                                opcode = (struct c33_opcode *)c33_ext_opcodes;
+	                                extra_data_befor_insn = true;
+				                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+				                    {
+		                                extraInsnBuf[0] = opcode->opcode;
+									}
+									else
+									{
+		                                extraInsnBuf[1] = opcode->opcode;
+		                            }
+									if( operand->range == 26 )
+									{
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+			                                extraInsnBuf[1] = opcode->opcode;
+										}
+										else
+										{
+			                                extraInsnBuf[2] = opcode->opcode;
+			                            }
+									}
+	                                if (fc >= MAX_INSN_FIXUPS)
+	                                  as_fatal (_("too many fixups"));
+
+									/* これは、リンク後、pushn %rs の %rs が、BFD_RELOC_C33_H に設定されてしまうので新規にBFD_RELOC_C33_PUSHN_R0
+									   を追加して、リンカで "pushn %r0" を設定させるためにある。 
+									   xld.x %rd,[symbol+imm] は、push/pop を行わない。 */
+				                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) == 0 )
+									{
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands; 
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_PUSHN_R0;
+		                                ++fc;
+		                            }
+
+									if( operand->range == 26 )
+									{
+		                                fixups[ fc ].exp     = ex;
+		                                fixups[ fc ].opindex = * opcode->operands;  /* operand of ext */
+		                                fixups[ fc ].reloc   = BFD_RELOC_C33_H;
+		                                ++fc;
+									}
+	                                fixups[ fc ].exp     = ex;
+	                                fixups[ fc ].opindex = * opcode->operands;
+	                                fixups[ fc ].reloc   = BFD_RELOC_C33_M;
+	                                ++fc;
+
+	                                reloc = BFD_RELOC_C33_L;
+
+                                    extra_data_befor_insn = true;
+                                    ulrd = insn & 0x000f;
+									if( operand->range == 26 )
+									{
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+		                                    extraInsnBuf[2] = insn;		/* ld.w %rd,sign6 */
+										}
+										else
+										{
+		                                    insn &= 0xfff0;
+		                                    extraInsnBuf[3] = insn;		/* ld.w %r0,sign6 */
+		                                }
+                                    }
+                                    else
+                                    {
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+											/* xld.x %rd,[symbol+imm] */
+		                                    extraInsnBuf[1] = insn;		/* ld.w %rd,sign6 */
+										}
+										else
+										{
+											/* xld.x [symbol+imm],%rs */
+		                                    insn &= 0xfff0;
+		                                    extraInsnBuf[2] = insn;		/* ld.w %r0,sign6 */
+										}
+	                                }
+				                    if ((operand->flags & C33_XLDB_RD) != 0) 
+                                    {
+                                    	insn = 0x2000 + ulrd + ulrd * 16;		/* ld.b %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDB_WR) != 0) 
+                                    {
+										g_iXload = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+	                                    insn = 0x3400;							/* ld.b [%r0],%rs */
+	                                }
+				                    if ((operand->flags & C33_XLDH_RD) != 0) 
+                                    {
+                                    	insn = 0x2800 + ulrd + ulrd * 16;		/* ld.h %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDH_WR) != 0) 
+                                    {
+										g_iXload = 1;				/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+	                                    insn = 0x3800;							/* ld.h [%r0],%rs */
+	                                }
+				                    if ((operand->flags & C33_XLDW_RD) != 0) 
+                                    {
+                                    	insn = 0x3000 + ulrd + ulrd * 16;		/* ld.w %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDW_WR) != 0) 
+                                    {
+										g_iXload = 1;				/* オペランド値取得用にフラグを１にする。 */
+										g_iXload_range = operand->range;
+	                                    insn = 0x3c00;							/* ld.w [%r0],%rs */
+	                                }
+				                    if ((operand->flags & C33_XLDUB_RD) != 0) 
+                                    {
+                                    	insn = 0x2400 + ulrd + ulrd * 16;		/* ld.ub %rd,[%rd] */
+                                    }
+                                    else if((operand->flags & C33_XLDUH_RD) != 0) 
+                                    {
+	                                    insn = 0x2c00 + ulrd + ulrd * 16;		/* ld.uh %rd,[%r0] */
+	                                }
+                                    else if((operand->flags & C33_XBTST) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xa800;				/* btst [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+                                    else if((operand->flags & C33_XBCLR) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xac00;				/* bclr [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+                                    else if((operand->flags & C33_XBSET) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xb000;				/* bset [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+                                    else if((operand->flags & C33_XBNOT) != 0) 
+                                    {
+										g_iBitTest = 1;		/* オペランド値取得用にフラグを１にする。 */
+										g_iBitTest_range = operand->range;
+	                                    insn = 0xb400;				/* bnot [%r0],imm3 */ /* ここではオペランド値 imm3 は設定しない。 */
+	                                }
+									if( operand->range == 26 )
+									{
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+		                                    extraInsnBuf[3] = insn;
+		                                    extra_data_len = 3;
+		                                }
+		                                else
+		                                {
+		                                    extraInsnBuf[4] = insn;
+		                                    insn = 0x0240;				/* popn %r0 */
+		                                    extraInsnBuf[5] = insn;
+		                                    extra_data_len = 5;
+		                                }
+	                                }
+	                                else
+	                                {
+					                    if ((operand->flags & (C33_XLDB_RD + C33_XLDH_RD + C33_XLDW_RD + C33_XLDUB_RD + C33_XLDUH_RD)) != 0 )
+					                    {
+		                                    extraInsnBuf[2] = insn;
+		                                    extra_data_len = 2;
+		                                }
+		                                else
+		                                {
+		                                    extraInsnBuf[3] = insn;
+		                                    insn = 0x0240;				/* popn %r0 */
+		                                    extraInsnBuf[4] = insn;
+		                                    extra_data_len = 4;
+		                                }
+									}
+
+
+								/* add T.Tazaki 2004/08/19 <<< */
+#endif	/* EXT_REMOVE */
+                                }
+                                else {
+                                    errmsg = _("invalid operand");
+                                }
+                            }
+                            else {
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                        else {
+                        /* NO Register */
+                            /* Are there any symbol and IMM which follow a register? */
+                            
+                            /* Pattern */
+                            /* [rb+imm32] */
+                            
+                            /* Skip Space */
+                            while (isspace (*input_line_pointer))
+                                ++input_line_pointer;
+                            
+                            /* IF ']' */
+                            if (*input_line_pointer == ']'){
+                            /* YES Register Only */
+    #if 0
+                                errmsg = _("invalid operand");
+    #else
+                                input_line_pointer++;
+    #endif
+                            }
+                            /* ELSE IF plus */
+                            else if (*input_line_pointer == '+'){
+                            /* YES plus */
+                            
+                                input_line_pointer++;
+                                /* symbol,imm */
+                                expression (& ext_ex);
+
+                                if (ext_ex.X_op == O_constant){
+                                    /* [%rd+imm26] */
+                                
+                                    uiNumber = ext_ex.X_add_number;
+                                    
+                                    if (uiNumber == 0){
+                                        /* EMPTY */
+                                    }
+                                    else if (uiNumber <= 0x1fff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 1;
+                                        extraInsnBuf[0] = opcode->opcode| (uiNumber & 0x1fff);
+                                    }
+                                    else if (uiNumber <= 0x3ffffff){
+                                        opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                        extra_data_befor_insn = true;
+                                        extra_data_len  = 2;
+                                        extraInsnBuf[0] = opcode->opcode| ((uiNumber >> 13) & 0x1fff);
+                                        extraInsnBuf[1] = opcode->opcode| (uiNumber & 0x1fff);
+                                    }
+                                    else {
+                                    /* NO more than 27bit ? */
+                                    
+                                        /* tnot support */
+                                        errmsg = _("invalid operand");
+                                        iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+                                    }
+                                }
+                                else {
+                                /* NO not immidiate */
+                                    errmsg = _("invalid operand");
+                                    iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+                                }
+                            }
+                            else {
+                            /* NO any other character  */
+                                /* error */
+                                errmsg = _("invalid operand");
+                                iMEM_IMM26_flag = 1;    /* add tazaki 2001.10.11 */
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                /* an operand -- the register with a post increment -- or [ being indirect ] */
+                else if ((operand->flags & C33_OPERAND_REGINC) != 0) 
+                {
+                    if (*str == '['){
+                        str++;
+                        input_line_pointer = str;
+
+                        if (!register_name (& ex))
+                        {
+                            errmsg = _("invalid register name");
+                        }
+                        else {
+                            str = input_line_pointer;
+
+                            /* Skip space */
+                            while (isspace (*str))
+                                ++str;
+
+                            if (*str == ']'){
+                                ++str;
+
+                                while (isspace (*str))
+                                    ++str;
+                                
+                                if (*str == '+'){
+                                    /* normal end */
+                                    str++;
+                                    input_line_pointer = str;
+                                    
+                                }
+                                else {
+                                    errmsg = _("invalid operand");
+                                }
+                            }
+                            else {
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                
+                
+                /* Register indirectness with the De Dis placement */
+                else if ((operand->flags & C33_OPERAND_SPMEM) != 0) 
+                {
+                    if (*str == '['){
+                        str++;
+                        /* Skip space */
+                        while (isspace (*str))
+                            ++str;
+
+                        input_line_pointer = str;
+
+                        /* check %sp */
+                        if ( ( strncmp(str,"%sp",3) != 0 ) && ( strncmp(str,"%SP",3) != 0 ))
+                        {
+                            /* YES  */
+                            errmsg = _("invalid system register name");
+                        }
+                        else {
+                            str+=3;
+                            while (isspace (*str))
+                                ++str;
+
+                            /* IF ']' */
+                            if (*str == ']'){
+                            /* YES only register */
+                                /* Support "[%sp]"  2001.3.29 ide */
+                                ex.X_op         = O_constant;
+                                ex.X_add_symbol = NULL;
+                                ex.X_op_symbol  = NULL;
+                                ex.X_add_number = 0;
+                                str++;
+                                input_line_pointer = str;
+                            }
+                            else if (*str == '+'){
+                            /* [sp+imm] */
+                                str++;
+                                input_line_pointer = str;
+
+                                expression (& ex);
+
+                                iNumber = ex.X_add_number;
+                                    
+                                if (operand->range <= 6){
+                                    /* EMPTY */
+                                }
+                                else if (operand->range == 32) {
+                                    /* update tazaki 2002.03.08 >>> */
+                                    if (opcode->specialFlag == 1){
+                                        /* ld.b */
+                                        if ((unsigned int)iNumber <= 0x3f){
+                                            ex.X_add_number /= 1;
+                                            
+                                        }else if ((unsigned int)iNumber <= 0x7ffff){
+                                            /* 1 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                    }
+                                    else if (opcode->specialFlag == 2){
+                                        /* ld.h */
+                                        if ((unsigned int)iNumber <= 0x7f){
+                                            ex.X_add_number /= 2;
+                                             
+                                        }else if ((unsigned int)iNumber <= 0x7ffff){
+                                            /* 1 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                    }
+                                    else if (opcode->specialFlag == 4){
+                                        /* ld.w */
+                                        if ((unsigned int)iNumber <= 0xff){
+                                            ex.X_add_number /= 4;
+                                            
+                                        }else if ((unsigned int)iNumber <= 0x7ffff){
+                                            /* 1 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 1;
+                                            extraInsnBuf[0] = opcode->opcode| ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                        else {
+                                            /* 2 ext */
+                                            opcode = (struct c33_opcode *)c33_ext_opcodes;
+                                            extra_data_befor_insn = true;
+                                            extra_data_len  = 2;
+                                            extraInsnBuf[0] = opcode->opcode | ((iNumber >> 19) & 0x1fff);
+                                            extraInsnBuf[1] = opcode->opcode | ((iNumber >> 6) & 0x1fff);
+                                            ex.X_add_number = iNumber & 0x3f;
+                                        }
+                                    }
+                                    /* update tazaki 2002.03.08 <<< */
+                                }
+                                else {
+                                    errmsg = _("constant too big to fit into instruction");
+                                }
+                            }
+                            else{
+                                errmsg = _("invalid operand");
+                            }
+                        }
+                    }
+                    else
+                        errmsg = _("invalid operand");
+                }
+                
+                if (errmsg)
+                    goto error;
+
+                switch (ex.X_op) 
+                {
+                    case O_cond:
+                        /* An operand and an operation code are made into a command code. */
+                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+                                      (char *) NULL, 0,
+                                      copy_of_instruction,flags);
+                        break;
+                    case O_op_shift:
+                        /* An operand and an operation code are made into a command code. */
+                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+                                      (char *) NULL, 0,
+                                      copy_of_instruction,flags);
+                        break;
+                    case O_spregister :
+                        /* Don't add %sp to a formula as an operand. */
+                        break;
+                    case O_dpregister :
+                        /* Don't add %sp to a formula as an operand. */
+                        break;
+                    case O_illegal:
+                        errmsg = _("illegal operand");
+                        goto error;
+                    case O_absent:
+                        errmsg = _("missing operand");
+                        goto error;
+                    case O_register:
+                        /* An operand and an operation code are made into a command code. */
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+						if (g_iXload == 1)		/* xld.x [symbol+imm],%rs ? */
+						{
+							if( g_iXload_range == 26 )	/* xld.x */
+							{
+								if( ex.X_add_number == 0 )	/* xld.x [symbol+imm],%rs  : %rs = %r0 ? */
+								{
+
+									/* change %r0 --> %r1 */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[0] = 0x0201;								/* pushn %r1 */
+										fixups[ 0 ].reloc   = BFD_RELOC_C33_PUSHN_R1;			/* pushn %r1 */
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[0] = 0x0011;								/* push %r1 */
+										fixups[ 0 ].reloc   = BFD_RELOC_C33_PUSH_R1;			/* push %r1 */
+									}
+									extraInsnBuf[insn_idx_low] = 0x6c01;						/* ld.w %r1,symbol+imm */
+									extraInsnBuf[insn_idx_load] = (extraInsnBuf[insn_idx_load] & 0xff0f) | 0x0010;	/* ld.x [%r1],%rs	   */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[insn_idx_pop] = 0x0241;					/* popn  %r1		   */
+										insn = 0x0241;
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[insn_idx_pop] = 0x0051;					/* pop	 %r1		   */
+										insn = 0x0051;
+									}
+								}
+								extraInsnBuf[insn_idx_load] = c33_insert_operand (extraInsnBuf[insn_idx_load], operand, ex.X_add_number,
+											  (char *) NULL, 0,
+											  copy_of_instruction,flags);
+							}
+							else
+							{
+								/* g_iXload_range = 19 : ald.x */
+								if( ex.X_add_number == 0 )	/* ald.x [symbol+imm],%rs  : %rs = %r0 ? */
+								{
+
+									/* change %r0 --> %r1 */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[0] = 0x0201;								/* pushn %r1 */
+										fixups[ 0 ].reloc   = BFD_RELOC_C33_PUSHN_R1;			/* pushn %r1 */
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[0] = 0x0011;								/* push %r1 */
+										fixups[ 0 ].reloc   = BFD_RELOC_C33_PUSH_R1;			/* push %r1 */
+									}
+									extraInsnBuf[insn_idx_low] = 0x6c01;						/* ld.w %r1,symbol+imm */
+									extraInsnBuf[insn_idx_load] = (extraInsnBuf[insn_idx_load] & 0xff0f) | 0x0010;	/* ld.x [%r1],%rs	   */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[insn_idx_pop] = 0x0241;					/* popn  %r1		   */
+										insn = 0x0241;
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[insn_idx_pop] = 0x0051;					/* pop	 %r1		   */
+										insn = 0x0051;
+									}
+								}
+								extraInsnBuf[insn_idx_load] = c33_insert_operand (extraInsnBuf[insn_idx_load], operand, ex.X_add_number,
+											  (char *) NULL, 0,
+											  copy_of_instruction,flags);
+							}
+							g_iXload = 0;
+							g_iXload_range = 0;
+						}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+                        /* add T.Tazaki 2004/08/19 >>> */
+				        if (g_iXload == 1)		/* xld.x [symbol+imm],%rs ? */
+				        {
+							if( g_iXload_range == 26 )	/* xld.x */
+							{
+								if( ex.X_add_number == 0 )	/* xld.x [symbol+imm],%rs  : %rs = %r0 ? */
+								{
+									/* change %r0 --> %r1 */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[0] = 0x0201;								/* pushn %r1 */
+		                                fixups[ fc-4 ].reloc   = BFD_RELOC_C33_PUSHN_R1;		/* pushn %r1 */
+		                            }
+		                            else
+		                            {
+										/* ADV or PE */
+										extraInsnBuf[0] = 0x0011;								/* push %r1 */
+		                                fixups[ fc-4 ].reloc   = BFD_RELOC_C33_PUSH_R1;			/* push %r1 */
+									}
+									extraInsnBuf[3] = 0x6c01;								/* ld.w %r1,symbol+imm */
+									extraInsnBuf[4] = (extraInsnBuf[4] & 0xff0f) | 0x0010;	/* ld.x [%r1],%rs      */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[5] = 0x0241;								/* popn  %r1           */
+										insn = 0x0241;
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[5] = 0x0051;								/* pop   %r1           */
+										insn = 0x0051;
+									}
+								}
+		                        extraInsnBuf[4] = c33_insert_operand (extraInsnBuf[4], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							else
+							{
+								/* g_iXload_range = 19 : ald.x */
+								if( ex.X_add_number == 0 )	/* ald.x [symbol+imm],%rs  : %rs = %r0 ? */
+								{
+
+									/* change %r0 --> %r1 */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[0] = 0x0201;								/* pushn %r1 */
+		                                fixups[ fc-3 ].reloc   = BFD_RELOC_C33_PUSHN_R1;		/* pushn %r1 */
+		                            }
+		                            else
+		                            {
+										/* ADV or PE */
+										extraInsnBuf[0] = 0x0011;								/* push %r1 */
+		                                fixups[ fc-3 ].reloc   = BFD_RELOC_C33_PUSH_R1;			/* push %r1 */
+									}
+									extraInsnBuf[2] = 0x6c01;								/* ld.w %r1,symbol+imm */
+									extraInsnBuf[3] = (extraInsnBuf[3] & 0xff0f) | 0x0010;	/* ld.x [%r1],%rs      */
+									if( g_iAdvance == 0 && g_iPE == 0 )	/* STD ? */
+									{
+										extraInsnBuf[4] = 0x0241;								/* popn  %r1           */
+										insn = 0x0241;
+									}
+									else
+									{
+										/* ADV or PE */
+										extraInsnBuf[4] = 0x0051;								/* pop   %r1           */
+										insn = 0x0051;
+									}
+								}
+		                        extraInsnBuf[3] = c33_insert_operand (extraInsnBuf[3], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							g_iXload = 0;
+							g_iXload_range = 0;
+						}
+                        /* add T.Tazaki 2004/08/19 <<< */
+#endif	/* EXT_REMOVE */
+						else
+						{
+	                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+                                      (char *) NULL, 0,
+                                      copy_of_instruction,flags);
+						}
+                        break;
+                        
+                    case O_constant:
+                        /* An operand and an operation code are made into a command code. */
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+						if (g_iBitTest == 1)		/* bit test inst ? */
+						{
+							if( g_iBitTest_range == 26 )
+							{
+								extraInsnBuf[insn_idx_load] = c33_insert_operand (extraInsnBuf[insn_idx_load], operand, ex.X_add_number,
+											  (char *) NULL, 0,
+											  copy_of_instruction,flags);
+							}
+							else
+							{
+								extraInsnBuf[insn_idx_load] = c33_insert_operand (extraInsnBuf[insn_idx_load], operand, ex.X_add_number,
+											  (char *) NULL, 0,
+											  copy_of_instruction,flags);
+							}
+							g_iBitTest = 0;
+							g_iBitTest_range = 0;
+						}
+#else
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+                        /* add T.Tazaki 2004/07/30 >>> */
+				        if (g_iBitTest == 1)		/* bit test inst ? */
+				        {
+							if( g_iBitTest_range == 26 )
+							{
+
+		                        extraInsnBuf[4] = c33_insert_operand (extraInsnBuf[4], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							else
+							{
+		                        extraInsnBuf[3] = c33_insert_operand (extraInsnBuf[3], operand, ex.X_add_number,
+		                                      (char *) NULL, 0,
+		                                      copy_of_instruction,flags);
+							}
+							g_iBitTest = 0;
+							g_iBitTest_range = 0;
+						}
+                        /* add T.Tazaki 2004/07/30 <<< */
+#endif	/* EXT_REMOVE */
+						else
+						{
+	                        insn = c33_insert_operand (insn, operand, ex.X_add_number,
+	                                      (char *) NULL, 0,
+	                                      copy_of_instruction,flags);
+						}
+                        break;
+
+                    case O_symbol:
+                        /* We need to generate a fixup for this expression.  */
+                        if (fc >= MAX_INSN_FIXUPS)
+                          as_fatal (_("too many fixups"));
+
+                        fixups[ fc ].exp     = ex;
+                        fixups[ fc ].opindex = * opindex_ptr;
+                        fixups[ fc ].reloc   = reloc;
+                        ++fc;
+                        break;
+
+                    default:
+                        /* We need to generate a fixup for this expression.  */
+                        if (fc >= MAX_INSN_FIXUPS)
+                          as_fatal (_("too many fixups"));
+
+                        fixups[ fc ].exp     = ex;
+                        fixups[ fc ].opindex = * opindex_ptr;
+                        fixups[ fc ].reloc   = BFD_RELOC_UNUSED;
+                        ++fc;
+                        break;
+                }
+            }
+            str = input_line_pointer;
+            input_line_pointer = hold;
+
+            while (*str == ' ' || *str == ',' || *str == ']' )
+                ++str;
+        }
+        match = 1;
+
+        error:
+        if (match == 0)
+        {
+
+            /* xld.w rd,[rs+imm26] : imm26 > 0x3ffffff ?    add tazaki 2001.10.11 */
+            if( iMEM_IMM26_flag == 0 ){ /* The following operand form is not seen at the time of range over.。*/
+                next_opcode = opcode + 1;
+                if (next_opcode->name != NULL
+                    && strcmp (next_opcode->name, opcode->name) == 0)
+                {
+                    opcode = next_opcode;
+                    continue;   
+                }
+            }
+            as_bad (_("%s: %s"), copy_of_instruction, errmsg);
+/*          as_bad ("%s: %s", copy_of_instruction, errmsg); Modify tazaki 2001.10.11 */
+
+            if (* input_line_pointer == ']')
+                ++ input_line_pointer;
+
+            ignore_rest_of_line ();
+            input_line_pointer = saved_input_line_pointer;
+            return;
+        }
+        break;
+    }
+      
+    while (isspace (*str))
+      ++str;
+
+    if (*str != '\0')
+    /* xgettext:c-format */
+        as_bad (_("junk at end of line: `%s'"), str);
+
+    input_line_pointer = str;
+
+    /* Write out the instruction. */
+
+    if (relaxable && fc > 0)
+    {
+
+        fc = 0;
+
+        if (!strcmp (opcode->name, "br"))
+        {
+            f = frag_var (rs_machine_dependent, 4, 2, 2,
+            fixups[0].exp.X_add_symbol,
+            fixups[0].exp.X_add_number,
+            (char *)fixups[0].opindex);
+            md_number_to_chars (f, insn, 2);
+            md_number_to_chars (f + 2, 0, 2);
+        }
+        else
+        {
+            f = frag_var (rs_machine_dependent, 6, 4, 0,
+                fixups[0].exp.X_add_symbol,
+                fixups[0].exp.X_add_number,
+                (char *)fixups[0].opindex);
+            md_number_to_chars (f, insn, 2);
+            md_number_to_chars (f + 2, 0, 4);
+        }
+    }
+    else 
+    {
+        /* ext command is set before a command code formula.   . */
+        if (extra_data_befor_insn)
+        {
+            /* Domain reservation */
+            f = where = frag_more (extra_data_len*2+2); /* 2byte length instruction */
+
+            /* The command code for extension (ext command) is acquired. */
+            fromP = &extraInsnBuf[0];
+
+            /* Only a part for the command code for FOR extensio */
+            for (i = extra_data_len; i; --i)
+            {
+                /* The command code is stored in the buffer in order. */
+                md_number_to_chars (where, (long) (*fromP), 2);
+                where += 2;
+                fromP++;
+            }
+
+// ADD D.Fujimoto 2007/06/25 calculating inst offset for ext remove >>>>>>>
+#ifdef EXT_REMOVE
+			ul_All_Offset += extra_data_len;
+#endif	/* EXT_REMOVE */
+// ADD D.Fujimoto 2007/06/25 calculating inst offset for ext remove <<<<<<<
+
+
+            extra_data_befor_insn = false;
+        }
+        else {
+            /* Domain reservation */
+            f = where = frag_more (2);  /* 2byte length instruction */
+        }
+
+        /* >>> add tazaki 2001.09.13 */
+        /* macclr,ld.cf ? */
+        if (opcode->specialFlag == 10){ 
+            insn |= 0x0010; /* bit 5,4 = 0,1 set */
+        }
+        /* <<< add tazaki 2001.09.13 */
+
+        /* The command code of 2 byte length is stored in a buffer. */
+        md_number_to_chars (where, insn, 2);
+    }
+
+    /* Create any fixups.  At this point we do not use a
+         bfd_reloc_code_real_type, but instead just use the
+         BFD_RELOC_UNUSED plus the operand index.  This lets us easily
+         handle fixups for any operand type, although that is admittedly
+         not a very exciting feature.  We pick a BFD reloc type in
+         md_apply_fix.  */  
+    for (i = 0; i < fc; i++)
+    {
+        const struct c33_operand * operand;
+        bfd_reloc_code_real_type    reloc;
+
+        operand = & c33_operands[ fixups[i].opindex ];
+
+        reloc = fixups[i].reloc;
+
+        if (reloc != BFD_RELOC_UNUSED)
+        {
+            reloc_howto_type * reloc_howto = bfd_reloc_type_lookup (stdoutput,
+                                      reloc);
+            int                size;
+            int                address;
+            fixS *             fixP;
+
+            if (!reloc_howto){
+                    ;
+            /*  abort();    */  /* del tazaki 2001.10.11 */
+            }else{
+
+                size = bfd_get_reloc_size (reloc_howto);
+            
+                if (size != 2) {
+                    ;
+                /*  abort ();   */  /* del tazaki 2001.10.11 */
+                }else{
+    
+                    address = (f - frag_now->fr_literal) + 2 - size;
+        
+                    f += 2;
+                    
+                    fixP = fix_new_exp (frag_now, address, size,
+                              & fixups[i].exp, 
+                              reloc_howto->pc_relative,
+                              reloc);
+        
+                    switch (reloc)
+                    {
+                        case BFD_RELOC_C33_RH:
+                        case BFD_RELOC_C33_RM:
+                        case BFD_RELOC_C33_RL:
+                        case BFD_RELOC_C33_S_RH:    /* add T.Tazaki 2002.05.02 */
+                        case BFD_RELOC_C33_S_RM:    /* add T.Tazaki 2002.05.02 */
+                        case BFD_RELOC_C33_S_RL:    /* add T.Tazaki 2002.05.02 */
+                        case BFD_RELOC_C33_JP:      /* add T.Tazaki 2002.04.22 */
+                        case BFD_RELOC_C33_AH:
+                        case BFD_RELOC_C33_AL:
+                        case BFD_RELOC_C33_H:
+                        case BFD_RELOC_C33_M:
+                        case BFD_RELOC_C33_L:
+                        /* >>>> add 2002.03.05 tazaki */
+                        case BFD_RELOC_C33_DH:
+                        case BFD_RELOC_C33_DL:
+                        case BFD_RELOC_C33_GL:
+                        case BFD_RELOC_C33_SH:
+                        case BFD_RELOC_C33_SL:
+                        case BFD_RELOC_C33_TH:
+                        case BFD_RELOC_C33_TL:
+                        case BFD_RELOC_C33_ZH:
+                        case BFD_RELOC_C33_ZL:
+                        case BFD_RELOC_C33_DPH:
+                        case BFD_RELOC_C33_DPM:
+                        case BFD_RELOC_C33_DPL:
+                        case BFD_RELOC_C33_LOOP:
+                        /* <<<< add 2002.03.05 tazaki */
+                        case BFD_RELOC_C33_PUSHN_R0:	/*  add T.Tazaki 2004/08/19 */
+                        case BFD_RELOC_C33_PUSHN_R1:	/*  add T.Tazaki 2004/08/19 */
+                        case BFD_RELOC_C33_PUSH_R1:		/*  add T.Tazaki 2004/08/19 */
+                            fixP->fx_no_overflow = 1;
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+        }
+        else
+        {
+            fix_new_exp (
+                   frag_now,
+                   f - frag_now->fr_literal, 4,
+                   & fixups[i].exp,
+                   1 /* FIXME: C33_OPERAND_RELATIVE ??? */,
+                   (bfd_reloc_code_real_type) (fixups[i].opindex
+                               + (int) BFD_RELOC_UNUSED)
+                   );
+        }
+    }
+
+    input_line_pointer = saved_input_line_pointer;
+}
+
+
+/* If while processing a fixup, a reloc really needs to be created */
+/* then it is done here.  */
+                 
+arelent *
+tc_gen_reloc (seg, fixp)
+     asection * seg;
+     fixS *     fixp;
+{
+  arelent * reloc;
+  
+  reloc              = (arelent *) xmalloc (sizeof (arelent));
+  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
+  *reloc->sym_ptr_ptr= symbol_get_bfdsym (fixp->fx_addsy);
+  reloc->address     = fixp->fx_frag->fr_address + fixp->fx_where;
+  reloc->howto       = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
+
+  if (reloc->howto == (reloc_howto_type *) NULL)
+    {
+      as_bad_where (fixp->fx_file, fixp->fx_line,
+            /* xgettext:c-format */
+                    _("reloc %d not supported by object file format"),
+            (int) fixp->fx_r_type);
+
+      xfree (reloc);
+      
+      return NULL;
+    }
+  
+    reloc->addend = fixp->fx_addnumber;
+  
+  return reloc;
+}
+
+/* Assume everything will fit in two bytes, then expand as necessary.  */
+int
+md_estimate_size_before_relax (fragp, seg)
+     fragS * fragp;
+     asection * seg;
+{
+  if (fragp->fr_subtype == 0)
+    fragp->fr_var = 4;
+  else if (fragp->fr_subtype == 2)
+    fragp->fr_var = 2;
+  else
+    abort ();
+  return 2;
+} 
+
+long
+c33_pcrel_from_section (fixp, section)
+     fixS * fixp;
+     segT   section;
+{
+  /* If the symbol is undefined, or in a section other than our own,
+     or it is weak (in which case it may well be in another section,
+     then let the linker figure it out.  */
+  if (fixp->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixp->fx_addsy)
+      || S_IS_WEAK (fixp->fx_addsy)
+      || (S_GET_SEGMENT (fixp->fx_addsy) != section)))
+    return 0;
+  
+  return fixp->fx_frag->fr_address + fixp->fx_where;
+}
+
+/*
+The symbol which can be decided inside a file is decided here.
+
+The tc_gen_reloc function which is in bfd library further is passed,
+ and, finally the symbol changed by referring to the exterior, the link,
+  and relocation is on HOWTO broad view of bfd.
+  It is processed by the defined method. 
+*/
+
+/* add T.Tazaki 2002.04.25 >>> */
+long    g_where_rh = 0xffffffff;
+long    g_where_rm = 0xffffffff;
+
+char    *g_pwhere_rh = 0;
+char    *g_pwhere_rm = 0;
+
+/* add T.Tazaki 2002.04.25 <<< */
+
+int
+md_apply_fix3 (fixp, valuep, seg)
+     fixS *   fixp;
+     valueT * valuep;
+     segT     seg;
+{
+  valueT value;
+  char * where;
+    long    insn;
+    int     iNumber;    /* add T.Tazaki 2002.04.25 */
+    long    lNumber;    /* add T.Tazaki 2002.04.25 */
+    
+    if (fixp->fx_addsy == (symbolS *) NULL)
+    {
+        value = * valuep;
+        fixp->fx_done = 1;
+    }
+    else if (fixp->fx_pcrel)
+        value = * valuep;
+    else
+    {
+        value = fixp->fx_offset;
+        if (fixp->fx_subsy != (symbolS *) NULL)
+        {
+            if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
+                value -= S_GET_VALUE (fixp->fx_subsy);
+            else
+            {
+                 /* We don't actually support subtracting a symbol.  */
+                 as_bad_where (fixp->fx_file, fixp->fx_line,
+                    _("expression too complex"));
+            }
+        }
+    }
+
+    if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
+    {
+      int                         opindex;
+      const struct c33_operand * operand;
+      unsigned long               insn;
+
+      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
+      operand = & c33_operands[ opindex ];
+
+      /* Fetch the instruction, insert the fully resolved operand
+         value, and stuff the instruction back again.
+
+     Note the instruction has been stored in little endian
+     format!  */
+      where = fixp->fx_frag->fr_literal + fixp->fx_where;
+
+      insn = bfd_getl16 ((unsigned char *) where);
+      insn = c33_insert_operand (insn, operand, (offsetT) value,
+                  fixp->fx_file, fixp->fx_line, NULL);
+      bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
+
+        if (fixp->fx_done)
+        {
+          /* Nothing else to do here. */
+          return 1;
+        }
+    }
+    else if (fixp->fx_done)
+    {
+        /* We still have to insert the value into memory!  */
+        where = fixp->fx_frag->fr_literal + fixp->fx_where;
+
+        if (fixp->fx_size == 1)
+            * where = value & 0xff;
+        else if (fixp->fx_size == 2){
+
+            /* An address when a symbol is decided is buried here
+             and crowded with the inside of a file. */
+
+            /* A command code is acquired. */
+            insn = bfd_getl16 ((unsigned char *) where);
+
+            switch (fixp->fx_r_type)
+            {
+            case BFD_RELOC_C33_AH:  /* @ah (25:13) */   /* NO USE : Absolute symbol */
+                
+                insn += ((value >> 13) & 0x1fff);
+                break;
+                
+                case BFD_RELOC_C33_AL:  /* @ah (12:0) */    /* NO USE : Absolute symbol */
+                insn += (value & 0x1fff);
+                break;
+
+            case BFD_RELOC_C33_RH:  /* LABEL-PC(31:22) */
+//              if( g_listing == 0 ){       /* No -a option ? */
+//                  g_where_rh = fixp->fx_where;
+//              }
+//              else{
+//                  g_pwhere_rh = where;
+//              }
+//
+                insn += (((value - 4) >> 19) & 0x1ff8);
+                break;
+                
+            case BFD_RELOC_C33_RM:  /* LABEL-PC(21:9)  */
+
+//              if( g_listing == 0 ){       /* No -a option ? */
+//
+//                  g_where_rm = fixp->fx_where;
+//                  if( g_where_rh != ( fixp->fx_where - 2 ) ){ /* add T.Tazaki 2002.04.25 */
+//                      
+//                      lNumber = value;
+//                      /* over signed 22bit ? */
+//                          if ((lNumber - 2) > 0x1ffffe || (lNumber - 2 ) < -0x200000 ) 
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_where_rh = 0xffffffff;
+//              }
+//              else
+//              {
+//                  g_pwhere_rm = where;
+//                  if( g_pwhere_rh != ( where - 100 ) ){   /* add T.Tazaki 2002.05.02 */
+//                      
+//                      lNumber = value;
+//                      /* over signed 22bit ? */
+//                          if ((lNumber - 2) > 0x1ffffe || (lNumber - 2 ) < -0x200000 ) 
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_pwhere_rh = 0;
+//              }
+                insn += (((value - 2) >> 9) & 0x1fff);
+                break;
+
+            case BFD_RELOC_C33_RL:  /* LABEL-PC(8:0)   */
+
+// -al オプション付きのとき、where値が必ずしも@rm のＰＣ+100とは限らないため、不採用。
+// -al無し( fixp->fx_where )ではＯＫだが、-alの有無でワーニング表示が異なるのは変なので両方削除した。
+
+//              if( g_listing == 0 ){       /* No -a option ? */
+//
+//                  if( g_where_rm != ( fixp->fx_where - 2 ) ){ /* add T.Tazaki 2002.04.25 */
+//
+//                      lNumber = value;
+//                      /* over signed 8bit ? */
+//                          if (lNumber > 254 || lNumber < -256)
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_where_rh = 0xffffffff;
+//                  g_where_rm = 0xffffffff;
+//              }
+//              else
+//              {
+//
+//                  if( g_pwhere_rm != ( where - 100 ) ){   /* add T.Tazaki 2002.05.02 */
+//
+//                      lNumber = value;
+//                      /* over signed 8bit ? */
+//                          if (lNumber > 254 || lNumber < -256)
+//                          as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+//                          /* as_bad_where = ERROR */
+//                  }
+//                  g_pwhere_rh = 0;
+//                  g_pwhere_rm = 0;
+//              }
+                
+                insn += ((value >> 1) & 0xff);
+                break;
+
+/* add T.Tazaki 2002.05.02 >>> */
+
+            case BFD_RELOC_C33_S_RH:    /* LABEL-PC(31:22) */   /* sjp,scall, xjp,xcall */
+                g_where_rh = fixp->fx_where;
+
+                insn += (((value - 4) >> 19) & 0x1ff8);
+                break;
+                
+            case BFD_RELOC_C33_S_RM:    /* LABEL-PC(21:9)  */   /* sjp,scall, xjp,xcall */
+
+                g_where_rm = fixp->fx_where;
+                if( g_where_rh != ( fixp->fx_where - 2 ) ){
+                    
+                    lNumber = value;
+                    /* over signed 22bit ? */
+                        if ((lNumber - 2) > 0x1ffffe || (lNumber - 2 ) < -0x200000 ) 
+                        as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+                        /* as_bad_where = ERROR */
+                }
+                g_where_rh = 0xffffffff;
+                insn += (((value - 2) >> 9) & 0x1fff);
+                break;
+
+            case BFD_RELOC_C33_S_RL:    /* LABEL-PC(8:0)   */   /* sjp,scall, xjp,xcall */
+
+                if( g_where_rm != ( fixp->fx_where - 2 ) ){
+
+                    lNumber = value;
+                    /* over signed 8bit ? */
+                        if (lNumber > 254 || lNumber < -256)
+                        as_warn_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+                        /* as_bad_where = ERROR */
+                }
+                g_where_rh = 0xffffffff;
+                g_where_rm = 0xffffffff;
+                
+                insn += ((value >> 1) & 0xff);
+                break;
+
+/* add T.Tazaki 2002.05.02 <<< */
+                    
+            case BFD_RELOC_C33_JP:  /* LABEL-PC(8:0)   */   /* add T.Tazaki 2002.04.22 */
+                /* jp label */
+
+                /* over signed 8bit ? */
+                iNumber = value;
+
+                if (iNumber > 254 || iNumber < -256)
+                     as_bad_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+
+                insn += ((value >> 1) & 0xff);
+                break;
+                    
+            case BFD_RELOC_C33_H:   /* LABEL(31:19) */  /* NO USE : Absolute symbol */
+                insn += ((value >> 19) & 0x1fff);
+                break;
+            
+            case BFD_RELOC_C33_M:   /* LABEL(18:6)  */  /* NO USE : Absolute symbol */
+                insn += ((value >> 6) & 0x1fff);
+                break;
+            
+            case BFD_RELOC_C33_L:   /* LABEL(5:0)   */  /* NO USE : Absolute symbol */
+                            /* ld.w rd,LABEL@l */
+                insn += (value & 0x3f) << 4;
+                break;
+
+            case BFD_RELOC_C33_LOOP:    /* LABEL-PC(4:0)   */
+
+                /* over imm 5bit ? */
+                iNumber = value;
+
+                if (iNumber > 30 || iNumber < 0)
+                     as_bad_where (fixp->fx_file, fixp->fx_line, _("operand out of range"));
+
+				/* "   loop %rc,Label-2 " 表現は使用し辛いので、 "loop %rc,Label" を可能とするため-１する。 add T.Tazaki 2004/09/22 >>> */
+				/* "   nop              " */
+				/* "   nop              " */
+				/* "Label:              " */
+				
+				--value;
+
+				/* add T.Tazaki 2004/09/22 <<< */
+
+                /* imm5=imm(4:1) imm5(0)=0 */
+                insn += (value & 0x1e) << 3;
+                break;
+                    
+            default:
+                break;
+            }
+
+            bfd_putl16 ((bfd_vma) insn, (unsigned char *) where);
+        }
+        else if (fixp->fx_size == 4)
+            bfd_putl32 (value, (unsigned char *) where);
+    }
+
+    fixp->fx_addnumber = value;
+    
+    return 1;
+}
+
+
+/* Parse a cons expression.  */
+void
+parse_cons_expression_c33 (exp)
+  expressionS * exp;
+{
+  /* See if there's a reloc prefix like hi() we have to handle.  */
+  hold_cons_reloc = c33_reloc_prefix ();
+
+  /* Do normal expression parsing.  */
+  expression (exp);
+}
+
+/* Create a fixup for a cons expression.  If parse_cons_expression_c33
+   found a reloc prefix, then we use that reloc, else we choose an
+   appropriate one based on the size of the expression.  */
+void
+cons_fix_new_c33 (frag, where, size, exp)
+     fragS * frag;
+     int where;
+     int size;
+     expressionS *exp;
+{
+  if (hold_cons_reloc == BFD_RELOC_UNUSED)
+    {
+      if (size == 4)
+    hold_cons_reloc = BFD_RELOC_32;
+      if (size == 2)
+    hold_cons_reloc = BFD_RELOC_16;
+      if (size == 1)
+    hold_cons_reloc = BFD_RELOC_8;
+    }
+
+  if (exp != NULL)
+    fix_new_exp (frag, where, size, exp, 0, hold_cons_reloc);
+  else
+    fix_new (frag, where, size, NULL, 0, 0, hold_cons_reloc);
+}
+
+boolean
+c33_fix_adjustable (fixP)
+    fixS * fixP;
+{
+  if (fixP->fx_addsy == NULL)
+    return 1;
+ 
+  /* Prevent all adjustments to global symbols. */
+  if (S_IS_EXTERN (fixP->fx_addsy))
+    return 0;
+  
+  if (S_IS_WEAK (fixP->fx_addsy))
+    return 0;
+  
+  /* Don't adjust function names */
+  if (S_IS_FUNCTION (fixP->fx_addsy))
+    return 0;
+
+  return 1;
+}
+ 
+int
+c33_force_relocation (fixP)
+      struct fix * fixP;
+{
+  if (fixP->fx_addsy && S_IS_WEAK (fixP->fx_addsy))
+    return 1;
+  
+  return 0;
+}
diff --git a/gas/config/tc-c33.h b/gas/config/tc-c33.h
new file mode 100644
index 0000000..98e62d2
--- /dev/null
+++ b/gas/config/tc-c33.h
@@ -0,0 +1,78 @@
+/* tc-c33.h -- Header file for tc-c33.c.
+   Copyright (C) 1996, 1997 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to the Free
+   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA. */
+
+#define TC_C33
+
+#include <elf/c33.h>
+
+#define TARGET_BYTES_BIG_ENDIAN 0
+
+#ifndef BFD_ASSEMBLER
+ #error C33 support requires BFD_ASSEMBLER
+#endif
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH 		bfd_arch_c33
+
+/* The target BFD format.  */
+#define TARGET_FORMAT 		"elf32-c33"
+
+#define MD_APPLY_FIX3
+
+#define md_operand(x)
+
+#define obj_fix_adjustable(fixP) c33_fix_adjustable(fixP)
+#define TC_FORCE_RELOCATION(fixp) c33_force_relocation(fixp)
+extern int c33_force_relocation PARAMS ((struct fix *));
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB 1
+
+#define DIFF_EXPR_OK		/* foo-. gets turned into PC relative relocs */
+
+/* We don't need to handle .word strangely.  */
+#define WORKING_DOT_WORD
+
+#define md_number_to_chars number_to_chars_littleendian
+     
+/* We need to handle lo(), hi(), etc etc in .hword, .word, etc
+   directives, so we have to parse "cons" expressions ourselves.  */
+#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_cons_expression_c33 (EXP)
+#define TC_CONS_FIX_NEW cons_fix_new_c33
+extern const struct relax_type md_relax_table[];
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+
+/* This section must be in the small data area (pointed to by GP).  */
+#define SHF_C33_GPREL		0x10000000
+
+/* tazaki 2001.12.03 */
+#define ELF_TC_SPECIAL_SECTIONS \
+  { ".comm",	SHT_C33_COMM,	 	SHF_ALLOC + SHF_WRITE + SHF_C33_GPREL	}, \
+  { ".gcomm",	SHT_C33_GCOMM,	 	SHF_ALLOC + SHF_WRITE + SHF_C33_GPREL	}, \
+  { ".scomm",	SHT_C33_SCOMM, 		SHF_ALLOC + SHF_WRITE + SHF_C33_GPREL	}, \
+  { ".tcomm",	SHT_C33_TCOMM,		SHF_ALLOC + SHF_WRITE + SHF_C33_GPREL	}, \
+  { ".zcomm",	SHT_C33_ZCOMM, 		SHF_ALLOC + SHF_WRITE + SHF_C33_GPREL	}, \
+
+
+#define MD_PCREL_FROM_SECTION(fixP,section) c33_pcrel_from_section (fixP, section)
+extern long c33_pcrel_from_section ();
+
+#define LEX_PCT  LEX_BEGIN_NAME	/* %を有効にする */
+
diff --git a/gas/configure b/gas/configure
index 28f69be..d01eb3c 100755
--- a/gas/configure
+++ b/gas/configure
@@ -1641,6 +1641,7 @@ for this_target in $target $canon_targets ; do
       sparc86x*)	cpu_type=sparc arch=sparc86x  ;;
       sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
       v850*)		cpu_type=v850 ;;
+      c33*)		cpu_type=c33 ;;
       *)		cpu_type=${cpu} ;;
     esac
 
@@ -1895,6 +1896,8 @@ EOF
       tic30-*-*coff*)       fmt=coff bfd_gas=yes ;;
       tic80-*-*)	    fmt=coff ;;
 
+      c33-*-*)		    fmt=elf bfd_gas=yes ;;
+
       v850-*-*)		    fmt=elf bfd_gas=yes ;;
       v850e-*-*)	    fmt=elf bfd_gas=yes ;;
       v850ea-*-*)	    fmt=elf bfd_gas=yes ;;
diff --git a/gas/configure.in b/gas/configure.in
index 1707acd..416e10e 100644
--- a/gas/configure.in
+++ b/gas/configure.in
@@ -119,6 +119,7 @@ changequote([,])dnl
       sparc86x*)	cpu_type=sparc arch=sparc86x  ;;
       sparc*)		cpu_type=sparc arch=sparclite ;; # ??? See tc-sparc.c.
       v850*)		cpu_type=v850 ;;
+      c33*)		cpu_type=c33 ;;
       *)		cpu_type=${cpu} ;;
     esac
 
diff --git a/gas/doc/Makefile.am b/gas/doc/Makefile.am
index c6eaf77..151e58f 100644
--- a/gas/doc/Makefile.am
+++ b/gas/doc/Makefile.am
@@ -34,6 +34,7 @@ CPU_DOCS = \
 	c-sparc.texi \
 	c-vax.texi \
 	c-v850.texi \
+	c-c33.texi \
 	c-z8k.texi
 
 gasver.texi: Makefile
diff --git a/gas/ext_remove.c b/gas/ext_remove.c
new file mode 100644
index 0000000..70f0d87
--- /dev/null
+++ b/gas/ext_remove.c
@@ -0,0 +1,2014 @@
+/* ext_remove.c - implementation for 2pass assemble.
+	This program will remove redundant ext 0x0 instructions
+	which emerge from memory load from LABEL/SYMBOLS or
+	from function calls to LABEL/SYMBOLS
+	Copyright (C) 2007 SEIKO EPSON CORP.
+
+	Written by D.Fujimoto@Irumasoft
+	DATE:2007/02/28
+
+	This file is part of GAS, the GNU Assembler.
+
+	GAS is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2, or (at your option)
+	any later version.
+
+	GAS is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with GAS; see the file COPYING.  If not, write to the Free
+	Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+	02111-1307, USA. 
+*/
+#include "as.h"
+#include "ext_remove.h"
+
+int g_c33_ext = 0;									// flag indicating that -mc33ext option is specified
+
+int i_File_Inf_Flg = 0;								// flag indicating that .file pseudo op exists in source file
+													// 0 -- initial vaule
+													// 1 -- ".file" exists.
+
+unsigned long g_dpAddress;							// address of data pointer(used when no-medda32)
+
+// symbols information of current file
+unsigned long ul_Cur_File_Symbol_Cnt;
+struct cur_inf** stpp_Cur_Inf = 0;
+char *cp_Current_File_Name = 0;						// pointer for current file name( include path )
+
+// symbols information of dump file
+unsigned long ul_Dump_Symbol_Cnt;
+struct dump_inf** stpp_Dump_Inf = 0;
+char *cp_Dump_File_Name = 0;						// pointer for dump file name( include path )
+
+volatile unsigned long ul_All_Offset = 0;			// offset(instruction counts) from all symbol
+unsigned char uc_Current_All_Symbol[INPUT_CUR_LINE_MAX] = { 0 };		// current symbol( local & global )
+unsigned char uc_Pre_All_Symbol[INPUT_CUR_LINE_MAX] = { 0 };			// pre symbol( local & global )
+
+
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file >>>>>
+// symbols information of all object dump file
+unsigned long ul_All_Dump_Symbol_Cnt;
+struct dump_inf** stpp_All_Dump_Inf;
+char *cp_All_Dump_File_Name;						// pointer for all objects' dump file name( include path )
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file <<<<<
+
+
+
+/*******************************************************************************************
+Format		: unsigned long chg_str_to_val( unsigned char* ucp_chg_ptr );
+Input		: unsigned char* ucp_chg_ptr -- pointer for string( hex code )
+Return		: value converted from string
+Expnalantion: convert string to value
+*******************************************************************************************/
+unsigned long chg_str_to_val( unsigned char* ucp_chg_ptr )
+{
+	unsigned long ul_ret;
+	
+	ul_ret = 0;
+	
+	while( 1 ){
+		if( ( '0' <= (*ucp_chg_ptr) ) && ( (*ucp_chg_ptr) <= '9' ) ){
+			ul_ret <<= 4;
+			ul_ret |= ( (*ucp_chg_ptr) - 0x30 );
+		} else if( ( 'a' <= (*ucp_chg_ptr) ) && ( (*ucp_chg_ptr) <= 'f' ) ){
+			ul_ret <<= 4;
+			ul_ret |= ( (*ucp_chg_ptr) - 0x57 );
+		} else if( ( 'A' <= (*ucp_chg_ptr) ) && ( (*ucp_chg_ptr) <= 'F' ) ){
+			ul_ret <<= 4;
+			ul_ret |= ( (*ucp_chg_ptr) - 0x37 );
+		} else {
+			break;
+		}
+		ucp_chg_ptr++;
+	}
+
+	return ul_ret;
+}
+
+/*******************************************************************************************
+Format		: void read_cur_file_info( char *cp_prm_file );
+Input		: char *cp_prm_file -- pointer for current file
+Return		: None
+Expnalantion: Read source file and get the symbol information of this file.
+*******************************************************************************************/
+void read_cur_file_info( char *cp_prm_file )
+{
+	FILE *f_file;
+	unsigned char uc_wk_buf[INPUT_CUR_LINE_MAX];
+	unsigned char uc_buf[INPUT_CUR_LINE_MAX];
+	unsigned char *ucp_wk;
+	unsigned long ul_cnt;
+	int i_ret,i_len,i_len_2;
+	int i_stab_flg;		// 0 -- normal
+						// 1 -- during ".stabs" / ".stabn" line
+	
+	// First, empty reading is carried out and get the total of symbols.
+	f_file = fopen (cp_prm_file, "r");
+	if (f_file == NULL)
+	{
+		fprintf (stderr, _("Error : Can't open %s for reading.\n"),cp_prm_file);
+		xexit (EXIT_FAILURE);
+	}
+	
+	ul_Cur_File_Symbol_Cnt = 0;
+	i_stab_flg = 0;
+	while( 1 ){
+		memset( uc_wk_buf,0,INPUT_CUR_LINE_MAX );
+		memset( uc_buf,0,INPUT_CUR_LINE_MAX );
+		ucp_wk = fgets( uc_wk_buf, INPUT_CUR_LINE_MAX, f_file );
+		if( ucp_wk == 0 ){
+			break;
+		}
+		
+		i_len = strlen( uc_wk_buf );
+		ucp_wk = strpbrk( uc_wk_buf,"\r\n" );
+		
+		if( i_stab_flg == 1 ){
+			if( ucp_wk != 0 ){
+				i_stab_flg = 0; 
+			}
+		} else {
+			if( ( ucp_wk == 0 ) && ( ( INPUT_CUR_LINE_MAX - 1 ) <= i_len ) ){
+				i_ret = chk_is_stab( uc_wk_buf );
+				if( i_ret == 0 ){
+					fprintf (stderr, _("Error : There are too many characters of one line in assembler source file.\n"));
+					xexit (EXIT_FAILURE);
+				}
+				i_stab_flg = 1;
+			} else {
+				get_valid_string( uc_wk_buf,uc_buf );
+				i_ret = get_label_info_from_src( uc_buf,uc_wk_buf );
+				if( i_ret != 0 ){
+					ul_Cur_File_Symbol_Cnt++;
+				}
+			}
+		}
+	}
+
+    if( fclose (f_file) == EOF ){
+		fprintf (stderr, _("Error : Can't close %s\n"),cp_prm_file);
+		xexit (EXIT_FAILURE);
+	}
+	
+	// Create the heap area for unsigned char*.
+	if( 0 < ul_Cur_File_Symbol_Cnt ){
+		stpp_Cur_Inf = xmalloc( sizeof(struct cur_inf*) * ul_Cur_File_Symbol_Cnt );
+		if( stpp_Cur_Inf == 0 ){
+			fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		memset( stpp_Cur_Inf,0,( sizeof(struct cur_inf*) * ul_Cur_File_Symbol_Cnt ) );
+		
+			// heap for the pointer of each struct cur_inf
+		for( ul_cnt = 0; ul_cnt < ul_Cur_File_Symbol_Cnt; ul_cnt++ ){
+			*(stpp_Cur_Inf+ul_cnt) = xmalloc( sizeof(struct cur_inf) );
+			if( *(stpp_Cur_Inf+ul_cnt) == 0 ){
+				fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+				xexit (EXIT_FAILURE);
+			}
+			memset( *(stpp_Cur_Inf+ul_cnt),0,( sizeof(struct cur_inf) ) );
+		}		
+		
+		// Second, file reopens and get symbol information.
+		f_file = fopen (cp_prm_file, "r");
+		if (f_file == NULL)
+		{
+			fprintf (stderr, _("Error : Can't open %s for reading.\n"),cp_prm_file);
+			xexit (EXIT_FAILURE);
+		}
+		
+		ul_cnt = 0;
+		i_stab_flg = 0;
+		while( 1 ){
+			memset( uc_wk_buf,0,INPUT_CUR_LINE_MAX );
+			memset( uc_buf,0,INPUT_CUR_LINE_MAX );
+			ucp_wk = fgets( uc_wk_buf, INPUT_CUR_LINE_MAX, f_file );
+			if( ucp_wk == 0 ){
+				break;
+			}
+			
+			i_len = strlen( uc_wk_buf );
+			ucp_wk = strpbrk( uc_wk_buf,"\r\n" );
+			
+			if( i_stab_flg == 1 ){
+				if( ucp_wk != 0 ){
+					i_stab_flg = 0; 
+				}
+			} else {
+				if( ( ucp_wk == 0 ) && ( ( INPUT_CUR_LINE_MAX - 1 ) <= i_len ) ){
+					i_ret = chk_is_stab( uc_wk_buf );
+					if( i_ret != 0 ){
+						i_stab_flg = 1;
+					}
+				} else {
+					get_valid_string( uc_wk_buf,uc_buf );
+					memset( uc_wk_buf,0,INPUT_CUR_LINE_MAX );
+					i_ret = get_label_info_from_src( uc_buf,uc_wk_buf );
+					if( i_ret != 0 ){
+						if( i_ret == 2 ){				// ".comm"
+							(*(stpp_Cur_Inf + ul_cnt))->i_Attribute = 1;		// attribute is global
+						}
+
+						i_len = strlen( uc_wk_buf );
+						(*(stpp_Cur_Inf + ul_cnt))->ucp_Symbol_Name = xmalloc(  i_len + 1 );
+						if( (*(stpp_Cur_Inf + ul_cnt))->ucp_Symbol_Name == 0 ){
+							fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+							xexit (EXIT_FAILURE);
+						}
+						memset( (*(stpp_Cur_Inf + ul_cnt))->ucp_Symbol_Name,0,( i_len + 1 ) );
+						memcpy( (*(stpp_Cur_Inf + ul_cnt))->ucp_Symbol_Name,uc_wk_buf,i_len );
+						
+						ul_cnt++;
+					}
+				}
+			}
+		}
+		
+	    if( fclose (f_file) == EOF ){
+			fprintf (stderr, _("Error : Can't close %s\n"),cp_prm_file);
+			xexit (EXIT_FAILURE);
+		}
+		
+		// Third, file reopens and get attribute information.
+		f_file = fopen (cp_prm_file, "r");
+		if (f_file == NULL)
+		{
+			fprintf (stderr, _("Error : Can't open %s for reading.\n"),cp_prm_file);
+			xexit (EXIT_FAILURE);
+		}
+		
+		ul_cnt = 0;
+		i_stab_flg = 0;
+		while( 1 ){
+			memset( uc_wk_buf,0,INPUT_CUR_LINE_MAX );
+			memset( uc_buf,0,INPUT_CUR_LINE_MAX );
+			ucp_wk = fgets( uc_wk_buf, INPUT_CUR_LINE_MAX, f_file );
+			if( ucp_wk == 0 ){
+				break;
+			}
+			
+			i_len = strlen( uc_wk_buf );
+			ucp_wk = strpbrk( uc_wk_buf,"\r\n" );
+			
+			if( i_stab_flg == 1 ){
+				if( ucp_wk != 0 ){
+					i_stab_flg = 0; 
+				}
+			} else {
+				if( ( ucp_wk == 0 ) && ( ( INPUT_CUR_LINE_MAX - 1 ) <= i_len ) ){
+					i_ret = chk_is_stab( uc_wk_buf );
+					if( i_ret != 0 ){
+						i_stab_flg = 1;
+					}
+				} else {
+					i_ret = get_attribute_info( uc_wk_buf,uc_buf );
+					if( i_ret != 0 ){
+						i_len_2 = strlen( uc_buf );
+						for( ul_cnt = 0; ul_cnt < ul_Cur_File_Symbol_Cnt; ul_cnt++ ){
+							i_len = strlen( (*(stpp_Cur_Inf + ul_cnt))->ucp_Symbol_Name );
+							if( i_len == i_len_2 ){
+								if( 0 == memcmp( (*(stpp_Cur_Inf + ul_cnt))->ucp_Symbol_Name,uc_buf,i_len ) ){
+									if( i_ret == 1 ){
+										// ".global"
+										(*(stpp_Cur_Inf + ul_cnt))->i_Attribute = 1;
+									} else {
+										// ".local"
+										(*(stpp_Cur_Inf + ul_cnt))->i_Attribute = 0;
+									}
+									break;
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+		
+	    if( fclose (f_file) == EOF ){
+			fprintf (stderr, _("Error : Can't close %s\n"),cp_prm_file);
+			xexit (EXIT_FAILURE);
+		}
+	}
+}
+
+
+/*******************************************************************************************
+Format		: void get_valid_string( unsigned char *ucp_rd_pt,unsigned char *ucp_wt_pt );
+Input		: unsigned char *ucp_rd -- read pointer
+              unsigned char *ucp_wt_pt -- write pointer
+Return		: None
+Expnalantion: Read buffer and get the valid stirng.
+              Comment / tab / space / cr・lf is excepted.
+              The back of a label name is not gotten even if it is effective.
+*******************************************************************************************/
+void get_valid_string( unsigned char *ucp_rd_pt,unsigned char *ucp_wt_pt )
+{
+	while( 1 ){
+		if( ( (*ucp_rd_pt) == '\t' ) || ( (*ucp_rd_pt) == ' ' ) ){
+			// skip
+			;
+		} else if ( ( (*ucp_rd_pt) == ';' ) || ( (*ucp_rd_pt) == '#' ) ) {
+			// this is comment
+			break;
+		} else if ( ( (*ucp_rd_pt) == '\r' ) || ( (*ucp_rd_pt) == '\n' ) ) {
+			// this is cr/lf
+			break;
+		} else {
+			*ucp_wt_pt = *ucp_rd_pt;
+			ucp_wt_pt++;
+			if( (*ucp_rd_pt) == ':' ){
+			// this is the end of label
+				break;
+			}
+		}
+		ucp_rd_pt++;
+	}
+}
+
+
+/*******************************************************************************************
+Format		: int get_label_info_from_src( unsigned char *uc_rd_pt,unsigned char *uc_wt_pt );
+Input		: unsigned char *uc_rd_pt -- pointer for read data
+              unsigned char *uc_wt_pt -- pointer for write data
+Return		: 0 -- normal
+              1 -- the contents of this buffer is label( "xxxx:" )
+              1 -- the contents of this buffer is label( ".comm" )
+Expnalantion: Read the buffer and check whether it is label.
+              The key word is "xxxx:" or ".comm".
+              If it is "xxxx:", ':' is replaced to '\0'.
+              If it is ".commxxxxxx,n,n", it is replaced to "xxxxxx".
+*******************************************************************************************/
+int get_label_info_from_src( unsigned char *uc_rd_pt,unsigned char *uc_wt_pt )
+{
+	int i_ret,i_len,i_len_2;
+	
+	i_ret = 0;
+	
+	if( 0 == strchr( uc_rd_pt,'"' ) ){	// exclude if it contains '"'
+		
+		i_len = strlen( uc_rd_pt );
+		
+		if( 2 <= i_len ){			// the smalles pattern is "x:"
+			if( uc_rd_pt[i_len-1] == ':' ){
+				// "xxxx:"
+				memcpy( uc_wt_pt,uc_rd_pt,i_len-1 );
+				uc_wt_pt[i_len-1] = '\0';
+				i_ret = 1;
+			}
+		}
+		
+		if( i_ret == 0 ){
+			if( 5 <= i_len ){
+				if( 0 == memcmp( ".comm",uc_rd_pt,5 ) ){
+					// ".commxxxxxx,n,n"
+					i_len_2 = strcspn( uc_rd_pt,"," );
+					if( 0 < i_len_2 ){
+						memcpy( uc_wt_pt,(uc_rd_pt+5),(i_len_2-5 ) );
+						i_ret = 2;
+					}
+				}
+			}
+		}
+	}
+	
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format		: int get_attribute_info( unsigned char *ucp_rd_pt,unsigned char *ucp_wt_pt );
+Input		: unsigned char *ucp_rd_pt -- pointer for read buffer
+              unsigned char *ucp_wt_pt -- pointer for write buffer
+Return		: 0 -- normal
+              1 -- the contents of read buffer is global label
+              2 -- the contents of read buffer is local label
+Expnalantion: Read the buffer and check whether it is global label.
+              The key word is ".global" or ".local".
+*******************************************************************************************/
+int get_attribute_info( unsigned char *ucp_rd_pt,unsigned char *ucp_wt_pt )
+{
+	int i_ret;
+	int i_chk_flg;
+	
+	i_ret = 0;
+	i_chk_flg = 0;
+	while( 1 ){
+		if( ( (*ucp_rd_pt) == '\t' ) || ( (*ucp_rd_pt) == ' ' ) ){
+			// skip
+			;
+		} else if ( 0 == memcmp( ".global",ucp_rd_pt,7 ) ) {
+			i_chk_flg = 1;			// we find the key word
+			ucp_rd_pt += 7;
+			
+		} else if ( 0 == memcmp( ".local",ucp_rd_pt,6 ) ) {
+			i_chk_flg = 2;			// we find the key word
+			ucp_rd_pt += 6;
+		
+		} else if ( ( (*ucp_rd_pt) == '\r' ) || ( (*ucp_rd_pt) == '\n' ) ) {
+			// this is cr/lf
+			break;
+		} else if ( ( (*ucp_rd_pt) == ';' ) || ( (*ucp_rd_pt) == '#' ) ) {
+			// this is comment
+			break;
+		} else {
+			if( i_chk_flg == 0 ){
+				break;
+			} else {
+				*ucp_wt_pt = *ucp_rd_pt;
+				ucp_wt_pt++;
+				i_ret = i_chk_flg;
+			}
+		}
+		ucp_rd_pt++;
+	}
+	
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format		: void free_cur_info();
+Input		: None
+Return		: None
+Expnalantion: Free the heap area for the current file information.
+*******************************************************************************************/
+void free_cur_info()
+{
+	unsigned long ul;
+
+	if( stpp_Cur_Inf != 0 ){
+	
+		for( ul = 0; ul < ul_Cur_File_Symbol_Cnt; ul++ ){
+		
+			if( *(stpp_Cur_Inf+ul) != 0 ){
+				
+				if( (*(stpp_Cur_Inf+ul))->ucp_Symbol_Name != 0 ){
+				
+					// free member pointer	
+					free( (*(stpp_Cur_Inf+ul))->ucp_Symbol_Name );
+				}
+				
+				// free the pointer of each struct cur_inf
+				free( *(stpp_Cur_Inf+ul) );
+			}
+		}
+	
+		// free the pointer of the pointer of struct cur_inf
+		free( stpp_Cur_Inf );
+		stpp_Cur_Inf = 0;
+	}
+}
+
+
+/*******************************************************************************************
+Format		: void free_ext_heap_area();
+Input		: None
+Return		: None
+Expnalantion: Free the heap area for ext process.
+*******************************************************************************************/
+void free_ext_heap_area()
+{
+	free_cur_info();
+	free_dump_info();
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file >>>>>
+	free_all_dump_info();
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file <<<<<
+
+
+}
+
+
+/*******************************************************************************************
+Format		: void read_dump_info( char* cp_dump_file_name,char* cp_out_file_name );
+Input		: char* cp_dump_file_name -- dump file name( include path )
+              char* cp_out_file_name -- output file name( include path )
+Return		: None
+Expnalantion: Read the dump file, and get the symbol information which belongs current file
+              and is local symbol only.
+*******************************************************************************************/
+void read_dump_info( char* cp_dump_file_name, char* cp_out_file_name )
+{
+	#define INPUT_DUMP_LINE_MAX (0x800 + 1)	// the maximum number of characters per one line of a dump file
+	
+	FILE *f_file;
+	unsigned char uc_buf[INPUT_DUMP_LINE_MAX];
+	int i_chk_sts;						// 0 -- default
+										// 1 -- check the file name
+										// 2 -- get the area information and the symbol information
+	unsigned char *ucp_wk;
+	char* cp_out_file_pt;
+	int i_cur_file_len;
+	unsigned long ul_cnt;
+	unsigned char uc_format_chk_buf[] = {   "SYMBOL TABLE:"  };
+	int i_len,i_chk_cnt;
+	
+	cp_out_file_pt = strrchr( cp_out_file_name,'/' );
+	
+	if( cp_out_file_pt != 0 ){
+		cp_out_file_pt++;
+	} else {
+		cp_out_file_pt = cp_out_file_name;
+	}
+	i_cur_file_len = strcspn( cp_out_file_pt,"." );
+	
+	// First, empty reading is carried out and get the total of symbols.
+	// A format check is also performed.
+	f_file = fopen (cp_dump_file_name, "r");
+	if (f_file == NULL)
+	{
+		fprintf (stderr, _("Error : Cannot find the dump file.\n"));
+		xexit (EXIT_FAILURE);
+	}
+	
+	ul_Dump_Symbol_Cnt = 0;
+	i_chk_sts = 0;
+	while( 1 ){
+		memset( uc_buf,0,INPUT_DUMP_LINE_MAX );
+		ucp_wk = fgets( uc_buf, INPUT_DUMP_LINE_MAX, f_file );
+		if( ucp_wk == 0 ){
+			break;
+		}
+		
+		i_len = strlen( uc_buf );
+		ucp_wk = strpbrk( uc_buf,"\r\n" );
+		if( ( ucp_wk == 0 ) && ( ( INPUT_DUMP_LINE_MAX - 1 ) <= i_len ) ){
+			fprintf (stderr, _("Error : There are too many characters of one line in dump file.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		
+		switch( i_chk_sts ){
+			case 0:
+				// *** check the dump file format ***
+				i_len = strcspn( uc_buf,"\r\n" );
+				if( i_len == 13 ){
+					if( 0 == memcmp( uc_buf,uc_format_chk_buf,13 ) ){
+						i_chk_sts++;
+					}
+				}
+				break;
+			case 1:
+				// *** check the file name ***
+				if( 0 == memcmp( &(uc_buf[14]),"df",2 ) ){
+					ucp_wk = strrchr( uc_buf,' ' );
+					ucp_wk++;
+					i_len = strcspn( ucp_wk,".\r\n" );
+					if( i_cur_file_len == i_len ){
+						if( 0 == memcmp( cp_out_file_pt,ucp_wk,i_len ) ){
+							i_chk_sts++;
+						}
+					}
+				}
+				break;
+			case 2:
+				if( 0 == memcmp( &(uc_buf[14]),"df",2 ) ){
+					if( uc_buf[9] == 'g' ){
+						// *** global symbol only ***
+						ul_Dump_Symbol_Cnt++;
+					}
+					i_chk_sts++;
+				} else {
+					// *** get the area information and the symbol information ***
+					// *** cuurent local syombol & global symbol ***
+					if( ( uc_buf[9] == 'l' ) || ( uc_buf[9] == 'g' ) ){
+						ul_Dump_Symbol_Cnt++;
+					}
+				}
+				break;
+			case 3:
+				if( uc_buf[9] == 'g' ){
+					// *** global symbol only ***
+					ul_Dump_Symbol_Cnt++;
+				}
+				break;
+			default:
+				;
+				break;
+		}
+	}
+	
+	if( i_chk_sts == 0 ){
+		fprintf (stderr, _("Error : The format of the dump file is invalid.\n"));
+		xexit (EXIT_FAILURE);
+	}
+	
+    if( fclose (f_file) == EOF ){
+		fprintf (stderr, _("Error : Can't close %s\n"),cp_dump_file_name);
+		xexit (EXIT_FAILURE);
+	}
+	
+	if( 0 < ul_Dump_Symbol_Cnt ){
+		// Second, file reopens and check whether there is any file of a same name.
+		f_file = fopen (cp_dump_file_name, "r");
+		if (f_file == NULL)
+		{
+			fprintf (stderr, _("Error : Cannot find the dump file.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		
+		i_chk_cnt = 0;
+		while( 1 ){
+			memset( uc_buf,0,INPUT_DUMP_LINE_MAX );
+			ucp_wk = fgets( uc_buf, INPUT_DUMP_LINE_MAX, f_file );
+			if( ucp_wk == 0 ){
+				break;
+			}
+			
+			i_len = strlen( uc_buf );
+			ucp_wk = strpbrk( uc_buf,"\r\n" );
+			if( ( ucp_wk == 0 ) && ( ( INPUT_DUMP_LINE_MAX - 1 ) <= i_len ) ){
+				fprintf (stderr, _("Error : There are too many characters of one line in dump file.\n"));
+				xexit (EXIT_FAILURE);
+			}
+			
+			// *** check the file name ***
+			if( 0 == memcmp( &(uc_buf[14]),"df",2 ) ){
+				ucp_wk = strrchr( uc_buf,' ' );
+				ucp_wk++;
+				i_len = strcspn( ucp_wk,".\r\n" );
+				if( i_cur_file_len == i_len ){
+					if( 0 == memcmp( cp_out_file_pt,ucp_wk,i_len ) ){
+						i_chk_cnt++;
+					}
+				}
+			}
+		}
+		
+		if( fclose (f_file) == EOF ){
+			fprintf (stderr, _("Error : Can't close %s\n"),cp_dump_file_name);
+			xexit (EXIT_FAILURE);
+		}
+		
+		if( 1 < i_chk_cnt ){
+			ul_Dump_Symbol_Cnt = 0;
+		}
+	}
+	
+	// Create the heap area for struct dump_inf.
+		// heap for the pointer of the pointer of struct dump_inf
+	if( 0 < ul_Dump_Symbol_Cnt ){
+		stpp_Dump_Inf = xmalloc( sizeof(struct dump_inf*) * ul_Dump_Symbol_Cnt );
+		if( stpp_Dump_Inf == 0 ){
+			fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		memset( stpp_Dump_Inf,0,( sizeof(struct dump_inf*) * ul_Dump_Symbol_Cnt ) );
+		
+			// heap for the pointer of each struct dump_inf
+		for( ul_cnt = 0; ul_cnt < ul_Dump_Symbol_Cnt; ul_cnt++ ){
+			*(stpp_Dump_Inf+ul_cnt) = xmalloc( sizeof(struct dump_inf) );
+			if( *(stpp_Dump_Inf+ul_cnt) == 0 ){
+				fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+				xexit (EXIT_FAILURE);
+			}			
+			memset( *(stpp_Dump_Inf+ul_cnt),0,( sizeof(struct dump_inf) ) );
+		}
+		
+		
+		// Third, file reopens and get symbol information.
+		f_file = fopen (cp_dump_file_name, "r");
+		if (f_file == NULL)
+		{
+			fprintf (stderr, _("Error : Cannot find the dump file.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		
+		i_chk_sts = 0;
+		ul_cnt = 0;
+		while( 1 ){
+			memset( uc_buf,0,INPUT_DUMP_LINE_MAX );
+			ucp_wk = fgets( uc_buf, INPUT_DUMP_LINE_MAX, f_file );
+			if( ucp_wk == 0 ){
+				break;
+			}
+			
+			i_len = strlen( uc_buf );
+			ucp_wk = strpbrk( uc_buf,"\r\n" );
+			if( ( ucp_wk == 0 ) && ( ( INPUT_DUMP_LINE_MAX - 1 ) <= i_len ) ){
+				fprintf (stderr, _("Error : There are too many characters of one line in dump file.\n"));
+				xexit (EXIT_FAILURE);
+			}
+			
+			switch( i_chk_sts ){
+				case 0:
+					// *** check the dump file format ***
+					i_len = strcspn( uc_buf,"\r\n" );
+					if( i_len == 13 ){
+						if( 0 == memcmp( uc_buf,uc_format_chk_buf,13 ) ){
+							i_chk_sts++;
+						}
+					}
+					break;
+				case 1:
+					// *** check the file name ***
+					if( 0 == memcmp( &(uc_buf[14]),"df",2 ) ){
+						ucp_wk = strrchr( uc_buf,' ' );
+						ucp_wk++;
+						i_len = strcspn( ucp_wk,".\r\n" );
+						if( i_cur_file_len == i_len ){
+							if( 0 == memcmp( cp_out_file_pt,ucp_wk,i_len ) ){
+								i_chk_sts++;
+							}
+						}
+					}
+					break;
+				case 2:
+					if( 0 == memcmp( &(uc_buf[14]),"df",2 ) ){
+						if( uc_buf[9] == 'g' ){
+							// *** global symbol only ***
+							get_label_info_from_dump( uc_buf,(stpp_Dump_Inf+ul_cnt) );
+							ul_cnt++;
+						}
+						i_chk_sts++;
+					} else {
+						// *** get the area information and the symbol information ***
+						// *** cuurent local syombol & global symbol ***
+						if( ( uc_buf[9] == 'l' ) || ( uc_buf[9] == 'g' ) ){
+							get_label_info_from_dump( uc_buf,(stpp_Dump_Inf+ul_cnt) );
+							ul_cnt++;
+						}
+					}
+					break;
+				case 3:
+					if( uc_buf[9] == 'g' ){
+						// *** global symbol only ***
+						get_label_info_from_dump( uc_buf,(stpp_Dump_Inf+ul_cnt) );
+						ul_cnt++;
+					}
+					break;
+				default:
+					;
+					break;
+			}
+		}
+		
+	    if( fclose (f_file) == EOF ){
+			fprintf (stderr, _("Error : Can't close %s\n"),cp_dump_file_name);
+			xexit (EXIT_FAILURE);
+		}
+	}
+}
+
+
+/*******************************************************************************************
+Format		: void get_label_info_from_dump( unsigned char *ucp_rd_pt,struct dump_inf **stpp_prm_dump_inf );
+Input		: unsigned char *ucp_rd_pt -- pointer for read data
+              struct dump_inf **stpp_prm_dump_inf -- pointer of pointer for struct dump_inf
+Return		: None
+Expnalantion: Read data and get the symbol information from dump file.
+*******************************************************************************************/
+void get_label_info_from_dump( unsigned char *ucp_rd_pt,struct dump_inf **stpp_prm_dump_inf )
+{
+	unsigned long ul_len;
+	char* cp_pt;
+	
+		// address
+	(*stpp_prm_dump_inf)->ul_Symbol_Addr = chg_str_to_val( &(ucp_rd_pt[0]) );
+	// no address masking
+	
+		// attribute
+	if( ucp_rd_pt[9] == 'g' ){
+		(*stpp_prm_dump_inf)->i_Attribute = 1;					// global
+	} else {	
+		(*stpp_prm_dump_inf)->i_Attribute = 0;					// local
+	}
+	
+		// area
+	ul_len = strcspn( &(ucp_rd_pt[17])," \t" );
+	(*stpp_prm_dump_inf)->ucp_Area_Name = xmalloc( ul_len + 1 );
+	if( (*stpp_prm_dump_inf)->ucp_Area_Name == 0 ){
+		fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+		xexit (EXIT_FAILURE);
+	}
+	memset( (*stpp_prm_dump_inf)->ucp_Area_Name,0,( ul_len + 1 ) );
+	memcpy( (*stpp_prm_dump_inf)->ucp_Area_Name, &(ucp_rd_pt[17]), ul_len );
+	
+		// symbol name
+	cp_pt = strrchr( ucp_rd_pt,' ' );
+	if( cp_pt != 0 ){
+		cp_pt++;
+		ul_len = strcspn( cp_pt,"\r\n" );
+		(*stpp_prm_dump_inf)->ucp_Symbol_Name = xmalloc( ul_len + 1 );
+		if( (*stpp_prm_dump_inf)->ucp_Symbol_Name == 0 ){
+			fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		memset( (*stpp_prm_dump_inf)->ucp_Symbol_Name,0,( ul_len + 1 ) );
+		memcpy( (*stpp_prm_dump_inf)->ucp_Symbol_Name, cp_pt, ul_len );
+	}
+
+/* >>>>> ADDED D.Fujimoto 2007/12/06 get address for .comm */
+	// Special case:
+	// for .comm areas, get the address from the 24rd column of dump file
+	if (strcmp((*stpp_prm_dump_inf)->ucp_Area_Name, ".comm") == 0) {
+		(*stpp_prm_dump_inf)->ul_Symbol_Addr = chg_str_to_val( &(ucp_rd_pt[24]) );
+	}
+/* <<<<< ADDED D.Fujimoto 2007/12/06 get address for .comm */
+
+}
+
+
+/*******************************************************************************************
+Format		: void free_dump_info();
+Input		: None
+Return		: None
+Expnalantion: Free the heap area for the dump file information.
+*******************************************************************************************/
+void free_dump_info()
+{
+	unsigned long ul;
+
+	if( stpp_Dump_Inf != 0 ){
+	
+		for( ul = 0; ul < ul_Dump_Symbol_Cnt; ul++ ){
+
+			if( *(stpp_Dump_Inf+ul) != 0 ){
+			
+				// free member pointer	
+				if( (*(stpp_Dump_Inf+ul))->ucp_Symbol_Name != 0 ){
+					free( (*(stpp_Dump_Inf+ul))->ucp_Symbol_Name );
+				}
+				if( (*(stpp_Dump_Inf+ul))->ucp_Area_Name != 0 ){
+					free( (*(stpp_Dump_Inf+ul))->ucp_Area_Name );
+				}
+
+				// free the pointer of each struct dump_inf
+				free( *(stpp_Dump_Inf+ul) );
+			}
+		}
+		
+		// free the pointer of the pointer of struct dump_inf
+		free( stpp_Dump_Inf );
+		stpp_Dump_Inf = 0;
+	}
+}
+
+
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file >>>>>
+/*******************************************************************************************
+Format		: void read_all_dump_info( char* cp_dump_file_name,char* cp_out_file_name );
+Input		: char* cp_dump_file_name -- dump file name( include path )
+              char* cp_out_file_name -- output file name( include path )
+Return		: None
+Expnalantion: Read the dump file (for all object files), and get the symbol information into
+			  the stpp_All_Dump_Inf.
+			  This function is derived from read_dump_info().
+			  This function uses global symbols  and ul_All_Dump_Symbol_Cnt
+*******************************************************************************************/
+void read_all_dump_info( char* cp_dump_file_name, char* cp_out_file_name )
+{
+	#define INPUT_DUMP_LINE_MAX (0x800 + 1)	// the maximum number of characters per one line of a dump file
+	
+	FILE *f_file;
+	unsigned char uc_buf[INPUT_DUMP_LINE_MAX];
+	int i_chk_sts;						// 0 -- default
+										// 1 -- check the file name
+										// 2 -- get the area information and the symbol information
+	unsigned char *ucp_wk;
+	char* cp_out_file_pt;
+	int i_cur_file_len;
+	unsigned long ul_cnt;
+	unsigned char uc_format_chk_buf[] = {   "SYMBOL TABLE:"  };
+	int i_len,i_chk_cnt;
+	enum CheckStatus status;
+	
+	cp_out_file_pt = strrchr( cp_out_file_name,'/' );
+	
+	if( cp_out_file_pt != 0 ){
+		cp_out_file_pt++;
+	} else {
+		cp_out_file_pt = cp_out_file_name;
+	}
+	i_cur_file_len = strcspn( cp_out_file_pt,"." );
+	
+	// First, empty reading is carried out and get the total of symbols.
+	// A format check is also performed.
+	f_file = fopen (cp_dump_file_name, "r");
+	if (f_file == NULL)
+	{
+		fprintf (stderr, _("Error : Cannot find the all objects\' dump file.\n"));
+		xexit (EXIT_FAILURE);
+	}
+	
+	ul_All_Dump_Symbol_Cnt = 0;
+	status = format;
+	i_chk_sts = 0;
+	while( 1 ){
+		memset( uc_buf,0,INPUT_DUMP_LINE_MAX );
+		ucp_wk = fgets( uc_buf, INPUT_DUMP_LINE_MAX, f_file );
+		if( ucp_wk == 0 ){
+			break;
+		}
+		
+		i_len = strlen( uc_buf );
+		ucp_wk = strpbrk( uc_buf,"\r\n" );
+		if( ( ucp_wk == 0 ) && ( ( INPUT_DUMP_LINE_MAX - 1 ) <= i_len ) ){
+			fprintf (stderr, _("Error : There are too many characters of one line in all objects\' dump file.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		
+		switch( status ){
+			case format:
+				// *** check the dump file format ***
+				i_len = strcspn( uc_buf,"\r\n" );
+				if( i_len == 13 ){
+					if( 0 == memcmp( uc_buf,uc_format_chk_buf,13 ) ){
+						i_chk_sts++;		// format OK
+						status = global;
+					}
+				}
+				break;
+			case global:
+				if( uc_buf[9] == 'g' ){
+					// *** global symbol only ***
+					ul_All_Dump_Symbol_Cnt++;
+				}
+				break;
+			default:
+				// ignore the current line
+				;
+				break;
+		}
+	}
+	
+	if( i_chk_sts == 0 ){
+		fprintf (stderr, _("Error : The format of the all objects\' dump file is invalid.\n"));
+		xexit (EXIT_FAILURE);
+	}
+	
+    if( fclose (f_file) == EOF ){
+		fprintf (stderr, _("Error : Can't close %s\n"),cp_dump_file_name);
+		xexit (EXIT_FAILURE);
+	}
+	
+	
+	// Create the heap area for struct dump_inf.
+		// heap for the pointer of the pointer of struct dump_inf
+	if( 0 < ul_All_Dump_Symbol_Cnt ){
+		stpp_All_Dump_Inf = xmalloc( sizeof(struct dump_inf*) * ul_All_Dump_Symbol_Cnt );
+		if( stpp_All_Dump_Inf == 0 ){
+			fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		memset( stpp_All_Dump_Inf,0,( sizeof(struct dump_inf*) * ul_All_Dump_Symbol_Cnt ) );
+		
+			// heap for the pointer of each struct dump_inf
+		for( ul_cnt = 0; ul_cnt < ul_All_Dump_Symbol_Cnt; ul_cnt++ ){
+			*(stpp_All_Dump_Inf+ul_cnt) = xmalloc( sizeof(struct dump_inf) );
+			if( *(stpp_All_Dump_Inf+ul_cnt) == 0 ){
+				fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+				xexit (EXIT_FAILURE);
+			}			
+			memset( *(stpp_All_Dump_Inf+ul_cnt),0,( sizeof(struct dump_inf) ) );
+		}
+		
+		
+		// Second, file reopens and get symbol information.
+		f_file = fopen (cp_dump_file_name, "r");
+		if (f_file == NULL)
+		{
+			fprintf (stderr, _("Error : Cannot find the all objects\' dump file.\n"));
+			xexit (EXIT_FAILURE);
+		}
+		
+		status = format;
+		i_chk_sts = 0;
+		ul_cnt = 0;
+		while( 1 ){
+			memset( uc_buf,0,INPUT_DUMP_LINE_MAX );
+			ucp_wk = fgets( uc_buf, INPUT_DUMP_LINE_MAX, f_file );
+			if( ucp_wk == 0 ){
+				break;
+			}
+			
+			i_len = strlen( uc_buf );
+			ucp_wk = strpbrk( uc_buf,"\r\n" );
+			if( ( ucp_wk == 0 ) && ( ( INPUT_DUMP_LINE_MAX - 1 ) <= i_len ) ){
+				fprintf (stderr, _("Error : There are too many characters of one line in all objects\' dump file.\n"));
+				xexit (EXIT_FAILURE);
+			}
+			
+			switch( status ){
+				case format:
+					// *** check the dump file format ***
+					i_len = strcspn( uc_buf,"\r\n" );
+					if( i_len == 13 ){
+						if( 0 == memcmp( uc_buf,uc_format_chk_buf,13 ) ){
+							i_chk_sts++;		// format is OK
+							status = global;
+						}
+					}
+					break;
+				case global:
+					if( uc_buf[9] == 'g' ){
+						// *** global symbol only ***
+						get_label_info_from_dump( uc_buf,(stpp_All_Dump_Inf+ul_cnt) );
+						ul_cnt++;
+					}
+					break;
+				default:
+					;
+					break;
+			}
+		}
+		
+	    if( fclose (f_file) == EOF ){
+			fprintf (stderr, _("Error : Can't close %s\n"),cp_dump_file_name);
+			xexit (EXIT_FAILURE);
+		}
+	}
+}
+
+
+/*******************************************************************************************
+Format		: void free_all_dump_info();
+Input		: None
+Return		: None
+Expnalantion: Free the heap area for the dump file information.
+			  Uses global symbols stpp_All_Dump_Inf and ul_All_Dump_Symbol_Cnt
+*******************************************************************************************/
+void free_all_dump_info()
+{
+	unsigned long ul;
+
+	if( stpp_All_Dump_Inf != 0 ){
+	
+		for( ul = 0; ul < ul_All_Dump_Symbol_Cnt; ul++ ){
+
+			if( *(stpp_All_Dump_Inf+ul) != 0 ){
+			
+				// free member pointer	
+				if( (*(stpp_All_Dump_Inf+ul))->ucp_Symbol_Name != 0 ){
+					free( (*(stpp_All_Dump_Inf+ul))->ucp_Symbol_Name );
+				}
+				if( (*(stpp_All_Dump_Inf+ul))->ucp_Area_Name != 0 ){
+					free( (*(stpp_All_Dump_Inf+ul))->ucp_Area_Name );
+				}
+
+				// free the pointer of each struct dump_inf
+				free( *(stpp_All_Dump_Inf+ul) );
+			}
+		}
+		
+		// free the pointer of the pointer of struct dump_inf
+		free( stpp_All_Dump_Inf );
+		stpp_All_Dump_Inf = 0;
+	}
+}
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file <<<<<
+
+
+/*******************************************************************************************
+Format		: void chk_is_file_inf( unsigned char *ucp_chk_file_pt );
+Input		: unsigned char *ucp_chk_pt -- pointer for file name
+Return		: None
+Expnalantion: Check whether ".file" exists from souce file.
+*******************************************************************************************/
+void chk_is_file_inf( unsigned char *ucp_chk_file_pt )
+{
+	FILE *f_file;
+	unsigned char uc_buf[INPUT_CUR_LINE_MAX];
+	unsigned char *ucp_wk;
+	int i_len;
+	int i_ret;
+	int i_stab_flg;		// 0 -- normal
+						// 1 -- during ".stabs" / ".stabn" line
+	
+	f_file = fopen (ucp_chk_file_pt, "r");
+	if (f_file == NULL)
+	{
+		fprintf (stderr, _("Error : Can't open %s for reading.\n"),ucp_chk_file_pt);
+		xexit (EXIT_FAILURE);
+	}
+	
+	i_stab_flg = 0;
+	while( 1 ){
+		memset( uc_buf,0,INPUT_CUR_LINE_MAX );
+		ucp_wk = fgets( uc_buf, INPUT_CUR_LINE_MAX, f_file );
+		if( ucp_wk == 0 ){
+			break;
+		}
+		
+		i_len = strlen( uc_buf );
+		ucp_wk = strpbrk( uc_buf,"\r\n" );
+		
+		if( i_stab_flg == 1 ){
+			if( ucp_wk != 0 ){
+				i_stab_flg = 0; 
+			}
+		} else {
+			if( ( ucp_wk == 0 ) && ( ( INPUT_CUR_LINE_MAX - 1 ) <= i_len ) ){
+				i_ret = chk_is_stab( uc_buf );
+				if( i_ret == 0 ){
+					fprintf (stderr, _("Error : There are too many characters of one line in assembler source file.\n"));
+					xexit (EXIT_FAILURE);
+				}
+				i_stab_flg = 1;
+			} else {
+				chk_is_file_inf_from_line( uc_buf );
+			}
+		}
+	}
+
+    if( fclose (f_file) == EOF ){
+		fprintf (stderr, _("Error : Can't close %s\n"),ucp_chk_file_pt);
+		xexit (EXIT_FAILURE);
+	}
+}
+
+
+/*******************************************************************************************
+Format		: void chk_is_file_inf( unsigned char *ucp_chk_pt );
+Input		: unsigned char *ucp_chk_pt -- check pointer
+Return		: None
+Expnalantion: Check whether ".file" exists from line.
+              If ".file" exists, file name is set.
+*******************************************************************************************/
+void chk_is_file_inf_from_line( unsigned char *ucp_chk_pt )
+{
+	if( i_File_Inf_Flg == 0 ){
+		while( 1 ){
+			if( ( (*ucp_chk_pt) == '\t' ) || ( (*ucp_chk_pt) == ' ' ) ){
+				// skip
+				;
+			} else if ( ( (*ucp_chk_pt) == ';' ) || ( (*ucp_chk_pt) == '#' ) ) {
+				// this is comment
+				break;
+			} else if ( ( (*ucp_chk_pt) == '\r' ) || ( (*ucp_chk_pt) == '\n' ) ) {
+				// this is cr/lf
+				break;
+			} else {
+				if( 5 <= strlen( ucp_chk_pt ) ){
+					if( 0 == memcmp( ucp_chk_pt,".file",5 ) ){
+						i_File_Inf_Flg = 1;
+						break;
+					}
+				} else {
+					break;
+				}
+			}
+			ucp_chk_pt++;
+		}
+	}
+}
+
+
+/*******************************************************************************************
+Format		: int chk_is_stab( unsigned char *ucp_chk_pt );
+Input		: unsigned char *ucp_chk_pt -- check pointer
+Return		: 0 -- ".stabs" / ".stabn" doesn't exists.
+              1 -- ".stabs" / ".stabn" exists.
+Expnalantion: Check whether ".stabs" / ".stabn" exists.
+*******************************************************************************************/
+int chk_is_stab( unsigned char *ucp_chk_pt )
+{
+	int i;
+	int i_ret;
+	
+	i_ret = 0;
+	for( i = 0; i < (INPUT_CUR_LINE_MAX - 1); i++ ){
+		if( ( (*ucp_chk_pt) == '\t' ) || ( (*ucp_chk_pt) == ' ' ) ){
+			// skip
+			;
+		} else if ( ( (*ucp_chk_pt) == ';' ) || ( (*ucp_chk_pt) == '#' ) ) {
+			// this is comment
+			break;
+		} else {
+			if( 6 <= strlen( ucp_chk_pt ) ){
+				if( ( 0 == memcmp( ucp_chk_pt,".stabs",6 ) )
+						|| ( 0 == memcmp( ucp_chk_pt,".stabn",6 ) ) ){
+					i_ret = 1;
+					break;
+				}
+			} else {
+				break;
+			}
+		}
+		ucp_chk_pt++;
+	}
+	
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format		: void s_app_file_2 ();
+Input		: None
+Return		: None
+Expnalantion: ADD ".file" information to object file.
+              If source file has already ".file" information, don't add it here.
+*******************************************************************************************/
+void s_app_file_2 ()
+{
+  register char *s,*cp_wk;
+//  int length;
+  int may_omit;
+  int appfile;  
+  
+  int i_len;
+  char *cp_file_name_pt = 0;
+
+  if( i_File_Inf_Flg == 0 ){
+  	  if( out_file_name != 0 ){
+	      	if( 0 < strlen( out_file_name ) ){
+			  appfile = 0;
+		        
+			  /* Some assemblers tolerate immediately following '"' */
+			  // if ((s = demand_copy_string (&length)) != 0)
+			  //  {
+			       // Get the file name from the "out_file_name".
+			       // And change extension to '*.s'.
+				   i_len = strlen( out_file_name );
+				   cp_file_name_pt = xmalloc( i_len + 1 );
+				   if( cp_file_name_pt == 0 ){
+					   fprintf (stderr, _("Error : Cannot allocate memory.\n"));
+					   xexit (EXIT_FAILURE);
+				   }
+				   memset( cp_file_name_pt,0,i_len + 1 );
+				   memcpy( cp_file_name_pt,out_file_name,i_len );
+			       s = strrchr( cp_file_name_pt,'/' );
+			       if( s != 0 ){
+				       s++;
+				   } else {
+					   s = cp_file_name_pt;
+				   }
+				   cp_wk = strrchr(  s,'.' );
+				   if( cp_wk != 0 ){
+					   cp_wk++;
+				       (*cp_wk) = 's';
+					   cp_wk++;
+					   (*cp_wk) = 0;
+				   }
+
+			      /* If this is a fake .appfile, a fake newline was inserted into
+			         the buffer.  Passing -2 to new_logical_line tells it to
+			         account for it.  */
+			       may_omit= (! new_logical_line (s, appfile ? -2 : -1) && appfile);
+
+			      /* In MRI mode, the preprocessor may have inserted an extraneous
+			         backquote.  */
+			      if (flag_m68k_mri
+			          && *input_line_pointer == '\''
+			          && is_end_of_line[(unsigned char) input_line_pointer[1]])
+			        ++input_line_pointer;
+
+			      // demand_empty_rest_of_line ();
+			      
+			      if (! may_omit)
+			        {
+			#ifdef LISTING
+			          if (listing)
+			            listing_source_file (s);
+			#endif
+			          register_dependency (s);
+			#ifdef obj_app_file
+			          obj_app_file (s);
+			#endif
+			        }
+			    // }
+			    
+			    if( cp_file_name_pt != 0 ){
+			    	free( cp_file_name_pt );
+			    }
+			}
+		}
+	}
+}
+
+/*******************************************************************************************
+Format		: int reset_current_symbol(char *input_line_pointer);
+Input		: char *input_line_pointer -- pointer for reading the source file
+Return		: NONE
+Explanation	: Reset the global variables if the ".section" changes.
+*******************************************************************************************/
+void reset_current_symbol(char *input_line_pointer)
+{
+	// if ".section" is found,reset the "uc_Current_All_Symbol".
+	if( 8 <= strlen( input_line_pointer ) ){
+		if( 0 == memcmp( ".section",input_line_pointer,8 ) ){
+			memset( uc_Current_All_Symbol,0,sizeof( uc_Current_All_Symbol ) );
+		}
+	}
+
+}
+
+/*******************************************************************************************
+Format		: int update_current_symbol(char *input_line_pointer);
+Input		: char *s -- label name
+Return		: NONE
+Explanation	: Check whether the label is local or global from the current file 
+			  and saves it to the global variables.
+*******************************************************************************************/
+void update_current_symbol(char *s)
+{
+	int i_ret;			// return value of a function
+	int i_len;			// length of the label
+
+	// Check whether the label is local or global from the current file only.
+	i_ret = chk_global_label_2( s );
+	if( i_ret == 1 ){
+		i_len = strlen( s );
+	}
+
+	i_len = strlen( s );
+	memset( uc_Current_All_Symbol,0,sizeof( uc_Current_All_Symbol ) );
+	memcpy( uc_Current_All_Symbol,s,i_len );
+
+}
+
+
+/*******************************************************************************************
+Format		: int evaluate_offset_from_symbol( void );
+Input		: NONE
+Return		: NONE
+Expnalantion: Save the current symbol to the previous symbol.
+			  Count up the offset from symbol if the current remains the same or,
+			  reset the offset from symbol if the current changes.
+			  Uses the following global vars
+				uc_Current_All_Symbol
+				uc_Pre_All_Symbol
+				ul_All_Offset
+*******************************************************************************************/
+void evaluate_offset_from_symbol(void)
+{
+
+	int i_len,i_len_2,i_chk_flg;
+
+    
+	// get the offset form all symbol
+	i_chk_flg = 0;
+	i_len = strlen( uc_Current_All_Symbol );
+	i_len_2 = strlen( uc_Pre_All_Symbol );
+	if( i_len == 0 ){
+		i_chk_flg = 1;
+	} else {
+		if( i_len == i_len_2 ){
+			if( 0 != memcmp( uc_Current_All_Symbol,uc_Pre_All_Symbol,i_len ) ){
+				i_chk_flg = 1;
+			}
+		} else {
+			i_chk_flg = 1;
+		}
+	}
+	
+	if( i_chk_flg == 0 ){
+		// count up offset if the newest all symbol name is the same
+		ul_All_Offset++;			// count up the offset
+	} else {
+		ul_All_Offset = 0;		// reset the offset
+	}
+	
+	if( i_len != 0 ){
+		memset( uc_Pre_All_Symbol,0,sizeof( uc_Pre_All_Symbol ) );
+		memcpy( uc_Pre_All_Symbol,uc_Current_All_Symbol,i_len );
+	} else {
+		memset( uc_Pre_All_Symbol,0,sizeof( uc_Pre_All_Symbol ) );
+	}
+
+}
+
+
+/*******************************************************************************************
+Format		: int chk_global_label_2( char* cp_label_name );
+Input		: char* cp_label_name -- pointer for label name
+Return		: 0 -- local label
+              1 -- global label
+Expnalantion: Check whether the label is local or global from the current file only.
+*******************************************************************************************/
+int chk_global_label_2( char* cp_label_name )
+{
+	int i_ret,i_len,i_len_2;
+	unsigned long ul;
+	
+	// compare symbol name to the current file
+	i_ret = 0;		// local
+	i_len = strlen( cp_label_name );
+	for( ul = 0; ul < ul_Cur_File_Symbol_Cnt; ul++ ){
+		i_len_2 = strlen( (*(stpp_Cur_Inf+ul))->ucp_Symbol_Name );
+		if( i_len == i_len_2 ){
+			if( 0 == memcmp( (*(stpp_Cur_Inf+ul))->ucp_Symbol_Name,cp_label_name,i_len ) ){
+				
+				// copy the attribute
+				i_ret = (*(stpp_Cur_Inf+ul))->i_Attribute;		// 0 -- local
+																// 1 -- global
+				break;
+			}
+		}
+	}
+	
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format		: int chk_label_address_from_dump( char* cp_label_name,offsetT off_offset,unsigned long *ulp_label_address );
+Input		: const char* cp_label_name -- pointer for label name
+              offsetT off_offset -- offset from label address
+              unsigned long *ulp_label_address -- pointer for label address
+Return		: 0 -- don't get the address
+              1 -- get the address
+Expnalantion: Get the label address and add offset from the dump file.
+              First compare the current local symbol, and if don't get the addresss, 
+              then compare the global symbol.
+*******************************************************************************************/
+int chk_label_address_from_dump( const char* cp_label_name,offsetT off_offset,unsigned long *ulp_label_address )
+{
+	int i_ret,i_len,i_len_2;
+	int i_attr;			// 0 -- local
+						// 1 -- global
+	unsigned long ul;
+	
+	i_ret = 0;
+	i_len = strlen( cp_label_name );
+	
+	// compare symbol name to the dump file
+	for( i_attr = 0; i_attr < 2; i_attr++ ){
+		for( ul = 0; ul < ul_Dump_Symbol_Cnt; ul++ ){
+			if( (*(stpp_Dump_Inf+ul))->i_Attribute == i_attr ){		// current local symbol / global symbol
+				i_len_2 = strlen( (*(stpp_Dump_Inf+ul))->ucp_Symbol_Name );
+				if( i_len == i_len_2 ){
+					if( 0 == memcmp( cp_label_name,(*(stpp_Dump_Inf+ul))->ucp_Symbol_Name,i_len_2 ) ){
+						i_ret = 1;
+						*ulp_label_address = (*(stpp_Dump_Inf+ul))->ul_Symbol_Addr + off_offset;
+						break;
+					}
+				}
+			}
+		}
+		if( i_ret == 1 ){
+			break;
+		}
+	}
+	
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format		: int chk_is_same_area_from_dump( unsigned char *ucp_chk_name_1,unsigned char *ucp_chk_name_2 );
+Input		: const char *ucp_chk_name_1    -- symbol name in expression
+              unsigned char *ucp_chk_name_2 -- current local or global symbol
+Return		: 0 -- area of check name 1 and check name 2 is not same
+                   or 
+                   don't get the symbol information
+              1 -- area of check name 1 and check name 2 is same
+Expnalantion: Check whether area of check name 1 and check name 2 is same from the dump file.
+              First compare the current local symbol, and if don't get the addresss, 
+              then compare the global symbol.
+*******************************************************************************************/
+int chk_is_same_area_from_dump( const char *ucp_chk_name_1,unsigned char *ucp_chk_name_2 )
+{
+	int i_ret;
+	int i_len_1,i_len_2,i_chk_flg;
+	int i_attr;			// 0 -- local
+						// 1 -- global
+	unsigned char *ucp_area_1 = NULL;
+	unsigned char *ucp_area_2 = NULL;
+	unsigned long ul;
+	
+	i_ret = 0;
+	
+	// compare check name 1 to the dump file
+	i_chk_flg = 0;
+	i_len_1 = strlen( ucp_chk_name_1 );
+	if( 0 < i_len_1 ){
+		// compare symbol name to the dump file
+		for( i_attr = 0; i_attr < 2; i_attr++ ){
+			for( ul = 0; ul < ul_Dump_Symbol_Cnt; ul++ ){
+				if( (*(stpp_Dump_Inf+ul))->i_Attribute == i_attr ){		// current local symbol / global symbol
+					i_len_2 = strlen( (*(stpp_Dump_Inf+ul))->ucp_Symbol_Name );
+					if( i_len_1 == i_len_2 ){
+						if( 0 == memcmp( ucp_chk_name_1,(*(stpp_Dump_Inf+ul))->ucp_Symbol_Name,i_len_2 ) ){
+							i_chk_flg = 1;
+							ucp_area_1 = (*(stpp_Dump_Inf+ul))->ucp_Area_Name;
+							break;
+						}
+					}
+				}
+			}
+			if( i_chk_flg == 1 ){
+				break;
+			}
+		}
+	}
+	
+	if( i_chk_flg == 1 ){
+		// compare check name 2 to the dump file
+		i_chk_flg = 0;
+		i_len_1 = strlen( ucp_chk_name_2 );
+		if( 0 < i_len_1 ){
+			// compare symbol name to the dump file
+			for( i_attr = 0; i_attr < 2; i_attr++ ){
+				for( ul = 0; ul < ul_Dump_Symbol_Cnt; ul++ ){
+					if( (*(stpp_Dump_Inf+ul))->i_Attribute == i_attr ){		// current local symbol / global symbol
+						i_len_2 = strlen( (*(stpp_Dump_Inf+ul))->ucp_Symbol_Name );
+						if( i_len_1 == i_len_2 ){
+							if( 0 == memcmp( ucp_chk_name_2,(*(stpp_Dump_Inf+ul))->ucp_Symbol_Name,i_len_2 ) ){
+								i_chk_flg = 1;
+								ucp_area_2 = (*(stpp_Dump_Inf+ul))->ucp_Area_Name;
+								break;
+							}
+						}
+					}
+				}
+				if( i_chk_flg == 1 ){
+					break;
+				}
+			}
+		}
+	}
+	
+	if( i_chk_flg == 1 ){
+		i_len_1 = strlen( ucp_area_1 );
+		i_len_2 = strlen( ucp_area_2 );
+		if( i_len_1 == i_len_2 ){
+			if( 0 < i_len_1 ){
+				if( 0 == memcmp( ucp_area_1,ucp_area_2,i_len_1 ) ){
+					i_ret = 1;
+				}
+			}
+		}
+	}
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format		: int clc_cur_address_from_dump( unsigned long* ul_address,unsigned long ul_tmp_cnt );
+Input		: unsigned long* ul_address -- pointer for save address
+              unsigned long ul_tmp_cnt -- additional instruction(ext) counts for caluclating offset
+Return		: 0 -- Address was not calculated.
+              1 -- Address was calculated.
+Expnalantion: Calculate the current address the form dump file and offset information.
+              First compare the current local symbol, and if don't get the addresss, 
+              then compare the global symbol.
+*******************************************************************************************/
+int clc_cur_address_from_dump( unsigned long* ul_address,unsigned long ul_tmp_cnt )
+{
+	int i_ret;
+	int i_len_1,i_len_2;
+	int i_attr;			// 0 -- local
+						// 1 -- global
+	unsigned long ul;
+	
+	i_ret = 0;
+	
+	i_len_1 = strlen( uc_Current_All_Symbol );
+	if( 0 < i_len_1 ){
+		// compare symbol name to the dump file
+		for( i_attr = 0; i_attr < 2; i_attr++ ){
+			for( ul = 0; ul < ul_Dump_Symbol_Cnt; ul++ ){
+				if( (*(stpp_Dump_Inf+ul))->i_Attribute == i_attr ){		// current local symbol / global symbol
+					i_len_2 = strlen( (*(stpp_Dump_Inf+ul))->ucp_Symbol_Name );
+					if( i_len_1 == i_len_2 ){
+						if( 0 == memcmp( uc_Current_All_Symbol,(*(stpp_Dump_Inf+ul))->ucp_Symbol_Name,i_len_2 ) ){
+							i_ret = 1;
+							*ul_address = (( ul_tmp_cnt + ul_All_Offset ) * 2) + (*(stpp_Dump_Inf+ul))->ul_Symbol_Addr;
+							// no address masking
+							break;
+						}
+					}
+				}
+			}
+			if( i_ret == 1 ){
+				break;
+			}
+		}
+	}
+	
+	return i_ret;
+}
+
+
+/*******************************************************************************************
+Format      : void getSymbolInfo(char *symbolName, struct dump_inf **pDumpInfo)
+Input       : char *symbolName     the calculated address of a symbol
+              struct dump_inf **pDumpInfo 
+                                  pointer to the global dump_inf pointer(stpp_Dump_Inf)
+                                  the result will be stored in this parameter
+Return      : NONE
+Expnalantion: Receives the pointer to dump info for symbolName
+*******************************************************************************************/
+void getSymbolInfo(char *symbolName, struct dump_inf **pDumpInfo)
+{
+	unsigned long i;
+
+	struct dump_inf **pSearchDumpInfo = stpp_Dump_Inf;
+	unsigned long symbolCount = ul_Dump_Symbol_Cnt;
+
+	for (i = 0; i < symbolCount; i++) {
+		if (strcmp(pSearchDumpInfo[i]->ucp_Symbol_Name, symbolName) == 0) {
+			*pDumpInfo = pSearchDumpInfo[i];
+			break;
+		}
+	}
+
+}
+
+
+/*******************************************************************************************
+Format      : unsigned long getDataPointerAddress(char *dpSymbol)
+Input       : char *dpSymbol     the symbol for the data pointer
+Return      : unsigned long      address of data pointer
+Expnalantion: Returns the address of the data pointer.
+              The symbol must exist in the dump file and be a global symbol,
+              otherwise the value will be 0
+*******************************************************************************************/
+unsigned long getDataPointerAddress(char *dpSymbol)
+{
+	unsigned long address = 0;				// return value
+	struct dump_inf *pDumpInfo = NULL;
+
+	getSymbolInfo(dpSymbol, &pDumpInfo);
+	if (pDumpInfo != NULL) {
+		// get the address when the symbol is a global symbol
+		if (pDumpInfo->i_Attribute == 1) {
+			address = pDumpInfo->ul_Symbol_Addr;
+		}
+	}
+
+	return address;
+
+}
+
+
+// ADD D.Fujimoto 2007/12/27 >>>>>
+/*******************************************************************************************
+Format      : void countDuplicateSymbols(struct dump_inf **pDumpInfo, struct dump_inf **pAllDumpInfo, unsigned long symbolCount)
+Input       :   struct dump_inf **pAllDumpInfo
+								  pointer to the global dump_inf pointer (all object file dump).
+								  This will be used to check duplicate symbols
+			  unsigned long		  element count of *pAllDumpInfo
+Return      : none
+Expnalantion: Count up the symbol occurence in stpp_Dump_Inf that appears in pAllDumpInfo.
+			  The count for pAllDumpInfo must be given as symbolCount.
+			  Global variable stpp_Dump_Inf is referenced here.
+			  Prior to calling this function, all elements of stpp_Dump_Inf[]->iCount should be 0
+*******************************************************************************************/
+void countDuplicateSymbols(struct dump_inf **pAllDumpInfo, unsigned long symbolCount)
+{
+	unsigned long i;
+	struct dump_inf *pDumpInfo = NULL;
+
+	for (i = 0; i < symbolCount; i++) {
+		// search for global symbols and match that with pDumpInfo
+		if (pAllDumpInfo[i]->i_Attribute == 1) {
+			getSymbolInfo(pAllDumpInfo[i]->ucp_Symbol_Name, &pDumpInfo);
+
+			// count it up
+			if (pDumpInfo != NULL) {
+				if (pDumpInfo->i_Attribute == 1) {
+					pDumpInfo->iCount++;
+				}
+			}
+		}
+	}
+
+}
+
+
+/*******************************************************************************************
+Format      : int isDuplicateSymbol(char *symbolName)
+Input       : char *symbolName
+					symbolName to search from stpp_Dump_Inf
+Return      : 1 = true, 0 = false
+Expnalantion: Search symbolName from stpp_Dump_Inf and check whether it is a duplicate.
+			  Duplicate symbols must not be used for ext insn optimization.
+			  Global variable stpp_Dump_Inf is referenced here.
+*******************************************************************************************/
+int isDuplicateSymbol(const char *symbolName)
+{
+	int ret = 0;
+	unsigned long i;
+
+	struct dump_inf **pSearchDumpInfo = stpp_Dump_Inf;
+	unsigned long symbolCount = ul_Dump_Symbol_Cnt;
+
+	// duplicate when the global symbol count is more than 1
+	for (i = 0; i < symbolCount; i++) {
+		if (strcmp(pSearchDumpInfo[i]->ucp_Symbol_Name, symbolName) == 0 && 
+			pSearchDumpInfo[i]->i_Attribute == 1 &&
+			pSearchDumpInfo[i]->iCount > 1) {
+			ret = 1;
+			break;
+		}
+	}
+
+	return ret;
+
+}
+// ADD D.Fujimoto 2007/12/27 <<<<<
+
+
+// ADD D.Fujimoto 2007/12/26 >>>>>
+/*******************************************************************************************
+Format      : void printDumpInf(struct dump_inf **pDumpInfo, unsigned long symbolCount)
+Input       : struct dump_inf **pDumpInfo	
+                                  pointer to the global dump_inf pointer
+			  unsigned long		element count of *pDumpInfo
+Return      : none
+Expnalantion: Print symbols in struct dump_inf for debugging.
+			  The count for struct dump_inf must be given as symbolCount.
+*******************************************************************************************/
+void printDumpInf(struct dump_inf **pDumpInfo, unsigned long symbolCount)
+{
+	int i;
+
+	for (i = 0; i < symbolCount; i++) {
+		printf("%s\t%s\t0x%x", pDumpInfo[i]->ucp_Symbol_Name, pDumpInfo[i]->ucp_Area_Name, pDumpInfo[i]->ul_Symbol_Addr);
+
+		printf("\t%s\n", (pDumpInfo[i]->i_Attribute == 1 ? "g" : "l"));
+	}
+
+}
+// ADD D.Fujimoto 2007/12/26 <<<<<
+
+
+/*******************************************************************************************
+Format		: int evaluate_ext_count(expressionS ex, ExtCountFunc pfunc)
+Input		: expressionS	ex		expression of current line
+              unsigned long dpAddress
+                                    Address of data pointer(used when no medda32).
+                                    Specify 0 when using medda32.
+              ExtCountFunc	pfunc	function to count ext for the current line
+Return      : The count of ext instructions, 
+	          or MAX_EXT_INSN_CNT if maximum ext instructions should be added.
+Expnalantion: Evaluates the needed ext counts for this expression.
+			  The given function will determine the actual ext counts.
+			  The function pointer arg should not be NULL.
+*******************************************************************************************/
+int evaluate_ext_count(expressionS ex, unsigned long dpAddress, ExtCountFunc pfunc)
+{
+	int i_ext_cnt = MAX_EXT_INSN_CNT;	// return value 
+	int i_ret;					// return values of the called functions
+	
+	unsigned long ul_address;	// the address of the symbol
+
+	if (pfunc == NULL) {
+		abort();
+	}
+
+// ADD D.Fujimoto 2008/01/07 >>>>>
+	// skip counting for duplicate (c++) symbols
+	if (isDuplicateSymbol(S_GET_NAME( ex.X_add_symbol ))) {
+		return MAX_EXT_INSN_CNT;
+	}
+// ADD D.Fujimoto 2008/01/07 <<<<<
+
+	// get symbol address ( include formula )
+	i_ret = chk_label_address_from_dump( S_GET_NAME( ex.X_add_symbol ),ex.X_add_number,&ul_address );
+	if( i_ret == 1 ){
+		// dp address is normally smaller than the symbol address
+		ul_address = (ul_address >= dpAddress) ? ul_address - dpAddress : ul_address;
+		i_ext_cnt = pfunc(ul_address);		// call the apropriate ExtCountFunc
+	}
+	
+	return i_ext_cnt;
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_xld_rd_symbol(unsigned long address)
+Input       : unsigned long address     the calculated address of a symbol
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - xld.w %rd, LABEL
+              This function is used as ExtCountFunc to be passed to evaluate_ext_count().
+*******************************************************************************************/
+int count_ext_for_xld_rd_symbol(unsigned long address)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+
+	if ( address <= 0x1F ) {
+		// 0 - 0x1F
+		ext_count = 0;
+	} else if ( (0x20 <= address) && (address <= 0x3FFFF) ) {
+		ext_count = 1;
+	} else if ( (0x40000 <= address) && (address <= 0x7FFFF) ) {
+		ext_count = 2;
+	}
+
+	return ext_count;
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_xld_mem_rw(unsigned long address)
+Input       : unsigned long address     the calculated address of a symbol
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - xld.* %rd, [LABEL]
+                - xld.* [LABEL], %rd
+                - xb*   [LABEL], imm3
+                  for STD, PE
+                      nomedda
+              This function is used as ExtCountFunc to be passed to evaluate_ext_count().
+*******************************************************************************************/
+int count_ext_for_xld_mem_rw(unsigned long address)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+
+	if ( address <= 0x1FFF ) {
+		// 0 - 0x1FFF
+		ext_count = 1;
+	}
+
+	return ext_count;
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_xld_mem_rw32(unsigned long address)
+Input       : unsigned long address     the calculated address of a symbol
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - xld.* %rd, [LABEL]
+                - xld.* [LABEL], %rd
+                - xb*   [LABEL], imm3
+                  for STD, PE, ADV
+                      medda
+              This function is used as ExtCountFunc to be passed to evaluate_ext_count().
+*******************************************************************************************/
+int count_ext_for_xld_mem_rw32(unsigned long address)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+
+	if ( address <= 0x1F ) {
+		// 0 - 0x1F
+		ext_count = 0;
+	} else if ( (0x20 <= address) && (address <= 0x3FFFF) ) {
+		ext_count = 1;
+	}
+
+	return ext_count;
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_xld_mem_rw_adv(unsigned long address)
+Input       : unsigned long address     the calculated address of a symbol
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - xld.* %rd, [LABEL]
+                - xld.* [LABEL], %rd
+                  for ADV
+                      nomedda
+              This function is used as ExtCountFunc to be passed to evaluate_ext_count().
+*******************************************************************************************/
+int count_ext_for_xld_mem_rw_adv(unsigned long address)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+
+	if ( address <= 0x7FFFF ) {
+		// 0x0 - 0x7FFFF
+		ext_count = 1;
+	}
+
+	return ext_count;
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_ald_mem_rw(unsigned long address)
+Input       : unsigned long address     the calculated address of a symbol
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - ald.* %rd, [LABEL]
+                - ald.* [LABEL], %rd
+                  for ADV
+                      nomedda
+              This function is used as ExtCountFunc to be passed to evaluate_ext_count().
+*******************************************************************************************/
+int count_ext_for_ald_mem_rw(unsigned long address)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+
+	if ( address <= 0x7FFFF ) {
+		// 0x0 - 0x7FFFF
+		ext_count = 1;
+	}
+
+	return ext_count;
+
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_ald_mem_rw32(unsigned long address)
+Input       : unsigned long address     the calculated address of a symbol
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - ald.* %rd, [LABEL]
+                - ald.* [LABEL], %rd
+                  for ADV
+                      medda
+              This function is used as ExtCountFunc to be passed to evaluate_ext_count().
+*******************************************************************************************/
+int count_ext_for_ald_mem_rw32(unsigned long address)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+
+	if ( address <= 0x1F ) {
+		// 0 - 0x1F
+		ext_count = 0;
+	} else if ( (0x20 <= address) && (address <= 0x7FFFF) ) {
+		ext_count = 1;
+	}
+
+	return ext_count;
+
+}
+
+
+/*******************************************************************************************
+Format		: int evaluate_ext_count_for_jumps(expressionS ex)
+Input		: expressionS	ex		expression of current line
+			: int addInstCount		additional instruction(ext) counts for calculating address
+              ExtCountFunc	pfunc	function to count ext for the current line
+Return      : The count of ext instructions, 
+	          or MAX_EXT_INSN_CNT if maximum ext instructions should be added.
+Expnalantion: Evaluates the needed ext counts for this expression(call and jp*).
+			  The given function will determine the actual ext counts.
+			  The function pointer arg should not be NULL.
+*******************************************************************************************/
+int evaluate_ext_count_for_jumps(expressionS ex, int addInstCount, ExtCountJumpFunc pfunc)
+{
+	
+	int i_ext_cnt = MAX_EXT_INSN_CNT;	// return value 
+	int i_ret;					// return values of the called functions
+	
+	unsigned long ul_dst_address;		// address of the LABEL(operand) 
+	unsigned long ul_src_address;		// address of the instruction
+
+	if (pfunc == NULL) {
+		abort();
+	}
+
+// ADD D.Fujimoto 2008/01/07 >>>>>
+	// skip counting for duplicate (c++) symbols
+	if (isDuplicateSymbol(S_GET_NAME( ex.X_add_symbol ))) {
+		return MAX_EXT_INSN_CNT;
+	}
+// ADD D.Fujimoto 2008/01/07 <<<<<
+
+	// get symbol address ( include formula )
+	i_ret = chk_label_address_from_dump( S_GET_NAME( ex.X_add_symbol ),ex.X_add_number,&ul_dst_address );
+	if( i_ret == 1 ){
+		// check whether area is same
+		i_ret = chk_is_same_area_from_dump( S_GET_NAME( ex.X_add_symbol ),uc_Current_All_Symbol );
+		if( i_ret == 1 ){
+			i_ret = clc_cur_address_from_dump( &ul_src_address, addInstCount );		// get current_address
+			if( i_ret == 1 ){
+				i_ext_cnt = pfunc(ul_dst_address, ul_src_address);		// call the apropriate ExtCountFunc
+			}
+		}
+	}
+
+	return i_ext_cnt;
+
+}
+
+
+/*******************************************************************************************
+Format      : int count_ext_for_jumps(unsigned long dstAddress, unsigned long srcAddress)
+Input       : unsigned long dstAddress     the calculated address of a symbol
+              unsigned long srcAddress     the calculated address of the instruction
+Return      : The count of ext instructions, 
+              or MAX_EXT_INSN_CNT if it cannot be determined
+Expnalantion: Evaluates the needed ext counts for reaching the given address for patterns:
+                - scall LABEL
+                - xcall LABEL
+                - sj*   LABEL
+                - xj*   LABEL
+              This function is used as ExtCountJumpFunc 
+              to be passed to evaluate_ext_count_for_jumps().
+*******************************************************************************************/
+int count_ext_for_jumps(unsigned long dstAddress, unsigned long srcAddress)
+{
+	int ext_count = MAX_EXT_INSN_CNT;
+	long distance;
+
+	// distance may be negative
+	distance = (long) (dstAddress - srcAddress);
+	if ( ( -256 <= distance ) && ( distance <= 254 ) ) {
+		ext_count = 0;
+	} else if ( ((-2097152 <= distance) && (distance < -256)) || 
+				((254 < distance) && (distance <= 2097150)) ) {
+		ext_count = 1;
+	} else if ( (distance < -2097152) ||  (2097150 < distance) ) {
+		ext_count = 2;
+	}
+
+	return ext_count;
+
+}
diff --git a/gas/ext_remove.h b/gas/ext_remove.h
new file mode 100644
index 0000000..261faad
--- /dev/null
+++ b/gas/ext_remove.h
@@ -0,0 +1,176 @@
+/* ext_remove.h - header file for 2pass assemble.
+	This program will remove redundant ext 0x0 instructions
+	which emerge from memory load from LABEL/SYMBOLS or
+	from function calls to LABEL/SYMBOLS
+	Copyright (C) 2007 SEIKO EPSON CORP.
+
+	Written by D.Fujimoto@Irumasoft
+	DATE:2007/02/28
+
+	This file is part of GAS, the GNU Assembler.
+
+	GAS is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2, or (at your option)
+	any later version.
+
+	GAS is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with GAS; see the file COPYING.  If not, write to the Free
+	Software Foundation, 59 Temple Place - Suite 330, Boston, MA
+	02111-1307, USA. 
+*/
+#ifndef	__EXT_REMOVE_H__
+#define	__EXT_REMOVE_H__
+
+//////////////////////////////////////////
+// Macro definitions
+#define	EXT_REMOVE							// the ext remove feature is alive where this macro appears
+											// in other source files
+
+#define INPUT_CUR_LINE_MAX (0x800 + 1)		// the maximum number of characters per one line of a current file
+
+#define	DATA_POINTER_SYMBOL		"__dp"		// symbol representing data pointer
+
+#define MAX_EXT_INSN_CNT	(-1)			// default return value for evaluate_ext_count() and related functions
+
+//////////////////////////////////////////
+// Structure declarations
+typedef struct cur_inf
+{
+	unsigned char* ucp_Symbol_Name;			// pointer for symbol name
+	int i_Attribute;						// 0 -- local
+											// 1 -- global
+} cur_inf;
+
+struct dump_inf
+{
+	unsigned char* ucp_Symbol_Name;			// pointer for symbol name ( cuurent local symbol & global symbol )
+	unsigned long ul_Symbol_Addr;			// address where symbol name is placed
+	unsigned char* ucp_Area_Name;			// pointer for area name in which symbol name belongs
+	int i_Attribute;						// 0 -- local
+											// 1 -- global
+	int iCount;								// symbol occurence  ADD D.Fujimoto 2007/12/27
+											// symbols that are found more than 1 should not be used for ext optimization
+};
+
+
+//////////////////////////////////////////
+// Enum declarations
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file >>>>>
+enum CheckStatus {format, filename, local_global, global};				// used in read_all_dump_info()
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file <<<<
+
+////////////////////////////////////////////
+// Global variables
+
+extern int g_c33_ext;									// flag indicating that -mc33ext option is specified
+														// 0=not specified, 1=-mc33ext specified
+
+extern int i_File_Inf_Flg	;							// 0 -- initial vaule
+														// 1 -- ".file" exists.
+
+extern unsigned long g_dpAddress;						// address of data pointer(used when no-medda32)
+
+// symbols information of current file
+extern unsigned long ul_Cur_File_Symbol_Cnt;
+extern struct cur_inf** stpp_Cur_Inf;
+extern char *cp_Current_File_Name;						// pointer for current file name( include path )
+
+// symbols information of dump file
+extern unsigned long ul_Dump_Symbol_Cnt;
+extern struct dump_inf** stpp_Dump_Inf;
+extern char *cp_Dump_File_Name;							// pointer for dump file name( include path )
+
+// variables for symbol offset calculation
+extern volatile unsigned long ul_All_Offset;							// offset(instruction counts) from all symbol
+extern unsigned char uc_Current_All_Symbol[INPUT_CUR_LINE_MAX];			// current symbol( local & global )
+extern unsigned char uc_Pre_All_Symbol[INPUT_CUR_LINE_MAX];				// pre symbol( local & global )
+
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file >>>>>
+// symbols information of all object dump file
+extern unsigned long ul_All_Dump_Symbol_Cnt;
+extern struct dump_inf** stpp_All_Dump_Inf;				// only global symbols will be stored
+extern char *cp_All_Dump_File_Name;							// pointer for dump file name( include path )
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file <<<<<
+
+
+//////////////////////////////////////////
+// Function prototypes
+unsigned long chg_str_to_val PARAMS (( unsigned char* ucp_chg_ptr ));
+
+void read_cur_file_info PARAMS(( char *cp_prm_file ));
+
+void get_valid_string PARAMS(( unsigned char *ucp_rd_pt,unsigned char *ucp_wt_pt ));
+int get_label_info_from_src PARAMS(( unsigned char *uc_rd_pt,unsigned char *uc_wt_pt ));
+int get_attribute_info PARAMS(( unsigned char *ucp_rd_pt,unsigned char *ucp_wt_pt ));
+
+void free_cur_info PARAMS(());
+void free_ext_heap_area PARAMS(());
+
+void read_dump_info( char* cp_dump_file_name, char* cp_out_file_name );
+void get_label_info_from_dump( unsigned char *ucp_rd_pt,struct dump_inf **stpp_prm_dump_inf );
+void free_dump_info();
+
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file >>>>>
+void read_all_dump_info( char* cp_dump_file_name, char* cp_out_file_name );
+void free_all_dump_info();
+// ADD D.Fujimoto 2007/12/26 for all 1pass objects' dump file <<<<<
+
+void chk_is_file_inf( unsigned char *ucp_chk_file_pt );
+void chk_is_file_inf_from_line( unsigned char *ucp_chk_pt );
+int chk_is_stab( unsigned char *ucp_chk_pt );
+
+
+void s_app_file_2 ();									// append .file pseudo op
+void reset_current_symbol(char *input_line_pointer);
+void update_current_symbol(char *s);
+
+int chk_global_label_2 PARAMS (( char* cp_label_name ));
+
+int chk_label_address_from_dump( const char* cp_label_name,offsetT off_offset,unsigned long *ulp_label_address );
+int chk_is_same_area_from_dump( const char *ucp_chk_name_1,unsigned char *ucp_chk_name_2 );
+int clc_cur_address_from_dump( unsigned long* ul_address,unsigned long ul_tmp_cnt );
+
+void getSymbolInfo(char *symbolName, struct dump_inf **pDumpInfo);
+unsigned long getDataPointerAddress(char *dataPointerSymbol);
+
+// ADD D.Fujimoto 2007/12/27 >>>>>
+void countDuplicateSymbols(struct dump_inf **pAllDumpInfo, unsigned long symbolCount);
+int isDuplicateSymbol(const char *symbolName);
+// ADD D.Fujimoto 2007/12/27 <<<<<
+
+// ADD D.Fujimoto 2007/12/26 >>>>>
+void printDumpInf(struct dump_inf **pDumpInfo, unsigned long symbolCount);		// print symbols for debugging
+// ADD D.Fujimoto 2007/12/26 <<<<<
+void evaluate_offset_from_symbol(void);					// reset or increment the offset from symbol
+
+
+// function pointer for ext counter functions
+typedef int (*ExtCountFunc)(unsigned long address);
+
+int evaluate_ext_count(expressionS ex, unsigned long dpAddress, ExtCountFunc pfunc);	// ext counter for mem read/write expressions
+
+// some ExtCountFuncs
+int count_ext_for_xld_rd_symbol(unsigned long address);
+int count_ext_for_xld_mem_rw(unsigned long address);
+int count_ext_for_xld_mem_rw32(unsigned long address);
+int count_ext_for_xld_mem_rw_adv(unsigned long address);
+int count_ext_for_ald_mem_rw(unsigned long address);
+int count_ext_for_ald_mem_rw32(unsigned long address);
+
+
+// function pointer for ext counter functions
+typedef int (*ExtCountJumpFunc)(unsigned long dstAddress, unsigned long srcAddress);
+
+int evaluate_ext_count_for_jumps(expressionS ex, int addInstCount, ExtCountJumpFunc pfunc);			// ext counter for call/jp expressions
+
+// some ExtCountJumpFuncs
+int count_ext_for_jumps(unsigned long dstAddress, unsigned long srcAddress);
+
+
+#endif	// __EXT_REMOVE_H__
diff --git a/gas/input-scrub.c b/gas/input-scrub.c
index ecbdaef..d0ce9e7 100644
--- a/gas/input-scrub.c
+++ b/gas/input-scrub.c
@@ -417,6 +417,13 @@ seen_at_least_1_file ()		/* TRUE if we opened any file. */
 {
   return (physical_input_file != NULL);
 }
+/* add T.Tazaki 2002.02.05 >>> */
+line_numberT
+get_physical_input_line()
+{
+	return physical_input_line;
+}
+/* add T.Tazaki 2002.02.05 <<< */
 
 void
 bump_line_counters ()
@@ -468,23 +475,33 @@ new_logical_line (fname, line_number)
  * namep should be char * const *, but there are compilers which screw
  * up declarations like that, and it's easier to avoid it.
  */
+ 
+
+/* >>> add T.Tazaki 2002.03.04 */
+extern char *c33_original_input_file;
+/* <<< add T.Tazaki 2002.03.04 */
+
 void 
 as_where (namep, linep)
      char **namep;
      unsigned int *linep;
 {
+
+	/*  */
+
+
   if (logical_input_file != NULL
       && (linep == NULL || logical_input_line >= 0))
     {
-      *namep = logical_input_file;
+	 *namep = logical_input_file;
       if (linep != NULL)
 	*linep = logical_input_line;
     }
   else if (physical_input_file != NULL)
     {
-      *namep = physical_input_file;
+      	*namep = physical_input_file;
       if (linep != NULL)
-	*linep = physical_input_line;
+	     *linep = physical_input_line;
     }
   else
     {
@@ -492,6 +509,14 @@ as_where (namep, linep)
       if (linep != NULL)
 	*linep = 0;
     }
+    
+    /* >>> add T.Tazaki 2002.03.04 */
+    /* input file name pointer set */
+    if( *c33_original_input_file != NULL ){
+	 *namep = c33_original_input_file;	/* cpp :# 1 "sample.s" */
+    }
+    /* <<< add T.Tazaki 2002.03.04 */
+    	
 }				/* as_where() */
 
 
diff --git a/gas/read.c b/gas/read.c
index 1522842..db40169 100644
--- a/gas/read.c
+++ b/gas/read.c
@@ -20,11 +20,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA. */
 
 #if 0
-#define MASK_CHAR (0xFF)	/* If your chars aren't 8 bits, you will
-				   change this a bit.  But then, GNU isn't
-				   spozed to run on your machine anyway.
-				   (RMS is so shortsighted sometimes.)
-				   */
+#define MASK_CHAR (0xFF)        /* If your chars aren't 8 bits, you will
+                                   change this a bit.  But then, GNU isn't
+                                   spozed to run on your machine anyway.
+                                   (RMS is so shortsighted sometimes.)
+                                   */
 #else
 #define MASK_CHAR ((int)(unsigned char)-1)
 #endif
@@ -48,6 +48,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #include "obstack.h"
 #include "listing.h"
 #include "ecoff.h"
+#include "ext_remove.h"				// add D.Fujimoto 2007/02/28
 
 #ifndef TC_START_LABEL
 #define TC_START_LABEL(x,y) (x==':')
@@ -76,7 +77,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #define NOP_OPCODE 0x00
 #endif
 
-char *input_line_pointer;	/*->next char of source file to parse. */
+char *input_line_pointer;       /*->next char of source file to parse. */
 
 #if BITS_PER_CHAR != 8
 /*  The following table is indexed by[(char)] and will break if
@@ -121,13 +122,13 @@ die horribly;
 /* used by is_... macros. our ctype[] */
 char lex_type[256] =
 {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* @ABCDEFGHIJKLMNO */
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* PQRSTUVWXYZ[\]^_ */
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,       /* @ABCDEFGHIJKLMNO */
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,       /* PQRSTUVWXYZ[\]^_ */
   0, 0, 0, LEX_HASH, LEX_DOLLAR, LEX_PCT, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, /* _!"#$%&'()*+,-./ */
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, LEX_QM,	/* 0123456789:;<=>? */
-  LEX_AT, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* @ABCDEFGHIJKLMNO */
+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, LEX_QM,  /* 0123456789:;<=>? */
+  LEX_AT, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,  /* @ABCDEFGHIJKLMNO */
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, 0, 3, /* PQRSTUVWXYZ[\]^_ */
-  0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* `abcdefghijklmno */
+  0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,       /* `abcdefghijklmno */
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~. */
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
@@ -148,48 +149,48 @@ char lex_type[256] =
 char is_end_of_line[256] =
 {
 #ifdef CR_EOL
-  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, 99, Z_, Z_,	/* @abcdefghijklmno */
+  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, 99, Z_, Z_,       /* @abcdefghijklmno */
 #else
-  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_, Z_,	/* @abcdefghijklmno */
+  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_, Z_,       /* @abcdefghijklmno */
 #endif
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
 #ifdef TC_HPPA
-  Z_,99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* _!"#$%&'()*+,-./ */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
+  Z_,99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,        /* _!"#$%&'()*+,-./ */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* 0123456789:;<=>? */
 #else
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_,       /* 0123456789:;<=>? */
 #endif
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
-  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
+  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,       /* */
 };
 #undef Z_
 
 /* Functions private to this file. */
 
-static char *buffer;	/* 1st char of each buffer of lines is here. */
-static char *buffer_limit;	/*->1 + last char in buffer. */
+static char *buffer;    /* 1st char of each buffer of lines is here. */
+static char *buffer_limit;      /*->1 + last char in buffer. */
 
 /* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1 in the
    tc-<CPU>.h file.  See the "Porting GAS" section of the internals manual. */
 int target_big_endian = TARGET_BYTES_BIG_ENDIAN;
 
-static char *old_buffer;	/* JF a hack */
+static char *old_buffer;        /* JF a hack */
 static char *old_input;
 static char *old_limit;
 
 /* Variables for handling include file directory table. */
 
-char **include_dirs;	/* Table of pointers to directories to
-			   search for .include's */
-int include_dir_count;	/* How many are in the table */
+char **include_dirs;    /* Table of pointers to directories to
+                           search for .include's */
+int include_dir_count;  /* How many are in the table */
 int include_dir_maxlen = 1;/* Length of longest in table */
 
 #ifndef WORKING_DOT_WORD
@@ -318,7 +319,7 @@ static const pseudo_typeS potable[] =
 /* dim */
   {"double", float_cons, 'd'},
 /* dsect */
-  {"eject", listing_eject, 0},	/* Formfeed listing */
+  {"eject", listing_eject, 0},  /* Formfeed listing */
   {"else", s_else, 0},
   {"elsec", s_else, 0},
   {"elseif", s_elseif, (int) O_ne},
@@ -332,7 +333,7 @@ static const pseudo_typeS potable[] =
   {"err", s_err, 0},
   {"exitm", s_mexit, 0},
 /* extend */
-  {"extern", s_ignore, 0},	/* We treat all undef as ext */
+  {"extern", s_ignore, 0},      /* We treat all undef as ext */
   {"appfile", s_app_file, 1},
   {"appline", s_app_line, 0},
   {"fail", s_fail, 0},
@@ -365,19 +366,19 @@ static const pseudo_typeS potable[] =
   {"irpc", s_irp, 1},
   {"irepc", s_irp, 1},
   {"lcomm", s_lcomm, 0},
-  {"lflags", listing_flags, 0},	/* Listing flags */
+  {"lflags", listing_flags, 0}, /* Listing flags */
   {"linkonce", s_linkonce, 0},
-  {"list", listing_list, 1},	/* Turn listing on */
+  {"list", listing_list, 1},    /* Turn listing on */
   {"llen", listing_psize, 1},
   {"long", cons, 4},
   {"lsym", s_lsym, 0},
   {"macro", s_macro, 0},
   {"mexit", s_mexit, 0},
   {"mri", s_mri, 0},
-  {".mri", s_mri, 0},	/* Special case so .mri works in MRI mode.  */
+  {".mri", s_mri, 0},   /* Special case so .mri works in MRI mode.  */
   {"name", s_ignore, 0},
   {"noformat", s_ignore, 0},
-  {"nolist", listing_list, 0},	/* Turn listing off */
+  {"nolist", listing_list, 0},  /* Turn listing off */
   {"nopage", listing_nopage, 0},
   {"octa", cons, 16},
   {"offset", s_struct, 0},
@@ -388,13 +389,13 @@ static const pseudo_typeS potable[] =
   {"page", listing_eject, 0},
   {"plen", listing_psize, 0},
   {"print", s_print, 0},
-  {"psize", listing_psize, 0},	/* set paper size */
+  {"psize", listing_psize, 0},  /* set paper size */
   {"purgem", s_purgem, 0},
   {"quad", cons, 8},
   {"rep", s_rept, 0},
   {"rept", s_rept, 0},
   {"rva", s_rva, 4},
-  {"sbttl", listing_title, 1},	/* Subtitle of listing */
+  {"sbttl", listing_title, 1},  /* Subtitle of listing */
 /* scl */
 /* sect */
   {"set", s_set, 0},
@@ -423,7 +424,7 @@ static const pseudo_typeS potable[] =
      this one.  Match it either way...  */
   {"this_gcc_requires_the_gnu_assembler", s_ignore, 0},
 
-  {"title", listing_title, 0},	/* Listing title */
+  {"title", listing_title, 0},  /* Listing title */
   {"ttl", listing_title, 0},
 /* type */
   {"uleb128", s_leb128, 0},
@@ -435,7 +436,7 @@ static const pseudo_typeS potable[] =
   {"xstabs", s_xstab, 's'},
   {"word", cons, 2},
   {"zero", s_space, 0},
-  {NULL, NULL, 0}			/* end sentinel */
+  {NULL, NULL, 0}                       /* end sentinel */
 };
 
 static int pop_override_ok = 0;
@@ -451,17 +452,17 @@ pop_insert (table)
     {
       errtxt = hash_insert (po_hash, pop->poc_name, (char *) pop);
       if (errtxt && (!pop_override_ok || strcmp (errtxt, "exists")))
-	as_fatal (_("error constructing %s pseudo-op table: %s"), pop_table_name,
-		  errtxt);
+        as_fatal (_("error constructing %s pseudo-op table: %s"), pop_table_name,
+                  errtxt);
     }
 }
 
 #ifndef md_pop_insert
-#define md_pop_insert()		pop_insert(md_pseudo_table)
+#define md_pop_insert()         pop_insert(md_pseudo_table)
 #endif
 
 #ifndef obj_pop_insert
-#define obj_pop_insert()	pop_insert(obj_pseudo_table)
+#define obj_pop_insert()        pop_insert(obj_pseudo_table)
 #endif
 
 static void 
@@ -483,13 +484,13 @@ pobegin ()
   pop_insert (potable);
 }
 
-#define HANDLE_CONDITIONAL_ASSEMBLY()					\
-  if (ignore_input ())							\
-    {									\
-      while (! is_end_of_line[(unsigned char) *input_line_pointer++])	\
-	if (input_line_pointer == buffer_limit)				\
-	  break;							\
-      continue;								\
+#define HANDLE_CONDITIONAL_ASSEMBLY()                                   \
+  if (ignore_input ())                                                  \
+    {                                                                   \
+      while (! is_end_of_line[(unsigned char) *input_line_pointer++])   \
+        if (input_line_pointer == buffer_limit)                         \
+          break;                                                        \
+      continue;                                                         \
     }
 
 
@@ -514,19 +515,48 @@ scrub_from_string (buf, buflen)
   return copy;
 }
 
-/*	read_a_source_file()
+/*      read_a_source_file()
  *
  * We read the file, putting things into a web that
  * represents what we have been reading.
  */
+ 
+/* add T.Tazaki 2002.03.04 >>> */
+char *c33_stabs_input_file;
+char szC33_stabs_input_file[300];
+char *c33_original_input_file;
+char szC33_original_input_file[300];
+extern enum debug_info_type debug_type;
+/* add T.Tazaki 2002.03.04 <<< */
+
 void 
 read_a_source_file (name)
      char *name;
 {
   register char c;
-  register char *s;		/* string of symbol, '\0' appended */
+  register char *s;             /* string of symbol, '\0' appended */
   register int temp;
   pseudo_typeS *pop;
+ 
+  /* add T.Tazaki 2002.03.04 >>> */
+  int   i;
+  char  *hold;
+  char  *hold2;
+  char  *file;
+  unsigned int lineno;
+  int   iPrepro = 0;
+  int   iFirst_stabs = 0; /* OFF */
+  int   iFirst_original = 0; /* OFF */
+  int   iLinePlusFirst = 0;  /* 0=first # line    add T.Tazaki 2003/05/20 */
+
+
+  c33_stabs_input_file = &szC33_stabs_input_file[0];
+  *c33_stabs_input_file = NULL;
+  
+  c33_original_input_file = &szC33_original_input_file[0];
+  *c33_original_input_file = NULL;
+  
+  /* add T.Tazaki 2002.03.04 <<< */
 
   buffer = input_scrub_new_file (name);
 
@@ -537,569 +567,815 @@ read_a_source_file (name)
   /* Generate debugging information before we've read anything in to denote
      this file as the "main" source file and not a subordinate one
      (e.g. N_SO vs N_SOL in stabs).  */
-  generate_file_debug ();
+     
+     hold = input_line_pointer;
+
+/*     generate_file_debug ();          */ /*  del T.Tazaki 2002.02.26 */
+
+// ADD D.Fujimoto append .file pseudo op 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+	s_app_file_2();
+#endif
+// ADD D.Fujimoto append .file pseudo op 2007/06/25 <<<<<<<
 
   while ((buffer_limit = input_scrub_next_buffer (&input_line_pointer)) != 0)
-    {				/* We have another line to parse. */
-      know (buffer_limit[-1] == '\n');	/* Must have a sentinel. */
-    contin:			/* JF this goto is my fault I admit it.
-				   Someone brave please re-write the whole
-				   input section here?  Pleeze???  */
+    {                           /* We have another line to parse. */
+      know (buffer_limit[-1] == '\n');  /* Must have a sentinel. */
+    contin:                     /* JF this goto is my fault I admit it.
+                                   Someone brave please re-write the whole
+                                   input section here?  Pleeze???  */
+
+        as_where (&file, &lineno);      /* debug */
+
+
       while (input_line_pointer < buffer_limit)
-	{
-	  /* We have more of this buffer to parse. */
-
-	  /*
-	   * We now have input_line_pointer->1st char of next line.
-	   * If input_line_pointer [-1] == '\n' then we just
-	   * scanned another line: so bump line counters.
-	   */
-	  if (is_end_of_line[(unsigned char) input_line_pointer[-1]])
-	    {
+        {
+          /* We have more of this buffer to parse. */
+
+          /*
+           * We now have input_line_pointer->1st char of next line.
+           * If input_line_pointer [-1] == '\n' then we just
+           * scanned another line: so bump line counters.
+           */
+          if (is_end_of_line[(unsigned char) input_line_pointer[-1]])
+            {
 #ifdef md_start_line_hook
-	      md_start_line_hook ();
+              md_start_line_hook ();
 #endif
 
-	      if (input_line_pointer[-1] == '\n')
-		bump_line_counters ();
-
-	      line_label = NULL;
-
-	      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)
-		{
-		  /* Text at the start of a line must be a label, we
-		     run down and stick a colon in.  */
-		  if (is_name_beginner (*input_line_pointer))
-		    {
-		      char *line_start = input_line_pointer;
-		      char c;
-		      int mri_line_macro;
-
-		      LISTING_NEWLINE ();
-		      HANDLE_CONDITIONAL_ASSEMBLY ();
-
-		      c = get_symbol_end ();
-
-		      /* In MRI mode, the EQU and MACRO pseudoops must
-			 be handled specially.  */
-		      mri_line_macro = 0;
-		      if (flag_m68k_mri)
-			{
-			  char *rest = input_line_pointer + 1;
-
-			  if (*rest == ':')
-			    ++rest;
-			  if (*rest == ' ' || *rest == '\t')
-			    ++rest;
-			  if ((strncasecmp (rest, "EQU", 3) == 0
-			       || strncasecmp (rest, "SET", 3) == 0)
-			      && (rest[3] == ' ' || rest[3] == '\t'))
-			    {
-			      input_line_pointer = rest + 3;
-			      equals (line_start,
-				      strncasecmp (rest, "SET", 3) == 0);
-			      continue;
-			    }
-			  if (strncasecmp (rest, "MACRO", 5) == 0
-			      && (rest[5] == ' '
-				  || rest[5] == '\t'
-				  || is_end_of_line[(unsigned char) rest[5]]))
-			    mri_line_macro = 1;
-			}
-
-		      /* In MRI mode, we need to handle the MACRO
+              if (input_line_pointer[-1] == '\n')
+              {
+
+                        /* add T.Tazaki 2002.03.18 >>> */
+
+                        if( *input_line_pointer == '\n' ){
+                                if( iFirst_stabs != 1 && iFirst_original != 1 ){        /* Non PrePro Source ? */
+                                        ++input_line_pointer;
+                                        bump_line_counters ();   /* ++lineno */
+                                        continue;
+                                }
+                        }
+                        
+                        /*==============================================================*/
+                        /* CPP Assembler debug Info : line number(stab info) modify     */
+                        /*==============================================================*/
+                        /* <format>                                                     */
+                        /*      # 999 "filename1"                                       */
+                        /*      # 999 "filename2" 999                                   */
+                        /*         .                                                    */
+                        /*         .                                                    */
+                        /*         .                                                    */
+                        /*      # 999 "filename1" 999                                   */
+                        /*         .                                                    */
+                        /*--------------------------------------------------------------*/
+                        if( *input_line_pointer == '#' ){               /* After CPP Mode ? */
+
+                                /*==============================================================*/
+                                /*  #                                                           */
+                                /*==============================================================*/
+
+                                ++input_line_pointer;
+
+                                as_where (&file, &lineno);
+                                
+                                if( debug_type == DEBUG_STABS ){
+                                        /*==============================================================*/
+                                        /* GSTABS                                                       */
+                                        /*==============================================================*/
+                                        
+                                        if( lineno == 0 ){
+                                                if( iFirst_stabs == 1 ){
+                                                        ++input_line_pointer;
+                                                }
+                                                /* Get True file name */
+                                                if( !(*input_line_pointer >= '0' && *input_line_pointer <= '9') ){
+                                                      as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                      bump_line_counters ();
+
+                                                }else{
+                                                        while( !(*input_line_pointer >= '0' && *input_line_pointer <= '9') ){   /* Skip until value  */
+                                                                ++input_line_pointer;
+                                                        }
+                                                        ++input_line_pointer;
+                                                        if( *input_line_pointer != ' ' ){
+                                                                as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                                bump_line_counters ();
+                                                        }else{
+                                                                ++input_line_pointer;
+                                                                if( *input_line_pointer != '\"' ){
+                                                                        as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                                        bump_line_counters ();
+                                                                }else{
+                                                                        ++input_line_pointer;
+                                                                        if( iFirst_stabs == 1 ){ /* ON ?*/
+                                                                                for( i = 0; *input_line_pointer != '\"'; ++i ){ /* Skip until \"  */
+                                                                                        ++input_line_pointer;
+                                                                                }
+                                                                                bump_line_counters ();   /* ++lineno */
+                                                                        }else{
+                                                                                /* Get Original Assembler File Name */
+                                                                                for( i = 0; *input_line_pointer != '\"'; ++i ){ /* Skip until \"  */
+                                                                                        szC33_stabs_input_file[i] = szC33_original_input_file[i] 
+                                                                                                                  = *input_line_pointer;
+                                                                                        ++input_line_pointer;
+                                                                                }
+
+                                                                                hold2 = input_line_pointer;
+                                                                                input_line_pointer = hold;
+                                                                                generate_file_debug ();
+                                                                                input_line_pointer = hold2;
+                                                                                
+                                                                                iFirst_stabs = 1; /* ON */
+                                                                        }
+                                                                }
+                                                        }
+                                                }
+                                        }
+                                }
+                                else
+                                {
+                                        /*==============================================================*/
+                                        /* NO GSTABS                                                    */
+                                        /*==============================================================*/
+                                        
+                                        if( lineno == 0 ){
+                                                if( iFirst_original == 1 ){
+                                                        ++input_line_pointer;
+                                                }
+                                                /* Get True file name */
+                                                if( !(*input_line_pointer >= '0' && *input_line_pointer <= '9') ){
+                                                      as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                      bump_line_counters ();
+                                                }else{
+                                                        while( !(*input_line_pointer >= '0' && *input_line_pointer <= '9') ){   /* Skip until value  */
+                                                                ++input_line_pointer;
+                                                        }
+                                                        ++input_line_pointer;
+                                                        if( *input_line_pointer != ' ' ){
+                                                                as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                                bump_line_counters ();
+                                                        }else{
+                                                                ++input_line_pointer;
+                                                                if( *input_line_pointer != '\"' ){
+                                                                        as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                                        bump_line_counters ();
+                                                                }else{
+                                                                        ++input_line_pointer;
+                                                                        if( iFirst_original == 1 ){ /* ON ?*/
+                                                                                for( i = 0; *input_line_pointer != '\"'; ++i ){ /* Skip until \"  */
+                                                                                        ++input_line_pointer;
+                                                                                }
+                                                                                bump_line_counters ();   /* ++lineno */
+                                                                        }else{
+                                                                                /* Get Original Assembler File Name */
+                                                                                for( i = 0; *input_line_pointer != '\"'; ++i ){ /* Skip until \"  */
+                                                                                        szC33_original_input_file[i] = *input_line_pointer;
+                                                                                        ++input_line_pointer;
+                                                                                }
+                                                                                iFirst_original = 1; /* ON */
+                                                                        }
+                                                                }
+                                                        }
+                                                }
+                                        }
+                                        else
+                                        {
+                                                ++input_line_pointer;
+
+                                                /* smaple #include "file.h" <----- NG!! */
+                                                if( !(*input_line_pointer >= '0' && *input_line_pointer <= '9') ){
+                                                      as_bad_where (file, lineno+1, "Invalid preprocess", NULL);
+                                                      bump_line_counters ();
+                                                }
+                                                ++input_line_pointer;
+                                        }
+                                }
+
+                                while( *input_line_pointer != '\n' ){   /* Skip until CRLF  */
+                                        ++input_line_pointer;
+                                }
+                                ++input_line_pointer;
+
+                                /* Assembler Source Name Get ? */
+                                
+                                if( iFirst_stabs == 1 || iFirst_original == 1 ){
+                                        
+                                        /* form # 1 "XXXXX" to # 1 "YYYYY" + 1 : not increment line number */
+                                        as_where (&file, &lineno);
+                                        if( lineno > 0 ){
+                                                if( iPrepro == 0 ){             /* line count ON/OFF switch */
+                                                        iPrepro = 1; /* ON */
+                                                }else{
+                                                        iPrepro = 0; /* OFF */
+                                                        /* Skip 1 line  */
+                                                        while( *input_line_pointer != '\n' ){
+                                                                ++input_line_pointer;
+                                                        }
+                                                        ++input_line_pointer;
+                                                /* add T.Tazaki bug fix 2003/05/21 >>> */
+                                                        if( iLinePlusFirst == 1 )
+                                                        {
+                                                                bump_line_counters ();
+                                                        }
+                                                        else
+                                                        {
+                                                                iLinePlusFirst = 1;
+                                                        }
+                                                /* add T.Tazaki bug fix 2003/05/21 >>> */
+                                                }
+                                        }
+                                }
+
+                                continue;
+                        }
+                        else{
+                                /*==============================================================*/
+                                /* NOT #                                                        */
+                                /*==============================================================*/
+                                as_where (&file, &lineno);
+                                if( lineno == 0 ){
+                                        hold2 = input_line_pointer;
+                                        input_line_pointer = hold;
+                                        generate_file_debug ();
+                                        input_line_pointer = hold2;
+                                }
+                                /*--------------------------------------------------------------*/
+                                /* line count up CASE : iPrepro == 0(OFF)                       */
+                                /* <format>                                                     */
+                                /*      ; comment or text <== ++lineno                          */
+                                /*      ; comment         <== ++lineno                          */
+                                /*      # 999 "filename2" 999                                   */
+                                /*          .SET SYM1,1                                         */
+                                /*      # 999 "filename1"                                       */
+                                /*      ; comment       <== ++lineno                            */
+                                /*      ; comment       <== ++lineno                            */
+                                /*      ; comment       <== ++lineno                            */
+                                /*--------------------------------------------------------------*/
+                                if( iPrepro == 0  ){ /* OFF ? : line count increment ? */
+                                        iLinePlusFirst = 1;     /* add T.Tazaki bug fix 2003/05/22 */
+                                        bump_line_counters ();
+                                }
+                        }
+              }
+              
+              /* add T.Tazaki 2002.02.26 <<< */
+
+              line_label = NULL;
+
+              if (LABELS_WITHOUT_COLONS || flag_m68k_mri)
+                {
+                  /* Text at the start of a line must be a label, we
+                     run down and stick a colon in.  */
+                  if (is_name_beginner (*input_line_pointer))
+                    {
+                      char *line_start = input_line_pointer;
+                      char c;
+                      int mri_line_macro;
+
+                      LISTING_NEWLINE ();
+                      HANDLE_CONDITIONAL_ASSEMBLY ();
+
+                      c = get_symbol_end ();
+
+                      /* In MRI mode, the EQU and MACRO pseudoops must
+                         be handled specially.  */
+                      mri_line_macro = 0;
+                      if (flag_m68k_mri)
+                        {
+                          char *rest = input_line_pointer + 1;
+
+                          if (*rest == ':')
+                            ++rest;
+                          if (*rest == ' ' || *rest == '\t')
+                            ++rest;
+                          if ((strncasecmp (rest, "EQU", 3) == 0
+                               || strncasecmp (rest, "SET", 3) == 0)
+                              && (rest[3] == ' ' || rest[3] == '\t'))
+                            {
+                              input_line_pointer = rest + 3;
+                              equals (line_start,
+                                      strncasecmp (rest, "SET", 3) == 0);
+                              continue;
+                            }
+                          if (strncasecmp (rest, "MACRO", 5) == 0
+                              && (rest[5] == ' '
+                                  || rest[5] == '\t'
+                                  || is_end_of_line[(unsigned char) rest[5]]))
+                            mri_line_macro = 1;
+                        }
+
+                      /* In MRI mode, we need to handle the MACRO
                          pseudo-op specially: we don't want to put the
                          symbol in the symbol table.  */
-		      if (! mri_line_macro 
+                      if (! mri_line_macro 
 #ifdef TC_START_LABEL_WITHOUT_COLON
                           && TC_START_LABEL_WITHOUT_COLON(c, 
                                                           input_line_pointer)
 #endif
                           )
-			line_label = colon (line_start);
-		      else
-			line_label = symbol_create (line_start,
-						    absolute_section,
-						    (valueT) 0,
-						    &zero_address_frag);
-
-		      *input_line_pointer = c;
-		      if (c == ':')
-			input_line_pointer++;
-		    }
-		}
-	    }
-
-	  /*
-	   * We are at the begining of a line, or similar place.
-	   * We expect a well-formed assembler statement.
-	   * A "symbol-name:" is a statement.
-	   *
-	   * Depending on what compiler is used, the order of these tests
-	   * may vary to catch most common case 1st.
-	   * Each test is independent of all other tests at the (top) level.
-	   * PLEASE make a compiler that doesn't use this assembler.
-	   * It is crufty to waste a compiler's time encoding things for this
-	   * assembler, which then wastes more time decoding it.
-	   * (And communicating via (linear) files is silly!
-	   * If you must pass stuff, please pass a tree!)
-	   */
-	  if ((c = *input_line_pointer++) == '\t'
-	      || c == ' '
-	      || c == '\f'
-	      || c == 0)
-	    {
-	      c = *input_line_pointer++;
-	    }
-	  know (c != ' ');	/* No further leading whitespace. */
+                        line_label = colon (line_start);
+                      else
+                        line_label = symbol_create (line_start,
+                                                    absolute_section,
+                                                    (valueT) 0,
+                                                    &zero_address_frag);
+
+                      *input_line_pointer = c;
+                      if (c == ':')
+                        input_line_pointer++;
+                    }
+                }
+            }
+
+          /*
+           * We are at the begining of a line, or similar place.
+           * We expect a well-formed assembler statement.
+           * A "symbol-name:" is a statement.
+           *
+           * Depending on what compiler is used, the order of these tests
+           * may vary to catch most common case 1st.
+           * Each test is independent of all other tests at the (top) level.
+           * PLEASE make a compiler that doesn't use this assembler.
+           * It is crufty to waste a compiler's time encoding things for this
+           * assembler, which then wastes more time decoding it.
+           * (And communicating via (linear) files is silly!
+           * If you must pass stuff, please pass a tree!)
+           */
+          if ((c = *input_line_pointer++) == '\t'
+              || c == ' '
+              || c == '\f'
+              || c == 0)
+            {
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+			  reset_current_symbol(input_line_pointer);
+#endif
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+              c = *input_line_pointer++;
+            }
+          know (c != ' ');      /* No further leading whitespace. */
 
 #ifndef NO_LISTING
-	  /* If listing is on, and we are expanding a macro, then give
-	     the listing code the contents of the expanded line.  */
-	  if (listing)
-	    {
-	      if ((listing & LISTING_MACEXP) && macro_nest > 0)
-		{
-		  char *copy;
-		  int len;
-
-		  /* Find the end of the current expanded macro line.  */
-		  for (s = input_line_pointer-1; *s ; ++s)
-		    if (is_end_of_line[(unsigned char) *s])
-		      break;
-
-		  /* Copy it for safe keeping.  Also give an indication of
-		     how much macro nesting is involved at this point.  */
-		  len = s - (input_line_pointer-1);
-		  copy = (char *) xmalloc (len + macro_nest + 2);
-		  memset (copy, '>', macro_nest);
-		  copy[macro_nest] = ' ';
-		  memcpy (copy + macro_nest + 1, input_line_pointer-1, len);
-		  copy[macro_nest+1+len] = '\0';
-
-		  /* Install the line with the listing facility.  */
-		  listing_newline (copy);
-		}
-	      else
-		listing_newline (NULL);
-	    }
+          /* If listing is on, and we are expanding a macro, then give
+             the listing code the contents of the expanded line.  */
+          if (listing)
+            {
+              if ((listing & LISTING_MACEXP) && macro_nest > 0)
+                {
+                  char *copy;
+                  int len;
+
+                  /* Find the end of the current expanded macro line.  */
+                  for (s = input_line_pointer-1; *s ; ++s)
+                    if (is_end_of_line[(unsigned char) *s])
+                      break;
+
+                  /* Copy it for safe keeping.  Also give an indication of
+                     how much macro nesting is involved at this point.  */
+                  len = s - (input_line_pointer-1);
+                  copy = (char *) xmalloc (len + macro_nest + 2);
+                  memset (copy, '>', macro_nest);
+                  copy[macro_nest] = ' ';
+                  memcpy (copy + macro_nest + 1, input_line_pointer-1, len);
+                  copy[macro_nest+1+len] = '\0';
+
+                  /* Install the line with the listing facility.  */
+                  listing_newline (copy);
+                }
+              else
+                listing_newline (NULL);
+            }
+#endif
+
+          /*
+           * C is the 1st significant character.
+           * Input_line_pointer points after that character.
+           */
+          if (is_name_beginner (c))
+            {
+              /* want user-defined label or pseudo/opcode */
+              HANDLE_CONDITIONAL_ASSEMBLY ();
+
+              s = --input_line_pointer;
+              c = get_symbol_end ();    /* name's delimiter */
+              /*
+               * C is character after symbol.
+               * That character's place in the input line is now '\0'.
+               * S points to the beginning of the symbol.
+               *   [In case of pseudo-op, s->'.'.]
+               * Input_line_pointer->'\0' where c was.
+               */
+              if (TC_START_LABEL(c, input_line_pointer))
+                {
+                  if (flag_m68k_mri)
+                    {
+                      char *rest = input_line_pointer + 1;
+
+                      /* In MRI mode, \tsym: set 0 is permitted.  */
+
+                      if (*rest == ':')
+                        ++rest;
+                      if (*rest == ' ' || *rest == '\t')
+                        ++rest;
+                      if ((strncasecmp (rest, "EQU", 3) == 0
+                           || strncasecmp (rest, "SET", 3) == 0)
+                          && (rest[3] == ' ' || rest[3] == '\t'))
+                        {
+                          input_line_pointer = rest + 3;
+                          equals (s, 1);
+                          continue;
+                        }
+                    }
+
+                  line_label = colon (s);       /* user-defined label */
+
+// ADD D.Fujimoto 2007/06/25 >>>>>>>
+#ifdef EXT_REMOVE
+				  update_current_symbol(s);
 #endif
+// ADD D.Fujimoto 2007/06/25 <<<<<<<
+
+                  *input_line_pointer++ = ':';  /* Put ':' back for error messages' sake. */
+                  /* Input_line_pointer->after ':'. */
+                  SKIP_WHITESPACE ();
 
-	  /*
-	   * C is the 1st significant character.
-	   * Input_line_pointer points after that character.
-	   */
-	  if (is_name_beginner (c))
-	    {
-	      /* want user-defined label or pseudo/opcode */
-	      HANDLE_CONDITIONAL_ASSEMBLY ();
-
-	      s = --input_line_pointer;
-	      c = get_symbol_end ();	/* name's delimiter */
-	      /*
-	       * C is character after symbol.
-	       * That character's place in the input line is now '\0'.
-	       * S points to the beginning of the symbol.
-	       *   [In case of pseudo-op, s->'.'.]
-	       * Input_line_pointer->'\0' where c was.
-	       */
-	      if (TC_START_LABEL(c, input_line_pointer))
-		{
-		  if (flag_m68k_mri)
-		    {
-		      char *rest = input_line_pointer + 1;
-
-		      /* In MRI mode, \tsym: set 0 is permitted.  */
-
-		      if (*rest == ':')
-			++rest;
-		      if (*rest == ' ' || *rest == '\t')
-			++rest;
-		      if ((strncasecmp (rest, "EQU", 3) == 0
-			   || strncasecmp (rest, "SET", 3) == 0)
-			  && (rest[3] == ' ' || rest[3] == '\t'))
-			{
-			  input_line_pointer = rest + 3;
-			  equals (s, 1);
-			  continue;
-			}
-		    }
-
-		  line_label = colon (s);	/* user-defined label */
-		  *input_line_pointer++ = ':';	/* Put ':' back for error messages' sake. */
-		  /* Input_line_pointer->after ':'. */
-		  SKIP_WHITESPACE ();
-
-
-		}
-	      else if (c == '='
-		       || ((c == ' ' || c == '\t')
-			   && input_line_pointer[1] == '='
+
+                }
+              else if (c == '='
+                       || ((c == ' ' || c == '\t')
+                           && input_line_pointer[1] == '='
 #ifdef TC_EQUAL_IN_INSN
-			   && ! TC_EQUAL_IN_INSN (c, input_line_pointer)
+                           && ! TC_EQUAL_IN_INSN (c, input_line_pointer)
 #endif
-			   ))
-		{
-		  equals (s, 1);
-		  demand_empty_rest_of_line ();
-		}
-	      else
-		{		/* expect pseudo-op or machine instruction */
-		  pop = NULL;
+                           ))
+                {
+                  equals (s, 1);
+                  demand_empty_rest_of_line ();
+                }
+              else
+                {               /* expect pseudo-op or machine instruction */
+                  pop = NULL;
 
 #define IGNORE_OPCODE_CASE
 #ifdef IGNORE_OPCODE_CASE
-		  {
-		    char *s2 = s;
-		    while (*s2)
-		      {
-			if (isupper ((unsigned char) *s2))
-			  *s2 = tolower (*s2);
-			s2++;
-		      }
-		  }
+                  {
+                    char *s2 = s;
+                    while (*s2)
+                      {
+                        if (isupper ((unsigned char) *s2))
+                          *s2 = tolower (*s2);
+                        s2++;
+                      }
+                  }
 #endif
 
-		  if (NO_PSEUDO_DOT || flag_m68k_mri)
-		    {
-		      /* The MRI assembler and the m88k use pseudo-ops
+                  if (NO_PSEUDO_DOT || flag_m68k_mri)
+                    {
+                      /* The MRI assembler and the m88k use pseudo-ops
                          without a period.  */
-		      pop = (pseudo_typeS *) hash_find (po_hash, s);
-		      if (pop != NULL && pop->poc_handler == NULL)
-			pop = NULL;
-		    }
-
-		  if (pop != NULL
-		      || (! flag_m68k_mri && *s == '.'))
-		    {
-		      /*
-		       * PSEUDO - OP.
-		       *
-		       * WARNING: c has next char, which may be end-of-line.
-		       * We lookup the pseudo-op table with s+1 because we
-		       * already know that the pseudo-op begins with a '.'.
-		       */
-
-		      if (pop == NULL)
-			pop = (pseudo_typeS *) hash_find (po_hash, s + 1);
-
-		      /* In MRI mode, we may need to insert an
+                      pop = (pseudo_typeS *) hash_find (po_hash, s);
+                      if (pop != NULL && pop->poc_handler == NULL)
+                        pop = NULL;
+                    }
+
+                  if (pop != NULL
+                      || (! flag_m68k_mri && *s == '.'))
+                    {
+                      /*
+                       * PSEUDO - OP.
+                       *
+                       * WARNING: c has next char, which may be end-of-line.
+                       * We lookup the pseudo-op table with s+1 because we
+                       * already know that the pseudo-op begins with a '.'.
+                       */
+
+                      if (pop == NULL)
+                        pop = (pseudo_typeS *) hash_find (po_hash, s + 1);
+
+                      /* In MRI mode, we may need to insert an
                          automatic alignment directive.  What a hack
                          this is.  */
-		      if (mri_pending_align
-			  && (pop == NULL
-			      || ! ((pop->poc_handler == cons
-				     && pop->poc_val == 1)
-				    || (pop->poc_handler == s_space
-					&& pop->poc_val == 1)
+                      if (mri_pending_align
+                          && (pop == NULL
+                              || ! ((pop->poc_handler == cons
+                                     && pop->poc_val == 1)
+                                    || (pop->poc_handler == s_space
+                                        && pop->poc_val == 1)
 #ifdef tc_conditional_pseudoop
-				    || tc_conditional_pseudoop (pop)
+                                    || tc_conditional_pseudoop (pop)
 #endif
-				    || pop->poc_handler == s_if
-				    || pop->poc_handler == s_ifdef
-				    || pop->poc_handler == s_ifc
-				    || pop->poc_handler == s_ifeqs
-				    || pop->poc_handler == s_else
-				    || pop->poc_handler == s_endif
-				    || pop->poc_handler == s_globl
-				    || pop->poc_handler == s_ignore)))
-			{
-			  do_align (1, (char *) NULL, 0, 0);
-			  mri_pending_align = 0;
-			  if (line_label != NULL)
-			    {
-			      symbol_set_frag (line_label, frag_now);
-			      S_SET_VALUE (line_label, frag_now_fix ());
-			    }
-			}
-
-		      /* Print the error msg now, while we still can */
-		      if (pop == NULL)
-			{
-			  as_bad (_("Unknown pseudo-op:  `%s'"), s);
-			  *input_line_pointer = c;
-			  s_ignore (0);
-			  continue;
-			}
-
-		      /* Put it back for error messages etc. */
-		      *input_line_pointer = c;
-		      /* The following skip of whitespace is compulsory.
-			 A well shaped space is sometimes all that separates
-			 keyword from operands. */
-		      if (c == ' ' || c == '\t')
-			input_line_pointer++;
-		      /*
-		       * Input_line is restored.
-		       * Input_line_pointer->1st non-blank char
-		       * after pseudo-operation.
-		       */
-		      (*pop->poc_handler) (pop->poc_val);
-
-		      /* If that was .end, just get out now.  */
-		      if (pop->poc_handler == s_end)
-			goto quit;
-		    }
-		  else
-		    {
-		      int inquote = 0;
+                                    || pop->poc_handler == s_if
+                                    || pop->poc_handler == s_ifdef
+                                    || pop->poc_handler == s_ifc
+                                    || pop->poc_handler == s_ifeqs
+                                    || pop->poc_handler == s_else
+                                    || pop->poc_handler == s_endif
+                                    || pop->poc_handler == s_globl
+                                    || pop->poc_handler == s_ignore)))
+                        {
+                          do_align (1, (char *) NULL, 0, 0);
+                          mri_pending_align = 0;
+                          if (line_label != NULL)
+                            {
+                              symbol_set_frag (line_label, frag_now);
+                              S_SET_VALUE (line_label, frag_now_fix ());
+                            }
+                        }
+
+                      /* Print the error msg now, while we still can */
+                      if (pop == NULL)
+                        {
+                          as_bad (_("Unknown pseudo-op:  `%s'"), s);
+                          *input_line_pointer = c;
+                          s_ignore (0);
+                          continue;
+                        }
+
+                      /* Put it back for error messages etc. */
+                      *input_line_pointer = c;
+                      /* The following skip of whitespace is compulsory.
+                         A well shaped space is sometimes all that separates
+                         keyword from operands. */
+                      if (c == ' ' || c == '\t')
+                        input_line_pointer++;
+                      /*
+                       * Input_line is restored.
+                       * Input_line_pointer->1st non-blank char
+                       * after pseudo-operation.
+                       */
+                      (*pop->poc_handler) (pop->poc_val);
+
+                      /* If that was .end, just get out now.  */
+                      if (pop->poc_handler == s_end)
+                        goto quit;
+                    }
+                  else
+                    {
+                      int inquote = 0;
 #ifdef QUOTES_IN_INSN
-		      int inescape = 0;
+                      int inescape = 0;
 #endif
 
-		      /* WARNING: c has char, which may be end-of-line. */
-		      /* Also: input_line_pointer->`\0` where c was. */
-		      *input_line_pointer = c;
-		      while (!is_end_of_line[(unsigned char) *input_line_pointer]
-			     || inquote
+                      /* WARNING: c has char, which may be end-of-line. */
+                      /* Also: input_line_pointer->`\0` where c was. */
+                      *input_line_pointer = c;
+                      while (!is_end_of_line[(unsigned char) *input_line_pointer]
+                             || inquote
 #ifdef TC_EOL_IN_INSN
-			     || TC_EOL_IN_INSN (input_line_pointer)
+                             || TC_EOL_IN_INSN (input_line_pointer)
 #endif
-			     )
-			{
-			  if (flag_m68k_mri && *input_line_pointer == '\'')
-			    inquote = ! inquote;
+                             )
+                        {
+                          if (flag_m68k_mri && *input_line_pointer == '\'')
+                            inquote = ! inquote;
 #ifdef QUOTES_IN_INSN
-			  if (inescape)
-			    inescape = 0;
-			  else if (*input_line_pointer == '"')
-			    inquote = ! inquote;
-			  else if (*input_line_pointer == '\\')
-			    inescape = 1;
+                          if (inescape)
+                            inescape = 0;
+                          else if (*input_line_pointer == '"')
+                            inquote = ! inquote;
+                          else if (*input_line_pointer == '\\')
+                            inescape = 1;
 #endif
-			  input_line_pointer++;
-			}
+                          input_line_pointer++;
+                        }
 
-		      c = *input_line_pointer;
-		      *input_line_pointer = '\0';
+                      c = *input_line_pointer;
+                      *input_line_pointer = '\0';
 
-		      generate_lineno_debug ();
+                      generate_lineno_debug ();
 
-		      if (macro_defined)
-			{
-			  sb out;
-			  const char *err;
+                      if (macro_defined)
+                        {
+                          sb out;
+                          const char *err;
                           macro_entry *macro;
 
-			  if (check_macro (s, &out, '\0', &err, &macro))
-			    {
-			      if (err != NULL)
-				as_bad ("%s", err);
-			      *input_line_pointer++ = c;
-			      input_scrub_include_sb (&out,
-						      input_line_pointer, 1);
-			      sb_kill (&out);
-			      buffer_limit =
-				input_scrub_next_buffer (&input_line_pointer);
+                          if (check_macro (s, &out, '\0', &err, &macro))
+                            {
+                              if (err != NULL)
+                                as_bad ("%s", err);
+                              *input_line_pointer++ = c;
+                              input_scrub_include_sb (&out,
+                                                      input_line_pointer, 1);
+                              sb_kill (&out);
+                              buffer_limit =
+                                input_scrub_next_buffer (&input_line_pointer);
 #ifdef md_macro_info
                               md_macro_info (macro);
 #endif
-			      continue;
-			    }
-			}
-
-		      if (mri_pending_align)
-			{
-			  do_align (1, (char *) NULL, 0, 0);
-			  mri_pending_align = 0;
-			  if (line_label != NULL)
-			    {
-			      symbol_set_frag (line_label, frag_now);
-			      S_SET_VALUE (line_label, frag_now_fix ());
-			    }
-			}
-
-		      md_assemble (s);	/* Assemble 1 instruction. */
-
-		      *input_line_pointer++ = c;
-
-		      /* We resume loop AFTER the end-of-line from
-			 this instruction. */
-		    }		/* if (*s=='.') */
-		}		/* if c==':' */
-	      continue;
-	    }			/* if (is_name_beginner(c) */
-
-
-	  /* Empty statement?  */
-	  if (is_end_of_line[(unsigned char) c])
-	    continue;
-
-	  if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB)
-	      && isdigit ((unsigned char) c))
-	    {
-	      /* local label  ("4:") */
-	      char *backup = input_line_pointer;
-
-	      HANDLE_CONDITIONAL_ASSEMBLY ();
-
-	      temp = c - '0';
-
-	      while (isdigit ((unsigned char) *input_line_pointer))
-		{
-		  temp = (temp * 10) + *input_line_pointer - '0';
-		  ++input_line_pointer;
-		}		/* read the whole number */
-
-	      if (LOCAL_LABELS_DOLLAR
-		  && *input_line_pointer == '$'
-		  && *(input_line_pointer + 1) == ':')
-		{
-		  input_line_pointer += 2;
-
-		  if (dollar_label_defined (temp))
-		    {
-		      as_fatal (_("label \"%d$\" redefined"), temp);
-		    }
-
-		  define_dollar_label (temp);
-		  colon (dollar_label_name (temp, 0));
-		  continue;
-		}
-
-	      if (LOCAL_LABELS_FB
-		  && *input_line_pointer++ == ':')
-		{
-		  fb_label_instance_inc (temp);
-		  colon (fb_label_name (temp, 0));
-		  continue;
-		}
-
-	      input_line_pointer = backup;
-	    }			/* local label  ("4:") */
-
-	  if (c && strchr (line_comment_chars, c))
-	    {			/* Its a comment.  Better say APP or NO_APP */
-	      char *ends;
-	      char *new_buf;
-	      char *new_tmp;
-	      unsigned int new_length;
-	      char *tmp_buf = 0;
-
-	      bump_line_counters ();
-	      s = input_line_pointer;
-	      if (strncmp (s, "APP\n", 4))
-		continue;	/* We ignore it */
-	      s += 4;
-
-	      ends = strstr (s, "#NO_APP\n");
-
-	      if (!ends)
-		{
-		  unsigned int tmp_len;
-		  unsigned int num;
-
-		  /* The end of the #APP wasn't in this buffer.  We
-		     keep reading in buffers until we find the #NO_APP
-		     that goes with this #APP  There is one.  The specs
-		     guarentee it. . . */
-		  tmp_len = buffer_limit - s;
-		  tmp_buf = xmalloc (tmp_len + 1);
-		  memcpy (tmp_buf, s, tmp_len);
-		  do
-		    {
-		      new_tmp = input_scrub_next_buffer (&buffer);
-		      if (!new_tmp)
-			break;
-		      else
-			buffer_limit = new_tmp;
-		      input_line_pointer = buffer;
-		      ends = strstr (buffer, "#NO_APP\n");
-		      if (ends)
-			num = ends - buffer;
-		      else
-			num = buffer_limit - buffer;
-
-		      tmp_buf = xrealloc (tmp_buf, tmp_len + num);
-		      memcpy (tmp_buf + tmp_len, buffer, num);
-		      tmp_len += num;
-		    }
-		  while (!ends);
-
-		  input_line_pointer = ends ? ends + 8 : NULL;
-
-		  s = tmp_buf;
-		  ends = s + tmp_len;
-
-		}
-	      else
-		{
-		  input_line_pointer = ends + 8;
-		}
-
-	      scrub_string = s;
-	      scrub_string_end = ends;
-
-	      new_length = ends - s;
-	      new_buf = (char *) xmalloc (new_length);
-	      new_tmp = new_buf;
-	      for (;;)
-		{
-		  int space;
-		  int size;
-
-		  space = (new_buf + new_length) - new_tmp;
-		  size = do_scrub_chars (scrub_from_string, new_tmp, space);
-
-		  if (size < space)
-		    {
-		      new_tmp += size;
-		      break;
-		    }
-
-		  new_buf = xrealloc (new_buf, new_length + 100);
-		  new_tmp = new_buf + new_length;
-		  new_length += 100;
-		}
-
-	      if (tmp_buf)
-		free (tmp_buf);
-	      old_buffer = buffer;
-	      old_input = input_line_pointer;
-	      old_limit = buffer_limit;
-	      buffer = new_buf;
-	      input_line_pointer = new_buf;
-	      buffer_limit = new_tmp;
-	      continue;
-	    }
-
-	  HANDLE_CONDITIONAL_ASSEMBLY ();
+                              continue;
+                            }
+                        }
+
+                      if (mri_pending_align)
+                        {
+                          do_align (1, (char *) NULL, 0, 0);
+                          mri_pending_align = 0;
+                          if (line_label != NULL)
+                            {
+                              symbol_set_frag (line_label, frag_now);
+                              S_SET_VALUE (line_label, frag_now_fix ());
+                            }
+                        }
+
+                      md_assemble (s);  /* Assemble 1 instruction. */
+
+/* add T.Tazaki 2002.03.18 >>> */
+                      if( *input_line_pointer == '\n' && c == '\n' ){
+                          bump_line_counters ();         /* ++lineno */
+                      }
+/* add T.Tazaki 2002.03.18 <<< */
+                      *input_line_pointer++ = c;
+
+                      /* We resume loop AFTER the end-of-line from
+                         this instruction. */
+                    }           /* if (*s=='.') */
+                }               /* if c==':' */
+              continue;
+            }                   /* if (is_name_beginner(c) */
+
+
+          /* Empty statement?  */
+          if (is_end_of_line[(unsigned char) c])
+            continue;
+
+          if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB)
+              && isdigit ((unsigned char) c))
+            {
+              /* local label  ("4:") */
+              char *backup = input_line_pointer;
+
+              HANDLE_CONDITIONAL_ASSEMBLY ();
+
+              temp = c - '0';
+
+              while (isdigit ((unsigned char) *input_line_pointer))
+                {
+                  temp = (temp * 10) + *input_line_pointer - '0';
+                  ++input_line_pointer;
+                }               /* read the whole number */
+
+              if (LOCAL_LABELS_DOLLAR
+                  && *input_line_pointer == '$'
+                  && *(input_line_pointer + 1) == ':')
+                {
+                  input_line_pointer += 2;
+
+                  if (dollar_label_defined (temp))
+                    {
+                      as_fatal (_("label \"%d$\" redefined"), temp);
+                    }
+
+                  define_dollar_label (temp);
+                  colon (dollar_label_name (temp, 0));
+                  continue;
+                }
+
+              if (LOCAL_LABELS_FB
+                  && *input_line_pointer++ == ':')
+                {
+                  fb_label_instance_inc (temp);
+                  colon (fb_label_name (temp, 0));
+                  continue;
+                }
+
+              input_line_pointer = backup;
+            }                   /* local label  ("4:") */
+
+          if (c && strchr (line_comment_chars, c))
+            {                   /* Its a comment.  Better say APP or NO_APP */
+              char *ends;
+              char *new_buf;
+              char *new_tmp;
+              unsigned int new_length;
+              char *tmp_buf = 0;
+
+              bump_line_counters ();
+              s = input_line_pointer;
+              if (strncmp (s, "APP\n", 4))
+                continue;       /* We ignore it */
+              s += 4;
+
+              ends = strstr (s, "#NO_APP\n");
+
+              if (!ends)
+                {
+                  unsigned int tmp_len;
+                  unsigned int num;
+
+                  /* The end of the #APP wasn't in this buffer.  We
+                     keep reading in buffers until we find the #NO_APP
+                     that goes with this #APP  There is one.  The specs
+                     guarentee it. . . */
+                  tmp_len = buffer_limit - s;
+                  tmp_buf = xmalloc (tmp_len + 1);
+                  memcpy (tmp_buf, s, tmp_len);
+                  do
+                    {
+                      new_tmp = input_scrub_next_buffer (&buffer);
+                      if (!new_tmp)
+                        break;
+                      else
+                        buffer_limit = new_tmp;
+                      input_line_pointer = buffer;
+                      ends = strstr (buffer, "#NO_APP\n");
+                      if (ends)
+                        num = ends - buffer;
+                      else
+                        num = buffer_limit - buffer;
+
+                      tmp_buf = xrealloc (tmp_buf, tmp_len + num);
+                      memcpy (tmp_buf + tmp_len, buffer, num);
+                      tmp_len += num;
+                    }
+                  while (!ends);
+
+                  input_line_pointer = ends ? ends + 8 : NULL;
+
+                  s = tmp_buf;
+                  ends = s + tmp_len;
+
+                }
+              else
+                {
+                  input_line_pointer = ends + 8;
+                }
+
+              scrub_string = s;
+              scrub_string_end = ends;
+
+              new_length = ends - s;
+              new_buf = (char *) xmalloc (new_length);
+              new_tmp = new_buf;
+              for (;;)
+                {
+                  int space;
+                  int size;
+
+                  space = (new_buf + new_length) - new_tmp;
+                  size = do_scrub_chars (scrub_from_string, new_tmp, space);
+
+                  if (size < space)
+                    {
+                      new_tmp += size;
+                      break;
+                    }
+
+                  new_buf = xrealloc (new_buf, new_length + 100);
+                  new_tmp = new_buf + new_length;
+                  new_length += 100;
+                }
+
+              if (tmp_buf)
+                free (tmp_buf);
+              old_buffer = buffer;
+              old_input = input_line_pointer;
+              old_limit = buffer_limit;
+              buffer = new_buf;
+              input_line_pointer = new_buf;
+              buffer_limit = new_tmp;
+              continue;
+            }
+
+          HANDLE_CONDITIONAL_ASSEMBLY ();
 
 #ifdef tc_unrecognized_line
-	  if (tc_unrecognized_line (c))
-	    continue;
+          if (tc_unrecognized_line (c))
+            continue;
 #endif
 
-	  /* as_warn("Junk character %d.",c);  Now done by ignore_rest */
-	  input_line_pointer--;	/* Report unknown char as ignored. */
-	  ignore_rest_of_line ();
-	}			/* while (input_line_pointer<buffer_limit) */
+          /* as_warn("Junk character %d.",c);  Now done by ignore_rest */
+          input_line_pointer--; /* Report unknown char as ignored. */
+          ignore_rest_of_line ();
+        }                       /* while (input_line_pointer<buffer_limit) */
 
 #ifdef md_after_pass_hook
       md_after_pass_hook ();
 #endif
 
       if (old_buffer)
-	{
-	  free (buffer);
-	  bump_line_counters ();
-	  if (old_input != 0)
-	    {
-	      buffer = old_buffer;
-	      input_line_pointer = old_input;
-	      buffer_limit = old_limit;
-	      old_buffer = 0;
-	      goto contin;
-	    }
-	}
-    }				/* while (more buffers to scan) */
+        {
+          free (buffer);
+          bump_line_counters ();
+          if (old_input != 0)
+            {
+              buffer = old_buffer;
+              input_line_pointer = old_input;
+              buffer_limit = old_limit;
+              old_buffer = 0;
+              goto contin;
+            }
+        }
+    }                           /* while (more buffers to scan) */
 
  quit:
 
 #ifdef md_cleanup
   md_cleanup();
 #endif
-  input_scrub_close ();		/* Close the input file */
+  input_scrub_close ();         /* Close the input file */
 }
 
 /* For most MRI pseudo-ops, the line actually ends at the first
@@ -1123,11 +1399,11 @@ mri_comment_field (stopcp)
 
   for (s = input_line_pointer;
        ((! is_end_of_line[(unsigned char) *s] && *s != ' ' && *s != '\t')
-	|| inquote);
+        || inquote);
        s++)
     {
       if (*s == '\'')
-	inquote = ! inquote;
+        inquote = ! inquote;
     }
   *stopcp = *s;
   *s = '\0';
@@ -1191,9 +1467,9 @@ do_align (n, fill, len, max)
   if (fill == NULL)
     {
       if (subseg_text_p (now_seg))
-	default_fill = NOP_OPCODE;
+        default_fill = NOP_OPCODE;
       else
-	default_fill = 0;
+        default_fill = 0;
       fill = &default_fill;
       len = 1;
     }
@@ -1202,9 +1478,9 @@ do_align (n, fill, len, max)
   if (n != 0 && !need_pass_2)
     {
       if (len <= 1)
-	frag_align (n, *fill, max);
+        frag_align (n, *fill, max);
       else
-	frag_align_pattern (n, fill, len, max);
+        frag_align_pattern (n, fill, len, max);
     }
 
 #ifdef md_do_align
@@ -1237,9 +1513,9 @@ s_align (arg, bytes_p)
   if (is_end_of_line[(unsigned char) *input_line_pointer])
     {
       if (arg < 0)
-	align = 0;
+        align = 0;
       else
-	align = arg;	/* Default value from pseudo-op table */
+        align = arg;    /* Default value from pseudo-op table */
     }
   else
     {
@@ -1251,15 +1527,15 @@ s_align (arg, bytes_p)
     {
       /* Convert to a power of 2.  */
       if (align != 0)
-	{
-	  unsigned int i;
+        {
+          unsigned int i;
 
-	  for (i = 0; (align & 1) == 0; align >>= 1, ++i)
-	    ;
-	  if (align != 1)
-	    as_bad (_("Alignment not a power of 2"));
-	  align = i;
-	}
+          for (i = 0; (align & 1) == 0; align >>= 1, ++i)
+            ;
+          if (align != 1)
+            as_bad (_("Alignment not a power of 2"));
+          align = i;
+        }
     }
 
   if (align > 15)
@@ -1277,27 +1553,27 @@ s_align (arg, bytes_p)
     {
       ++input_line_pointer;
       if (*input_line_pointer == ',')
-	fill_p = 0;
+        fill_p = 0;
       else
-	{
-	  fill = get_absolute_expression ();
-	  SKIP_WHITESPACE ();
-	  fill_p = 1;
-	}
+        {
+          fill = get_absolute_expression ();
+          SKIP_WHITESPACE ();
+          fill_p = 1;
+        }
 
       if (*input_line_pointer != ',')
-	max = 0;
+        max = 0;
       else
-	{
-	  ++input_line_pointer;
-	  max = get_absolute_expression ();
-	}
+        {
+          ++input_line_pointer;
+          max = get_absolute_expression ();
+        }
     }
 
   if (! fill_p)
     {
       if (arg < 0)
-	as_warn (_("expected fill pattern missing"));
+        as_warn (_("expected fill pattern missing"));
       do_align (align, (char *) NULL, 0, max);
     }
   else
@@ -1305,25 +1581,25 @@ s_align (arg, bytes_p)
       int fill_len;
 
       if (arg >= 0)
-	fill_len = 1;
+        fill_len = 1;
       else
-	fill_len = - arg;
+        fill_len = - arg;
       if (fill_len <= 1)
-	{
-	  char fill_char;
+        {
+          char fill_char;
 
-	  fill_char = fill;
-	  do_align (align, &fill_char, fill_len, max);
-	}
+          fill_char = fill;
+          do_align (align, &fill_char, fill_len, max);
+        }
       else
-	{
-	  char ab[16];
+        {
+          char ab[16];
 
-	  if ((size_t) fill_len > sizeof ab)
-	    abort ();
-	  md_number_to_chars (ab, fill, fill_len);
-	  do_align (align, ab, fill_len, max);
-	}
+          if ((size_t) fill_len > sizeof ab)
+            abort ();
+          md_number_to_chars (ab, fill, fill_len);
+          do_align (align, ab, fill_len, max);
+        }
     }
 
   demand_empty_rest_of_line ();
@@ -1378,16 +1654,16 @@ s_comm (ignore)
       as_bad (_("Expected comma after symbol-name: rest of line ignored."));
       ignore_rest_of_line ();
       if (flag_mri)
-	mri_comment_end (stop, stopc);
+        mri_comment_end (stop, stopc);
       return;
     }
-  input_line_pointer++;		/* skip ',' */
+  input_line_pointer++;         /* skip ',' */
   if ((temp = get_absolute_expression ()) < 0)
     {
       as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
       ignore_rest_of_line ();
       if (flag_mri)
-	mri_comment_end (stop, stopc);
+        mri_comment_end (stop, stopc);
       return;
     }
   *p = 0;
@@ -1396,19 +1672,19 @@ s_comm (ignore)
   if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
     {
       as_bad (_("Ignoring attempt to re-define symbol `%s'."),
-	      S_GET_NAME (symbolP));
+              S_GET_NAME (symbolP));
       ignore_rest_of_line ();
       if (flag_mri)
-	mri_comment_end (stop, stopc);
+        mri_comment_end (stop, stopc);
       return;
     }
   if (S_GET_VALUE (symbolP))
     {
       if (S_GET_VALUE (symbolP) != (valueT) temp)
-	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
-		S_GET_NAME (symbolP),
-		(long) S_GET_VALUE (symbolP),
-		(long) temp);
+        as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
+                S_GET_NAME (symbolP),
+                (long) S_GET_VALUE (symbolP),
+                (long) temp);
     }
   else
     {
@@ -1428,7 +1704,7 @@ s_comm (ignore)
 
   if (flag_mri)
     mri_comment_end (stop, stopc);
-}				/* s_comm() */
+}                               /* s_comm() */
 
 /* The MRI COMMON pseudo-op.  We handle this by creating a common
    symbol with the appropriate name.  We make s_space do the right
@@ -1462,21 +1738,21 @@ s_mri_common (small)
   else
     {
       do
-	{
-	  ++input_line_pointer;
-	}
+        {
+          ++input_line_pointer;
+        }
       while (isdigit ((unsigned char) *input_line_pointer));
       c = *input_line_pointer;
       *input_line_pointer = '\0';
 
       if (line_label != NULL)
-	{
-	  alc = (char *) xmalloc (strlen (S_GET_NAME (line_label))
-				  + (input_line_pointer - name)
-				  + 1);
-	  sprintf (alc, "%s%s", name, S_GET_NAME (line_label));
-	  name = alc;
-	}
+        {
+          alc = (char *) xmalloc (strlen (S_GET_NAME (line_label))
+                                  + (input_line_pointer - name)
+                                  + 1);
+          sprintf (alc, "%s%s", name, S_GET_NAME (line_label));
+          name = alc;
+        }
     }
 
   sym = symbol_find_or_make (name);
@@ -1575,30 +1851,30 @@ s_app_file (appfile)
   if ((s = demand_copy_string (&length)) != 0)
     {
       /* If this is a fake .appfile, a fake newline was inserted into
-	 the buffer.  Passing -2 to new_logical_line tells it to
-	 account for it.  */
+         the buffer.  Passing -2 to new_logical_line tells it to
+         account for it.  */
       int may_omit
-	= (! new_logical_line (s, appfile ? -2 : -1) && appfile);
+        = (! new_logical_line (s, appfile ? -2 : -1) && appfile);
 
       /* In MRI mode, the preprocessor may have inserted an extraneous
          backquote.  */
       if (flag_m68k_mri
-	  && *input_line_pointer == '\''
-	  && is_end_of_line[(unsigned char) input_line_pointer[1]])
-	++input_line_pointer;
+          && *input_line_pointer == '\''
+          && is_end_of_line[(unsigned char) input_line_pointer[1]])
+        ++input_line_pointer;
 
       demand_empty_rest_of_line ();
       if (! may_omit)
-	{
+        {
 #ifdef LISTING
-	  if (listing)
-	    listing_source_file (s);
+          if (listing)
+            listing_source_file (s);
 #endif
-	  register_dependency (s);
+          register_dependency (s);
 #ifdef obj_app_file
-	  obj_app_file (s);
+          obj_app_file (s);
 #endif
-	}
+        }
     }
 }
 
@@ -1624,7 +1900,7 @@ s_app_line (ignore)
       new_logical_line ((char *) NULL, l);
 #ifdef LISTING
       if (listing)
-	listing_source_line (l);
+        listing_source_line (l);
 #endif
     }
   demand_empty_rest_of_line ();
@@ -1643,9 +1919,9 @@ s_end (ignore)
          but we don't support that.  */
       SKIP_WHITESPACE ();
       if (! is_end_of_line[(unsigned char) *input_line_pointer]
-	  && *input_line_pointer != '*'
-	  && *input_line_pointer != '!')
-	as_warn (_("start address not supported"));
+          && *input_line_pointer != '*'
+          && *input_line_pointer != '!')
+        as_warn (_("start address not supported"));
     }
 }
 
@@ -1703,10 +1979,10 @@ s_fill (ignore)
       input_line_pointer++;
       size = get_absolute_expression ();
       if (*input_line_pointer == ',')
-	{
-	  input_line_pointer++;
-	  fill = get_absolute_expression ();
-	}
+        {
+          input_line_pointer++;
+          fill = get_absolute_expression ();
+        }
     }
 
   /* This is to be compatible with BSD 4.2 AS, not for any rational reason.  */
@@ -1724,44 +2000,44 @@ s_fill (ignore)
   else if (rep_exp.X_op == O_constant && rep_exp.X_add_number <= 0)
     {
       if (rep_exp.X_add_number < 0)
-	as_warn (_("Repeat < 0, .fill ignored"));
+        as_warn (_("Repeat < 0, .fill ignored"));
       size = 0;
     }
 
   if (size && !need_pass_2)
     {
       if (rep_exp.X_op == O_constant)
-	{
-	  p = frag_var (rs_fill, (int) size, (int) size,
-			(relax_substateT) 0, (symbolS *) 0,
-			(offsetT) rep_exp.X_add_number,
-			(char *) 0);
-	}
+        {
+          p = frag_var (rs_fill, (int) size, (int) size,
+                        (relax_substateT) 0, (symbolS *) 0,
+                        (offsetT) rep_exp.X_add_number,
+                        (char *) 0);
+        }
       else
-	{
-	  /* We don't have a constant repeat count, so we can't use
-	     rs_fill.  We can get the same results out of rs_space,
-	     but its argument is in bytes, so we must multiply the
-	     repeat count by size.  */
-
-	  symbolS *rep_sym;
-	  rep_sym = make_expr_symbol (&rep_exp);
-	  if (size != 1)
-	    {
-	      expressionS size_exp;
-	      size_exp.X_op = O_constant;
-	      size_exp.X_add_number = size;
-
-	      rep_exp.X_op = O_multiply;
-	      rep_exp.X_add_symbol = rep_sym;
-	      rep_exp.X_op_symbol = make_expr_symbol (&size_exp);
-	      rep_exp.X_add_number = 0;
-	      rep_sym = make_expr_symbol (&rep_exp);
-	    }
-
-	  p = frag_var (rs_space, (int) size, (int) size,
-			(relax_substateT) 0, rep_sym, (offsetT) 0, (char *) 0);
-	}
+        {
+          /* We don't have a constant repeat count, so we can't use
+             rs_fill.  We can get the same results out of rs_space,
+             but its argument is in bytes, so we must multiply the
+             repeat count by size.  */
+
+          symbolS *rep_sym;
+          rep_sym = make_expr_symbol (&rep_exp);
+          if (size != 1)
+            {
+              expressionS size_exp;
+              size_exp.X_op = O_constant;
+              size_exp.X_add_number = size;
+
+              rep_exp.X_op = O_multiply;
+              rep_exp.X_add_symbol = rep_sym;
+              rep_exp.X_op_symbol = make_expr_symbol (&size_exp);
+              rep_exp.X_add_number = 0;
+              rep_sym = make_expr_symbol (&rep_exp);
+            }
+
+          p = frag_var (rs_space, (int) size, (int) size,
+                        (relax_substateT) 0, rep_sym, (offsetT) 0, (char *) 0);
+        }
       memset (p, 0, (unsigned int) size);
       /* The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX
        * flavoured AS.  The following bizzare behaviour is to be
@@ -1770,9 +2046,9 @@ s_fill (ignore)
        * extend. Un*x Sux. */
 #define BSD_FILL_SIZE_CROCK_4 (4)
       md_number_to_chars (p, (valueT) fill,
-			  (size > BSD_FILL_SIZE_CROCK_4
-			   ? BSD_FILL_SIZE_CROCK_4
-			   : (int) size));
+                          (size > BSD_FILL_SIZE_CROCK_4
+                           ? BSD_FILL_SIZE_CROCK_4
+                           : (int) size));
       /* Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes)
        * but emits no error message because it seems a legal thing to do.
        * It is a degenerate case of .fill but could be emitted by a compiler.
@@ -1805,12 +2081,12 @@ s_globl (ignore)
       SKIP_WHITESPACE ();
       c = *input_line_pointer;
       if (c == ',')
-	{
-	  input_line_pointer++;
-	  SKIP_WHITESPACE ();
-	  if (*input_line_pointer == '\n')
-	    c = '\n';
-	}
+        {
+          input_line_pointer++;
+          SKIP_WHITESPACE ();
+          if (*input_line_pointer == '\n')
+            c = '\n';
+        }
     }
   while (c == ',');
 
@@ -1874,15 +2150,15 @@ s_linkonce (ignore)
       s = input_line_pointer;
       c = get_symbol_end ();
       if (strcasecmp (s, "discard") == 0)
-	type = LINKONCE_DISCARD;
+        type = LINKONCE_DISCARD;
       else if (strcasecmp (s, "one_only") == 0)
-	type = LINKONCE_ONE_ONLY;
+        type = LINKONCE_ONE_ONLY;
       else if (strcasecmp (s, "same_size") == 0)
-	type = LINKONCE_SAME_SIZE;
+        type = LINKONCE_SAME_SIZE;
       else if (strcasecmp (s, "same_contents") == 0)
-	type = LINKONCE_SAME_CONTENTS;
+        type = LINKONCE_SAME_CONTENTS;
       else
-	as_warn (_("unrecognized .linkonce type `%s'"), s);
+        as_warn (_("unrecognized .linkonce type `%s'"), s);
 
       *input_line_pointer = c;
     }
@@ -1902,23 +2178,23 @@ s_linkonce (ignore)
     switch (type)
       {
       default:
-	abort ();
+        abort ();
       case LINKONCE_DISCARD:
-	flags |= SEC_LINK_DUPLICATES_DISCARD;
-	break;
+        flags |= SEC_LINK_DUPLICATES_DISCARD;
+        break;
       case LINKONCE_ONE_ONLY:
-	flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
-	break;
+        flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
+        break;
       case LINKONCE_SAME_SIZE:
-	flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
-	break;
+        flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
+        break;
       case LINKONCE_SAME_CONTENTS:
-	flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
-	break;
+        flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
+        break;
       }
     if (! bfd_set_section_flags (stdoutput, now_seg, flags))
       as_bad (_("bfd_set_section_flags: %s"),
-	      bfd_errmsg (bfd_get_error ()));
+              bfd_errmsg (bfd_get_error ()));
   }
 #else /* ! defined (BFD_ASSEMBLER) */
   as_warn (_(".linkonce is not supported for this object file format"));
@@ -1931,10 +2207,10 @@ s_linkonce (ignore)
 static void 
 s_lcomm_internal (needs_align, bytes_p)
      /* 1 if this was a ".bss" directive, which may require a 3rd argument
-	(alignment); 0 if it was an ".lcomm" (2 args only)  */
+        (alignment); 0 if it was an ".lcomm" (2 args only)  */
      int needs_align;
      /* 1 if the alignment value should be interpreted as the byte boundary,
-	rather than the power of 2. */
+        rather than the power of 2. */
      int bytes_p;
 {
   register char *name;
@@ -1981,15 +2257,15 @@ s_lcomm_internal (needs_align, bytes_p)
     {
       /* For MIPS and Alpha ECOFF or ELF, small objects are put in .sbss.  */
       if (temp <= bfd_get_gp_size (stdoutput))
-	{
-	  bss_seg = subseg_new (".sbss", 1);
-	  seg_info (bss_seg)->bss = 1;
+        {
+          bss_seg = subseg_new (".sbss", 1);
+          seg_info (bss_seg)->bss = 1;
 #ifdef BFD_ASSEMBLER
-	  if (! bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
-	    as_warn (_("error setting flags for \".sbss\": %s"),
-		     bfd_errmsg (bfd_get_error ()));
+          if (! bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
+            as_warn (_("error setting flags for \".sbss\": %s"),
+                     bfd_errmsg (bfd_get_error ()));
 #endif
-	}
+        }
     }
 #endif
 
@@ -2007,55 +2283,55 @@ s_lcomm_internal (needs_align, bytes_p)
       align = 0;
       SKIP_WHITESPACE ();
       if (*input_line_pointer != ',')
-	{
-	  as_bad (_("Expected comma after size"));
-	  ignore_rest_of_line ();
-	  return;
-	}
+        {
+          as_bad (_("Expected comma after size"));
+          ignore_rest_of_line ();
+          return;
+        }
       input_line_pointer++;
       SKIP_WHITESPACE ();
       if (*input_line_pointer == '\n')
-	{
-	  as_bad (_("Missing alignment"));
-	  return;
-	}
+        {
+          as_bad (_("Missing alignment"));
+          return;
+        }
       align = get_absolute_expression ();
       if (bytes_p)
-	{
-	  /* Convert to a power of 2.  */
-	  if (align != 0)
-	    {
-	      unsigned int i;
-
-	      for (i = 0; (align & 1) == 0; align >>= 1, ++i)
-		;
-	      if (align != 1)
-		as_bad (_("Alignment not a power of 2"));
-	      align = i;
-	    }
-	}
+        {
+          /* Convert to a power of 2.  */
+          if (align != 0)
+            {
+              unsigned int i;
+
+              for (i = 0; (align & 1) == 0; align >>= 1, ++i)
+                ;
+              if (align != 1)
+                as_bad (_("Alignment not a power of 2"));
+              align = i;
+            }
+        }
       if (align > max_alignment)
-	{
-	  align = max_alignment;
-	  as_warn (_("Alignment too large: %d. assumed."), align);
-	}
+        {
+          align = max_alignment;
+          as_warn (_("Alignment too large: %d. assumed."), align);
+        }
       else if (align < 0)
-	{
-	  align = 0;
-	  as_warn (_("Alignment negative. 0 assumed."));
-	}
+        {
+          align = 0;
+          as_warn (_("Alignment negative. 0 assumed."));
+        }
       record_alignment (bss_seg, align);
-    }				/* if needs align */
+    }                           /* if needs align */
   else
     {
       /* Assume some objects may require alignment on some systems.  */
 #if defined (TC_ALPHA) && ! defined (VMS)
       if (temp > 1)
-	{
-	  align = ffs (temp) - 1;
-	  if (temp % (1 << align))
-	    abort ();
-	}
+        {
+          align = ffs (temp) - 1;
+          if (temp % (1 << align))
+            abort ();
+        }
 #endif
     }
 
@@ -2081,14 +2357,14 @@ s_lcomm_internal (needs_align, bytes_p)
       subseg_set (bss_seg, 1);
 
       if (align)
-	frag_align (align, 0, 0);
-					/* detach from old frag	*/
+        frag_align (align, 0, 0);
+                                        /* detach from old frag */
       if (S_GET_SEGMENT (symbolP) == bss_seg)
-	symbol_get_frag (symbolP)->fr_symbol = NULL;
+        symbol_get_frag (symbolP)->fr_symbol = NULL;
 
       symbol_set_frag (symbolP, frag_now);
       pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
-			(offsetT) temp, (char *) 0);
+                        (offsetT) temp, (char *) 0);
       *pfrag = 0;
 
       S_SET_SEGMENT (symbolP, bss_seg);
@@ -2098,9 +2374,9 @@ s_lcomm_internal (needs_align, bytes_p)
          ".globl" directive -- be careful not to step on storage class
          in that case.  Otherwise, set it to static. */
       if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
-	{
-	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
-	}
+        {
+          S_SET_STORAGE_CLASS (symbolP, C_STAT);
+        }
 #endif /* OBJ_COFF */
 
 #ifdef S_SET_SIZE
@@ -2109,12 +2385,12 @@ s_lcomm_internal (needs_align, bytes_p)
     }
   else
     as_bad (_("Ignoring attempt to re-define symbol `%s'."),
-	    S_GET_NAME (symbolP));
+            S_GET_NAME (symbolP));
 
   subseg_set (current_seg, current_subseg);
 
   demand_empty_rest_of_line ();
-}				/* s_lcomm_internal() */
+}                               /* s_lcomm_internal() */
 
 void
 s_lcomm (needs_align)
@@ -2176,11 +2452,11 @@ s_lsym (ignore)
       && S_GET_VALUE (symbolP) == 0)
     {
       /* The name might be an undefined .global symbol; be sure to
-	 keep the "external" bit. */
+         keep the "external" bit. */
       S_SET_SEGMENT (symbolP,
-		     (exp.X_op == O_constant
-		      ? absolute_section
-		      : reg_section));
+                     (exp.X_op == O_constant
+                      ? absolute_section
+                      : reg_section));
       S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
     }
   else
@@ -2189,7 +2465,7 @@ s_lsym (ignore)
     }
   *p = c;
   demand_empty_rest_of_line ();
-}				/* s_lsym() */
+}                               /* s_lsym() */
 
 /* Read a line into an sb.  */
 
@@ -2206,7 +2482,7 @@ get_line_sb (line)
     {
       buffer_limit = input_scrub_next_buffer (&input_line_pointer);
       if (buffer_limit == 0)
-	return 0;
+        return 0;
     }
 
   /* If app.c sets any other characters to LEX_IS_STRINGQUOTE, this
@@ -2225,24 +2501,24 @@ get_line_sb (line)
 
   inquote = '\0';
   while (! is_end_of_line[(unsigned char) *input_line_pointer]
-	 || (inquote != '\0' && *input_line_pointer != '\n'))
+         || (inquote != '\0' && *input_line_pointer != '\n'))
     {
       if (inquote == *input_line_pointer)
-	inquote = '\0';
+        inquote = '\0';
       else if (inquote == '\0')
-	{
-	  if (*input_line_pointer == quote1)
-	    inquote = quote1;
-	  else if (*input_line_pointer == quote2)
-	    inquote = quote2;
-	}
+        {
+          if (*input_line_pointer == quote1)
+            inquote = quote1;
+          else if (*input_line_pointer == quote2)
+            inquote = quote2;
+        }
       sb_add_char (line, *input_line_pointer++);
     }
   while (input_line_pointer < buffer_limit
-	 && is_end_of_line[(unsigned char) *input_line_pointer])
+         && is_end_of_line[(unsigned char) *input_line_pointer])
     {
       if (input_line_pointer[-1] == '\n')
-	bump_line_counters ();
+        bump_line_counters ();
       ++input_line_pointer;
     }
   return 1;
@@ -2278,19 +2554,19 @@ s_macro (ignore)
   else
     {
       if (line_label != NULL)
-	{
-	  S_SET_SEGMENT (line_label, undefined_section);
-	  S_SET_VALUE (line_label, 0);
-	  symbol_set_frag (line_label, &zero_address_frag);
-	}
+        {
+          S_SET_SEGMENT (line_label, undefined_section);
+          S_SET_VALUE (line_label, 0);
+          symbol_set_frag (line_label, &zero_address_frag);
+        }
 
       if (((NO_PSEUDO_DOT || flag_m68k_mri)
-	   && hash_find (po_hash, name) != NULL)
-	  || (! flag_m68k_mri
-	      && *name == '.'
-	      && hash_find (po_hash, name + 1) != NULL))
-	as_warn (_("attempt to redefine pseudo-op `%s' ignored"),
-		 name);
+           && hash_find (po_hash, name) != NULL)
+          || (! flag_m68k_mri
+              && *name == '.'
+              && hash_find (po_hash, name + 1) != NULL))
+        as_warn (_("attempt to redefine pseudo-op `%s' ignored"),
+                 name);
     }
 
   sb_kill (&s);
@@ -2356,17 +2632,17 @@ do_org (segment, exp, fill)
 {
   if (segment != now_seg && segment != absolute_section)
     as_bad (_("invalid segment \"%s\"; segment \"%s\" assumed"),
-	    segment_name (segment), segment_name (now_seg));
+            segment_name (segment), segment_name (now_seg));
 
   if (now_seg == absolute_section)
     {
       if (fill != 0)
-	as_warn (_("ignoring fill value in absolute section"));
+        as_warn (_("ignoring fill value in absolute section"));
       if (exp->X_op != O_constant)
-	{
-	  as_bad (_("only constant offsets supported in absolute section"));
-	  exp->X_add_number = 0;
-	}
+        {
+          as_bad (_("only constant offsets supported in absolute section"));
+          exp->X_add_number = 0;
+        }
       abs_section_offset = exp->X_add_number;
     }
   else
@@ -2374,7 +2650,7 @@ do_org (segment, exp, fill)
       char *p;
 
       p = frag_var (rs_org, 1, 1, (relax_substateT) 0, exp->X_add_symbol,
-		    exp->X_add_number * OCTETS_PER_BYTE, (char *) NULL);
+                    exp->X_add_number * OCTETS_PER_BYTE, (char *) NULL);
       *p = fill;
     }
 }
@@ -2426,7 +2702,7 @@ s_org (ignore)
     do_org (segment, &exp, temp_fill);
 
   demand_empty_rest_of_line ();
-}				/* s_org() */
+}                               /* s_org() */
 
 /* Handle parsing for the MRI SECT/SECTION pseudo-op.  This should be
    called by the obj-format routine which handles section changing
@@ -2453,9 +2729,9 @@ s_mri_sect (type)
   else
     {
       do
-	{
-	  ++input_line_pointer;
-	}
+        {
+          ++input_line_pointer;
+        }
       while (isdigit ((unsigned char) *input_line_pointer));
       c = *input_line_pointer;
       *input_line_pointer = '\0';
@@ -2482,29 +2758,29 @@ s_mri_sect (type)
       c = *++input_line_pointer;
       c = toupper ((unsigned char) c);
       if (c == 'C' || c == 'D' || c == 'M' || c == 'R')
-	*type = c;
+        *type = c;
       else
-	as_bad (_("unrecognized section type"));
+        as_bad (_("unrecognized section type"));
       ++input_line_pointer;
 
 #ifdef BFD_ASSEMBLER
       {
-	flagword flags;
-
-	flags = SEC_NO_FLAGS;
-	if (*type == 'C')
-	  flags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE;
-	else if (*type == 'D' || *type == 'M')
-	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA;
-	else if (*type == 'R')
-	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY | SEC_ROM;
-	if (flags != SEC_NO_FLAGS)
-	  {
-	    if (! bfd_set_section_flags (stdoutput, seg, flags))
-	      as_warn (_("error setting flags for \"%s\": %s"),
-		       bfd_section_name (stdoutput, seg),
-		       bfd_errmsg (bfd_get_error ()));
-	  }
+        flagword flags;
+
+        flags = SEC_NO_FLAGS;
+        if (*type == 'C')
+          flags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE;
+        else if (*type == 'D' || *type == 'M')
+          flags = SEC_ALLOC | SEC_LOAD | SEC_DATA;
+        else if (*type == 'R')
+          flags = SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY | SEC_ROM;
+        if (flags != SEC_NO_FLAGS)
+          {
+            if (! bfd_set_section_flags (stdoutput, seg, flags))
+              as_warn (_("error setting flags for \"%s\": %s"),
+                       bfd_section_name (stdoutput, seg),
+                       bfd_errmsg (bfd_get_error ()));
+          }
       }
 #endif
     }
@@ -2544,15 +2820,15 @@ s_mri_sect (type)
       sectype = input_line_pointer;
       c = get_symbol_end ();
       if (*sectype == '\0')
-	*type = 'C';
+        *type = 'C';
       else if (strcasecmp (sectype, "text") == 0)
-	*type = 'C';
+        *type = 'C';
       else if (strcasecmp (sectype, "data") == 0)
-	*type = 'D';
+        *type = 'D';
       else if (strcasecmp (sectype, "romdata") == 0)
-	*type = 'R';
+        *type = 'R';
       else
-	as_warn (_("unrecognized section type `%s'"), sectype);
+        as_warn (_("unrecognized section type `%s'"), sectype);
       *input_line_pointer = c;
     }
 
@@ -2565,28 +2841,28 @@ s_mri_sect (type)
       seccmd = input_line_pointer;
       c = get_symbol_end ();
       if (strcasecmp (seccmd, "absolute") == 0)
-	{
-	  as_bad (_("absolute sections are not supported"));
-	  *input_line_pointer = c;
-	  ignore_rest_of_line ();
-	  return;
-	}
+        {
+          as_bad (_("absolute sections are not supported"));
+          *input_line_pointer = c;
+          ignore_rest_of_line ();
+          return;
+        }
       else if (strcasecmp (seccmd, "align") == 0)
-	{
-	  int align;
+        {
+          int align;
 
-	  *input_line_pointer = c;
-	  align = get_absolute_expression ();
-	  record_alignment (seg, align);
-	}
+          *input_line_pointer = c;
+          align = get_absolute_expression ();
+          record_alignment (seg, align);
+        }
       else
-	{
-	  as_warn (_("unrecognized section command `%s'"), seccmd);
-	  *input_line_pointer = c;
-	}
+        {
+          as_warn (_("unrecognized section command `%s'"), seccmd);
+          *input_line_pointer = c;
+        }
     }
 
-  demand_empty_rest_of_line ();	  
+  demand_empty_rest_of_line ();   
 
 #else /* ! TC_I960 */
   /* The MRI assembler seems to use different forms of .sect for
@@ -2746,7 +3022,7 @@ s_set (equiv)
       segment = get_known_segmented_expression (&exp);
 
       if (!need_pass_2)
-	do_org (segment, &exp, 0);
+        do_org (segment, &exp, 0);
 
       *end_name = delim;
       return;
@@ -2757,28 +3033,28 @@ s_set (equiv)
     {
 #ifndef NO_LISTING
       /* When doing symbol listings, play games with dummy fragments living
-	 outside the normal fragment chain to record the file and line info
+         outside the normal fragment chain to record the file and line info
          for this symbol.  */
       if (listing & LISTING_SYMBOLS)
-	{
-	  extern struct list_info_struct *listing_tail;
-	  fragS *dummy_frag = (fragS *) xmalloc (sizeof(fragS));
-	  memset (dummy_frag, 0, sizeof(fragS));
-	  dummy_frag->fr_type = rs_fill;
-	  dummy_frag->line = listing_tail;
-	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
-	  dummy_frag->fr_symbol = symbolP;
-	}
+        {
+          extern struct list_info_struct *listing_tail;
+          fragS *dummy_frag = (fragS *) xmalloc (sizeof(fragS));
+          memset (dummy_frag, 0, sizeof(fragS));
+          dummy_frag->fr_type = rs_fill;
+          dummy_frag->line = listing_tail;
+          symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
+          dummy_frag->fr_symbol = symbolP;
+        }
       else
 #endif
         symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
-			    
+                            
 #ifdef OBJ_COFF
       /* "set" symbols are local unless otherwise specified. */
       SF_SET_LOCAL (symbolP);
 #endif /* OBJ_COFF */
 
-    }				/* make a new symbol */
+    }                           /* make a new symbol */
 
   symbol_table_insert (symbolP);
 
@@ -2791,7 +3067,7 @@ s_set (equiv)
 
   pseudo_set (symbolP);
   demand_empty_rest_of_line ();
-}				/* s_set() */
+}                               /* s_set() */
 
 void 
 s_space (mult)
@@ -2816,39 +3092,39 @@ s_space (mult)
   if (flag_m68k_mri && mult > 1)
     {
       if (now_seg == absolute_section)
-	{
-	  abs_section_offset += abs_section_offset & 1;
-	  if (line_label != NULL)
-	    S_SET_VALUE (line_label, abs_section_offset);
-	}
+        {
+          abs_section_offset += abs_section_offset & 1;
+          if (line_label != NULL)
+            S_SET_VALUE (line_label, abs_section_offset);
+        }
       else if (mri_common_symbol != NULL)
-	{
-	  valueT val;
-
-	  val = S_GET_VALUE (mri_common_symbol);
-	  if ((val & 1) != 0)
-	    {
-	      S_SET_VALUE (mri_common_symbol, val + 1);
-	      if (line_label != NULL)
-		{
-		  expressionS *symexp;
-
-		  symexp = symbol_get_value_expression (line_label);
-		  know (symexp->X_op == O_symbol);
-		  know (symexp->X_add_symbol == mri_common_symbol);
-		  symexp->X_add_number += 1;
-		}
-	    }
-	}
+        {
+          valueT val;
+
+          val = S_GET_VALUE (mri_common_symbol);
+          if ((val & 1) != 0)
+            {
+              S_SET_VALUE (mri_common_symbol, val + 1);
+              if (line_label != NULL)
+                {
+                  expressionS *symexp;
+
+                  symexp = symbol_get_value_expression (line_label);
+                  know (symexp->X_op == O_symbol);
+                  know (symexp->X_add_symbol == mri_common_symbol);
+                  symexp->X_add_number += 1;
+                }
+            }
+        }
       else
-	{
-	  do_align (1, (char *) NULL, 0, 0);
-	  if (line_label != NULL)
-	    {
-	      symbol_set_frag (line_label, frag_now);
-	      S_SET_VALUE (line_label, frag_now_fix ());
-	    }
-	}
+        {
+          do_align (1, (char *) NULL, 0, 0);
+          if (line_label != NULL)
+            {
+              symbol_set_frag (line_label, frag_now);
+              S_SET_VALUE (line_label, frag_now_fix ());
+            }
+        }
     }
 
   bytes = mult;
@@ -2873,77 +3149,77 @@ s_space (mult)
       || (mult != 0 && mult != 1 && val.X_add_number != 0))
     {
       if (exp.X_op != O_constant)
-	as_bad (_("Unsupported variable size or fill value"));
+        as_bad (_("Unsupported variable size or fill value"));
       else
-	{
-	  offsetT i;
+        {
+          offsetT i;
 
-	  if (mult == 0)
-	    mult = 1;
-	  bytes = mult * exp.X_add_number;
-	  for (i = 0; i < exp.X_add_number; i++)
-	    emit_expr (&val, mult);
-	}
+          if (mult == 0)
+            mult = 1;
+          bytes = mult * exp.X_add_number;
+          for (i = 0; i < exp.X_add_number; i++)
+            emit_expr (&val, mult);
+        }
     }
   else
     {
       if (exp.X_op == O_constant)
-	{
-	  long repeat;
-
-	  repeat = exp.X_add_number;
-	  if (mult)
-	    repeat *= mult;
-	  bytes = repeat;
-	  if (repeat <= 0)
-	    {
-	      if (! flag_mri)
-		as_warn (_(".space repeat count is zero, ignored"));
-	      else if (repeat < 0)
-		as_warn (_(".space repeat count is negative, ignored"));
-	      goto getout;
-	    }
-
-	  /* If we are in the absolute section, just bump the offset.  */
-	  if (now_seg == absolute_section)
-	    {
-	      abs_section_offset += repeat;
-	      goto getout;
-	    }
-
-	  /* If we are secretly in an MRI common section, then
-	     creating space just increases the size of the common
-	     symbol.  */
-	  if (mri_common_symbol != NULL)
-	    {
-	      S_SET_VALUE (mri_common_symbol,
-			   S_GET_VALUE (mri_common_symbol) + repeat);
-	      goto getout;
-	    }
-
-	  if (!need_pass_2)
-	    p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
-			  (offsetT) repeat, (char *) 0);
-	}
+        {
+          long repeat;
+
+          repeat = exp.X_add_number;
+          if (mult)
+            repeat *= mult;
+          bytes = repeat;
+          if (repeat <= 0)
+            {
+              if (! flag_mri)
+                as_warn (_(".space repeat count is zero, ignored"));
+              else if (repeat < 0)
+                as_warn (_(".space repeat count is negative, ignored"));
+              goto getout;
+            }
+
+          /* If we are in the absolute section, just bump the offset.  */
+          if (now_seg == absolute_section)
+            {
+              abs_section_offset += repeat;
+              goto getout;
+            }
+
+          /* If we are secretly in an MRI common section, then
+             creating space just increases the size of the common
+             symbol.  */
+          if (mri_common_symbol != NULL)
+            {
+              S_SET_VALUE (mri_common_symbol,
+                           S_GET_VALUE (mri_common_symbol) + repeat);
+              goto getout;
+            }
+
+          if (!need_pass_2)
+            p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
+                          (offsetT) repeat, (char *) 0);
+        }
       else
-	{
-	  if (now_seg == absolute_section)
-	    {
-	      as_bad (_("space allocation too complex in absolute section"));
-	      subseg_set (text_section, 0);
-	    }
-	  if (mri_common_symbol != NULL)
-	    {
-	      as_bad (_("space allocation too complex in common section"));
-	      mri_common_symbol = NULL;
-	    }
-	  if (!need_pass_2)
-	    p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
-			  make_expr_symbol (&exp), (offsetT) 0, (char *) 0);
-	}
+        {
+          if (now_seg == absolute_section)
+            {
+              as_bad (_("space allocation too complex in absolute section"));
+              subseg_set (text_section, 0);
+            }
+          if (mri_common_symbol != NULL)
+            {
+              as_bad (_("space allocation too complex in common section"));
+              mri_common_symbol = NULL;
+            }
+          if (!need_pass_2)
+            p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
+                          make_expr_symbol (&exp), (offsetT) 0, (char *) 0);
+        }
 
       if (p)
-	*p = val.X_add_number;
+        *p = val.X_add_number;
     }
 
  getout:
@@ -2985,7 +3261,7 @@ s_float_space (float_type)
       as_bad (_("missing value"));
       ignore_rest_of_line ();
       if (flag_mri)
-	mri_comment_end (stop, stopc);
+        mri_comment_end (stop, stopc);
       return;
     }
 
@@ -3005,12 +3281,12 @@ s_float_space (float_type)
     {
       flen = hex_float (float_type, temp);
       if (flen < 0)
-	{
-	  ignore_rest_of_line ();
-	  if (flag_mri)
-	    mri_comment_end (stop, stopc);
-	  return;
-	}
+        {
+          ignore_rest_of_line ();
+          if (flag_mri)
+            mri_comment_end (stop, stopc);
+          return;
+        }
     }
   else
     {
@@ -3020,13 +3296,13 @@ s_float_space (float_type)
       know (flen <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
       know (flen > 0);
       if (err)
-	{
-	  as_bad (_("Bad floating literal: %s"), err);
-	  ignore_rest_of_line ();
-	  if (flag_mri)
-	    mri_comment_end (stop, stopc);
-	  return;
-	}
+        {
+          as_bad (_("Bad floating literal: %s"), err);
+          ignore_rest_of_line ();
+          if (flag_mri)
+            mri_comment_end (stop, stopc);
+          return;
+        }
     }
 
   while (--count >= 0)
@@ -3073,7 +3349,7 @@ s_text (ignore)
 #ifdef OBJ_VMS
   const_flag &= ~IN_DEFAULT_SECTION;
 #endif
-}				/* s_text() */
+}                               /* s_text() */
 
 
 void 
@@ -3089,26 +3365,26 @@ demand_empty_rest_of_line ()
       ignore_rest_of_line ();
     }
   /* Return having already swallowed end-of-line. */
-}				/* Return pointing just after end-of-line. */
+}                               /* Return pointing just after end-of-line. */
 
 void
-ignore_rest_of_line ()		/* For suspect lines: gives warning. */
+ignore_rest_of_line ()          /* For suspect lines: gives warning. */
 {
   if (!is_end_of_line[(unsigned char) *input_line_pointer])
     {
       if (isprint ((unsigned char) *input_line_pointer))
-	as_bad (_("Rest of line ignored. First ignored character is `%c'."),
-		*input_line_pointer);
+        as_bad (_("Rest of line ignored. First ignored character is `%c'."),
+                *input_line_pointer);
       else
-	as_bad (_("Rest of line ignored. First ignored character valued 0x%x."),
-		*input_line_pointer);
+        as_bad (_("Rest of line ignored. First ignored character valued 0x%x."),
+                *input_line_pointer);
       while (input_line_pointer < buffer_limit
-	     && !is_end_of_line[(unsigned char) *input_line_pointer])
-	{
-	  input_line_pointer++;
-	}
+             && !is_end_of_line[(unsigned char) *input_line_pointer])
+        {
+          input_line_pointer++;
+        }
     }
-  input_line_pointer++;		/* Return pointing just after end-of-line. */
+  input_line_pointer++;         /* Return pointing just after end-of-line. */
   know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
 }
 
@@ -3125,14 +3401,14 @@ discard_rest_of_line ()
 }
 
 /*
- *			pseudo_set()
+ *                      pseudo_set()
  *
- * In:	Pointer to a symbol.
- *	Input_line_pointer->expression.
+ * In:  Pointer to a symbol.
+ *      Input_line_pointer->expression.
  *
- * Out:	Input_line_pointer->just after any whitespace after expression.
- *	Tried to set symbol to value of expression.
- *	Will change symbols type, value, and frag;
+ * Out: Input_line_pointer->just after any whitespace after expression.
+ *      Tried to set symbol to value of expression.
+ *      Will change symbols type, value, and frag;
  */
 void
 pseudo_set (symbolP)
@@ -3143,7 +3419,7 @@ pseudo_set (symbolP)
   int ext;
 #endif /* OBJ_AOUT or OBJ_BOUT */
 
-  know (symbolP);		/* NULL pointer is logic error. */
+  know (symbolP);               /* NULL pointer is logic error. */
 #if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
   ext = S_IS_EXTERNAL (symbolP);
 #endif /* OBJ_AOUT or OBJ_BOUT */
@@ -3157,20 +3433,20 @@ pseudo_set (symbolP)
   else if (exp.X_op == O_big)
     {
       if (exp.X_add_number > 0)
-	as_bad (_("bignum invalid; zero assumed"));
+        as_bad (_("bignum invalid; zero assumed"));
       else
-	as_bad (_("floating point number invalid; zero assumed"));
+        as_bad (_("floating point number invalid; zero assumed"));
     }
   else if (exp.X_op == O_subtract
-	   && (S_GET_SEGMENT (exp.X_add_symbol)
-	       == S_GET_SEGMENT (exp.X_op_symbol))
-	   && SEG_NORMAL (S_GET_SEGMENT (exp.X_add_symbol))
-	   && (symbol_get_frag (exp.X_add_symbol)
-	       == symbol_get_frag (exp.X_op_symbol)))
+           && (S_GET_SEGMENT (exp.X_add_symbol)
+               == S_GET_SEGMENT (exp.X_op_symbol))
+           && SEG_NORMAL (S_GET_SEGMENT (exp.X_add_symbol))
+           && (symbol_get_frag (exp.X_add_symbol)
+               == symbol_get_frag (exp.X_op_symbol)))
     {
       exp.X_op = O_constant;
       exp.X_add_number = (S_GET_VALUE (exp.X_add_symbol)
-			  - S_GET_VALUE (exp.X_op_symbol));
+                          - S_GET_VALUE (exp.X_op_symbol));
     }
 
   switch (exp.X_op)
@@ -3184,9 +3460,9 @@ pseudo_set (symbolP)
       S_SET_SEGMENT (symbolP, absolute_section);
 #if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
       if (ext)
-	S_SET_EXTERNAL (symbolP);
+        S_SET_EXTERNAL (symbolP);
       else
-	S_CLEAR_EXTERNAL (symbolP);
+        S_CLEAR_EXTERNAL (symbolP);
 #endif /* OBJ_AOUT or OBJ_BOUT */
       S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
       if (exp.X_op != O_constant)
@@ -3201,38 +3477,38 @@ pseudo_set (symbolP)
 
     case O_symbol:
       if (S_GET_SEGMENT (exp.X_add_symbol) == undefined_section
-	  || exp.X_add_number != 0)
-	symbol_set_value_expression (symbolP, &exp);
+          || exp.X_add_number != 0)
+        symbol_set_value_expression (symbolP, &exp);
       else if (symbol_section_p (symbolP))
-	as_bad ("invalid attempt to set value of section symbol");
+        as_bad ("invalid attempt to set value of section symbol");
       else
-	{
-	  symbolS *s = exp.X_add_symbol;
+        {
+          symbolS *s = exp.X_add_symbol;
 
-	  S_SET_SEGMENT (symbolP, S_GET_SEGMENT (s));
+          S_SET_SEGMENT (symbolP, S_GET_SEGMENT (s));
 #if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
-	  if (ext)
-	    S_SET_EXTERNAL (symbolP);
-	  else
-	    S_CLEAR_EXTERNAL (symbolP);
+          if (ext)
+            S_SET_EXTERNAL (symbolP);
+          else
+            S_CLEAR_EXTERNAL (symbolP);
 #endif /* OBJ_AOUT or OBJ_BOUT */
-	  S_SET_VALUE (symbolP,
-		       exp.X_add_number + S_GET_VALUE (s));
-	  symbol_set_frag (symbolP, symbol_get_frag (s));
-	  copy_symbol_attributes (symbolP, s);
-	}
+          S_SET_VALUE (symbolP,
+                       exp.X_add_number + S_GET_VALUE (s));
+          symbol_set_frag (symbolP, symbol_get_frag (s));
+          copy_symbol_attributes (symbolP, s);
+        }
       break;
 
     default:
       /* The value is some complex expression.
-	 FIXME: Should we set the segment to anything?  */
+         FIXME: Should we set the segment to anything?  */
       symbol_set_value_expression (symbolP, &exp);
       break;
     }
 }
 
 /*
- *			cons()
+ *                      cons()
  *
  * CONStruct more frag of .bytes, or .words etc.
  * Should need_pass_2 be 1 then emit no frag(s).
@@ -3284,7 +3560,7 @@ parse_repeat_cons PARAMS ((expressionS *exp, unsigned int nbytes));
 /* end-of-line. */
 static void 
 cons_worker (nbytes, rva)
-     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
+     register int nbytes;       /* 1=.byte, 2=.word, 4=.long */
      int rva;
 {
   int c;
@@ -3303,7 +3579,7 @@ cons_worker (nbytes, rva)
     {
       demand_empty_rest_of_line ();
       if (flag_mri)
-	mri_comment_end (stop, stopc);
+        mri_comment_end (stop, stopc);
       return;
     }
 
@@ -3316,18 +3592,18 @@ cons_worker (nbytes, rva)
     {
 #ifdef TC_M68K
       if (flag_m68k_mri)
-	parse_mri_cons (&exp, (unsigned int) nbytes);
+        parse_mri_cons (&exp, (unsigned int) nbytes);
       else
 #endif
-	TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);
+        TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);
 
       if (rva)
-	{
-	  if (exp.X_op == O_symbol)
-	    exp.X_op = O_symbol_rva;
-	  else
-	    as_fatal (_("rva without symbol"));
-	}
+        {
+          if (exp.X_op == O_symbol)
+            exp.X_op = O_symbol_rva;
+          else
+            as_fatal (_("rva without symbol"));
+        }
       emit_expr (&exp, (unsigned int) nbytes);
       ++c;
     }
@@ -3339,7 +3615,7 @@ cons_worker (nbytes, rva)
   if (flag_mri && nbytes == 1 && (c & 1) != 0)
     mri_pending_align = 1;
 
-  input_line_pointer--;		/* Put terminator back into stream. */
+  input_line_pointer--;         /* Put terminator back into stream. */
 
   demand_empty_rest_of_line ();
 
@@ -3389,13 +3665,13 @@ emit_expr (exp, nbytes)
     if (strcmp (segment_name (now_seg), ".line") != 0)
       dwarf_line = -1;
     else if (dwarf_line >= 0
-	     && nbytes == 2
-	     && exp->X_op == O_constant
-	     && (exp->X_add_number == -1 || exp->X_add_number == 0xffff))
+             && nbytes == 2
+             && exp->X_op == O_constant
+             && (exp->X_add_number == -1 || exp->X_add_number == 0xffff))
       listing_source_line ((unsigned int) dwarf_line);
     else if (nbytes == 4
-	     && exp->X_op == O_constant
-	     && exp->X_add_number >= 0)
+             && exp->X_op == O_constant
+             && exp->X_add_number >= 0)
       dwarf_line = exp->X_add_number;
     else
       dwarf_line = -1;
@@ -3412,22 +3688,22 @@ emit_expr (exp, nbytes)
     if (strcmp (segment_name (now_seg), ".debug") != 0)
       dwarf_file = 0;
     else if (dwarf_file == 0
-	     && nbytes == 2
-	     && exp->X_op == O_constant
-	     && exp->X_add_number == 0x11)
+             && nbytes == 2
+             && exp->X_op == O_constant
+             && exp->X_add_number == 0x11)
       dwarf_file = 1;
     else if (dwarf_file == 1
-	     && nbytes == 2
-	     && exp->X_op == O_constant
-	     && exp->X_add_number == 0x12)
+             && nbytes == 2
+             && exp->X_op == O_constant
+             && exp->X_add_number == 0x12)
       dwarf_file = 2;
     else if (dwarf_file == 2
-	     && nbytes == 4)
+             && nbytes == 4)
       dwarf_file = 3;
     else if (dwarf_file == 3
-	     && nbytes == 2
-	     && exp->X_op == O_constant
-	     && exp->X_add_number == 0x38)
+             && nbytes == 2
+             && exp->X_op == O_constant
+             && exp->X_add_number == 0x38)
       dwarf_file = 4;
     else
       dwarf_file = 0;
@@ -3451,7 +3727,7 @@ emit_expr (exp, nbytes)
   if (now_seg == absolute_section)
     {
       if (op != O_constant || exp->X_add_number != 0)
-	as_bad (_("attempt to store value in absolute section"));
+        as_bad (_("attempt to store value in absolute section"));
       abs_section_offset += nbytes;
       return;
     }
@@ -3470,18 +3746,18 @@ emit_expr (exp, nbytes)
       /* Negate the bignum: one's complement each digit and add 1.  */
       carry = 1;
       for (i = 0; i < exp->X_add_number; i++)
-	{
-	  unsigned long next;
+        {
+          unsigned long next;
 
-	  next = (((~ (generic_bignum[i] & LITTLENUM_MASK))
-		   & LITTLENUM_MASK)
-		  + carry);
-	  generic_bignum[i] = next & LITTLENUM_MASK;
-	  carry = next >> LITTLENUM_NUMBER_OF_BITS;
-	}
+          next = (((~ (generic_bignum[i] & LITTLENUM_MASK))
+                   & LITTLENUM_MASK)
+                  + carry);
+          generic_bignum[i] = next & LITTLENUM_MASK;
+          carry = next >> LITTLENUM_NUMBER_OF_BITS;
+        }
 
       /* We can ignore any carry out, because it will be handled by
-	 extra_digit if it is needed.  */
+         extra_digit if it is needed.  */
 
       extra_digit = (valueT) -1;
       op = O_big;
@@ -3539,15 +3815,15 @@ emit_expr (exp, nbytes)
       int gencnt;
 
       if (! exp->X_unsigned && exp->X_add_number < 0)
-	extra_digit = (valueT) -1;
+        extra_digit = (valueT) -1;
       val = (valueT) exp->X_add_number;
       gencnt = 0;
       do
-	{
-	  generic_bignum[gencnt] = val & LITTLENUM_MASK;
-	  val >>= LITTLENUM_NUMBER_OF_BITS;
-	  ++gencnt;
-	}
+        {
+          generic_bignum[gencnt] = val & LITTLENUM_MASK;
+          val >>= LITTLENUM_NUMBER_OF_BITS;
+          ++gencnt;
+        }
       while (val != 0);
       op = exp->X_op = O_big;
       exp->X_add_number = gencnt;
@@ -3562,38 +3838,38 @@ emit_expr (exp, nbytes)
       register valueT unmask;
 
       /* JF << of >= number of bits in the object is undefined.  In
-	 particular SPARC (Sun 4) has problems */
+         particular SPARC (Sun 4) has problems */
       if (nbytes >= sizeof (valueT))
-	{
-	  mask = 0;
-	  if (nbytes > sizeof (valueT))
-	    hibit = 0;
-	  else
-	    hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
-	}
+        {
+          mask = 0;
+          if (nbytes > sizeof (valueT))
+            hibit = 0;
+          else
+            hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
+        }
       else
-	{
-	  /* Don't store these bits. */
-	  mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);
-	  hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
-	}
+        {
+          /* Don't store these bits. */
+          mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);
+          hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
+        }
 
-      unmask = ~mask;		/* Do store these bits. */
+      unmask = ~mask;           /* Do store these bits. */
 
 #ifdef NEVER
       "Do this mod if you want every overflow check to assume SIGNED 2's complement data.";
-      mask = ~(unmask >> 1);	/* Includes sign bit now. */
+      mask = ~(unmask >> 1);    /* Includes sign bit now. */
 #endif
 
       get = exp->X_add_number;
       use = get & unmask;
       if ((get & mask) != 0
-	  && ((get & mask) != mask
-	      || (get & hibit) == 0))
-	{		/* Leading bits contain both 0s & 1s. */
-	  as_warn (_("Value 0x%lx truncated to 0x%lx."),
-		   (unsigned long) get, (unsigned long) use);
-	}
+          && ((get & mask) != mask
+              || (get & hibit) == 0))
+        {               /* Leading bits contain both 0s & 1s. */
+          as_warn (_("Value 0x%lx truncated to 0x%lx."),
+                   (unsigned long) get, (unsigned long) use);
+        }
       /* put bytes in right order. */
       md_number_to_chars (p, use, (int) nbytes);
     }
@@ -3606,90 +3882,90 @@ emit_expr (exp, nbytes)
 
       size = exp->X_add_number * CHARS_PER_LITTLENUM;
       if (nbytes < size)
-	{
-	  as_warn (_("Bignum truncated to %d bytes"), nbytes);
-	  size = nbytes;
-	}
+        {
+          as_warn (_("Bignum truncated to %d bytes"), nbytes);
+          size = nbytes;
+        }
 
       if (target_big_endian)
-	{
-	  while (nbytes > size)
-	    {
-	      md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
-	      nbytes -= CHARS_PER_LITTLENUM;
-	      p += CHARS_PER_LITTLENUM;
-	    }
-
-	  nums = generic_bignum + size / CHARS_PER_LITTLENUM;
-	  while (size > 0)
-	    {
-	      --nums;
-	      md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
-	      size -= CHARS_PER_LITTLENUM;
-	      p += CHARS_PER_LITTLENUM;
-	    }
-	}
+        {
+          while (nbytes > size)
+            {
+              md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
+              nbytes -= CHARS_PER_LITTLENUM;
+              p += CHARS_PER_LITTLENUM;
+            }
+
+          nums = generic_bignum + size / CHARS_PER_LITTLENUM;
+          while (size > 0)
+            {
+              --nums;
+              md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
+              size -= CHARS_PER_LITTLENUM;
+              p += CHARS_PER_LITTLENUM;
+            }
+        }
       else
-	{
-	  nums = generic_bignum;
-	  while (size > 0)
-	    {
-	      md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
-	      ++nums;
-	      size -= CHARS_PER_LITTLENUM;
-	      p += CHARS_PER_LITTLENUM;
-	      nbytes -= CHARS_PER_LITTLENUM;
-	    }
-
-	  while (nbytes > 0)
-	    {
-	      md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
-	      nbytes -= CHARS_PER_LITTLENUM;
-	      p += CHARS_PER_LITTLENUM;
-	    }
-	}
+        {
+          nums = generic_bignum;
+          while (size > 0)
+            {
+              md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
+              ++nums;
+              size -= CHARS_PER_LITTLENUM;
+              p += CHARS_PER_LITTLENUM;
+              nbytes -= CHARS_PER_LITTLENUM;
+            }
+
+          while (nbytes > 0)
+            {
+              md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
+              nbytes -= CHARS_PER_LITTLENUM;
+              p += CHARS_PER_LITTLENUM;
+            }
+        }
     }
   else
     {
       memset (p, 0, nbytes);
 
       /* Now we need to generate a fixS to record the symbol value.
-	 This is easy for BFD.  For other targets it can be more
-	 complex.  For very complex cases (currently, the HPPA and
-	 NS32K), you can define TC_CONS_FIX_NEW to do whatever you
-	 want.  For simpler cases, you can define TC_CONS_RELOC to be
-	 the name of the reloc code that should be stored in the fixS.
-	 If neither is defined, the code uses NO_RELOC if it is
-	 defined, and otherwise uses 0.  */
+         This is easy for BFD.  For other targets it can be more
+         complex.  For very complex cases (currently, the HPPA and
+         NS32K), you can define TC_CONS_FIX_NEW to do whatever you
+         want.  For simpler cases, you can define TC_CONS_RELOC to be
+         the name of the reloc code that should be stored in the fixS.
+         If neither is defined, the code uses NO_RELOC if it is
+         defined, and otherwise uses 0.  */
 
 #ifdef BFD_ASSEMBLER
 #ifdef TC_CONS_FIX_NEW
       TC_CONS_FIX_NEW (frag_now, p - frag_now->fr_literal, nbytes, exp);
 #else
       {
-	bfd_reloc_code_real_type r;
-
-	switch (nbytes)
-	  {
-	  case 1:
-	    r = BFD_RELOC_8;
-	    break;
-	  case 2:
-	    r = BFD_RELOC_16;
-	    break;
-	  case 4:
-	    r = BFD_RELOC_32;
-	    break;
-	  case 8:
-	    r = BFD_RELOC_64;
-	    break;
-	  default:
-	    as_bad (_("unsupported BFD relocation size %u"), nbytes);
-	    r = BFD_RELOC_32;
-	    break;
-	  }
-	fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp,
-		     0, r);
+        bfd_reloc_code_real_type r;
+
+        switch (nbytes)
+          {
+          case 1:
+            r = BFD_RELOC_8;
+            break;
+          case 2:
+            r = BFD_RELOC_16;
+            break;
+          case 4:
+            r = BFD_RELOC_32;
+            break;
+          case 8:
+            r = BFD_RELOC_64;
+            break;
+          default:
+            as_bad (_("unsupported BFD relocation size %u"), nbytes);
+            r = BFD_RELOC_32;
+            break;
+          }
+        fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp,
+                     0, r);
       }
 #endif
 #else
@@ -3697,8 +3973,8 @@ emit_expr (exp, nbytes)
       TC_CONS_FIX_NEW (frag_now, p - frag_now->fr_literal, nbytes, exp);
 #else
       /* Figure out which reloc number to use.  Use TC_CONS_RELOC if
-	 it is defined, otherwise use NO_RELOC if it is defined,
-	 otherwise use 0.  */
+         it is defined, otherwise use NO_RELOC if it is defined,
+         otherwise use 0.  */
 #ifndef TC_CONS_RELOC
 #ifdef NO_RELOC
 #define TC_CONS_RELOC NO_RELOC
@@ -3707,7 +3983,7 @@ emit_expr (exp, nbytes)
 #endif
 #endif
       fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp, 0,
-		   TC_CONS_RELOC);
+                   TC_CONS_RELOC);
 #endif /* TC_CONS_FIX_NEW */
 #endif /* BFD_ASSEMBLER */
     }
@@ -3740,101 +4016,101 @@ parse_bitfield_cons (exp, nbytes)
   (void) expression (exp);
 
   if (*input_line_pointer == ':')
-    {			/* bitfields */
+    {                   /* bitfields */
       long value = 0;
 
       for (;;)
-	{
-	  unsigned long width;
-
-	  if (*input_line_pointer != ':')
-	    {
-	      input_line_pointer = hold;
-	      break;
-	    }			/* next piece is not a bitfield */
-
-	  /* In the general case, we can't allow
-	     full expressions with symbol
-	     differences and such.  The relocation
-	     entries for symbols not defined in this
-	     assembly would require arbitrary field
-	     widths, positions, and masks which most
-	     of our current object formats don't
-	     support.
-
-	     In the specific case where a symbol
-	     *is* defined in this assembly, we
-	     *could* build fixups and track it, but
-	     this could lead to confusion for the
-	     backends.  I'm lazy. I'll take any
-	     SEG_ABSOLUTE. I think that means that
-	     you can use a previous .set or
-	     .equ type symbol.  xoxorich. */
-
-	  if (exp->X_op == O_absent)
-	    {
-	      as_warn (_("using a bit field width of zero"));
-	      exp->X_add_number = 0;
-	      exp->X_op = O_constant;
-	    }			/* implied zero width bitfield */
-
-	  if (exp->X_op != O_constant)
-	    {
-	      *input_line_pointer = '\0';
-	      as_bad (_("field width \"%s\" too complex for a bitfield"), hold);
-	      *input_line_pointer = ':';
-	      demand_empty_rest_of_line ();
-	      return;
-	    }			/* too complex */
-
-	  if ((width = exp->X_add_number) > (BITS_PER_CHAR * nbytes))
-	    {
-	      as_warn (_("field width %lu too big to fit in %d bytes: truncated to %d bits"),
-		       width, nbytes, (BITS_PER_CHAR * nbytes));
-	      width = BITS_PER_CHAR * nbytes;
-	    }			/* too big */
-
-	  if (width > bits_available)
-	    {
-	      /* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
-	      input_line_pointer = hold;
-	      exp->X_add_number = value;
-	      break;
-	    }			/* won't fit */
-
-	  hold = ++input_line_pointer; /* skip ':' */
-
-	  (void) expression (exp);
-	  if (exp->X_op != O_constant)
-	    {
-	      char cache = *input_line_pointer;
-
-	      *input_line_pointer = '\0';
-	      as_bad (_("field value \"%s\" too complex for a bitfield"), hold);
-	      *input_line_pointer = cache;
-	      demand_empty_rest_of_line ();
-	      return;
-	    }			/* too complex */
-
-	  value |= ((~(-1 << width) & exp->X_add_number)
-		    << ((BITS_PER_CHAR * nbytes) - bits_available));
-
-	  if ((bits_available -= width) == 0
-	      || is_it_end_of_statement ()
-	      || *input_line_pointer != ',')
-	    {
-	      break;
-	    }			/* all the bitfields we're gonna get */
-
-	  hold = ++input_line_pointer;
-	  (void) expression (exp);
-	}			/* forever loop */
+        {
+          unsigned long width;
+
+          if (*input_line_pointer != ':')
+            {
+              input_line_pointer = hold;
+              break;
+            }                   /* next piece is not a bitfield */
+
+          /* In the general case, we can't allow
+             full expressions with symbol
+             differences and such.  The relocation
+             entries for symbols not defined in this
+             assembly would require arbitrary field
+             widths, positions, and masks which most
+             of our current object formats don't
+             support.
+
+             In the specific case where a symbol
+             *is* defined in this assembly, we
+             *could* build fixups and track it, but
+             this could lead to confusion for the
+             backends.  I'm lazy. I'll take any
+             SEG_ABSOLUTE. I think that means that
+             you can use a previous .set or
+             .equ type symbol.  xoxorich. */
+
+          if (exp->X_op == O_absent)
+            {
+              as_warn (_("using a bit field width of zero"));
+              exp->X_add_number = 0;
+              exp->X_op = O_constant;
+            }                   /* implied zero width bitfield */
+
+          if (exp->X_op != O_constant)
+            {
+              *input_line_pointer = '\0';
+              as_bad (_("field width \"%s\" too complex for a bitfield"), hold);
+              *input_line_pointer = ':';
+              demand_empty_rest_of_line ();
+              return;
+            }                   /* too complex */
+
+          if ((width = exp->X_add_number) > (BITS_PER_CHAR * nbytes))
+            {
+              as_warn (_("field width %lu too big to fit in %d bytes: truncated to %d bits"),
+                       width, nbytes, (BITS_PER_CHAR * nbytes));
+              width = BITS_PER_CHAR * nbytes;
+            }                   /* too big */
+
+          if (width > bits_available)
+            {
+              /* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
+              input_line_pointer = hold;
+              exp->X_add_number = value;
+              break;
+            }                   /* won't fit */
+
+          hold = ++input_line_pointer; /* skip ':' */
+
+          (void) expression (exp);
+          if (exp->X_op != O_constant)
+            {
+              char cache = *input_line_pointer;
+
+              *input_line_pointer = '\0';
+              as_bad (_("field value \"%s\" too complex for a bitfield"), hold);
+              *input_line_pointer = cache;
+              demand_empty_rest_of_line ();
+              return;
+            }                   /* too complex */
+
+          value |= ((~(-1 << width) & exp->X_add_number)
+                    << ((BITS_PER_CHAR * nbytes) - bits_available));
+
+          if ((bits_available -= width) == 0
+              || is_it_end_of_statement ()
+              || *input_line_pointer != ',')
+            {
+              break;
+            }                   /* all the bitfields we're gonna get */
+
+          hold = ++input_line_pointer;
+          (void) expression (exp);
+        }                       /* forever loop */
 
       exp->X_add_number = value;
       exp->X_op = O_constant;
       exp->X_unsigned = 1;
-    }				/* if looks like a bitfield */
-}				/* parse_bitfield_cons() */
+    }                           /* if looks like a bitfield */
+}                               /* parse_bitfield_cons() */
 
 #endif /* BITFIELD_CONS_EXPRESSIONS */
 
@@ -3848,8 +4124,8 @@ parse_mri_cons (exp, nbytes)
 {
   if (*input_line_pointer != '\''
       && (input_line_pointer[1] != '\''
-	  || (*input_line_pointer != 'A'
-	      && *input_line_pointer != 'E')))
+          || (*input_line_pointer != 'A'
+              && *input_line_pointer != 'E')))
     TC_PARSE_CONS_EXPRESSION (exp, nbytes);
   else
     {
@@ -3857,50 +4133,50 @@ parse_mri_cons (exp, nbytes)
       unsigned int result = 0;
 
       /* An MRI style string.  Cut into as many bytes as will fit into
-	 a nbyte chunk, left justify if necessary, and separate with
-	 commas so we can try again later.  */
+         a nbyte chunk, left justify if necessary, and separate with
+         commas so we can try again later.  */
       if (*input_line_pointer == 'A')
-	++input_line_pointer;
+        ++input_line_pointer;
       else if (*input_line_pointer == 'E')
-	{
-	  as_bad (_("EBCDIC constants are not supported"));
-	  ++input_line_pointer;
-	}
+        {
+          as_bad (_("EBCDIC constants are not supported"));
+          ++input_line_pointer;
+        }
 
       input_line_pointer++;
       for (scan = 0; scan < nbytes; scan++)
-	{
-	  if (*input_line_pointer == '\'')
-	    {
-	      if (input_line_pointer[1] == '\'')
-		{
-		  input_line_pointer++;
-		}
-	      else
-		break;
-	    }
-	  result = (result << 8) | (*input_line_pointer++);
-	}
+        {
+          if (*input_line_pointer == '\'')
+            {
+              if (input_line_pointer[1] == '\'')
+                {
+                  input_line_pointer++;
+                }
+              else
+                break;
+            }
+          result = (result << 8) | (*input_line_pointer++);
+        }
 
       /* Left justify */
       while (scan < nbytes)
-	{
-	  result <<= 8;
-	  scan++;
-	}
+        {
+          result <<= 8;
+          scan++;
+        }
       /* Create correct expression */
       exp->X_op = O_constant;
       exp->X_add_number = result;
       /* Fake it so that we can read the next char too */
       if (input_line_pointer[0] != '\'' ||
-	  (input_line_pointer[0] == '\'' && input_line_pointer[1] == '\''))
-	{
-	  input_line_pointer -= 2;
-	  input_line_pointer[0] = ',';
-	  input_line_pointer[1] = '\'';
-	}
+          (input_line_pointer[0] == '\'' && input_line_pointer[1] == '\''))
+        {
+          input_line_pointer -= 2;
+          input_line_pointer[0] = ',';
+          input_line_pointer[1] = '\'';
+        }
       else
-	input_line_pointer++;
+        input_line_pointer++;
     }
 }
 #endif /* TC_M68K */
@@ -3998,47 +4274,47 @@ hex_float (float_type, bytes)
       int d;
 
       /* The MRI assembler accepts arbitrary underscores strewn about
-	 through the hex constant, so we ignore them as well. */
+         through the hex constant, so we ignore them as well. */
       if (*input_line_pointer == '_')
-	{
-	  ++input_line_pointer;
-	  continue;
-	}
+        {
+          ++input_line_pointer;
+          continue;
+        }
 
       if (i >= length)
-	{
-	  as_warn (_("Floating point constant too large"));
-	  return -1;
-	}
+        {
+          as_warn (_("Floating point constant too large"));
+          return -1;
+        }
       d = hex_value (*input_line_pointer) << 4;
       ++input_line_pointer;
       while (*input_line_pointer == '_')
-	++input_line_pointer;
+        ++input_line_pointer;
       if (hex_p (*input_line_pointer))
-	{
-	  d += hex_value (*input_line_pointer);
-	  ++input_line_pointer;
-	}
+        {
+          d += hex_value (*input_line_pointer);
+          ++input_line_pointer;
+        }
       if (target_big_endian)
-	bytes[i] = d;
+        bytes[i] = d;
       else
-	bytes[length - i - 1] = d;
+        bytes[length - i - 1] = d;
       ++i;
     }
 
   if (i < length)
     {
       if (target_big_endian)
-	memset (bytes + i, 0, length - i);
+        memset (bytes + i, 0, length - i);
       else
-	memset (bytes, 0, length - i);
+        memset (bytes, 0, length - i);
     }
 
   return length;
 }
 
 /*
- *			float_cons()
+ *                      float_cons()
  *
  * CONStruct some more frag chars of .floats .ffloats etc.
  * Makes 0 or more new frags.
@@ -4053,18 +4329,18 @@ hex_float (float_type, bytes)
  * a choice of 2 flavours of noise according to which of 2 floating-point
  * scanners you directed AS to use.
  *
- * In:	input_line_pointer->whitespace before, or '0' of flonum.
+ * In:  input_line_pointer->whitespace before, or '0' of flonum.
  *
  */
 
 void
 float_cons (float_type)
      /* Clobbers input_line-pointer, checks end-of-line. */
-     register int float_type;	/* 'f':.ffloat ... 'F':.float ... */
+     register int float_type;   /* 'f':.ffloat ... 'F':.float ... */
 {
   register char *p;
-  int length;			/* Number of chars in an object. */
-  register char *err;		/* Error from scanning floating literal. */
+  int length;                   /* Number of chars in an object. */
+  register char *err;           /* Error from scanning floating literal. */
   char temp[MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT];
 
   if (is_it_end_of_statement ())
@@ -4088,70 +4364,70 @@ float_cons (float_type)
        * diagnostics if your input is ill-conditioned.
        */
       if (input_line_pointer[0] == '0'
-	  && isalpha ((unsigned char) input_line_pointer[1]))
-	input_line_pointer += 2;
+          && isalpha ((unsigned char) input_line_pointer[1]))
+        input_line_pointer += 2;
 
       /* Accept :xxxx, where the x's are hex digits, for a floating
          point with the exact digits specified.  */
       if (input_line_pointer[0] == ':')
-	{
-	  ++input_line_pointer;
-	  length = hex_float (float_type, temp);
-	  if (length < 0)
-	    {
-	      ignore_rest_of_line ();
-	      return;
-	    }
-	}
+        {
+          ++input_line_pointer;
+          length = hex_float (float_type, temp);
+          if (length < 0)
+            {
+              ignore_rest_of_line ();
+              return;
+            }
+        }
       else
-	{
-	  err = md_atof (float_type, temp, &length);
-	  know (length <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
-	  know (length > 0);
-	  if (err)
-	    {
-	      as_bad (_("Bad floating literal: %s"), err);
-	      ignore_rest_of_line ();
-	      return;
-	    }
-	}
+        {
+          err = md_atof (float_type, temp, &length);
+          know (length <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
+          know (length > 0);
+          if (err)
+            {
+              as_bad (_("Bad floating literal: %s"), err);
+              ignore_rest_of_line ();
+              return;
+            }
+        }
 
       if (!need_pass_2)
-	{
-	  int count;
+        {
+          int count;
 
-	  count = 1;
+          count = 1;
 
 #ifdef REPEAT_CONS_EXPRESSIONS
-	  if (*input_line_pointer == ':')
-	    {
-	      expressionS count_exp;
-
-	      ++input_line_pointer;
-	      expression (&count_exp);
-	      if (count_exp.X_op != O_constant
-		  || count_exp.X_add_number <= 0)
-		{
-		  as_warn (_("unresolvable or nonpositive repeat count; using 1"));
-		}
-	      else
-		count = count_exp.X_add_number;
-	    }
+          if (*input_line_pointer == ':')
+            {
+              expressionS count_exp;
+
+              ++input_line_pointer;
+              expression (&count_exp);
+              if (count_exp.X_op != O_constant
+                  || count_exp.X_add_number <= 0)
+                {
+                  as_warn (_("unresolvable or nonpositive repeat count; using 1"));
+                }
+              else
+                count = count_exp.X_add_number;
+            }
 #endif
 
-	  while (--count >= 0)
-	    {
-	      p = frag_more (length);
-	      memcpy (p, temp, (unsigned int) length);
-	    }
-	}
+          while (--count >= 0)
+            {
+              p = frag_more (length);
+              memcpy (p, temp, (unsigned int) length);
+            }
+        }
       SKIP_WHITESPACE ();
     }
   while (*input_line_pointer++ == ',');
 
-  --input_line_pointer;		/* Put terminator back into stream.  */
+  --input_line_pointer;         /* Put terminator back into stream.  */
   demand_empty_rest_of_line ();
-}				/* float_cons() */
+}                               /* float_cons() */
 
 /* Return the size of a LEB128 value */
 
@@ -4166,13 +4442,13 @@ sizeof_sleb128 (value)
     {
       byte = (value & 0x7f);
       /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
-	 Fortunately, we can structure things so that the extra work reduces
-	 to a noop on systems that do things "properly".  */
+         Fortunately, we can structure things so that the extra work reduces
+         to a noop on systems that do things "properly".  */
       value = (value >> 7) | ~(-(offsetT)1 >> 7);
       size += 1;
     }
   while (!(((value == 0) && ((byte & 0x40) == 0))
-	   || ((value == -1) && ((byte & 0x40) != 0))));
+           || ((value == -1) && ((byte & 0x40) != 0))));
 
   return size;
 }
@@ -4221,14 +4497,14 @@ output_sleb128 (p, value)
       unsigned byte = (value & 0x7f);
 
       /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
-	 Fortunately, we can structure things so that the extra work reduces
-	 to a noop on systems that do things "properly".  */
+         Fortunately, we can structure things so that the extra work reduces
+         to a noop on systems that do things "properly".  */
       value = (value >> 7) | ~(-(offsetT)1 >> 7);
 
       more = !((((value == 0) && ((byte & 0x40) == 0))
-		|| ((value == -1) && ((byte & 0x40) != 0))));
+                || ((value == -1) && ((byte & 0x40) != 0))));
       if (more)
-	byte |= 0x80;
+        byte |= 0x80;
 
       *p++ = byte;
     }
@@ -4249,8 +4525,8 @@ output_uleb128 (p, value)
       unsigned byte = (value & 0x7f);
       value >>= 7;
       if (value != 0)
-	/* More bytes to follow.  */
-	byte |= 0x80;
+        /* More bytes to follow.  */
+        byte |= 0x80;
 
       *p++ = byte;
     }
@@ -4293,27 +4569,27 @@ output_big_sleb128 (p, bignum, size)
   do
     {
       if (loaded < 7 && size > 0)
-	{
-	  val |= (*bignum << loaded);
-	  loaded += 8 * CHARS_PER_LITTLENUM;
-	  size--;
-	  bignum++;
-	}
+        {
+          val |= (*bignum << loaded);
+          loaded += 8 * CHARS_PER_LITTLENUM;
+          size--;
+          bignum++;
+        }
 
       byte = val & 0x7f;
       loaded -= 7;
       val >>= 7;
 
       if (size == 0)
-	{
-	  if ((val == 0 && (byte & 0x40) == 0)
-	      || (~(val | ~(((valueT)1 << loaded) - 1)) == 0
-		  && (byte & 0x40) != 0))
-	    byte |= 0x80;
-	}
+        {
+          if ((val == 0 && (byte & 0x40) == 0)
+              || (~(val | ~(((valueT)1 << loaded) - 1)) == 0
+                  && (byte & 0x40) != 0))
+            byte |= 0x80;
+        }
 
       if (orig)
-	*p = byte;
+        *p = byte;
       p++;
     }
   while (byte & 0x80);
@@ -4340,22 +4616,22 @@ output_big_uleb128 (p, bignum, size)
   do
     {
       if (loaded < 7 && size > 0)
-	{
-	  val |= (*bignum << loaded);
-	  loaded += 8 * CHARS_PER_LITTLENUM;
-	  size--;
-	  bignum++;
-	}
+        {
+          val |= (*bignum << loaded);
+          loaded += 8 * CHARS_PER_LITTLENUM;
+          size--;
+          bignum++;
+        }
 
       byte = val & 0x7f;
       loaded -= 7;
       val >>= 7;
 
       if (size > 0 || val)
-	byte |= 0x80;
+        byte |= 0x80;
 
       if (orig)
-	*p = byte;
+        *p = byte;
       p++;
     }
   while (byte & 0x80);
@@ -4429,10 +4705,10 @@ emit_leb128_expr(exp, sign)
   else
     {
       /* Otherwise, we have to create a variable sized fragment and 
-	 resolve things later.  */
+         resolve things later.  */
 
       frag_var (rs_leb128, sizeof_uleb128 (~(valueT)0), 0, sign,
-		make_expr_symbol (exp), 0, (char *) NULL);
+                make_expr_symbol (exp), 0, (char *) NULL);
     }
 }
 
@@ -4454,7 +4730,7 @@ s_leb128 (sign)
 }
 
 /*
- *			stringer()
+ *                      stringer()
  *
  * We read 0 or more ',' separated, double-quoted strings.
  *
@@ -4463,9 +4739,9 @@ s_leb128 (sign)
 
 
 void 
-stringer (append_zero)		/* Worker to do .ascii etc statements. */
+stringer (append_zero)          /* Worker to do .ascii etc statements. */
      /* Checks end-of-line. */
-     register int append_zero;	/* 0: don't append '\0', else 1 */
+     register int append_zero;  /* 0: don't append '\0', else 1 */
 {
   register unsigned int c;
   char *start;
@@ -4484,72 +4760,72 @@ stringer (append_zero)		/* Worker to do .ascii etc statements. */
    */
   if (is_it_end_of_statement ())
     {
-      c = 0;			/* Skip loop. */
-      ++input_line_pointer;	/* Compensate for end of loop. */
+      c = 0;                    /* Skip loop. */
+      ++input_line_pointer;     /* Compensate for end of loop. */
     }
   else
     {
-      c = ',';			/* Do loop. */
+      c = ',';                  /* Do loop. */
     }
   while (c == ',' || c == '<' || c == '"')
     {
       SKIP_WHITESPACE ();
       switch (*input_line_pointer)
-	{
-	case '\"':
-	  ++input_line_pointer;	/*->1st char of string. */
-	  start = input_line_pointer;
-	  while (is_a_char (c = next_char_of_string ()))
-	    {
-	      FRAG_APPEND_1_CHAR (c);
-	    }
-	  if (append_zero)
-	    {
-	      FRAG_APPEND_1_CHAR (0);
-	    }
-	  know (input_line_pointer[-1] == '\"');
+        {
+        case '\"':
+          ++input_line_pointer; /*->1st char of string. */
+          start = input_line_pointer;
+          while (is_a_char (c = next_char_of_string ()))
+            {
+              FRAG_APPEND_1_CHAR (c);
+            }
+          if (append_zero)
+            {
+              FRAG_APPEND_1_CHAR (0);
+            }
+          know (input_line_pointer[-1] == '\"');
 
 #ifndef NO_LISTING
 #ifdef OBJ_ELF
-	  /* In ELF, when gcc is emitting DWARF 1 debugging output, it
+          /* In ELF, when gcc is emitting DWARF 1 debugging output, it
              will emit .string with a filename in the .debug section
              after a sequence of constants.  See the comment in
              emit_expr for the sequence.  emit_expr will set
              dwarf_file_string to non-zero if this string might be a
              source file name.  */
-	  if (strcmp (segment_name (now_seg), ".debug") != 0)
-	    dwarf_file_string = 0;
-	  else if (dwarf_file_string)
-	    {
-	      c = input_line_pointer[-1];
-	      input_line_pointer[-1] = '\0';
-	      listing_source_file (start);
-	      input_line_pointer[-1] = c;
-	    }
+          if (strcmp (segment_name (now_seg), ".debug") != 0)
+            dwarf_file_string = 0;
+          else if (dwarf_file_string)
+            {
+              c = input_line_pointer[-1];
+              input_line_pointer[-1] = '\0';
+              listing_source_file (start);
+              input_line_pointer[-1] = c;
+            }
 #endif
 #endif
 
-	  break;
-	case '<':
-	  input_line_pointer++;
-	  c = get_single_number ();
-	  FRAG_APPEND_1_CHAR (c);
-	  if (*input_line_pointer != '>')
-	    {
-	      as_bad (_("Expected <nn>"));
-	    }
-	  input_line_pointer++;
-	  break;
-	case ',':
-	  input_line_pointer++;
-	  break;
-	}
+          break;
+        case '<':
+          input_line_pointer++;
+          c = get_single_number ();
+          FRAG_APPEND_1_CHAR (c);
+          if (*input_line_pointer != '>')
+            {
+              as_bad (_("Expected <nn>"));
+            }
+          input_line_pointer++;
+          break;
+        case ',':
+          input_line_pointer++;
+          break;
+        }
       SKIP_WHITESPACE ();
       c = *input_line_pointer;
     }
 
   demand_empty_rest_of_line ();
-}				/* stringer() */
+}                               /* stringer() */
 
 /* FIXME-SOMEDAY: I had trouble here on characters with the
     high bits set.  We'll probably also have trouble with
@@ -4576,104 +4852,104 @@ next_char_of_string ()
 #ifndef NO_STRING_ESCAPES
     case '\\':
       switch (c = *input_line_pointer++)
-	{
-	case 'b':
-	  c = '\b';
-	  break;
-
-	case 'f':
-	  c = '\f';
-	  break;
-
-	case 'n':
-	  c = '\n';
-	  break;
-
-	case 'r':
-	  c = '\r';
-	  break;
-
-	case 't':
-	  c = '\t';
-	  break;
-
-	case 'v':
-	  c = '\013';
-	  break;
-
-	case '\\':
-	case '"':
-	  break;		/* As itself. */
-
-	case '0':
-	case '1':
-	case '2':
-	case '3':
-	case '4':
-	case '5':
-	case '6':
-	case '7':
-	case '8':
-	case '9':
-	  {
-	    long number;
-	    int i;
-
-	    for (i = 0, number = 0; isdigit (c) && i < 3; c = *input_line_pointer++, i++)
-	      {
-		number = number * 8 + c - '0';
-	      }
-	    c = number & 0xff;
-	  }
-	  --input_line_pointer;
-	  break;
-
-	case 'x':
-	case 'X':
-	  {
-	    long number;
-
-	    number = 0;
-	    c = *input_line_pointer++;
-	    while (isxdigit (c))
-	      {
-		if (isdigit (c))
-		  number = number * 16 + c - '0';
-		else if (isupper (c))
-		  number = number * 16 + c - 'A' + 10;
-		else
-		  number = number * 16 + c - 'a' + 10;
-		c = *input_line_pointer++;
-	      }
-	    c = number & 0xff;
-	    --input_line_pointer;
-	  }
-	  break;
-
-	case '\n':
-	  /* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
-	  as_warn (_("Unterminated string: Newline inserted."));
-	  c = '\n';
-	  bump_line_counters ();
-	  break;
-
-	default:
+        {
+        case 'b':
+          c = '\b';
+          break;
+
+        case 'f':
+          c = '\f';
+          break;
+
+        case 'n':
+          c = '\n';
+          break;
+
+        case 'r':
+          c = '\r';
+          break;
+
+        case 't':
+          c = '\t';
+          break;
+
+        case 'v':
+          c = '\013';
+          break;
+
+        case '\\':
+        case '"':
+          break;                /* As itself. */
+
+        case '0':
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+        case '8':
+        case '9':
+          {
+            long number;
+            int i;
+
+            for (i = 0, number = 0; isdigit (c) && i < 3; c = *input_line_pointer++, i++)
+              {
+                number = number * 8 + c - '0';
+              }
+            c = number & 0xff;
+          }
+          --input_line_pointer;
+          break;
+
+        case 'x':
+        case 'X':
+          {
+            long number;
+
+            number = 0;
+            c = *input_line_pointer++;
+            while (isxdigit (c))
+              {
+                if (isdigit (c))
+                  number = number * 16 + c - '0';
+                else if (isupper (c))
+                  number = number * 16 + c - 'A' + 10;
+                else
+                  number = number * 16 + c - 'a' + 10;
+                c = *input_line_pointer++;
+              }
+            c = number & 0xff;
+            --input_line_pointer;
+          }
+          break;
+
+        case '\n':
+          /* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
+          as_warn (_("Unterminated string: Newline inserted."));
+          c = '\n';
+          bump_line_counters ();
+          break;
+
+        default:
 
 #ifdef ONLY_STANDARD_ESCAPES
-	  as_bad (_("Bad escaped character in string, '?' assumed"));
-	  c = '?';
+          as_bad (_("Bad escaped character in string, '?' assumed"));
+          c = '?';
 #endif /* ONLY_STANDARD_ESCAPES */
 
-	  break;
-	}			/* switch on escaped char */
+          break;
+        }                       /* switch on escaped char */
       break;
 #endif /* ! defined (NO_STRING_ESCAPES) */
 
     default:
       break;
-    }				/* switch on char */
+    }                           /* switch on char */
   return (c);
-}				/* next_char_of_string() */
+}                               /* next_char_of_string() */
 
 static segT
 get_segmented_expression (expP)
@@ -4703,20 +4979,20 @@ get_known_segmented_expression (expP)
   if ((retval = get_segmented_expression (expP)) == undefined_section)
     {
       /* There is no easy way to extract the undefined symbol from the
-	 expression.  */
+         expression.  */
       if (expP->X_add_symbol != NULL
-	  && S_GET_SEGMENT (expP->X_add_symbol) != expr_section)
-	as_warn (_("symbol \"%s\" undefined; zero assumed"),
-		 S_GET_NAME (expP->X_add_symbol));
+          && S_GET_SEGMENT (expP->X_add_symbol) != expr_section)
+        as_warn (_("symbol \"%s\" undefined; zero assumed"),
+                 S_GET_NAME (expP->X_add_symbol));
       else
-	as_warn (_("some symbol undefined; zero assumed"));
+        as_warn (_("some symbol undefined; zero assumed"));
       retval = absolute_section;
       expP->X_op = O_constant;
       expP->X_add_number = 0;
     }
   know (retval == absolute_section || SEG_NORMAL (retval));
   return (retval);
-}				/* get_known_segmented_expression() */
+}                               /* get_known_segmented_expression() */
 
 offsetT
 get_absolute_expression ()
@@ -4727,15 +5003,15 @@ get_absolute_expression ()
   if (exp.X_op != O_constant)
     {
       if (exp.X_op != O_absent)
-	as_bad (_("bad or irreducible absolute expression; zero assumed"));
+        as_bad (_("bad or irreducible absolute expression; zero assumed"));
       exp.X_add_number = 0;
     }
   return exp.X_add_number;
 }
 
-char				/* return terminator */
+char                            /* return terminator */
 get_absolute_expression_and_terminator (val_pointer)
-     long *val_pointer;		/* return value of expression */
+     long *val_pointer;         /* return value of expression */
 {
   /* FIXME: val_pointer should probably be offsetT *.  */
   *val_pointer = (long) get_absolute_expression ();
@@ -4743,7 +5019,7 @@ get_absolute_expression_and_terminator (val_pointer)
 }
 
 /*
- *			demand_copy_C_string()
+ *                      demand_copy_C_string()
  *
  * Like demand_copy_string, but return NULL if the string contains any '\0's.
  * Give a warning if that happens.
@@ -4759,21 +5035,21 @@ demand_copy_C_string (len_pointer)
       register int len;
 
       for (len = *len_pointer; len > 0; len--)
-	{
-	  if (*s == 0)
-	    {
-	      s = 0;
-	      len = 1;
-	      *len_pointer = 0;
-	      as_bad (_("This string may not contain \'\\0\'"));
-	    }
-	}
+        {
+          if (*s == 0)
+            {
+              s = 0;
+              len = 1;
+              *len_pointer = 0;
+              as_bad (_("This string may not contain \'\\0\'"));
+            }
+        }
     }
   return s;
 }
 
 /*
- *			demand_copy_string()
+ *                      demand_copy_string()
  *
  * Demand string, but return a safe (=private) copy of the string.
  * Return NULL if we can't read a string here.
@@ -4790,15 +5066,15 @@ demand_copy_string (lenP)
   SKIP_WHITESPACE ();
   if (*input_line_pointer == '\"')
     {
-      input_line_pointer++;	/* Skip opening quote. */
+      input_line_pointer++;     /* Skip opening quote. */
 
       while (is_a_char (c = next_char_of_string ()))
-	{
-	  obstack_1grow (&notes, c);
-	  len++;
-	}
+        {
+          obstack_1grow (&notes, c);
+          len++;
+        }
       /* JF this next line is so demand_copy_C_string will return a
-	 null terminated string. */
+         null terminated string. */
       obstack_1grow (&notes, '\0');
       retval = obstack_finish (&notes);
     }
@@ -4810,30 +5086,30 @@ demand_copy_string (lenP)
     }
   *lenP = len;
   return (retval);
-}				/* demand_copy_string() */
+}                               /* demand_copy_string() */
 
 /*
- *		is_it_end_of_statement()
+ *              is_it_end_of_statement()
  *
- * In:	Input_line_pointer->next character.
+ * In:  Input_line_pointer->next character.
  *
- * Do:	Skip input_line_pointer over all whitespace.
+ * Do:  Skip input_line_pointer over all whitespace.
  *
- * Out:	1 if input_line_pointer->end-of-line.
+ * Out: 1 if input_line_pointer->end-of-line.
 */
 int 
 is_it_end_of_statement ()
 {
   SKIP_WHITESPACE ();
   return (is_end_of_line[(unsigned char) *input_line_pointer]);
-}				/* is_it_end_of_statement() */
+}                               /* is_it_end_of_statement() */
 
 void 
 equals (sym_name, reassign)
      char *sym_name;
      int reassign;
 {
-  register symbolS *symbolP;	/* symbol we are working with */
+  register symbolS *symbolP;    /* symbol we are working with */
   char *stop = NULL;
   char stopc;
 
@@ -4855,16 +5131,16 @@ equals (sym_name, reassign)
 
       segment = get_known_segmented_expression (&exp);
       if (!need_pass_2)
-	do_org (segment, &exp, 0);
+        do_org (segment, &exp, 0);
     }
   else
     {
       symbolP = symbol_find_or_make (sym_name);
       /* Permit register names to be redefined.  */
       if (! reassign
-	  && S_IS_DEFINED (symbolP)
-	  && S_GET_SEGMENT (symbolP) != reg_section)
-	as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
+          && S_IS_DEFINED (symbolP)
+          && S_GET_SEGMENT (symbolP) != reg_section)
+        as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
       pseudo_set (symbolP);
     }
 
@@ -4873,7 +5149,7 @@ equals (sym_name, reassign)
        ignore_rest_of_line (); /* check garbage after the expression */
        mri_comment_end (stop, stopc);
      }
-}				/* equals() */
+}                               /* equals() */
 
 /* .include -- include a file at this point. */
 
@@ -4891,28 +5167,28 @@ s_include (arg)
     {
       filename = demand_copy_string (&i);
       if (filename == NULL)
-	{
-	  /* demand_copy_string has already printed an error and
+        {
+          /* demand_copy_string has already printed an error and
              called ignore_rest_of_line.  */
-	  return;
-	}
+          return;
+        }
     }
   else
     {
       SKIP_WHITESPACE ();
       i = 0;
       while (! is_end_of_line[(unsigned char) *input_line_pointer]
-	     && *input_line_pointer != ' '
-	     && *input_line_pointer != '\t')
-	{
-	  obstack_1grow (&notes, *input_line_pointer);
-	  ++input_line_pointer;
-	  ++i;
-	}
+             && *input_line_pointer != ' '
+             && *input_line_pointer != '\t')
+        {
+          obstack_1grow (&notes, *input_line_pointer);
+          ++input_line_pointer;
+          ++i;
+        }
       obstack_1grow (&notes, '\0');
       filename = obstack_finish (&notes);
       while (! is_end_of_line[(unsigned char) *input_line_pointer])
-	++input_line_pointer;
+        ++input_line_pointer;
     }
   demand_empty_rest_of_line ();
   path = xmalloc ((unsigned long) i + include_dir_maxlen + 5 /* slop */ );
@@ -4922,10 +5198,10 @@ s_include (arg)
       strcat (path, "/");
       strcat (path, filename);
       if (0 != (try = fopen (path, "r")))
-	{
-	  fclose (try);
-	  goto gotit;
-	}
+        {
+          fclose (try);
+          goto gotit;
+        }
     }
   free (path);
   path = filename;
@@ -4933,7 +5209,7 @@ gotit:
   /* malloc Storage leak when file is found on path.  FIXME-SOMEDAY. */
   register_dependency (path);
   input_scrub_insert_file (path);
-}				/* s_include() */
+}                               /* s_include() */
 
 void 
 add_include_dir (path)
@@ -4944,29 +5220,29 @@ add_include_dir (path)
   if (include_dir_count == 0)
     {
       include_dirs = (char **) xmalloc (2 * sizeof (*include_dirs));
-      include_dirs[0] = ".";	/* Current dir */
+      include_dirs[0] = ".";    /* Current dir */
       include_dir_count = 2;
     }
   else
     {
       include_dir_count++;
       include_dirs = (char **) realloc (include_dirs,
-				include_dir_count * sizeof (*include_dirs));
+                                include_dir_count * sizeof (*include_dirs));
     }
 
-  include_dirs[include_dir_count - 1] = path;	/* New one */
+  include_dirs[include_dir_count - 1] = path;   /* New one */
 
   i = strlen (path);
   if (i > include_dir_maxlen)
     include_dir_maxlen = i;
-}				/* add_include_dir() */
+}                               /* add_include_dir() */
 
 /* Output debugging information to denote the source file.  */
 
 static void
 generate_file_debug ()
 {
-  if (debug_type == DEBUG_STABS)
+   if (debug_type == DEBUG_STABS)
     stabs_generate_asm_file ();
 }
 
@@ -4983,7 +5259,7 @@ generate_lineno_debug ()
       if (ECOFF_DEBUGGING && ecoff_no_current_file ())
         debug_type = DEBUG_ECOFF;
       else
-	debug_type = DEBUG_NONE;
+        debug_type = DEBUG_NONE;
     }
 #endif
 
@@ -5032,14 +5308,14 @@ do_s_func (end_p, default_prefix)
   if (end_p)
     {
       if (current_name == NULL)
-	{
-	  as_bad (_("missing .func"));
-	  ignore_rest_of_line ();
-	  return;
-	}
+        {
+          as_bad (_("missing .func"));
+          ignore_rest_of_line ();
+          return;
+        }
 
       if (debug_type == DEBUG_STABS)
-	stabs_generate_asm_endfunc (current_name, current_label);
+        stabs_generate_asm_endfunc (current_name, current_label);
 
       current_name = current_label = NULL;
     }
@@ -5049,11 +5325,11 @@ do_s_func (end_p, default_prefix)
       char delim1,delim2;
 
       if (current_name != NULL)
-	{
-	  as_bad (_(".endfunc missing for previous .func"));
-	  ignore_rest_of_line ();
-	  return;
-	}
+        {
+          as_bad (_(".endfunc missing for previous .func"));
+          ignore_rest_of_line ();
+          return;
+        }
 
       name = input_line_pointer;
       delim1 = get_symbol_end ();
@@ -5061,35 +5337,35 @@ do_s_func (end_p, default_prefix)
       *input_line_pointer = delim1;
       SKIP_WHITESPACE ();
       if (*input_line_pointer != ',')
-	{
-	  if (default_prefix)
-	    asprintf (&label, "%s%s", default_prefix, name);
-	  else
-	    {
-	      char leading_char = 0;
+        {
+          if (default_prefix)
+            asprintf (&label, "%s%s", default_prefix, name);
+          else
+            {
+              char leading_char = 0;
 #ifdef BFD_ASSEMBLER
-	      leading_char = bfd_get_symbol_leading_char (stdoutput);
+              leading_char = bfd_get_symbol_leading_char (stdoutput);
 #endif
-	      /* Missing entry point, use function's name with the leading
-		 char prepended.  */
-	      if (leading_char)
-		asprintf (&label, "%c%s", leading_char, name);
-	      else
-		label = name;
-	    }
-	}
+              /* Missing entry point, use function's name with the leading
+                 char prepended.  */
+              if (leading_char)
+                asprintf (&label, "%c%s", leading_char, name);
+              else
+                label = name;
+            }
+        }
       else
-	{
-	  ++input_line_pointer;
-	  SKIP_WHITESPACE ();
-	  label = input_line_pointer;
-	  delim2 = get_symbol_end ();
-	  label = xstrdup (label);
-	  *input_line_pointer = delim2;
-	}
+        {
+          ++input_line_pointer;
+          SKIP_WHITESPACE ();
+          label = input_line_pointer;
+          delim2 = get_symbol_end ();
+          label = xstrdup (label);
+          *input_line_pointer = delim2;
+        }
 
       if (debug_type == DEBUG_STABS)
-	stabs_generate_asm_func (name, label);
+        stabs_generate_asm_func (name, label);
 
       current_name = name;
       current_label = label;
diff --git a/gas/stabs.c b/gas/stabs.c
index 7c13c2f..bbd8bfc 100644
--- a/gas/stabs.c
+++ b/gas/stabs.c
@@ -107,12 +107,12 @@ get_stab_string_offset (string, stabstr_secname)
 #ifdef BFD_ASSEMBLER
       bfd_set_section_flags (stdoutput, seg, SEC_READONLY | SEC_DEBUGGING);
       if (seg->name == stabstr_secname)
-	seg->name = xstrdup (stabstr_secname);
+    seg->name = xstrdup (stabstr_secname);
 #endif
     }
 
   if (length > 0)
-    {				/* Ordinary case. */
+    {               /* Ordinary case. */
       p = frag_more (length + 1);
       strcpy (p, string);
 
@@ -128,7 +128,7 @@ get_stab_string_offset (string, stabstr_secname)
 
 #ifdef AOUT_STABS
 #ifndef OBJ_PROCESS_STAB
-#define OBJ_PROCESS_STAB(SEG,W,S,T,O,D)	aout_process_stab(W,S,T,O,D)
+#define OBJ_PROCESS_STAB(SEG,W,S,T,O,D) aout_process_stab(W,S,T,O,D)
 #endif
 
 static void aout_process_stab PARAMS ((int, const char *, int, int, int));
@@ -148,7 +148,7 @@ aout_process_stab (what, string, type, other, desc)
      ends in "\" and the debug info is continued in the next .stabs
      directive) from being separated by other random symbols.  */
   symbol = symbol_create (string, undefined_section, 0,
-			  (struct frag *) NULL);
+              (struct frag *) NULL);
   if (what == 's' || what == 'n')
     {
       /* Pick up the value from the input line.  */
@@ -203,13 +203,13 @@ s_stab_generic (what, stab_secname, stabstr_secname)
       string = demand_copy_C_string (&length);
       SKIP_WHITESPACE ();
       if (*input_line_pointer == ',')
-	input_line_pointer++;
+    input_line_pointer++;
       else
-	{
-	  as_warn (_(".stabs: Missing comma"));
-	  ignore_rest_of_line ();
-	  return;
-	}
+    {
+      as_warn (_(".stabs: Missing comma"));
+      ignore_rest_of_line ();
+      return;
+    }
     }
 
   if (get_absolute_expression_and_terminator (&longint) != ',')
@@ -232,11 +232,11 @@ s_stab_generic (what, stab_secname, stabstr_secname)
   if (what == 's' || what == 'n')
     {
       if (*input_line_pointer != ',')
-	{
-	  as_warn (_(".stab%c: Missing comma"), what);
-	  ignore_rest_of_line ();
-	  return;
-	}
+    {
+      as_warn (_(".stab%c: Missing comma"), what);
+      ignore_rest_of_line ();
+      return;
+    }
       input_line_pointer++;
       SKIP_WHITESPACE ();
     }
@@ -251,12 +251,12 @@ s_stab_generic (what, stab_secname, stabstr_secname)
 
       SKIP_WHITESPACE ();
       if (*input_line_pointer == ',')
-	{
-	  input_line_pointer++;
-	  what = 'n';
-	}
+    {
+      input_line_pointer++;
+      what = 'n';
+    }
       else
-	input_line_pointer = save_location;
+    input_line_pointer = save_location;
     }
 #endif /* OBJ_ELF */
 #endif /* TC_PPC */
@@ -265,15 +265,15 @@ s_stab_generic (what, stab_secname, stabstr_secname)
   if (listing)
     {
       switch (type)
-	{
-	case N_SLINE:
-	  listing_source_line ((unsigned int) desc);
-	  break;
-	case N_SO:
-	case N_SOL:
-	  listing_source_file (string);
-	  break;
-	}
+    {
+    case N_SLINE:
+      listing_source_line ((unsigned int) desc);
+      break;
+    case N_SO:
+    case N_SOL:
+      listing_source_file (string);
+      break;
+    }
     }
 #endif /* ! NO_LISTING */
 
@@ -303,40 +303,40 @@ s_stab_generic (what, stab_secname, stabstr_secname)
 #endif
 
       if (cached_secname && !strcmp (cached_secname, stab_secname))
-	{
-	  seg = cached_sec;
-	  subseg_set (seg, 0);
-	}
+    {
+      seg = cached_sec;
+      subseg_set (seg, 0);
+    }
       else
-	{
-	  seg = subseg_new (stab_secname, 0);
-	  if (cached_secname)
-	    free (cached_secname);
-	  cached_secname = xstrdup (stab_secname);
-	  cached_sec = seg;
-	}
+    {
+      seg = subseg_new (stab_secname, 0);
+      if (cached_secname)
+        free (cached_secname);
+      cached_secname = xstrdup (stab_secname);
+      cached_sec = seg;
+    }
 
       if (! seg_info (seg)->hadone)
-	{
+    {
 #ifdef BFD_ASSEMBLER
-	  bfd_set_section_flags (stdoutput, seg,
-				 SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);
+      bfd_set_section_flags (stdoutput, seg,
+                 SEC_READONLY | SEC_RELOC | SEC_DEBUGGING);
 #endif
 #ifdef INIT_STAB_SECTION
-	  INIT_STAB_SECTION (seg);
+      INIT_STAB_SECTION (seg);
 #endif
-	  seg_info (seg)->hadone = 1;
-	}
+      seg_info (seg)->hadone = 1;
+    }
 
       stroff = get_stab_string_offset (string, stabstr_secname);
       if (what == 's')
-	{
-	  /* release the string */
-	  obstack_free (&notes, string);
-	}
+    {
+      /* release the string */
+      obstack_free (&notes, string);
+    }
 
       /* At least for now, stabs in a special stab section are always
-	 output as 12 byte blocks of information.  */
+     output as 12 byte blocks of information.  */
       p = frag_more (8);
       md_number_to_chars (p, (valueT) stroff, 4);
       md_number_to_chars (p + 4, (valueT) type, 1);
@@ -344,27 +344,27 @@ s_stab_generic (what, stab_secname, stabstr_secname)
       md_number_to_chars (p + 6, (valueT) desc, 2);
 
       if (what == 's' || what == 'n')
-	{
-	  /* Pick up the value from the input line.  */
-	  cons (4);
-	  input_line_pointer--;
-	}
+    {
+      /* Pick up the value from the input line.  */
+      cons (4);
+      input_line_pointer--;
+    }
       else
-	{
-	  const char *fake;
-	  symbolS *symbol;
-	  expressionS exp;
+    {
+      const char *fake;
+      symbolS *symbol;
+      expressionS exp;
 
-	  /* Arrange for a value representing the current location.  */
-	  fake = FAKE_LABEL_NAME;
-	  symbol = symbol_new (fake, saved_seg, dot, saved_frag);
+      /* Arrange for a value representing the current location.  */
+      fake = FAKE_LABEL_NAME;
+      symbol = symbol_new (fake, saved_seg, dot, saved_frag);
 
-	  exp.X_op = O_symbol;
-	  exp.X_add_symbol = symbol;
-	  exp.X_add_number = 0;
+      exp.X_op = O_symbol;
+      exp.X_add_symbol = symbol;
+      exp.X_add_number = 0;
 
-	  emit_expr (&exp, 4);
-	}
+      emit_expr (&exp, 4);
+    }
 
 #ifdef OBJ_PROCESS_STAB
       OBJ_PROCESS_STAB (seg, what, string, type, other, desc);
@@ -425,10 +425,10 @@ s_xstab (what)
       strcpy (stabstr_secname, stab_secname);
       strcat (stabstr_secname, "str");
       if (saved_secname)
-	{
-	  free (saved_secname);
-	  free (saved_strsecname);
-	}
+    {
+      free (saved_secname);
+      free (saved_strsecname);
+    }
       saved_secname = stab_secname;
       saved_strsecname = stabstr_secname;
     }
@@ -471,12 +471,17 @@ s_desc (ignore)
       S_SET_DESC (symbolP, temp);
     }
   demand_empty_rest_of_line ();
-}				/* s_desc() */
+}               /* s_desc() */
 
 #endif /* defined (S_SET_DESC) */
 
 /* Generate stabs debugging information to denote the main source file.  */
 
+/* add T.Tazaki 2002.02.26 >>> */
+extern char *c33_stabs_input_file;
+extern enum debug_info_type debug_type;
+/* add T.Tazaki 2002.02.26 <<< */
+
 void
 stabs_generate_asm_file ()
 {
@@ -484,6 +489,10 @@ stabs_generate_asm_file ()
   unsigned int lineno;
 
   as_where (&file, &lineno);
+  
+  if( *c33_stabs_input_file != NULL )       /* add T.Tazaki 2002.02.26 */
+      file = c33_stabs_input_file;      /* add T.Tazaki 2002.02.26 */
+
   generate_asm_file (N_SO, file);
 }
 
@@ -498,8 +507,11 @@ generate_asm_file (type, file)
   static char *last_file;
   static int label_count;
   char *hold;
-  char *buf = xmalloc (2 * strlen (file) + 10);
-  char sym[30];
+//  char *buf = xmalloc (2 * strlen (file) + 10);/* buf fix 2003/06/17 */
+//  char *buf = xmalloc (2 * strlen (file) + 12); /* buf fix 2003/06/17 */
+  char *buf = xmalloc (2 * strlen (file) + 30); /* buf fix 2004/01/05 */
+//  char sym[30];/* buf fix 2004/01/05 */
+  char sym[60];/* buf fix 2004/01/05 */
 
   /* Rather than try to do this in some efficient fashion, we just
      generate a string and then parse it again.  That lets us use the
@@ -538,7 +550,7 @@ generate_asm_file (type, file)
       colon (sym);
 
       if (last_file != NULL)
-	free (last_file);
+    free (last_file);
       last_file = xstrdup (file);
     }
 
@@ -568,6 +580,9 @@ stabs_generate_asm_lineno ()
 
   as_where (&file, &lineno);
 
+  if( *c33_stabs_input_file != NULL )       /* add T.Tazaki 2002.02.26 */
+      file = c33_stabs_input_file;      /* add T.Tazaki 2002.02.26 */
+
   generate_asm_file (N_SOL, file);
 
   sprintf (sym, "%sL%d", FAKE_LABEL_NAME, label_count);
@@ -577,7 +592,7 @@ stabs_generate_asm_lineno ()
     {
       buf = (char *) alloca (100 + strlen (current_function_label));
       sprintf (buf, "%d,0,%d,%s-%s\n", N_SLINE, lineno,
-	       sym, current_function_label);
+           sym, current_function_label);
     }
   else
     {
@@ -614,7 +629,7 @@ stabs_generate_asm_func (funcname, startlabname)
 
   as_where (&file, &lineno);
   asprintf (&buf, "\"%s:F1\",%d,0,%d,%s",
-	    funcname, N_FUN, lineno + 1, startlabname);
+        funcname, N_FUN, lineno + 1, startlabname);
   input_line_pointer = buf;
   s_stab ('s');
   free (buf);
diff --git a/gas/write.c b/gas/write.c
index e386ece..8386c4f 100644
--- a/gas/write.c
+++ b/gas/write.c
@@ -48,7 +48,7 @@
 #define TC_FORCE_RELOCATION_SECTION(FIXP,SEG) TC_FORCE_RELOCATION(FIXP)
 #endif
 
-#ifndef	MD_PCREL_FROM_SECTION
+#ifndef MD_PCREL_FROM_SECTION
 #define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from(FIXP)
 #endif
 
@@ -77,9 +77,9 @@ struct frag *text_frag_root;
 struct frag *data_frag_root;
 struct frag *bss_frag_root;
 
-struct frag *text_last_frag;	/* Last frag in segment. */
-struct frag *data_last_frag;	/* Last frag in segment. */
-static struct frag *bss_last_frag;	/* Last frag in segment. */
+struct frag *text_last_frag;    /* Last frag in segment. */
+struct frag *data_last_frag;    /* Last frag in segment. */
+static struct frag *bss_last_frag;      /* Last frag in segment. */
 #endif
 
 #ifndef BFD
@@ -87,7 +87,7 @@ static object_headers headers;
 #endif
 
 long string_byte_count;
-char *next_object_file_charP;	/* Tracks object file bytes. */
+char *next_object_file_charP;   /* Tracks object file bytes. */
 
 #ifndef OBJ_VMS
 int magic_number_for_object_file = DEFAULT_MAGIC_NUMBER_FOR_OBJECT_FILE;
@@ -99,14 +99,14 @@ static int n_fixups;
 
 #ifdef BFD_ASSEMBLER
 static fixS *fix_new_internal PARAMS ((fragS *, int where, int size,
-				       symbolS *add, symbolS *sub,
-				       offsetT offset, int pcrel,
-				       bfd_reloc_code_real_type r_type));
+                                       symbolS *add, symbolS *sub,
+                                       offsetT offset, int pcrel,
+                                       bfd_reloc_code_real_type r_type));
 #else
 static fixS *fix_new_internal PARAMS ((fragS *, int where, int size,
-				       symbolS *add, symbolS *sub,
-				       offsetT offset, int pcrel,
-				       int r_type));
+                                       symbolS *add, symbolS *sub,
+                                       offsetT offset, int pcrel,
+                                       int r_type));
 #endif
 #if defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS))
 static long fixup_segment PARAMS ((fixS * fixP, segT this_segment_type));
@@ -134,24 +134,24 @@ static void relax_and_size_all_segments PARAMS ((void));
 #endif
 
 /*
- *			fix_new()
+ *                      fix_new()
  *
  * Create a fixS in obstack 'notes'.
  */
 static fixS *
 fix_new_internal (frag, where, size, add_symbol, sub_symbol, offset, pcrel,
-		  r_type)
-     fragS *frag;		/* Which frag? */
-     int where;			/* Where in that frag? */
-     int size;			/* 1, 2, or 4 usually. */
-     symbolS *add_symbol;	/* X_add_symbol. */
-     symbolS *sub_symbol;	/* X_op_symbol. */
-     offsetT offset;		/* X_add_number. */
-     int pcrel;			/* TRUE if PC-relative relocation. */
+                  r_type)
+     fragS *frag;               /* Which frag? */
+     int where;                 /* Where in that frag? */
+     int size;                  /* 1, 2, or 4 usually. */
+     symbolS *add_symbol;       /* X_add_symbol. */
+     symbolS *sub_symbol;       /* X_op_symbol. */
+     offsetT offset;            /* X_add_number. */
+     int pcrel;                 /* TRUE if PC-relative relocation. */
 #ifdef BFD_ASSEMBLER
      bfd_reloc_code_real_type r_type; /* Relocation type */
 #else
-     int r_type;		/* Relocation type */
+     int r_type;                /* Relocation type */
 #endif
 {
   fixS *fixP;
@@ -206,11 +206,11 @@ fix_new_internal (frag, where, size, add_symbol, sub_symbol, offset, pcrel,
 
 #ifdef BFD_ASSEMBLER
     fixS **seg_fix_rootP = (frags_chained
-			    ? &seg_info (now_seg)->fix_root
-			    : &frchain_now->fix_root);
+                            ? &seg_info (now_seg)->fix_root
+                            : &frchain_now->fix_root);
     fixS **seg_fix_tailP = (frags_chained
-			    ? &seg_info (now_seg)->fix_tail
-			    : &frchain_now->fix_tail);
+                            ? &seg_info (now_seg)->fix_tail
+                            : &frchain_now->fix_tail);
 #endif
 
 #ifdef REVERSE_SORT_RELOCS
@@ -239,20 +239,20 @@ fix_new_internal (frag, where, size, add_symbol, sub_symbol, offset, pcrel,
 
 fixS *
 fix_new (frag, where, size, add_symbol, offset, pcrel, r_type)
-     fragS *frag;		/* Which frag? */
-     int where;			/* Where in that frag? */
-     int size;			/* 1, 2, or 4 usually. */
-     symbolS *add_symbol;	/* X_add_symbol. */
-     offsetT offset;		/* X_add_number. */
-     int pcrel;			/* TRUE if PC-relative relocation. */
+     fragS *frag;               /* Which frag? */
+     int where;                 /* Where in that frag? */
+     int size;                  /* 1, 2, or 4 usually. */
+     symbolS *add_symbol;       /* X_add_symbol. */
+     offsetT offset;            /* X_add_number. */
+     int pcrel;                 /* TRUE if PC-relative relocation. */
 #ifdef BFD_ASSEMBLER
      bfd_reloc_code_real_type r_type; /* Relocation type */
 #else
-     int r_type;		/* Relocation type */
+     int r_type;                /* Relocation type */
 #endif
 {
   return fix_new_internal (frag, where, size, add_symbol,
-			   (symbolS *) NULL, offset, pcrel, r_type);
+                           (symbolS *) NULL, offset, pcrel, r_type);
 }
 
 /* Create a fixup for an expression.  Currently we only support fixups
@@ -261,15 +261,15 @@ fix_new (frag, where, size, add_symbol, offset, pcrel, r_type)
 
 fixS *
 fix_new_exp (frag, where, size, exp, pcrel, r_type)
-     fragS *frag;		/* Which frag? */
-     int where;			/* Where in that frag? */
-     int size;			/* 1, 2, or 4 usually. */
-     expressionS *exp;		/* Expression.  */
-     int pcrel;			/* TRUE if PC-relative relocation. */
+     fragS *frag;               /* Which frag? */
+     int where;                 /* Where in that frag? */
+     int size;                  /* 1, 2, or 4 usually. */
+     expressionS *exp;          /* Expression.  */
+     int pcrel;                 /* TRUE if PC-relative relocation. */
 #ifdef BFD_ASSEMBLER
      bfd_reloc_code_real_type r_type; /* Relocation type */
 #else
-     int r_type;		/* Relocation type */
+     int r_type;                /* Relocation type */
 #endif
 {
   symbolS *add = NULL;
@@ -283,14 +283,14 @@ fix_new_exp (frag, where, size, exp, pcrel, r_type)
 
     case O_add:
       /* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read, if
-	 the difference expression cannot immediately be reduced.  */
+         the difference expression cannot immediately be reduced.  */
       {
-	symbolS *stmp = make_expr_symbol (exp);
-	exp->X_op = O_symbol;
-	exp->X_op_symbol = 0;
-	exp->X_add_symbol = stmp;
-	exp->X_add_number = 0;
-	return fix_new_exp (frag, where, size, exp, pcrel, r_type);
+        symbolS *stmp = make_expr_symbol (exp);
+        exp->X_op = O_symbol;
+        exp->X_op_symbol = 0;
+        exp->X_add_symbol = stmp;
+        exp->X_add_number = 0;
+        return fix_new_exp (frag, where, size, exp, pcrel, r_type);
       }
 
     case O_symbol_rva:
@@ -329,7 +329,7 @@ fix_new_exp (frag, where, size, exp, pcrel, r_type)
     }
 
   return fix_new_internal (frag, where, size, add, sub, off,
-			   pcrel, r_type);
+                           pcrel, r_type);
 }
 
 /* Append a string onto another string, bumping the pointer along.  */
@@ -362,7 +362,7 @@ record_alignment (seg, align)
      /* Segment to which alignment pertains */
      segT seg;
      /* Alignment, as a power of 2 (e.g., 1 => 2-byte boundary, 2 => 4-byte
-	boundary, etc.)  */
+        boundary, etc.)  */
      int align;
 {
   if (seg == absolute_section)
@@ -413,13 +413,13 @@ chain_frchains_together_1 (section, frchp)
       assert (prev_frag->fr_type != 0);
 #ifdef BFD_ASSEMBLER
       if (frchp->fix_root != (fixS *) NULL)
-	{
-	  if (seg_info (section)->fix_root == (fixS *) NULL)
-	    seg_info (section)->fix_root = frchp->fix_root;
-	  prev_fix->fx_next = frchp->fix_root;
-	  seg_info (section)->fix_tail = frchp->fix_tail;
-	  prev_fix = frchp->fix_tail;
-	}
+        {
+          if (seg_info (section)->fix_root == (fixS *) NULL)
+            seg_info (section)->fix_root = frchp->fix_root;
+          prev_fix->fx_next = frchp->fix_root;
+          seg_info (section)->fix_tail = frchp->fix_tail;
+          prev_fix = frchp->fix_tail;
+        }
 #endif
     }
   assert (prev_frag->fr_type != 0);
@@ -494,14 +494,14 @@ cvt_frag_to_fill (headersP, sec, fragP)
 #endif
       know (fragP->fr_next != NULL);
       fragP->fr_offset = (fragP->fr_next->fr_address
-			  - fragP->fr_address
-			  - fragP->fr_fix) / fragP->fr_var;
+                          - fragP->fr_address
+                          - fragP->fr_fix) / fragP->fr_var;
       if (fragP->fr_offset < 0)
-	{
-	  as_bad_where (fragP->fr_file, fragP->fr_line,
-			_("attempt to .org/.space backwards? (%ld)"),
-			(long) fragP->fr_offset);
-	}
+        {
+          as_bad_where (fragP->fr_file, fragP->fr_line,
+                        _("attempt to .org/.space backwards? (%ld)"),
+                        (long) fragP->fr_offset);
+        }
       fragP->fr_type = rs_fill;
       break;
 
@@ -510,17 +510,17 @@ cvt_frag_to_fill (headersP, sec, fragP)
 
     case rs_leb128:
       {
-	valueT value = S_GET_VALUE (fragP->fr_symbol);
-	int size;
+        valueT value = S_GET_VALUE (fragP->fr_symbol);
+        int size;
 
-	size = output_leb128 (fragP->fr_literal + fragP->fr_fix, value,
-			      fragP->fr_subtype);
+        size = output_leb128 (fragP->fr_literal + fragP->fr_fix, value,
+                              fragP->fr_subtype);
 
-	fragP->fr_fix += size;
-	fragP->fr_type = rs_fill;
-	fragP->fr_var = 0;
-	fragP->fr_offset = 0;
-	fragP->fr_symbol = NULL;
+        fragP->fr_fix += size;
+        fragP->fr_type = rs_fill;
+        fragP->fr_var = 0;
+        fragP->fr_offset = 0;
+        fragP->fr_symbol = NULL;
       }
       break;
 
@@ -536,8 +536,8 @@ cvt_frag_to_fill (headersP, sec, fragP)
 #endif
 
       assert (fragP->fr_next == NULL
-	      || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
-		  == fragP->fr_fix));
+              || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
+                  == fragP->fr_fix));
 
       /*
        * After md_convert_frag, we make the frag into a ".space 0".
@@ -550,18 +550,18 @@ cvt_frag_to_fill (headersP, sec, fragP)
 #ifndef WORKING_DOT_WORD
     case rs_broken_word:
       {
-	struct broken_word *lie;
-
-	if (fragP->fr_subtype)
-	  {
-	    fragP->fr_fix += md_short_jump_size;
-	    for (lie = (struct broken_word *) (fragP->fr_symbol);
-		 lie && lie->dispfrag == fragP;
-		 lie = lie->next_broken_word)
-	      if (lie->added == 1)
-		fragP->fr_fix += md_long_jump_size;
-	  }
-	frag_wane (fragP);
+        struct broken_word *lie;
+
+        if (fragP->fr_subtype)
+          {
+            fragP->fr_fix += md_short_jump_size;
+            for (lie = (struct broken_word *) (fragP->fr_symbol);
+                 lie && lie->dispfrag == fragP;
+                 lie = lie->next_broken_word)
+              if (lie->added == 1)
+                fragP->fr_fix += md_long_jump_size;
+          }
+        frag_wane (fragP);
       }
       break;
 #endif
@@ -596,11 +596,11 @@ relax_and_size_seg (abfd, sec, xxx)
     {
       relax_segment (seginfo->frchainP->frch_root, sec);
       for (fragp = seginfo->frchainP->frch_root; fragp; fragp = fragp->fr_next)
-	cvt_frag_to_fill (sec, fragp);
+        cvt_frag_to_fill (sec, fragp);
       for (fragp = seginfo->frchainP->frch_root;
-	   fragp->fr_next;
-	   fragp = fragp->fr_next)
-	/* walk to last elt */;
+           fragp->fr_next;
+           fragp = fragp->fr_next)
+        /* walk to last elt */;
       size = fragp->fr_address + fragp->fr_fix;
     }
   else
@@ -629,7 +629,7 @@ relax_and_size_seg (abfd, sec, xxx)
       fragS *last = seginfo->frchainP->frch_last;
       fragp = seginfo->frchainP->frch_root;
       while (fragp->fr_next != last)
-	fragp = fragp->fr_next;
+        fragp = fragp->fr_next;
       last->fr_address = size;
       fragp->fr_offset += newsize - size;
     }
@@ -662,19 +662,19 @@ dump_section_relocs (abfd, sec, stream_)
       symbolS *s = fixp->fx_addsy;
 
       fprintf (stream, "  %08lx: type %d ", (unsigned long) fixp,
-	       (int) fixp->fx_r_type);
+               (int) fixp->fx_r_type);
       if (s == NULL)
-	fprintf (stream, "no sym\n");
+        fprintf (stream, "no sym\n");
       else
-	{
-	  print_symbol_value_1 (stream, s);
-	  fprintf (stream, "\n");
-	}
+        {
+          print_symbol_value_1 (stream, s);
+          fprintf (stream, "\n");
+        }
       fixp = fixp->fx_next;
     }
 }
 #else
-#define dump_section_relocs(ABFD,SEC,STREAM)	((void) 0)
+#define dump_section_relocs(ABFD,SEC,STREAM)    ((void) 0)
 #endif
 
 #ifndef EMIT_SECTION_SYMBOLS
@@ -700,184 +700,184 @@ adjust_reloc_syms (abfd, sec, xxx)
       /* ignore it */;
     else if (fixp->fx_addsy)
       {
-	symbolS *sym;
-	asection *symsec;
+        symbolS *sym;
+        asection *symsec;
 
 #ifdef DEBUG5
-	fprintf (stderr, "\n\nadjusting fixup:\n");
-	print_fixup (fixp);
+        fprintf (stderr, "\n\nadjusting fixup:\n");
+        print_fixup (fixp);
 #endif
 
-	sym = fixp->fx_addsy;
+        sym = fixp->fx_addsy;
 
-	/* All symbols should have already been resolved at this
-	   point.  It is possible to see unresolved expression
-	   symbols, though, since they are not in the regular symbol
-	   table.  */
-	if (sym != NULL)
-	  resolve_symbol_value (sym, 1);
-	
-	if (fixp->fx_subsy != NULL)
-	  resolve_symbol_value (fixp->fx_subsy, 1);
+        /* All symbols should have already been resolved at this
+           point.  It is possible to see unresolved expression
+           symbols, though, since they are not in the regular symbol
+           table.  */
+        if (sym != NULL)
+          resolve_symbol_value (sym, 1);
+        
+        if (fixp->fx_subsy != NULL)
+          resolve_symbol_value (fixp->fx_subsy, 1);
 
-	/* If this symbol is equated to an undefined symbol, convert
+        /* If this symbol is equated to an undefined symbol, convert
            the fixup to being against that symbol.  */
-	if (sym != NULL && symbol_equated_p (sym)
-	    && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
-	  {
-	    fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
-	    sym = symbol_get_value_expression (sym)->X_add_symbol;
-	    fixp->fx_addsy = sym;
-	  }
-
-	if (sym != NULL && symbol_mri_common_p (sym))
-	  {
-	    /* These symbols are handled specially in fixup_segment.  */
-	    goto done;
-	  }
-
-	symsec = S_GET_SEGMENT (sym);
-
-	if (symsec == NULL)
-	  abort ();
-	
-	if (bfd_is_abs_section (symsec))
-	  {
-	    /* The fixup_segment routine will not use this symbol in a
+        if (sym != NULL && symbol_equated_p (sym)
+            && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
+          {
+            fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
+            sym = symbol_get_value_expression (sym)->X_add_symbol;
+            fixp->fx_addsy = sym;
+          }
+
+        if (sym != NULL && symbol_mri_common_p (sym))
+          {
+            /* These symbols are handled specially in fixup_segment.  */
+            goto done;
+          }
+
+        symsec = S_GET_SEGMENT (sym);
+
+        if (symsec == NULL)
+          abort ();
+        
+        if (bfd_is_abs_section (symsec))
+          {
+            /* The fixup_segment routine will not use this symbol in a
                relocation unless TC_FORCE_RELOCATION returns 1.  */
-	    if (TC_FORCE_RELOCATION (fixp))
-	      {
-		symbol_mark_used_in_reloc (fixp->fx_addsy);
+            if (TC_FORCE_RELOCATION (fixp))
+              {
+                symbol_mark_used_in_reloc (fixp->fx_addsy);
 #ifdef UNDEFINED_DIFFERENCE_OK
-		if (fixp->fx_subsy != NULL)
-		  symbol_mark_used_in_reloc (fixp->fx_subsy);
-#endif
-	      }
-	    goto done;
-	  }
-
-	/* If it's one of these sections, assume the symbol is
-	   definitely going to be output.  The code in
-	   md_estimate_size_before_relax in tc-mips.c uses this test
-	   as well, so if you change this code you should look at that
-	   code.  */
-	if (bfd_is_und_section (symsec)
-	    || bfd_is_com_section (symsec))
-	  {
-	    symbol_mark_used_in_reloc (fixp->fx_addsy);
+                if (fixp->fx_subsy != NULL)
+                  symbol_mark_used_in_reloc (fixp->fx_subsy);
+#endif
+              }
+            goto done;
+          }
+
+        /* If it's one of these sections, assume the symbol is
+           definitely going to be output.  The code in
+           md_estimate_size_before_relax in tc-mips.c uses this test
+           as well, so if you change this code you should look at that
+           code.  */
+        if (bfd_is_und_section (symsec)
+            || bfd_is_com_section (symsec))
+          {
+            symbol_mark_used_in_reloc (fixp->fx_addsy);
 #ifdef UNDEFINED_DIFFERENCE_OK
-	    /* We have the difference of an undefined symbol and some
-	       other symbol.  Make sure to mark the other symbol as used
-	       in a relocation so that it will always be output.  */
-	    if (fixp->fx_subsy)
-	      symbol_mark_used_in_reloc (fixp->fx_subsy);
+            /* We have the difference of an undefined symbol and some
+               other symbol.  Make sure to mark the other symbol as used
+               in a relocation so that it will always be output.  */
+            if (fixp->fx_subsy)
+              symbol_mark_used_in_reloc (fixp->fx_subsy);
 #endif
-	    goto done;
-	  }
+            goto done;
+          }
 
-	/* Don't try to reduce relocs which refer to non-local symbols
+        /* Don't try to reduce relocs which refer to non-local symbols
            in .linkonce sections.  It can lead to confusion when a
            debugging section refers to a .linkonce section.  I hope
            this will always be correct.  */
-	if (symsec != sec && ! S_IS_LOCAL (sym))
-	  {
-	    boolean linkonce;
+        if (symsec != sec && ! S_IS_LOCAL (sym))
+          {
+            boolean linkonce;
 
-	    linkonce = false;
+            linkonce = false;
 #ifdef BFD_ASSEMBLER
-	    if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
-		!= 0)
-	      linkonce = true;
+            if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
+                != 0)
+              linkonce = true;
 #endif
 #ifdef OBJ_ELF
-	    /* The GNU toolchain uses an extension for ELF: a section
+            /* The GNU toolchain uses an extension for ELF: a section
                beginning with the magic string .gnu.linkonce is a
                linkonce section.  */
-	    if (strncmp (segment_name (symsec), ".gnu.linkonce",
-			 sizeof ".gnu.linkonce" - 1) == 0)
-	      linkonce = true;
+            if (strncmp (segment_name (symsec), ".gnu.linkonce",
+                         sizeof ".gnu.linkonce" - 1) == 0)
+              linkonce = true;
 #endif
 
-	    if (linkonce)
-	      {
-		symbol_mark_used_in_reloc (fixp->fx_addsy);
+            if (linkonce)
+              {
+                symbol_mark_used_in_reloc (fixp->fx_addsy);
 #ifdef UNDEFINED_DIFFERENCE_OK
-		if (fixp->fx_subsy != NULL)
-		  symbol_mark_used_in_reloc (fixp->fx_subsy);
+                if (fixp->fx_subsy != NULL)
+                  symbol_mark_used_in_reloc (fixp->fx_subsy);
 #endif
-		goto done;
-	      }
-	  }
+                goto done;
+              }
+          }
 
-	/* Since we're reducing to section symbols, don't attempt to reduce
-	   anything that's already using one.  */
-	if (symbol_section_p (sym))
-	  {
-	    symbol_mark_used_in_reloc (fixp->fx_addsy);
-	    goto done;
-	  }
+        /* Since we're reducing to section symbols, don't attempt to reduce
+           anything that's already using one.  */
+        if (symbol_section_p (sym))
+          {
+            symbol_mark_used_in_reloc (fixp->fx_addsy);
+            goto done;
+          }
 
 #ifdef BFD_ASSEMBLER
-	/* We can never adjust a reloc against a weak symbol.  If we
+        /* We can never adjust a reloc against a weak symbol.  If we
            did, and the weak symbol was overridden by a real symbol
            somewhere else, then our relocation would be pointing at
            the wrong area of memory.  */
-	if (S_IS_WEAK (sym))
-	  {
-	    symbol_mark_used_in_reloc (fixp->fx_addsy);
-	    goto done;
-	  }
+        if (S_IS_WEAK (sym))
+          {
+            symbol_mark_used_in_reloc (fixp->fx_addsy);
+            goto done;
+          }
 #endif
 
-	/* Is there some other reason we can't adjust this one?  (E.g.,
-	   call/bal links in i960-bout symbols.)  */
+        /* Is there some other reason we can't adjust this one?  (E.g.,
+           call/bal links in i960-bout symbols.)  */
 #ifdef obj_fix_adjustable
-	if (! obj_fix_adjustable (fixp))
-	  {
-	    symbol_mark_used_in_reloc (fixp->fx_addsy);
-	    goto done;
-	  }
+        if (! obj_fix_adjustable (fixp))
+          {
+            symbol_mark_used_in_reloc (fixp->fx_addsy);
+            goto done;
+          }
 #endif
 
-	/* Is there some other (target cpu dependent) reason we can't adjust
-	   this one?  (E.g. relocations involving function addresses on
-	   the PA.  */
+        /* Is there some other (target cpu dependent) reason we can't adjust
+           this one?  (E.g. relocations involving function addresses on
+           the PA.  */
 #ifdef tc_fix_adjustable
-	if (! tc_fix_adjustable (fixp))
-	  {
-	    symbol_mark_used_in_reloc (fixp->fx_addsy);
-	    goto done;
-	  }
-#endif
-
-	/* If the section symbol isn't going to be output, the relocs
-	   at least should still work.  If not, figure out what to do
-	   when we run into that case.
-
-	   We refetch the segment when calling section_symbol, rather
-	   than using symsec, because S_GET_VALUE may wind up changing
-	   the section when it calls resolve_symbol_value. */
-	fixp->fx_offset += S_GET_VALUE (sym);
-	fixp->fx_addsy = section_symbol (S_GET_SEGMENT (sym));
-	symbol_mark_used_in_reloc (fixp->fx_addsy);
+        if (! tc_fix_adjustable (fixp))
+          {
+            symbol_mark_used_in_reloc (fixp->fx_addsy);
+            goto done;
+          }
+#endif
+
+        /* If the section symbol isn't going to be output, the relocs
+           at least should still work.  If not, figure out what to do
+           when we run into that case.
+
+           We refetch the segment when calling section_symbol, rather
+           than using symsec, because S_GET_VALUE may wind up changing
+           the section when it calls resolve_symbol_value. */
+        fixp->fx_offset += S_GET_VALUE (sym);
+        fixp->fx_addsy = section_symbol (S_GET_SEGMENT (sym));
+        symbol_mark_used_in_reloc (fixp->fx_addsy);
 #ifdef DEBUG5
-	fprintf (stderr, "\nadjusted fixup:\n");
-	print_fixup (fixp);
+        fprintf (stderr, "\nadjusted fixup:\n");
+        print_fixup (fixp);
 #endif
 
       done:
-	;
+        ;
       }
 #if 1/*def RELOC_REQUIRES_SYMBOL*/
     else
       {
-	/* There was no symbol required by this relocation.  However,
-	   BFD doesn't really handle relocations without symbols well.
-	   (At least, the COFF support doesn't.)  So for now we fake up
-	   a local symbol in the absolute section.  */
+        /* There was no symbol required by this relocation.  However,
+           BFD doesn't really handle relocations without symbols well.
+           (At least, the COFF support doesn't.)  So for now we fake up
+           a local symbol in the absolute section.  */
 
-	fixp->fx_addsy = section_symbol (absolute_section);
-/*	fixp->fx_addsy->sy_used_in_reloc = 1; */
+        fixp->fx_addsy = section_symbol (absolute_section);
+/*      fixp->fx_addsy->sy_used_in_reloc = 1; */
       }
 #endif
 
@@ -921,62 +921,62 @@ write_relocs (abfd, sec, xxx)
       symbolS *sym;
 
       if (fixp->fx_done)
-	{
-	  n--;
-	  continue;
-	}
+        {
+          n--;
+          continue;
+        }
 
       /* If this is an undefined symbol which was equated to another
          symbol, then use generate the reloc against the latter symbol
          rather than the former.  */
       sym = fixp->fx_addsy;
       while (symbol_equated_p (sym)
-	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
-	{
-	  symbolS *n;
-
-	  /* We must avoid looping, as that can occur with a badly
-	     written program.  */
-	  n = symbol_get_value_expression (sym)->X_add_symbol;
-	  if (n == sym)
-	    break;
-	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
-	  sym = n;
-	}
+             && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
+        {
+          symbolS *n;
+
+          /* We must avoid looping, as that can occur with a badly
+             written program.  */
+          n = symbol_get_value_expression (sym)->X_add_symbol;
+          if (n == sym)
+            break;
+          fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
+          sym = n;
+        }
       fixp->fx_addsy = sym;
 
       reloc = tc_gen_reloc (sec, fixp);
       if (!reloc)
-	{
-	  n--;
-	  continue;
-	}
+        {
+          n--;
+          continue;
+        }
 
 #if 0
       /* This test is triggered inappropriately for the SH.  */
       if (fixp->fx_where + fixp->fx_size
-	  > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
-	abort ();
+          > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
+        abort ();
 #endif
 
       s = bfd_install_relocation (stdoutput, reloc,
-				  fixp->fx_frag->fr_literal,
-				  fixp->fx_frag->fr_address,
-				  sec, &err);
+                                  fixp->fx_frag->fr_literal,
+                                  fixp->fx_frag->fr_address,
+                                  sec, &err);
       switch (s)
-	{
-	case bfd_reloc_ok:
-	  break;
-	case bfd_reloc_overflow:
-	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation overflow"));
-	  break;
-	case bfd_reloc_outofrange:
-	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation out of range"));
-	  break;
-	default:
-	  as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
-		    fixp->fx_file, fixp->fx_line, s);
-	}
+        {
+        case bfd_reloc_ok:
+          break;
+        case bfd_reloc_overflow:
+          as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation overflow"));
+          break;
+        case bfd_reloc_outofrange:
+          as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation out of range"));
+          break;
+        default:
+          as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
+                    fixp->fx_file, fixp->fx_line, s);
+        }
       relocs[i++] = reloc;
     }
 #else
@@ -994,50 +994,50 @@ write_relocs (abfd, sec, xxx)
       int j;
 
       if (fixp->fx_done)
-	{
-	  n--;
-	  continue;
-	}
+        {
+          n--;
+          continue;
+        }
 
       /* If this is an undefined symbol which was equated to another
          symbol, then use generate the reloc against the latter symbol
          rather than the former.  */
       sym = fixp->fx_addsy;
       while (symbol_equated_p (sym)
-	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
-	sym = symbol_get_value_expression (sym)->X_add_symbol;
+             && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
+        sym = symbol_get_value_expression (sym)->X_add_symbol;
       fixp->fx_addsy = sym;
 
       reloc = tc_gen_reloc (sec, fixp);
 
       for (j = 0; reloc[j]; j++)
-	{
+        {
           relocs[i++] = reloc[j];
           assert(i <= n);
-	}
+        }
       data = fixp->fx_frag->fr_literal + fixp->fx_where;
       if (fixp->fx_where + fixp->fx_size
-	  > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
-	as_bad_where (fixp->fx_file, fixp->fx_line,
-		      _("internal error: fixup not contained within frag"));
+          > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
+        as_bad_where (fixp->fx_file, fixp->fx_line,
+                      _("internal error: fixup not contained within frag"));
       for (j = 0; reloc[j]; j++)
         {
-	  s = bfd_install_relocation (stdoutput, reloc[j],
-				      fixp->fx_frag->fr_literal,
-				      fixp->fx_frag->fr_address,
-				      sec, &err);
+          s = bfd_install_relocation (stdoutput, reloc[j],
+                                      fixp->fx_frag->fr_literal,
+                                      fixp->fx_frag->fr_address,
+                                      sec, &err);
           switch (s)
-	    {
-	    case bfd_reloc_ok:
-	      break;
-	    case bfd_reloc_overflow:
-	      as_bad_where (fixp->fx_file, fixp->fx_line,
-			    _("relocation overflow"));
-	      break;
-	    default:
-	      as_fatal (_("%s:%u: bad return from bfd_install_relocation"),
-			fixp->fx_file, fixp->fx_line);
-	    }
+            {
+            case bfd_reloc_ok:
+              break;
+            case bfd_reloc_overflow:
+              as_bad_where (fixp->fx_file, fixp->fx_line,
+                            _("relocation overflow"));
+              break;
+            default:
+              as_fatal (_("%s:%u: bad return from bfd_install_relocation"),
+                        fixp->fx_file, fixp->fx_line);
+            }
         }
     }
   n = i;
@@ -1051,13 +1051,13 @@ write_relocs (abfd, sec, xxx)
     nsyms = bfd_get_symcount (stdoutput);
     for (i = 0; i < n; i++)
       if (((*relocs[i]->sym_ptr_ptr)->flags & BSF_SECTION_SYM) == 0)
-	{
-	  for (j = 0; j < nsyms; j++)
-	    if (sympp[j] == *relocs[i]->sym_ptr_ptr)
-	      break;
-	  if (j == nsyms)
-	    abort ();
-	}
+        {
+          for (j = 0; j < nsyms; j++)
+            if (sympp[j] == *relocs[i]->sym_ptr_ptr)
+              break;
+          if (j == nsyms)
+            abort ();
+        }
   }
 #endif
 
@@ -1065,8 +1065,8 @@ write_relocs (abfd, sec, xxx)
     bfd_set_reloc (stdoutput, sec, relocs, n);
   else
     bfd_set_section_flags (abfd, sec,
-			   (bfd_get_section_flags (abfd, sec)
-			    & (flagword) ~SEC_RELOC));
+                           (bfd_get_section_flags (abfd, sec)
+                            & (flagword) ~SEC_RELOC));
 
 #ifdef SET_SECTION_RELOCS
   SET_SECTION_RELOCS (sec, relocs, n);
@@ -1080,10 +1080,10 @@ write_relocs (abfd, sec, xxx)
     fprintf (stderr, "relocs for sec %s\n", sec->name);
     for (i = 0; i < n; i++)
       {
-	r = relocs[i];
-	s = *r->sym_ptr_ptr;
-	fprintf (stderr, "  reloc %2d @%08x off %4x : sym %-10s addend %x\n",
-		 i, r, r->address, s->name, r->addend);
+        r = relocs[i];
+        s = *r->sym_ptr_ptr;
+        fprintf (stderr, "  reloc %2d @%08x off %4x : sym %-10s addend %x\n",
+                 i, r, r->address, s->name, r->addend);
       }
   }
 #endif
@@ -1115,73 +1115,73 @@ write_contents (abfd, sec, xxx)
 
       assert (f->fr_type == rs_fill);
       if (f->fr_fix)
-	{
-	  x = bfd_set_section_contents (stdoutput, sec,
-					f->fr_literal, (file_ptr) offset,
-					(bfd_size_type) f->fr_fix);
-	  if (x == false)
-	    {
-	      bfd_perror (stdoutput->filename);
-	      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
-	      exit (EXIT_FAILURE);
-	    }
-	  offset += f->fr_fix;
-	}
+        {
+          x = bfd_set_section_contents (stdoutput, sec,
+                                        f->fr_literal, (file_ptr) offset,
+                                        (bfd_size_type) f->fr_fix);
+          if (x == false)
+            {
+              bfd_perror (stdoutput->filename);
+              as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
+              exit (EXIT_FAILURE);
+            }
+          offset += f->fr_fix;
+        }
       fill_literal = f->fr_literal + f->fr_fix;
       fill_size = f->fr_var;
       count = f->fr_offset;
       assert (count >= 0);
       if (fill_size && count)
-	{
-	  char buf[256];
-	  if (fill_size > sizeof(buf))
-	    {
-	      /* Do it the old way. Can this ever happen? */
-	      while (count--)
-		{
-		  x = bfd_set_section_contents (stdoutput, sec,
-						fill_literal,
-						(file_ptr) offset,
-						(bfd_size_type) fill_size);
-		  if (x == false)
-		    {
-		      bfd_perror (stdoutput->filename);
-		      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
-		      exit (EXIT_FAILURE);
-		    }
-		  offset += fill_size;
-		}
-	    }
-	  else
-	    {
-	      /* Build a buffer full of fill objects and output it as
-		 often as necessary. This saves on the overhead of
-		 potentially lots of bfd_set_section_contents calls.  */
-	      int n_per_buf, i;
-	      if (fill_size == 1)
-		{
-		  n_per_buf = sizeof (buf);
-		  memset (buf, *fill_literal, n_per_buf);
-		}
-	      else
-		{
-		  char *bufp;
-		  n_per_buf = sizeof(buf)/fill_size;
-		  for (i = n_per_buf, bufp = buf; i; i--, bufp += fill_size)
-		    memcpy(bufp, fill_literal, fill_size);
-		}
-	      for (; count > 0; count -= n_per_buf)
-		{
-		  n_per_buf = n_per_buf > count ? count : n_per_buf;
-		  x = bfd_set_section_contents (stdoutput, sec,
-						buf, (file_ptr) offset,
-						(bfd_size_type) n_per_buf * fill_size);
-		  if (x != true)
-		    as_fatal (_("Cannot write to output file."));
-		  offset += n_per_buf * fill_size;
-		}
-	    }
-	}
+        {
+          char buf[256];
+          if (fill_size > sizeof(buf))
+            {
+              /* Do it the old way. Can this ever happen? */
+              while (count--)
+                {
+                  x = bfd_set_section_contents (stdoutput, sec,
+                                                fill_literal,
+                                                (file_ptr) offset,
+                                                (bfd_size_type) fill_size);
+                  if (x == false)
+                    {
+                      bfd_perror (stdoutput->filename);
+                      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
+                      exit (EXIT_FAILURE);
+                    }
+                  offset += fill_size;
+                }
+            }
+          else
+            {
+              /* Build a buffer full of fill objects and output it as
+                 often as necessary. This saves on the overhead of
+                 potentially lots of bfd_set_section_contents calls.  */
+              int n_per_buf, i;
+              if (fill_size == 1)
+                {
+                  n_per_buf = sizeof (buf);
+                  memset (buf, *fill_literal, n_per_buf);
+                }
+              else
+                {
+                  char *bufp;
+                  n_per_buf = sizeof(buf)/fill_size;
+                  for (i = n_per_buf, bufp = buf; i; i--, bufp += fill_size)
+                    memcpy(bufp, fill_literal, fill_size);
+                }
+              for (; count > 0; count -= n_per_buf)
+                {
+                  n_per_buf = n_per_buf > count ? count : n_per_buf;
+                  x = bfd_set_section_contents (stdoutput, sec,
+                                                buf, (file_ptr) offset,
+                                                (bfd_size_type) n_per_buf * fill_size);
+                  if (x != true)
+                    as_fatal (_("Cannot write to output file."));
+                  offset += n_per_buf * fill_size;
+                }
+            }
+        }
     }
 }
 #endif
@@ -1248,21 +1248,21 @@ relax_and_size_all_segments ()
 
       H_SET_DATA_SIZE (&headers, data_last_frag->fr_address);
       data_last_frag->fr_address = H_GET_DATA_SIZE (&headers);
-      slide = H_GET_TEXT_SIZE (&headers);	/* & in file of the data segment. */
+      slide = H_GET_TEXT_SIZE (&headers);       /* & in file of the data segment. */
 #ifdef OBJ_BOUT
 #define RoundUp(N,S) (((N)+(S)-1)&-(S))
       /* For b.out: If the data section has a strict alignment
-	 requirement, its load address in the .o file will be
-	 rounded up from the size of the text section.  These
-	 two values are *not* the same!  Similarly for the bss
-	 section....  */
+         requirement, its load address in the .o file will be
+         rounded up from the size of the text section.  These
+         two values are *not* the same!  Similarly for the bss
+         section....  */
       slide = RoundUp (slide, 1 << section_alignment[SEG_DATA]);
 #endif
 
       for (fragP = data_frag_root; fragP; fragP = fragP->fr_next)
-	{
-	  fragP->fr_address += slide;
-	}			/* for each data frag */
+        {
+          fragP->fr_address += slide;
+        }                       /* for each data frag */
 
       know (text_last_frag != 0);
       text_last_frag->fr_next = data_frag_root;
@@ -1285,7 +1285,7 @@ relax_and_size_all_segments ()
   }
 #else /* ! OBJ_BOUT */
   bss_address_frag.fr_address = (H_GET_TEXT_SIZE (&headers) +
-				 H_GET_DATA_SIZE (&headers));
+                                 H_GET_DATA_SIZE (&headers));
 
 #endif /* ! OBJ_BOUT */
 
@@ -1295,14 +1295,14 @@ relax_and_size_all_segments ()
       relax_addressT slide = bss_address_frag.fr_address;
 
       for (fragP = bss_frag_root; fragP; fragP = fragP->fr_next)
-	{
-	  fragP->fr_address += slide;
-	}			/* for each bss frag */
+        {
+          fragP->fr_address += slide;
+        }                       /* for each bss frag */
     }
 
   if (bss_last_frag)
     H_SET_BSS_SIZE (&headers,
-		    bss_last_frag->fr_address - bss_frag_root->fr_address);
+                    bss_last_frag->fr_address - bss_frag_root->fr_address);
   else
     H_SET_BSS_SIZE (&headers, 0);
 }
@@ -1332,13 +1332,13 @@ set_symtab ()
       int i;
 
       asympp = (asymbol **) bfd_alloc (stdoutput,
-				       nsyms * sizeof (asymbol *));
+                                       nsyms * sizeof (asymbol *));
       symp = symbol_rootP;
       for (i = 0; i < nsyms; i++, symp = symbol_next (symp))
-	{
-	  asympp[i] = symbol_get_bfdsym (symp);
-	  symbol_mark_written (symp);
-	}
+        {
+          asympp[i] = symbol_get_bfdsym (symp);
+          symbol_mark_written (symp);
+        }
     }
   else
     asympp = 0;
@@ -1375,14 +1375,14 @@ subsegs_finish ()
          any alignment is meaningless, and, moreover, will look weird
          if we are generating a listing.  */
       frag_align (had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg),
-		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
-		  0);
+                  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
+                  0);
 
       /* frag_align will have left a new frag.
-	 Use this last frag for an empty ".fill".
+         Use this last frag for an empty ".fill".
 
-	 For this segment ...
-	 Create a last frag. Do not leave a "being filled in frag".  */
+         For this segment ...
+         Create a last frag. Do not leave a "being filled in frag".  */
 
       frag_wane (frag_now);
       frag_now->fr_fix = 0;
@@ -1396,7 +1396,7 @@ void
 write_object_file ()
 {
 #if ! defined (BFD_ASSEMBLER) || ! defined (WORKING_DOT_WORD)
-  fragS *fragP;			/* Track along all frags. */
+  fragS *fragP;                 /* Track along all frags. */
 #endif
 
   /* Do we really want to write it?  */
@@ -1408,21 +1408,21 @@ write_object_file ()
        regardless of warnings and errors.  */
     if (flag_always_generate_output)
       {
-	if (n_warns || n_errs)
-	  as_warn (_("%d error%s, %d warning%s, generating bad object file.\n"),
-		   n_errs, n_errs == 1 ? "" : "s",
-		   n_warns, n_warns == 1 ? "" : "s");
+        if (n_warns || n_errs)
+          as_warn (_("%d error%s, %d warning%s, generating bad object file.\n"),
+                   n_errs, n_errs == 1 ? "" : "s",
+                   n_warns, n_warns == 1 ? "" : "s");
       }
     else
       {
-	if (n_errs)
-	  as_fatal (_("%d error%s, %d warning%s, no object file generated.\n"),
-		    n_errs, n_errs == 1 ? "" : "s",
-		    n_warns, n_warns == 1 ? "" : "s");
+        if (n_errs)
+          as_fatal (_("%d error%s, %d warning%s, no object file generated.\n"),
+                    n_errs, n_errs == 1 ? "" : "s",
+                    n_warns, n_warns == 1 ? "" : "s");
       }
   }
 
-#ifdef	OBJ_VMS
+#ifdef  OBJ_VMS
   /* Under VMS we try to be compatible with VAX-11 "C".  Thus, we call
      a routine to check for the definition of the procedure "_main",
      and if so -- fix it up so that it can be program entry point. */
@@ -1441,17 +1441,17 @@ write_object_file ()
     seclist = &stdoutput->sections;
     while (seclist && *seclist)
       {
-	sec = *seclist;
-	while (sec == reg_section || sec == expr_section)
-	  {
-	    sec = sec->next;
-	    *seclist = sec;
-	    stdoutput->section_count--;
-	    if (!sec)
-	      break;
-	  }
-	if (*seclist)
-	  seclist = &(*seclist)->next;
+        sec = *seclist;
+        while (sec == reg_section || sec == expr_section)
+          {
+            sec = sec->next;
+            *seclist = sec;
+            stdoutput->section_count--;
+            if (!sec)
+              break;
+          }
+        if (*seclist)
+          seclist = &(*seclist)->next;
       }
     i = 0;
     bfd_map_over_sections (stdoutput, renumber_sections, &i);
@@ -1527,7 +1527,7 @@ write_object_file ()
          which may call fix_new.  We need to ensure that fix_new adds
          the fixup to the right section.  */
       if (fragP == data_frag_root)
-	subseg_change (SEG_DATA, 0);
+        subseg_change (SEG_DATA, 0);
 
       cvt_frag_to_fill (&headers, SEG_TEXT, fragP);
 
@@ -1535,11 +1535,11 @@ write_object_file ()
 #ifndef NDEBUG
       if (!(fragP->fr_next == NULL
 #ifdef OBJ_BOUT
-	    || fragP->fr_next == data_frag_root
+            || fragP->fr_next == data_frag_root
 #endif
-	    || ((fragP->fr_next->fr_address - fragP->fr_address)
-		== (fragP->fr_fix + fragP->fr_offset * fragP->fr_var))))
-	abort ();
+            || ((fragP->fr_next->fr_address - fragP->fr_address)
+                == (fragP->fr_fix + fragP->fr_offset * fragP->fr_var))))
+        abort ();
 #endif
     }
 #endif /* ! BFD_ASSEMBLER */
@@ -1552,108 +1552,108 @@ write_object_file ()
     prevP = &broken_words;
     for (lie = broken_words; lie; lie = lie->next_broken_word)
       if (!lie->added)
-	{
-	  expressionS exp;
-
-	  subseg_change (lie->seg, lie->subseg);
-	  exp.X_op = O_subtract;
-	  exp.X_add_symbol = lie->add;
-	  exp.X_op_symbol = lie->sub;
-	  exp.X_add_number = lie->addnum;
+        {
+          expressionS exp;
+
+          subseg_change (lie->seg, lie->subseg);
+          exp.X_op = O_subtract;
+          exp.X_add_symbol = lie->add;
+          exp.X_op_symbol = lie->sub;
+          exp.X_add_number = lie->addnum;
 #ifdef BFD_ASSEMBLER
 #ifdef TC_CONS_FIX_NEW
-	  TC_CONS_FIX_NEW (lie->frag,
-		       lie->word_goes_here - lie->frag->fr_literal,
-		       2, &exp);
+          TC_CONS_FIX_NEW (lie->frag,
+                       lie->word_goes_here - lie->frag->fr_literal,
+                       2, &exp);
 #else
-	  fix_new_exp (lie->frag,
-		       lie->word_goes_here - lie->frag->fr_literal,
-		       2, &exp, 0, BFD_RELOC_16);
+          fix_new_exp (lie->frag,
+                       lie->word_goes_here - lie->frag->fr_literal,
+                       2, &exp, 0, BFD_RELOC_16);
 #endif
 #else
 #if defined(TC_SPARC) || defined(TC_A29K) || defined(NEED_FX_R_TYPE)
-	  fix_new_exp (lie->frag,
-		       lie->word_goes_here - lie->frag->fr_literal,
-		       2, &exp, 0, NO_RELOC);
+          fix_new_exp (lie->frag,
+                       lie->word_goes_here - lie->frag->fr_literal,
+                       2, &exp, 0, NO_RELOC);
 #else
 #ifdef TC_NS32K
-	  fix_new_ns32k_exp (lie->frag,
-			     lie->word_goes_here - lie->frag->fr_literal,
-			     2, &exp, 0, 0, 2, 0, 0);
+          fix_new_ns32k_exp (lie->frag,
+                             lie->word_goes_here - lie->frag->fr_literal,
+                             2, &exp, 0, 0, 2, 0, 0);
 #else
-	  fix_new_exp (lie->frag,
-		       lie->word_goes_here - lie->frag->fr_literal,
-		       2, &exp, 0, 0);
+          fix_new_exp (lie->frag,
+                       lie->word_goes_here - lie->frag->fr_literal,
+                       2, &exp, 0, 0);
 #endif /* TC_NS32K */
 #endif /* TC_SPARC|TC_A29K|NEED_FX_R_TYPE */
 #endif /* BFD_ASSEMBLER */
-	  *prevP = lie->next_broken_word;
-	}
+          *prevP = lie->next_broken_word;
+        }
       else
-	prevP = &(lie->next_broken_word);
+        prevP = &(lie->next_broken_word);
 
     for (lie = broken_words; lie;)
       {
-	struct broken_word *untruth;
-	char *table_ptr;
-	addressT table_addr;
-	addressT from_addr, to_addr;
-	int n, m;
-
-	subseg_change (lie->seg, lie->subseg);
-	fragP = lie->dispfrag;
-
-	/* Find out how many broken_words go here.  */
-	n = 0;
-	for (untruth = lie; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
-	  if (untruth->added == 1)
-	    n++;
-
-	table_ptr = lie->dispfrag->fr_opcode;
-	table_addr = lie->dispfrag->fr_address + (table_ptr - lie->dispfrag->fr_literal);
-	/* Create the jump around the long jumps.  This is a short
-	   jump from table_ptr+0 to table_ptr+n*long_jump_size.  */
-	from_addr = table_addr;
-	to_addr = table_addr + md_short_jump_size + n * md_long_jump_size;
-	md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
-	table_ptr += md_short_jump_size;
-	table_addr += md_short_jump_size;
-
-	for (m = 0; lie && lie->dispfrag == fragP; m++, lie = lie->next_broken_word)
-	  {
-	    if (lie->added == 2)
-	      continue;
-	    /* Patch the jump table */
-	    /* This is the offset from ??? to table_ptr+0 */
-	    to_addr = table_addr - S_GET_VALUE (lie->sub);
+        struct broken_word *untruth;
+        char *table_ptr;
+        addressT table_addr;
+        addressT from_addr, to_addr;
+        int n, m;
+
+        subseg_change (lie->seg, lie->subseg);
+        fragP = lie->dispfrag;
+
+        /* Find out how many broken_words go here.  */
+        n = 0;
+        for (untruth = lie; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
+          if (untruth->added == 1)
+            n++;
+
+        table_ptr = lie->dispfrag->fr_opcode;
+        table_addr = lie->dispfrag->fr_address + (table_ptr - lie->dispfrag->fr_literal);
+        /* Create the jump around the long jumps.  This is a short
+           jump from table_ptr+0 to table_ptr+n*long_jump_size.  */
+        from_addr = table_addr;
+        to_addr = table_addr + md_short_jump_size + n * md_long_jump_size;
+        md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
+        table_ptr += md_short_jump_size;
+        table_addr += md_short_jump_size;
+
+        for (m = 0; lie && lie->dispfrag == fragP; m++, lie = lie->next_broken_word)
+          {
+            if (lie->added == 2)
+              continue;
+            /* Patch the jump table */
+            /* This is the offset from ??? to table_ptr+0 */
+            to_addr = table_addr - S_GET_VALUE (lie->sub);
 #ifdef BFD_ASSEMBLER
-	    to_addr -= symbol_get_frag (lie->sub)->fr_address;
-#endif
-	    md_number_to_chars (lie->word_goes_here, to_addr, 2);
-	    for (untruth = lie->next_broken_word; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
-	      {
-		if (untruth->use_jump == lie)
-		  md_number_to_chars (untruth->word_goes_here, to_addr, 2);
-	      }
-
-	    /* Install the long jump */
-	    /* this is a long jump from table_ptr+0 to the final target */
-	    from_addr = table_addr;
-	    to_addr = S_GET_VALUE (lie->add) + lie->addnum;
+            to_addr -= symbol_get_frag (lie->sub)->fr_address;
+#endif
+            md_number_to_chars (lie->word_goes_here, to_addr, 2);
+            for (untruth = lie->next_broken_word; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
+              {
+                if (untruth->use_jump == lie)
+                  md_number_to_chars (untruth->word_goes_here, to_addr, 2);
+              }
+
+            /* Install the long jump */
+            /* this is a long jump from table_ptr+0 to the final target */
+            from_addr = table_addr;
+            to_addr = S_GET_VALUE (lie->add) + lie->addnum;
 #ifdef BFD_ASSEMBLER
-	    to_addr += symbol_get_frag (lie->add)->fr_address;
+            to_addr += symbol_get_frag (lie->add)->fr_address;
 #endif
-	    md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
-	    table_ptr += md_long_jump_size;
-	    table_addr += md_long_jump_size;
-	  }
+            md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
+            table_ptr += md_long_jump_size;
+            table_addr += md_long_jump_size;
+          }
       }
   }
 #endif /* not WORKING_DOT_WORD */
 
 #ifndef BFD_ASSEMBLER
-#ifndef	OBJ_VMS
-  {				/* not vms */
+#ifndef OBJ_VMS
+  {                             /* not vms */
     char *the_object_file;
     long object_file_size;
     /*
@@ -1672,7 +1672,7 @@ write_object_file ()
     H_SET_MAGIC_NUMBER (&headers, magic_number_for_object_file);
     H_SET_ENTRY_POINT (&headers, 0);
 
-    obj_pre_write_hook (&headers);	/* extra coff stuff */
+    obj_pre_write_hook (&headers);      /* extra coff stuff */
 
     object_file_size = H_GET_FILE_SIZE (&headers);
     next_object_file_charP = the_object_file = xmalloc (object_file_size);
@@ -1688,23 +1688,23 @@ write_object_file ()
      */
     for (fragP = text_frag_root; fragP; fragP = fragP->fr_next)
       {
-	register long count;
-	register char *fill_literal;
-	register long fill_size;
+        register long count;
+        register char *fill_literal;
+        register long fill_size;
 
-	PROGRESS (1);
-	know (fragP->fr_type == rs_fill);
-	append (&next_object_file_charP, fragP->fr_literal, (unsigned long) fragP->fr_fix);
-	fill_literal = fragP->fr_literal + fragP->fr_fix;
-	fill_size = fragP->fr_var;
-	know (fragP->fr_offset >= 0);
+        PROGRESS (1);
+        know (fragP->fr_type == rs_fill);
+        append (&next_object_file_charP, fragP->fr_literal, (unsigned long) fragP->fr_fix);
+        fill_literal = fragP->fr_literal + fragP->fr_fix;
+        fill_size = fragP->fr_var;
+        know (fragP->fr_offset >= 0);
 
-	for (count = fragP->fr_offset; count; count--)
-	  {
-	    append (&next_object_file_charP, fill_literal, (unsigned long) fill_size);
-	  }			/* for each  */
+        for (count = fragP->fr_offset; count; count--)
+          {
+            append (&next_object_file_charP, fill_literal, (unsigned long) fill_size);
+          }                     /* for each  */
 
-      }				/* for each code frag. */
+      }                         /* for each code frag. */
 
     know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers)));
 
@@ -1743,8 +1743,8 @@ write_object_file ()
 
     if (string_byte_count > 0)
       {
-	obj_emit_strings (&next_object_file_charP);
-      }				/* only if we have a string table */
+        obj_emit_strings (&next_object_file_charP);
+      }                         /* only if we have a string table */
 
 #ifdef BFD_HEADERS
     bfd_seek (stdoutput, 0, 0);
@@ -1755,15 +1755,15 @@ write_object_file ()
     output_file_append (the_object_file, object_file_size, out_file_name);
     free (the_object_file);
 #endif
-  }				/* non vms output */
+  }                             /* non vms output */
 #else /* OBJ_VMS */
   /*
-   *	Now do the VMS-dependent part of writing the object file
+   *    Now do the VMS-dependent part of writing the object file
    */
   vms_write_object_file (H_GET_TEXT_SIZE (&headers),
-			 H_GET_DATA_SIZE (&headers),
-			 H_GET_BSS_SIZE (&headers),
-			 text_frag_root, data_frag_root);
+                         H_GET_DATA_SIZE (&headers),
+                         H_GET_BSS_SIZE (&headers),
+                         text_frag_root, data_frag_root);
 #endif /* OBJ_VMS */
 #else /* BFD_ASSEMBLER */
 
@@ -1774,7 +1774,7 @@ write_object_file ()
       symbolS *symp;
 
       for (symp = symbol_rootP; symp; symp = symbol_next (symp))
-	resolve_symbol_value (symp, 1);
+        resolve_symbol_value (symp, 1);
     }
   resolve_local_symbol_values ();
 
@@ -1795,98 +1795,107 @@ write_object_file ()
       symbolS *symp;
 
       for (symp = symbol_rootP; symp; symp = symbol_next (symp))
-	{
-	  int punt = 0;
-	  const char *name;
-
-	  if (symbol_mri_common_p (symp))
-	    {
-	      if (S_IS_EXTERNAL (symp))
-		as_bad (_("%s: global symbols not supported in common sections"),
-			S_GET_NAME (symp));
-	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
-	      continue;
-	    }
-
-	  name = S_GET_NAME (symp);
-	  if (name)
-	    {
-	      const char *name2 = decode_local_label_name ((char *)S_GET_NAME (symp));
-	      /* They only differ if `name' is a fb or dollar local
-		 label name.  */
-	      if (name2 != name && ! S_IS_DEFINED (symp))
-		as_bad (_("local label %s is not defined"), name2);
-	    }
-
-	  /* Do it again, because adjust_reloc_syms might introduce
-	     more symbols.  They'll probably only be section symbols,
-	     but they'll still need to have the values computed.  */
-	  resolve_symbol_value (symp, 1);
-
-	  /* Skip symbols which were equated to undefined or common
+        {
+          int punt = 0;
+          const char *name;
+
+          if (symbol_mri_common_p (symp))
+            {
+              if (S_IS_EXTERNAL (symp))
+                as_bad (_("%s: global symbols not supported in common sections"),
+                        S_GET_NAME (symp));
+              symbol_remove (symp, &symbol_rootP, &symbol_lastP);
+              continue;
+            }
+
+          name = S_GET_NAME (symp);
+          if (name)
+            {
+              const char *name2 = decode_local_label_name ((char *)S_GET_NAME (symp));
+              /* They only differ if `name' is a fb or dollar local
+                 label name.  */
+              if (name2 != name && ! S_IS_DEFINED (symp)){
+                /* add T.Tazaki 2003/01/14 short source name length ==> error : bug fix */
+                /* del T.Tazaki 2003/06/17 >>> */
+//              if( !strncmp( name2,"\"0\" (",5 ) )
+//              {
+//                      continue;               /* skip */
+//              }
+                /* del T.Tazaki 2003/06/17 <<< */
+                /* add T.Tazaki 2003/01/14 short source name length ==> error : bug fix */
+                as_bad (_("local label %s is not defined"), name2);
+              }
+            }
+
+          /* Do it again, because adjust_reloc_syms might introduce
+             more symbols.  They'll probably only be section symbols,
+             but they'll still need to have the values computed.  */
+          resolve_symbol_value (symp, 1);
+
+          /* Skip symbols which were equated to undefined or common
              symbols.  */
-	  if (symbol_equated_p (symp)
-	      && (! S_IS_DEFINED (symp) || S_IS_COMMON (symp)))
-	    {
-	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
-	      continue;
-	    }
-
-	  /* So far, common symbols have been treated like undefined symbols.
-	     Put them in the common section now.  */
-	  if (S_IS_DEFINED (symp) == 0
-	      && S_GET_VALUE (symp) != 0)
-	    S_SET_SEGMENT (symp, bfd_com_section_ptr);
+          if (symbol_equated_p (symp)
+              && (! S_IS_DEFINED (symp) || S_IS_COMMON (symp)))
+            {
+              symbol_remove (symp, &symbol_rootP, &symbol_lastP);
+              continue;
+            }
+
+          /* So far, common symbols have been treated like undefined symbols.
+             Put them in the common section now.  */
+          if (S_IS_DEFINED (symp) == 0
+              && S_GET_VALUE (symp) != 0)
+            S_SET_SEGMENT (symp, bfd_com_section_ptr);
 #if 0
-	  printf ("symbol `%s'\n\t@%x: value=%d flags=%x seg=%s\n",
-		  S_GET_NAME (symp), symp,
-		  S_GET_VALUE (symp),
-		  symbol_get_bfdsym (symp)->flags,
-		  segment_name (S_GET_SEGMENT (symp)));
+          printf ("symbol `%s'\n\t@%x: value=%d flags=%x seg=%s\n",
+                  S_GET_NAME (symp), symp,
+                  S_GET_VALUE (symp),
+                  symbol_get_bfdsym (symp)->flags,
+                  segment_name (S_GET_SEGMENT (symp)));
 #endif
 
 #ifdef obj_frob_symbol
-	  obj_frob_symbol (symp, punt);
+          obj_frob_symbol (symp, punt);
 #endif
 #ifdef tc_frob_symbol
-	  if (! punt || symbol_used_in_reloc_p (symp))
-	    tc_frob_symbol (symp, punt);
-#endif
-
-	  /* If we don't want to keep this symbol, splice it out of
-	     the chain now.  If EMIT_SECTION_SYMBOLS is 0, we never
-	     want section symbols.  Otherwise, we skip local symbols
-	     and symbols that the frob_symbol macros told us to punt,
-	     but we keep such symbols if they are used in relocs.  */
-	  if ((! EMIT_SECTION_SYMBOLS
-	       && symbol_section_p (symp))
-	      /* Note that S_IS_EXTERN and S_IS_LOCAL are not always
-		 opposites.  Sometimes the former checks flags and the
-		 latter examines the name...  */
-	      || (!S_IS_EXTERN (symp)
-		  && (S_IS_LOCAL (symp) || punt)
-		  && ! symbol_used_in_reloc_p (symp)))
-	    {
-	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
-	      /* After symbol_remove, symbol_next(symp) still returns
-		 the one that came after it in the chain.  So we don't
-		 need to do any extra cleanup work here.  */
-
-	      continue;
-	    }
-
-	  /* Make sure we really got a value for the symbol.  */
-	  if (! symbol_resolved_p (symp))
-	    {
-	      as_bad (_("can't resolve value for symbol \"%s\""),
-		      S_GET_NAME (symp));
-	      symbol_mark_resolved (symp);
-	    }
-
-	  /* Set the value into the BFD symbol.  Up til now the value
-	     has only been kept in the gas symbolS struct.  */
-	  symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
-	}
+          if (! punt || symbol_used_in_reloc_p (symp))
+            tc_frob_symbol (symp, punt);
+#endif
+
+          /* If we don't want to keep this symbol, splice it out of
+             the chain now.  If EMIT_SECTION_SYMBOLS is 0, we never
+             want section symbols.  Otherwise, we skip local symbols
+             and symbols that the frob_symbol macros told us to punt,
+             but we keep such symbols if they are used in relocs.  */
+          if ((! EMIT_SECTION_SYMBOLS
+               && symbol_section_p (symp))
+              /* Note that S_IS_EXTERN and S_IS_LOCAL are not always
+                 opposites.  Sometimes the former checks flags and the
+                 latter examines the name...  */
+              || (!S_IS_EXTERN (symp)
+                  && (S_IS_LOCAL (symp) || punt)
+                  && ! symbol_used_in_reloc_p (symp)))
+            {
+              symbol_remove (symp, &symbol_rootP, &symbol_lastP);
+              /* After symbol_remove, symbol_next(symp) still returns
+                 the one that came after it in the chain.  So we don't
+                 need to do any extra cleanup work here.  */
+
+              continue;
+            }
+
+          /* Make sure we really got a value for the symbol.  */
+          if (! symbol_resolved_p (symp))
+            {
+              as_bad (_("can't resolve value for symbol \"%s\""),
+                      S_GET_NAME (symp));
+              symbol_mark_resolved (symp);
+            }
+
+          /* Set the value into the BFD symbol.  Up til now the value
+             has only been kept in the gas symbolS struct.  */
+          symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
+        }
     }
 
   PROGRESS (1);
@@ -1930,7 +1939,7 @@ write_object_file ()
 #endif /* ! BFD */
 
 /*
- *			relax_segment()
+ *                      relax_segment()
  *
  * Now we have a segment, not a crowd of sub-segments, we can make fr_address
  * values.
@@ -1986,30 +1995,30 @@ relax_frag (fragP, stretch)
 #ifndef DIFF_EXPR_OK
 #if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
       know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
-	    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
-	    || (S_GET_SEGMENT (symbolP) == SEG_BSS)
-	    || (S_GET_SEGMENT (symbolP) == SEG_TEXT));
+            || (S_GET_SEGMENT (symbolP) == SEG_DATA)
+            || (S_GET_SEGMENT (symbolP) == SEG_BSS)
+            || (S_GET_SEGMENT (symbolP) == SEG_TEXT));
 #endif
       know (symbolP->sy_frag);
 #endif
       know (!(S_GET_SEGMENT (symbolP) == absolute_section)
-	    || symbolP->sy_frag == &zero_address_frag);
-      target +=	S_GET_VALUE (symbolP) + symbol_get_frag (symbolP)->fr_address;
+            || symbolP->sy_frag == &zero_address_frag);
+      target += S_GET_VALUE (symbolP) + symbol_get_frag (symbolP)->fr_address;
 
       /* If frag has yet to be reached on this pass,
-	 assume it will move by STRETCH just as we did.
-	 If this is not so, it will be because some frag
-	 between grows, and that will force another pass.
+         assume it will move by STRETCH just as we did.
+         If this is not so, it will be because some frag
+         between grows, and that will force another pass.
 
-	 Beware zero-length frags.
+         Beware zero-length frags.
 
-	 There should be a faster way to do this.  */
+         There should be a faster way to do this.  */
 
       if (symbol_get_frag (symbolP)->fr_address >= was_address
-	  && is_dnrange (fragP, symbol_get_frag (symbolP)))
-	{
-	  target += stretch;
-	}
+          && is_dnrange (fragP, symbol_get_frag (symbolP)))
+        {
+          target += stretch;
+        }
     }
 
   aim = target - address - fragP->fr_fix;
@@ -2029,29 +2038,29 @@ relax_frag (fragP, stretch)
     {
       /* Look backwards. */
       for (next_state = this_type->rlx_more; next_state;)
-	if (aim >= this_type->rlx_backward)
-	  next_state = 0;
-	else
-	  {
-	    /* Grow to next state. */
-	    this_state = next_state;
-	    this_type = table + this_state;
-	    next_state = this_type->rlx_more;
-	  }
+        if (aim >= this_type->rlx_backward)
+          next_state = 0;
+        else
+          {
+            /* Grow to next state. */
+            this_state = next_state;
+            this_type = table + this_state;
+            next_state = this_type->rlx_more;
+          }
     }
   else
     {
       /* Look forwards. */
       for (next_state = this_type->rlx_more; next_state;)
-	if (aim <= this_type->rlx_forward)
-	  next_state = 0;
-	else
-	  {
-	    /* Grow to next state. */
-	    this_state = next_state;
-	    this_type = table + this_state;
-	    next_state = this_type->rlx_more;
-	  }
+        if (aim <= this_type->rlx_forward)
+          next_state = 0;
+        else
+          {
+            /* Grow to next state. */
+            this_state = next_state;
+            this_type = table + this_state;
+            next_state = this_type->rlx_more;
+          }
     }
 
   growth = this_type->rlx_length - start_type->rlx_length;
@@ -2066,8 +2075,8 @@ relax_frag (fragP, stretch)
    lowest order bits all 0s, return size of adjustment made.  */
 static relax_addressT
 relax_align (address, alignment)
-     register relax_addressT address;	/* Address now. */
-     register int alignment;	/* Alignment (binary). */
+     register relax_addressT address;   /* Address now. */
+     register int alignment;    /* Alignment (binary). */
 {
   relax_addressT mask;
   relax_addressT new_address;
@@ -2105,283 +2114,283 @@ relax_segment (segment_frag_root, segment)
       address += fragP->fr_fix;
 
       switch (fragP->fr_type)
-	{
-	case rs_fill:
-	  address += fragP->fr_offset * fragP->fr_var;
-	  break;
-
-	case rs_align:
-	case rs_align_code:
-	  {
-	    addressT offset = relax_align (address, (int) fragP->fr_offset);
-
-	    if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
-	      offset = 0;
-
-	    if (offset % fragP->fr_var != 0)
-	      {
-		as_bad (_("alignment padding (%lu bytes) not a multiple of %ld"),
-			(unsigned long) offset, (long) fragP->fr_var);
-		offset -= (offset % fragP->fr_var);
-	      }
-
-	    address += offset;
-	  }
-	  break;
-
-	case rs_org:
-	case rs_space:
-	  /* Assume .org is nugatory. It will grow with 1st relax.  */
-	  break;
-
-	case rs_machine_dependent:
-	  address += md_estimate_size_before_relax (fragP, segment);
-	  break;
+        {
+        case rs_fill:
+          address += fragP->fr_offset * fragP->fr_var;
+          break;
+
+        case rs_align:
+        case rs_align_code:
+          {
+            addressT offset = relax_align (address, (int) fragP->fr_offset);
+
+            if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
+              offset = 0;
+
+            if (offset % fragP->fr_var != 0)
+              {
+                as_bad (_("alignment padding (%lu bytes) not a multiple of %ld"),
+                        (unsigned long) offset, (long) fragP->fr_var);
+                offset -= (offset % fragP->fr_var);
+              }
+
+            address += offset;
+          }
+          break;
+
+        case rs_org:
+        case rs_space:
+          /* Assume .org is nugatory. It will grow with 1st relax.  */
+          break;
+
+        case rs_machine_dependent:
+          address += md_estimate_size_before_relax (fragP, segment);
+          break;
 
 #ifndef WORKING_DOT_WORD
-	  /* Broken words don't concern us yet */
-	case rs_broken_word:
-	  break;
+          /* Broken words don't concern us yet */
+        case rs_broken_word:
+          break;
 #endif
 
-	case rs_leb128:
-	  /* Initial guess is always 1; doing otherwise can result in 
-	     stable solutions that are larger than the minimum.  */
-	  address += fragP->fr_offset = 1;
-	  break;
+        case rs_leb128:
+          /* Initial guess is always 1; doing otherwise can result in 
+             stable solutions that are larger than the minimum.  */
+          address += fragP->fr_offset = 1;
+          break;
 
-	case rs_cfa:
-	  address += eh_frame_estimate_size_before_relax (fragP);
-	  break;
+        case rs_cfa:
+          address += eh_frame_estimate_size_before_relax (fragP);
+          break;
 
-	default:
-	  BAD_CASE (fragP->fr_type);
-	  break;
-	}			/* switch(fr_type) */
-    }				/* for each frag in the segment */
+        default:
+          BAD_CASE (fragP->fr_type);
+          break;
+        }                       /* switch(fr_type) */
+    }                           /* for each frag in the segment */
 
   /* Do relax().  */
   {
-    long stretch;	/* May be any size, 0 or negative. */
+    long stretch;       /* May be any size, 0 or negative. */
     /* Cumulative number of addresses we have */
     /* relaxed this pass. */
     /* We may have relaxed more than one address. */
-    long stretched;	/* Have we stretched on this pass? */
+    long stretched;     /* Have we stretched on this pass? */
     /* This is 'cuz stretch may be zero, when, in fact some piece of code
        grew, and another shrank.  If a branch instruction doesn't fit anymore,
        we could be scrod.  */
 
     do
       {
-	stretch = stretched = 0;
-	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
-	  {
-	    long growth = 0;
-	    addressT was_address;
-	    offsetT offset;
-	    symbolS *symbolP;
-
-	    was_address = fragP->fr_address;
-	    address = fragP->fr_address += stretch;
-	    symbolP = fragP->fr_symbol;
-	    offset = fragP->fr_offset;
-
-	    switch (fragP->fr_type)
-	      {
-	      case rs_fill:	/* .fill never relaxes. */
-		growth = 0;
-		break;
+        stretch = stretched = 0;
+        for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
+          {
+            long growth = 0;
+            addressT was_address;
+            offsetT offset;
+            symbolS *symbolP;
+
+            was_address = fragP->fr_address;
+            address = fragP->fr_address += stretch;
+            symbolP = fragP->fr_symbol;
+            offset = fragP->fr_offset;
+
+            switch (fragP->fr_type)
+              {
+              case rs_fill:     /* .fill never relaxes. */
+                growth = 0;
+                break;
 
 #ifndef WORKING_DOT_WORD
-		/* JF:  This is RMS's idea.  I do *NOT* want to be blamed
-		   for it I do not want to write it.  I do not want to have
-		   anything to do with it.  This is not the proper way to
-		   implement this misfeature.  */
-	      case rs_broken_word:
-		{
-		  struct broken_word *lie;
-		  struct broken_word *untruth;
-
-		  /* Yes this is ugly (storing the broken_word pointer
-		     in the symbol slot).  Still, this whole chunk of
-		     code is ugly, and I don't feel like doing anything
-		     about it.  Think of it as stubbornness in action.  */
-		  growth = 0;
-		  for (lie = (struct broken_word *) (fragP->fr_symbol);
-		       lie && lie->dispfrag == fragP;
-		       lie = lie->next_broken_word)
-		    {
-
-		      if (lie->added)
-			continue;
-
-		      offset = (symbol_get_frag (lie->add)->fr_address
-				+ S_GET_VALUE (lie->add)
-				+ lie->addnum
-				- (symbol_get_frag (lie->sub)->fr_address
-				   + S_GET_VALUE (lie->sub)));
-		      if (offset <= -32768 || offset >= 32767)
-			{
-			  if (flag_warn_displacement)
-			    {
-			      char buf[50];
-			      sprint_value (buf, (addressT) lie->addnum);
-			      as_warn (_(".word %s-%s+%s didn't fit"),
-				       S_GET_NAME (lie->add),
-				       S_GET_NAME (lie->sub),
-				       buf);
-			    }
-			  lie->added = 1;
-			  if (fragP->fr_subtype == 0)
-			    {
-			      fragP->fr_subtype++;
-			      growth += md_short_jump_size;
-			    }
-			  for (untruth = lie->next_broken_word;
-			       untruth && untruth->dispfrag == lie->dispfrag;
-			       untruth = untruth->next_broken_word)
-			    if ((symbol_get_frag (untruth->add)
-				 == symbol_get_frag (lie->add))
-				&& (S_GET_VALUE (untruth->add)
-				    == S_GET_VALUE (lie->add)))
-			      {
-				untruth->added = 2;
-				untruth->use_jump = lie;
-			      }
-			  growth += md_long_jump_size;
-			}
-		    }
-
-		  break;
-		}		/* case rs_broken_word */
-#endif
-	      case rs_align:
-	      case rs_align_code:
-		{
-		  addressT oldoff, newoff;
-
-		  oldoff = relax_align (was_address + fragP->fr_fix,
-					(int) offset);
-		  newoff = relax_align (address + fragP->fr_fix,
-					(int) offset);
-
-		  if (fragP->fr_subtype != 0)
-		    {
-		      if (oldoff > fragP->fr_subtype)
-			oldoff = 0;
-		      if (newoff > fragP->fr_subtype)
-			newoff = 0;
-		    }
-
-		  growth = newoff - oldoff;
-		}
-		break;
-
-	      case rs_org:
-		{
-		  long target = offset;
-		  long after;
-
-		  if (symbolP)
-		    {
+                /* JF:  This is RMS's idea.  I do *NOT* want to be blamed
+                   for it I do not want to write it.  I do not want to have
+                   anything to do with it.  This is not the proper way to
+                   implement this misfeature.  */
+              case rs_broken_word:
+                {
+                  struct broken_word *lie;
+                  struct broken_word *untruth;
+
+                  /* Yes this is ugly (storing the broken_word pointer
+                     in the symbol slot).  Still, this whole chunk of
+                     code is ugly, and I don't feel like doing anything
+                     about it.  Think of it as stubbornness in action.  */
+                  growth = 0;
+                  for (lie = (struct broken_word *) (fragP->fr_symbol);
+                       lie && lie->dispfrag == fragP;
+                       lie = lie->next_broken_word)
+                    {
+
+                      if (lie->added)
+                        continue;
+
+                      offset = (symbol_get_frag (lie->add)->fr_address
+                                + S_GET_VALUE (lie->add)
+                                + lie->addnum
+                                - (symbol_get_frag (lie->sub)->fr_address
+                                   + S_GET_VALUE (lie->sub)));
+                      if (offset <= -32768 || offset >= 32767)
+                        {
+                          if (flag_warn_displacement)
+                            {
+                              char buf[50];
+                              sprint_value (buf, (addressT) lie->addnum);
+                              as_warn (_(".word %s-%s+%s didn't fit"),
+                                       S_GET_NAME (lie->add),
+                                       S_GET_NAME (lie->sub),
+                                       buf);
+                            }
+                          lie->added = 1;
+                          if (fragP->fr_subtype == 0)
+                            {
+                              fragP->fr_subtype++;
+                              growth += md_short_jump_size;
+                            }
+                          for (untruth = lie->next_broken_word;
+                               untruth && untruth->dispfrag == lie->dispfrag;
+                               untruth = untruth->next_broken_word)
+                            if ((symbol_get_frag (untruth->add)
+                                 == symbol_get_frag (lie->add))
+                                && (S_GET_VALUE (untruth->add)
+                                    == S_GET_VALUE (lie->add)))
+                              {
+                                untruth->added = 2;
+                                untruth->use_jump = lie;
+                              }
+                          growth += md_long_jump_size;
+                        }
+                    }
+
+                  break;
+                }               /* case rs_broken_word */
+#endif
+              case rs_align:
+              case rs_align_code:
+                {
+                  addressT oldoff, newoff;
+
+                  oldoff = relax_align (was_address + fragP->fr_fix,
+                                        (int) offset);
+                  newoff = relax_align (address + fragP->fr_fix,
+                                        (int) offset);
+
+                  if (fragP->fr_subtype != 0)
+                    {
+                      if (oldoff > fragP->fr_subtype)
+                        oldoff = 0;
+                      if (newoff > fragP->fr_subtype)
+                        newoff = 0;
+                    }
+
+                  growth = newoff - oldoff;
+                }
+                break;
+
+              case rs_org:
+                {
+                  long target = offset;
+                  long after;
+
+                  if (symbolP)
+                    {
 #if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
-		      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
-			    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
-			    || (S_GET_SEGMENT (symbolP) == SEG_TEXT)
-			    || S_GET_SEGMENT (symbolP) == SEG_BSS);
-		      know (symbolP->sy_frag);
-		      know (!(S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
-			    || (symbolP->sy_frag == &zero_address_frag));
-#endif
-		      target += (S_GET_VALUE (symbolP)
-				 + symbol_get_frag (symbolP)->fr_address);
-		    }		/* if we have a symbol */
-
-		  know (fragP->fr_next);
-		  after = fragP->fr_next->fr_address;
-		  growth = target - after;
-		  if (growth < 0)
-		    {
-		      /* Growth may be negative, but variable part of frag
-			 cannot have fewer than 0 chars.  That is, we can't
-			 .org backwards. */
-		      as_bad_where (fragP->fr_file, fragP->fr_line,
-				    _("attempt to .org backwards ignored"));
-
-		      /* We've issued an error message.  Change the
+                      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
+                            || (S_GET_SEGMENT (symbolP) == SEG_DATA)
+                            || (S_GET_SEGMENT (symbolP) == SEG_TEXT)
+                            || S_GET_SEGMENT (symbolP) == SEG_BSS);
+                      know (symbolP->sy_frag);
+                      know (!(S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
+                            || (symbolP->sy_frag == &zero_address_frag));
+#endif
+                      target += (S_GET_VALUE (symbolP)
+                                 + symbol_get_frag (symbolP)->fr_address);
+                    }           /* if we have a symbol */
+
+                  know (fragP->fr_next);
+                  after = fragP->fr_next->fr_address;
+                  growth = target - after;
+                  if (growth < 0)
+                    {
+                      /* Growth may be negative, but variable part of frag
+                         cannot have fewer than 0 chars.  That is, we can't
+                         .org backwards. */
+                      as_bad_where (fragP->fr_file, fragP->fr_line,
+                                    _("attempt to .org backwards ignored"));
+
+                      /* We've issued an error message.  Change the
                          frag to avoid cascading errors.  */
-		      fragP->fr_type = rs_align;
-		      fragP->fr_subtype = 0;
-		      fragP->fr_offset = 0;
-		      fragP->fr_fix = after - address;
-		      growth = stretch;
-		    }
-
-		  growth -= stretch;	/* This is an absolute growth factor */
-		  break;
-		}
-
-	      case rs_space:
-		if (symbolP)
-		  {
-		    growth = S_GET_VALUE (symbolP);
-		    if (symbol_get_frag (symbolP) != &zero_address_frag
-			|| S_IS_COMMON (symbolP)
-			|| ! S_IS_DEFINED (symbolP))
-		      as_bad_where (fragP->fr_file, fragP->fr_line,
-				    _(".space specifies non-absolute value"));
-		    fragP->fr_symbol = 0;
-		    if (growth < 0)
-		      {
-			as_warn (_(".space or .fill with negative value, ignored"));
-			growth = 0;
-		      }
-		  }
-		else
-		  growth = 0;
-		break;
-
-	      case rs_machine_dependent:
+                      fragP->fr_type = rs_align;
+                      fragP->fr_subtype = 0;
+                      fragP->fr_offset = 0;
+                      fragP->fr_fix = after - address;
+                      growth = stretch;
+                    }
+
+                  growth -= stretch;    /* This is an absolute growth factor */
+                  break;
+                }
+
+              case rs_space:
+                if (symbolP)
+                  {
+                    growth = S_GET_VALUE (symbolP);
+                    if (symbol_get_frag (symbolP) != &zero_address_frag
+                        || S_IS_COMMON (symbolP)
+                        || ! S_IS_DEFINED (symbolP))
+                      as_bad_where (fragP->fr_file, fragP->fr_line,
+                                    _(".space specifies non-absolute value"));
+                    fragP->fr_symbol = 0;
+                    if (growth < 0)
+                      {
+                        as_warn (_(".space or .fill with negative value, ignored"));
+                        growth = 0;
+                      }
+                  }
+                else
+                  growth = 0;
+                break;
+
+              case rs_machine_dependent:
 #ifdef md_relax_frag
-		growth = md_relax_frag (fragP, stretch);
+                growth = md_relax_frag (fragP, stretch);
 #else
 #ifdef TC_GENERIC_RELAX_TABLE
-		/* The default way to relax a frag is to look through
-		   TC_GENERIC_RELAX_TABLE.  */
-		growth = relax_frag (fragP, stretch);
+                /* The default way to relax a frag is to look through
+                   TC_GENERIC_RELAX_TABLE.  */
+                growth = relax_frag (fragP, stretch);
 #endif /* TC_GENERIC_RELAX_TABLE */
 #endif
-		break;
-
-	      case rs_leb128:
-		{
-		  valueT value;
-		  int size;
-
-		  value = resolve_symbol_value (fragP->fr_symbol, 0);
-		  size = sizeof_leb128 (value, fragP->fr_subtype);
-		  growth = size - fragP->fr_offset;
-		  fragP->fr_offset = size;
-		}
-		break;
-
-	      case rs_cfa:
-		growth = eh_frame_relax_frag (fragP);
-		break;
-
-	      default:
-		BAD_CASE (fragP->fr_type);
-		break;
-	      }
-	    if (growth)
-	      {
-		stretch += growth;
-		stretched++;
-	      }
-	  }			/* For each frag in the segment. */
+                break;
+
+              case rs_leb128:
+                {
+                  valueT value;
+                  int size;
+
+                  value = resolve_symbol_value (fragP->fr_symbol, 0);
+                  size = sizeof_leb128 (value, fragP->fr_subtype);
+                  growth = size - fragP->fr_offset;
+                  fragP->fr_offset = size;
+                }
+                break;
+
+              case rs_cfa:
+                growth = eh_frame_relax_frag (fragP);
+                break;
+
+              default:
+                BAD_CASE (fragP->fr_type);
+                break;
+              }
+            if (growth)
+              {
+                stretch += growth;
+                stretched++;
+              }
+          }                     /* For each frag in the segment. */
       }
-    while (stretched);		/* Until nothing further to relax. */
-  }				/* do_relax */
+    while (stretched);          /* Until nothing further to relax. */
+  }                             /* do_relax */
 
   /*
    * We now have valid fr_address'es for each frag.
@@ -2391,7 +2400,7 @@ relax_segment (segment_frag_root, segment)
    * All fr_address's are correct, relative to their own segment.
    * We have made all the fixS we will ever make.
    */
-}				/* relax_segment() */
+}                               /* relax_segment() */
 
 #if defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS))
 
@@ -2413,7 +2422,7 @@ relax_segment (segment_frag_root, segment)
 static long
 fixup_segment (fixP, this_segment_type)
      register fixS *fixP;
-     segT this_segment_type;	/* N_TYPE bits for segment. */
+     segT this_segment_type;    /* N_TYPE bits for segment. */
 {
   long seg_reloc_count = 0;
   symbolS *add_symbolP;
@@ -2436,7 +2445,7 @@ fixup_segment (fixP, this_segment_type)
   if (linkrelax)
     {
       for (; fixP; fixP = fixP->fx_next)
-	seg_reloc_count++;
+        seg_reloc_count++;
       TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
       return seg_reloc_count;
     }
@@ -2465,307 +2474,307 @@ fixup_segment (fixP, this_segment_type)
       plt = fixP->fx_plt;
 
       if (add_symbolP != NULL
-	  && symbol_mri_common_p (add_symbolP))
-	{
-	  know (add_symbolP->sy_value.X_op == O_symbol);
-	  add_number += S_GET_VALUE (add_symbolP);
-	  fixP->fx_offset = add_number;
-	  add_symbolP = fixP->fx_addsy =
-	    symbol_get_value_expression (add_symbolP)->X_add_symbol;
-	}
+          && symbol_mri_common_p (add_symbolP))
+        {
+          know (add_symbolP->sy_value.X_op == O_symbol);
+          add_number += S_GET_VALUE (add_symbolP);
+          fixP->fx_offset = add_number;
+          add_symbolP = fixP->fx_addsy =
+            symbol_get_value_expression (add_symbolP)->X_add_symbol;
+        }
 
       if (add_symbolP)
-	add_symbol_segment = S_GET_SEGMENT (add_symbolP);
+        add_symbol_segment = S_GET_SEGMENT (add_symbolP);
 
       if (sub_symbolP)
-	{
-	  resolve_symbol_value (sub_symbolP, 1);
-	  if (add_symbolP == NULL || add_symbol_segment == absolute_section)
-	    {
-	      if (add_symbolP != NULL)
-		{
-		  add_number += S_GET_VALUE (add_symbolP);
-		  add_symbolP = NULL;
-		  fixP->fx_addsy = NULL;
-		}
-
-	      /* It's just -sym */
-	      if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
-		{
-		  add_number -= S_GET_VALUE (sub_symbolP);
-		  fixP->fx_subsy = NULL;
-		}
-	      else if (pcrel
-		       && S_GET_SEGMENT (sub_symbolP) == this_segment_type)
-		{
-		  /* Should try converting to a constant.  */
-		  goto bad_sub_reloc;
-		}
-	      else
-	      bad_sub_reloc:
-		as_bad_where (fixP->fx_file, fixP->fx_line,
-			      _("Negative of non-absolute symbol %s"),
-			      S_GET_NAME (sub_symbolP));
-	    }
-	  else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
-		   && SEG_NORMAL (add_symbol_segment))
-	    {
-	      /* Difference of 2 symbols from same segment.
-		 Can't make difference of 2 undefineds: 'value' means
-		 something different for N_UNDF. */
+        {
+          resolve_symbol_value (sub_symbolP, 1);
+          if (add_symbolP == NULL || add_symbol_segment == absolute_section)
+            {
+              if (add_symbolP != NULL)
+                {
+                  add_number += S_GET_VALUE (add_symbolP);
+                  add_symbolP = NULL;
+                  fixP->fx_addsy = NULL;
+                }
+
+              /* It's just -sym */
+              if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
+                {
+                  add_number -= S_GET_VALUE (sub_symbolP);
+                  fixP->fx_subsy = NULL;
+                }
+              else if (pcrel
+                       && S_GET_SEGMENT (sub_symbolP) == this_segment_type)
+                {
+                  /* Should try converting to a constant.  */
+                  goto bad_sub_reloc;
+                }
+              else
+              bad_sub_reloc:
+                as_bad_where (fixP->fx_file, fixP->fx_line,
+                              _("Negative of non-absolute symbol %s"),
+                              S_GET_NAME (sub_symbolP));
+            }
+          else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
+                   && SEG_NORMAL (add_symbol_segment))
+            {
+              /* Difference of 2 symbols from same segment.
+                 Can't make difference of 2 undefineds: 'value' means
+                 something different for N_UNDF. */
 #ifdef TC_I960
-	      /* Makes no sense to use the difference of 2 arbitrary symbols
-		 as the target of a call instruction.  */
-	      if (fixP->fx_tcbit)
-		as_bad_where (fixP->fx_file, fixP->fx_line,
-			      _("callj to difference of 2 symbols"));
+              /* Makes no sense to use the difference of 2 arbitrary symbols
+                 as the target of a call instruction.  */
+              if (fixP->fx_tcbit)
+                as_bad_where (fixP->fx_file, fixP->fx_line,
+                              _("callj to difference of 2 symbols"));
 #endif /* TC_I960 */
-	      add_number += S_GET_VALUE (add_symbolP) -
-		S_GET_VALUE (sub_symbolP);
-
-	      add_symbolP = NULL;
-	      pcrel = 0;	/* No further pcrel processing. */
-
-	      /* Let the target machine make the final determination
-		 as to whether or not a relocation will be needed to
-		 handle this fixup.  */
-	      if (!TC_FORCE_RELOCATION_SECTION (fixP, this_segment_type))
-		{
-		  fixP->fx_pcrel = 0;
-		  fixP->fx_addsy = NULL;
-		  fixP->fx_subsy = NULL;
-		}
-	    }
-	  else
-	    {
-	      /* Different segments in subtraction. */
-	      know (!(S_IS_EXTERNAL (sub_symbolP)
-		      && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));
-
-	      if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
-		add_number -= S_GET_VALUE (sub_symbolP);
+              add_number += S_GET_VALUE (add_symbolP) -
+                S_GET_VALUE (sub_symbolP);
+
+              add_symbolP = NULL;
+              pcrel = 0;        /* No further pcrel processing. */
+
+              /* Let the target machine make the final determination
+                 as to whether or not a relocation will be needed to
+                 handle this fixup.  */
+              if (!TC_FORCE_RELOCATION_SECTION (fixP, this_segment_type))
+                {
+                  fixP->fx_pcrel = 0;
+                  fixP->fx_addsy = NULL;
+                  fixP->fx_subsy = NULL;
+                }
+            }
+          else
+            {
+              /* Different segments in subtraction. */
+              know (!(S_IS_EXTERNAL (sub_symbolP)
+                      && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));
+
+              if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
+                add_number -= S_GET_VALUE (sub_symbolP);
 
 #ifdef DIFF_EXPR_OK
-	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type
+              else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type
 #if 0 /* Do this even if it's already described as pc-relative.  For example,
-	 on the m68k, an operand of "pc@(foo-.-2)" should address "foo" in a
-	 pc-relative mode.  */
-		       && pcrel
-#endif
-		       )
-		{
-		  /* Make it pc-relative.  */
-		  add_number += (MD_PCREL_FROM_SECTION (fixP, this_segment_type)
-				 - S_GET_VALUE (sub_symbolP));
-		  pcrel = 1;
-		  fixP->fx_pcrel = 1;
-		  sub_symbolP = 0;
-		  fixP->fx_subsy = 0;
-		}
+         on the m68k, an operand of "pc@(foo-.-2)" should address "foo" in a
+         pc-relative mode.  */
+                       && pcrel
+#endif
+                       )
+                {
+                  /* Make it pc-relative.  */
+                  add_number += (MD_PCREL_FROM_SECTION (fixP, this_segment_type)
+                                 - S_GET_VALUE (sub_symbolP));
+                  pcrel = 1;
+                  fixP->fx_pcrel = 1;
+                  sub_symbolP = 0;
+                  fixP->fx_subsy = 0;
+                }
 #endif
 #ifdef UNDEFINED_DIFFERENCE_OK
-	      /* The PA needs this for PIC code generation.  We basically
-		 don't want to do anything if we have the difference of two
-		 symbols at this point.  */
-	      else if (1)
-		{
-		  /* Leave it alone.  */
-		}
+              /* The PA needs this for PIC code generation.  We basically
+                 don't want to do anything if we have the difference of two
+                 symbols at this point.  */
+              else if (1)
+                {
+                  /* Leave it alone.  */
+                }
 #endif
 #ifdef BFD_ASSEMBLER
-	      else if (fixP->fx_r_type == BFD_RELOC_GPREL32
-		       || fixP->fx_r_type == BFD_RELOC_GPREL16)
-		{
-		  /* Leave it alone.  */
-		}
-#endif
-	      else
-		{
-		  char buf[50];
-		  sprint_value (buf, fragP->fr_address + where);
-		  as_bad_where (fixP->fx_file, fixP->fx_line,
-				_("Subtraction of two symbols in different sections \"%s\" {%s section} - \"%s\" {%s section} at file address %s."),
-				S_GET_NAME (add_symbolP),
-				segment_name (S_GET_SEGMENT (add_symbolP)),
-				S_GET_NAME (sub_symbolP),
-				segment_name (S_GET_SEGMENT (sub_symbolP)),
-				buf);
-		}
-	    }
-	}
+              else if (fixP->fx_r_type == BFD_RELOC_GPREL32
+                       || fixP->fx_r_type == BFD_RELOC_GPREL16)
+                {
+                  /* Leave it alone.  */
+                }
+#endif
+              else
+                {
+                  char buf[50];
+                  sprint_value (buf, fragP->fr_address + where);
+                  as_bad_where (fixP->fx_file, fixP->fx_line,
+                                _("Subtraction of two symbols in different sections \"%s\" {%s section} - \"%s\" {%s section} at file address %s."),
+                                S_GET_NAME (add_symbolP),
+                                segment_name (S_GET_SEGMENT (add_symbolP)),
+                                S_GET_NAME (sub_symbolP),
+                                segment_name (S_GET_SEGMENT (sub_symbolP)),
+                                buf);
+                }
+            }
+        }
 
       if (add_symbolP)
-	{
-	  if (add_symbol_segment == this_segment_type && pcrel && !plt
-	      && TC_RELOC_RTSYM_LOC_FIXUP (fixP))
-	    {
-	      /*
-	       * This fixup was made when the symbol's segment was
-	       * SEG_UNKNOWN, but it is now in the local segment.
-	       * So we know how to do the address without relocation.
-	       */
+        {
+          if (add_symbol_segment == this_segment_type && pcrel && !plt
+              && TC_RELOC_RTSYM_LOC_FIXUP (fixP))
+            {
+              /*
+               * This fixup was made when the symbol's segment was
+               * SEG_UNKNOWN, but it is now in the local segment.
+               * So we know how to do the address without relocation.
+               */
 #ifdef TC_I960
-	      /* reloc_callj() may replace a 'call' with a 'calls' or a
-		 'bal', in which cases it modifies *fixP as appropriate.
-		 In the case of a 'calls', no further work is required,
-		 and *fixP has been set up to make the rest of the code
-		 below a no-op. */
-	      reloc_callj (fixP);
+              /* reloc_callj() may replace a 'call' with a 'calls' or a
+                 'bal', in which cases it modifies *fixP as appropriate.
+                 In the case of a 'calls', no further work is required,
+                 and *fixP has been set up to make the rest of the code
+                 below a no-op. */
+              reloc_callj (fixP);
 #endif /* TC_I960 */
 
-	      add_number += S_GET_VALUE (add_symbolP);
-	      add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
-	      pcrel = 0;	/* Lie. Don't want further pcrel processing. */
-
-	      /* Let the target machine make the final determination
-		 as to whether or not a relocation will be needed to
-		 handle this fixup.  */
-	      if (!TC_FORCE_RELOCATION (fixP))
-		{
-		  fixP->fx_pcrel = 0;
-		  fixP->fx_addsy = NULL;
-		}
-	    }
-	  else
-	    {
-	      if (add_symbol_segment == absolute_section
-		  && ! pcrel)
-		{
+              add_number += S_GET_VALUE (add_symbolP);
+              add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
+              pcrel = 0;        /* Lie. Don't want further pcrel processing. */
+
+              /* Let the target machine make the final determination
+                 as to whether or not a relocation will be needed to
+                 handle this fixup.  */
+              if (!TC_FORCE_RELOCATION (fixP))
+                {
+                  fixP->fx_pcrel = 0;
+                  fixP->fx_addsy = NULL;
+                }
+            }
+          else
+            {
+              if (add_symbol_segment == absolute_section
+                  && ! pcrel)
+                {
 #ifdef TC_I960
-		  /* See comment about reloc_callj() above.  */
-		  reloc_callj (fixP);
+                  /* See comment about reloc_callj() above.  */
+                  reloc_callj (fixP);
 #endif /* TC_I960 */
-		  add_number += S_GET_VALUE (add_symbolP);
-
-		  /* Let the target machine make the final determination
-		     as to whether or not a relocation will be needed to
-		     handle this fixup.  */
-
-		  if (!TC_FORCE_RELOCATION (fixP))
-		    {
-		      fixP->fx_addsy = NULL;
-		      add_symbolP = NULL;
-		    }
-		}
-	      else if (add_symbol_segment == undefined_section
+                  add_number += S_GET_VALUE (add_symbolP);
+
+                  /* Let the target machine make the final determination
+                     as to whether or not a relocation will be needed to
+                     handle this fixup.  */
+
+                  if (!TC_FORCE_RELOCATION (fixP))
+                    {
+                      fixP->fx_addsy = NULL;
+                      add_symbolP = NULL;
+                    }
+                }
+              else if (add_symbol_segment == undefined_section
 #ifdef BFD_ASSEMBLER
-		       || bfd_is_com_section (add_symbol_segment)
+                       || bfd_is_com_section (add_symbol_segment)
 #endif
-		       )
-		{
+                       )
+                {
 #ifdef TC_I960
-		  if ((int) fixP->fx_bit_fixP == 13)
-		    {
-		      /* This is a COBR instruction.  They have only a
-		       * 13-bit displacement and are only to be used
-		       * for local branches: flag as error, don't generate
-		       * relocation.
-		       */
-		      as_bad_where (fixP->fx_file, fixP->fx_line,
-				    _("can't use COBR format with external label"));
-		      fixP->fx_addsy = NULL;
-		      fixP->fx_done = 1;
-		      continue;
-		    }		/* COBR */
+                  if ((int) fixP->fx_bit_fixP == 13)
+                    {
+                      /* This is a COBR instruction.  They have only a
+                       * 13-bit displacement and are only to be used
+                       * for local branches: flag as error, don't generate
+                       * relocation.
+                       */
+                      as_bad_where (fixP->fx_file, fixP->fx_line,
+                                    _("can't use COBR format with external label"));
+                      fixP->fx_addsy = NULL;
+                      fixP->fx_done = 1;
+                      continue;
+                    }           /* COBR */
 #endif /* TC_I960 */
 
 #ifdef OBJ_COFF
 #ifdef TE_I386AIX
-		  if (S_IS_COMMON (add_symbolP))
-		    add_number += S_GET_VALUE (add_symbolP);
+                  if (S_IS_COMMON (add_symbolP))
+                    add_number += S_GET_VALUE (add_symbolP);
 #endif /* TE_I386AIX */
 #endif /* OBJ_COFF */
-		  ++seg_reloc_count;
-		}
-	      else
-		{
-		  seg_reloc_count++;
+                  ++seg_reloc_count;
+                }
+              else
+                {
+                  seg_reloc_count++;
 #if !(defined (TC_V850) && defined (OBJ_ELF))
 #if !(defined (TC_M68K) && defined (OBJ_ELF))
 #if !(defined (TC_ARM)  && defined (OBJ_ELF))
 #if !(defined (TC_I960) && defined (OBJ_ELF))
 #if !defined (TC_I386) || !(defined (OBJ_ELF) || defined (OBJ_COFF)) || defined (TE_PE)
-		  add_number += S_GET_VALUE (add_symbolP);
+                  add_number += S_GET_VALUE (add_symbolP);
 #endif
 #endif
 #endif
 #endif
 #endif
-		}
-	    }
-	}
+                }
+            }
+        }
 
       if (pcrel)
-	{
-	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
-	  if (add_symbolP == 0)
-	    {
+        {
+          add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
+          if (add_symbolP == 0)
+            {
 #ifndef BFD_ASSEMBLER
-	      fixP->fx_addsy = &abs_symbol;
+              fixP->fx_addsy = &abs_symbol;
 #else
-	      fixP->fx_addsy = section_symbol (absolute_section);
+              fixP->fx_addsy = section_symbol (absolute_section);
 #endif
-	      symbol_mark_used_in_reloc (fixP->fx_addsy);
-	      ++seg_reloc_count;
-	    }
-	}
+              symbol_mark_used_in_reloc (fixP->fx_addsy);
+              ++seg_reloc_count;
+            }
+        }
 
       if (!fixP->fx_done)
-	{
+        {
 #ifdef MD_APPLY_FIX3
-	  md_apply_fix3 (fixP, &add_number, this_segment_type);
+          md_apply_fix3 (fixP, &add_number, this_segment_type);
 #else
 #ifdef BFD_ASSEMBLER
-	  md_apply_fix (fixP, &add_number);
+          md_apply_fix (fixP, &add_number);
 #else
-	  md_apply_fix (fixP, add_number);
+          md_apply_fix (fixP, add_number);
 #endif
 #endif
 
 #ifndef TC_HANDLES_FX_DONE
-	  /* If the tc-* files haven't been converted, assume it's handling
-	     it the old way, where a null fx_addsy means that the fix has
-	     been applied completely, and no further work is needed.  */
-	  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
-	    fixP->fx_done = 1;
+          /* If the tc-* files haven't been converted, assume it's handling
+             it the old way, where a null fx_addsy means that the fix has
+             been applied completely, and no further work is needed.  */
+          if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
+            fixP->fx_done = 1;
 #endif
-	}
+        }
 
       if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && size > 0)
-	{
-	  if ((size_t) size < sizeof (valueT))
-	    {
-	      valueT mask;
-
-	      mask = 0;
-	      mask--;		/* set all bits to one */
-	      mask <<= size * 8 - (fixP->fx_signed ? 1 : 0);
-	      if ((add_number & mask) != 0 && (add_number & mask) != mask)
-		{
-		  char buf[50], buf2[50];
-		  sprint_value (buf, fragP->fr_address + where);
-		  if (add_number > 1000)
-		    sprint_value (buf2, add_number);
-		  else
-		    sprintf (buf2, "%ld", (long) add_number);
-		  as_bad_where (fixP->fx_file, fixP->fx_line,
-				_("Value of %s too large for field of %d bytes at %s"),
-				buf2, size, buf);
-		} /* generic error checking */
-	    }
+        {
+          if ((size_t) size < sizeof (valueT))
+            {
+              valueT mask;
+
+              mask = 0;
+              mask--;           /* set all bits to one */
+              mask <<= size * 8 - (fixP->fx_signed ? 1 : 0);
+              if ((add_number & mask) != 0 && (add_number & mask) != mask)
+                {
+                  char buf[50], buf2[50];
+                  sprint_value (buf, fragP->fr_address + where);
+                  if (add_number > 1000)
+                    sprint_value (buf2, add_number);
+                  else
+                    sprintf (buf2, "%ld", (long) add_number);
+                  as_bad_where (fixP->fx_file, fixP->fx_line,
+                                _("Value of %s too large for field of %d bytes at %s"),
+                                buf2, size, buf);
+                } /* generic error checking */
+            }
 #ifdef WARN_SIGNED_OVERFLOW_WORD
-	  /* Warn if a .word value is too large when treated as a signed
-	     number.  We already know it is not too negative.  This is to
-	     catch over-large switches generated by gcc on the 68k.  */
-	  if (!flag_signed_overflow_ok
-	      && size == 2
-	      && add_number > 0x7fff)
-	    as_bad_where (fixP->fx_file, fixP->fx_line,
-			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
-			  (long) add_number,
-			  (unsigned long) (fragP->fr_address + where));
-#endif
-	}			/* not a bit fix */
+          /* Warn if a .word value is too large when treated as a signed
+             number.  We already know it is not too negative.  This is to
+             catch over-large switches generated by gcc on the 68k.  */
+          if (!flag_signed_overflow_ok
+              && size == 2
+              && add_number > 0x7fff)
+            as_bad_where (fixP->fx_file, fixP->fx_line,
+                          _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
+                          (long) add_number,
+                          (unsigned long) (fragP->fr_address + where));
+#endif
+        }                       /* not a bit fix */
 
 #ifdef TC_VALIDATE_FIX
     skip:  ATTRIBUTE_UNUSED_LABEL
@@ -2775,7 +2784,7 @@ fixup_segment (fixP, this_segment_type)
       fprintf (stderr, "result:\n");
       print_fixup (fixP);
 #endif
-    }				/* For each fixS in this segment. */
+    }                           /* For each fixS in this segment. */
 
   TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
   return seg_reloc_count;
@@ -2846,11 +2855,11 @@ print_fixup (fixp)
   if (fixp->fx_done)
     fprintf (stderr, " done");
   fprintf (stderr, "\n    size=%d frag=%lx where=%ld offset=%lx addnumber=%lx",
-	   fixp->fx_size, (long) fixp->fx_frag, (long) fixp->fx_where,
-	   (long) fixp->fx_offset, (long) fixp->fx_addnumber);
+           fixp->fx_size, (long) fixp->fx_frag, (long) fixp->fx_where,
+           (long) fixp->fx_offset, (long) fixp->fx_addnumber);
 #ifdef BFD_ASSEMBLER
   fprintf (stderr, "\n    %s (%d)", bfd_get_reloc_code_name (fixp->fx_r_type),
-	   fixp->fx_r_type);
+           fixp->fx_r_type);
 #else
 #ifdef NEED_FX_R_TYPE
   fprintf (stderr, " r_type=%d", fixp->fx_r_type);
diff --git a/include/dis-asm.h b/include/dis-asm.h
index 6e6c04b..6ca65a7 100644
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -196,6 +196,10 @@ extern int print_insn_tic80		PARAMS ((bfd_vma, disassemble_info*));
 extern int print_insn_pj		PARAMS ((bfd_vma, disassemble_info*));
 extern int print_insn_avr		PARAMS ((bfd_vma, disassemble_info*));
 
+/* 追加 2001.1.15 ide */
+extern int print_insn_c33		PARAMS ((bfd_vma, disassemble_info*));
+
+
 extern void print_arm_disassembler_options PARAMS ((FILE *));
 extern void parse_arm_disassembler_option  PARAMS ((char *));
 extern int  get_arm_regname_num_options    PARAMS ((void));
diff --git a/include/elf/c33.h b/include/elf/c33.h
new file mode 100644
index 0000000..ccb410f
--- /dev/null
+++ b/include/elf/c33.h
@@ -0,0 +1,128 @@
+/* C33 ELF support for BFD.
+   Copyright (C) 1997,2001 Free Software Foundation, Inc.
+   Created by Michael Meissner, Cygnus Support <meissner@cygnus.com>
+
+This file is part of BFD, the Binary File Descriptor library.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+/* This file holds definitions specific to the MIPS ELF ABI.  Note
+   that most of this is not actually implemented by BFD.  */
+
+#ifndef _ELF_C33_H
+#define _ELF_C33_H
+
+/* Processor specific flags for the ELF header e_flags field.  */
+#if 0	/* c33 */
+/* これらはbinutils\readelf.cで使用している */
+/*	get_machine_flags()でELFヘッダのe_flagsによって、アーキテクチャの文字列を */
+/*	設定している。ｃ３３の場合はどうしたらいいか？	*/
+
+/* Four bit C33 architecture field.  */
+#define EF_V850_ARCH		0xf0000000
+
+/* v850 code.  */
+#define E_V850_ARCH		0x00000000
+
+/* v850e code.  */
+#define E_V850E_ARCH		0x10000000
+
+/* v850ea code.  */
+#define E_V850EA_ARCH		0x20000000
+#endif	/* c33 */
+
+
+/* Flags for the st_other field */
+#define V850_OTHER_SDA		0x01	/* symbol had SDA relocations */
+#define V850_OTHER_ZDA		0x02	/* symbol had ZDA relocations */
+#define V850_OTHER_TDA		0x04	/* symbol had TDA relocations */
+#define V850_OTHER_TDA_BYTE	0x08	/* symbol had TDA byte relocations */
+#define V850_OTHER_ERROR	0x80	/* symbol had an error reported */
+
+/* C33 relocations */
+#include "elf/reloc-macros.h"
+
+START_RELOC_NUMBERS (c33_reloc_type)
+     RELOC_NUMBER (R_C33_NONE, 0)
+     RELOC_NUMBER (R_C33_32, 1)
+     RELOC_NUMBER (R_C33_16, 2)
+     RELOC_NUMBER (R_C33_8,  3)
+     RELOC_NUMBER (R_C33_AH, 4)
+     RELOC_NUMBER (R_C33_AL, 5)
+     RELOC_NUMBER (R_C33_RH, 6)
+     RELOC_NUMBER (R_C33_RM, 7)
+     RELOC_NUMBER (R_C33_RL, 8)
+     RELOC_NUMBER (R_C33_H,  9)
+     RELOC_NUMBER (R_C33_M,  10)
+     RELOC_NUMBER (R_C33_L,  11)
+     RELOC_NUMBER (R_C33_DH, 12)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_DL, 13)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_GL, 14)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_SH, 15)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_SL, 16)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_TH, 17)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_TL, 18)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_ZH, 19)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_ZL, 20)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_DPH,21)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_DPM,22)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_DPL,23)	/* add tazaki 2002.01.11 */
+     RELOC_NUMBER (R_C33_LOOP,24)	/* add tazaki 2002.03.05 */
+     RELOC_NUMBER (R_C33_JP, 25)	/* add tazaki 2002.04.22 */
+     RELOC_NUMBER (R_C33_S_RH, 26)	/* add tazaki 2002.05.02 */
+     RELOC_NUMBER (R_C33_S_RM, 27)	/* add tazaki 2002.05.02 */
+     RELOC_NUMBER (R_C33_S_RL, 28)	/* add tazaki 2002.05.02 */
+     RELOC_NUMBER (R_C33_PUSHN_R0,29)	/* add tazaki 2004/08/19 */
+     RELOC_NUMBER (R_C33_PUSHN_R1,30)	/* add tazaki 2004/08/19 */
+     RELOC_NUMBER (R_C33_PUSH_R1,31)	/* add tazaki 2004/08/19 */
+
+     EMPTY_RELOC (R_C33_max)
+END_RELOC_NUMBERS
+
+
+/* Processor specific section indices.  These sections do not actually
+   exist.  Symbols with a st_shndx field corresponding to one of these
+   values have a special meaning.  */
+
+/* Small data area common symbol.  */
+#define SHN_C33_COMM	0xff00
+#define SHN_C33_GCOMM	0xff01
+#define SHN_C33_SCOMM	0xff02
+#define SHN_C33_TCOMM	0xff03
+#define SHN_C33_ZCOMM	0xff04
+#define SHN_C33_GBSS	0xff05
+#define SHN_C33_SBSS	0xff06
+#define SHN_C33_TBSS	0xff07
+#define SHN_C33_ZBSS	0xff08
+
+
+/* Processor specific section types.  */
+
+/* Section contains the .scommon data.  */
+#define SHT_C33_COMM	0x70000000
+#define SHT_C33_GCOMM	0x70000001
+#define SHT_C33_SCOMM	0x70000002
+#define SHT_C33_TCOMM	0x70000003
+#define SHT_C33_ZCOMM	0x70000004
+#define SHT_C33_GBSS	0x70000005
+#define SHT_C33_SBSS	0x70000006
+#define SHT_C33_TBSS	0x70000007
+#define SHT_C33_ZBSS	0x70000008
+
+
+
+#endif /* _ELF_C33_H */
+
+
diff --git a/include/elf/common.h b/include/elf/common.h
index b290853..5b8c585 100644
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -202,6 +202,12 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
    Written in the absense of an ABI.  */
 #define EM_AVR			0x1057
 
+/* C33 magic number */
+#define EM_SE_C33		107	/* S1C33 Family of Seiko Epson processor */
+
+/* C17 magic number */
+#define EM_SE_C17		139	/* C17 Family of Seiko Epson processor */
+
 /* See the above comment before you add a new EM_* value here.  */
 
 /* Values for e_version */
diff --git a/include/opcode/c33.h b/include/opcode/c33.h
new file mode 100644
index 0000000..6d48650
--- /dev/null
+++ b/include/opcode/c33.h
@@ -0,0 +1,205 @@
+/* c33.h -- Header file for EPSON C33 opcode table
+   Copyright 1996 Free Software Foundation, Inc.
+   Written by J.T. Conklin, Cygnus Support
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+1, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#ifndef V850_H
+#define V850_H
+
+/* The opcode table is an array of struct c33_opcode.  */
+
+struct c33_opcode
+{
+  /* The opcode name.  */
+  const char *name;
+
+  /* The opcode itself.  Those bits which will be filled in with
+     operands are zeroes.  */
+  unsigned long opcode;
+
+  /* The opcode mask.  This is used by the disassembler.  This is a
+     mask containing ones indicating those bits which must match the
+     opcode field, and zeroes indicating those bits which need not
+     match (and are presumably filled in by operands).  */
+  unsigned long mask;
+
+  /* An array of operand codes.  Each code is an index into the
+     operand table.  They appear in the order which the operands must
+     appear in assembly code, and are terminated by a zero.  */
+  unsigned char operands[8];
+
+  /* Which (if any) operand is a memory operand.  */
+  unsigned int memop;
+
+	/* special flag */
+	/* 0: special process none */
+	/* 1: [sp+imm32]  byte (1byte) */
+	/* 2: [sp+imm32]  half word (2byte) */
+	/* 4: [sp+imm32]  word(4byte) */
+	/* 5:shift/lotate */
+	unsigned int specialFlag;
+};
+
+#if 0	/* c33 */
+/* Values for the processors field in the c33_opcode structure.  */
+#define PROCESSOR_V850		(1 << 0)		/* Just the V850.  */
+#define PROCESSOR_ALL		-1			/* Any processor.  */
+#define PROCESSOR_V850E		(1 << 1)		/* Just the V850E. */
+#define PROCESSOR_NOT_V850	(~ PROCESSOR_V850)	/* Any processor except the V850.  */
+#define PROCESSOR_V850EA	(1 << 2)		/* Just the V850EA. */
+#endif	/* c33 */
+
+/* The table itself is sorted by major opcode number, and is otherwise
+   in the order in which the disassembler should consider
+   instructions.  */
+extern const struct c33_opcode c33_opcodes[];
+
+/* add tazaki 2001.11.07 */
+extern int	g_iAdvance;
+extern const struct c33_opcode c33_advance_opcodes[];
+/* add tazaki 2001.09.19 */
+extern const struct c33_opcode c33_ext_opcodes[];
+/* add tazaki 2001.09.19 */
+extern const int c33_num_opcodes;
+
+/* add T.Tazaki 2003/11/18 >>> */
+extern int g_iPE;
+extern const struct c33_opcode c33_pe_opcodes[];
+/* add T.Tazaki 2003/11/18 <<< */
+
+/* add T.Tazaki 2004/07/30 >>> */
+extern int g_iMedda32;
+extern const struct c33_opcode c33_opcodes32[];
+extern const struct c33_opcode c33_advance_opcodes32[];
+extern const struct c33_opcode c33_pe_opcodes32[];
+/* add T.Tazaki 2004/07/30 <<< */
+
+
+
+/* The operands table is an array of struct c33_operand.  */
+
+struct c33_operand
+{
+  /* The number of bits in the operand.  */
+  /* If this value is -1 then the operand's bits are in a discontinous distribution in the instruction. */
+  int bits;
+
+  /* (bits >= 0):  How far the operand is left shifted in the instruction.  */
+  /* (bits == -1): Bit mask of the bits in the operand.  */
+  int shift;
+
+  /* Insertion function.  This is used by the assembler.  To insert an
+     operand value into an instruction, check this field.
+
+     If it is NULL, execute
+         i |= (op & ((1 << o->bits) - 1)) << o->shift;
+     (i is the instruction which we are filling in, o is a pointer to
+     this structure, and op is the opcode value; this assumes twos
+     complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction and the operand value.  It will return the new value
+     of the instruction.  If the ERRMSG argument is not NULL, then if
+     the operand value is illegal, *ERRMSG will be set to a warning
+     string (the operand will be inserted in any case).  If the
+     operand value is legal, *ERRMSG will be unchanged (most operands
+     can accept any value).  */
+  unsigned long (* insert) PARAMS ((unsigned long instruction, long op,
+				   const char ** errmsg));
+
+  /* Extraction function.  This is used by the disassembler.  To
+     extract this operand type from an instruction, check this field.
+
+     If it is NULL, compute
+         op = o->bits == -1 ? ((i) & o->shift) : ((i) >> o->shift) & ((1 << o->bits) - 1);
+	 if (o->flags & V850_OPERAND_SIGNED)
+	     op = (op << (32 - o->bits)) >> (32 - o->bits);
+     (i is the instruction, o is a pointer to this structure, and op
+     is the result; this assumes twos complement arithmetic).
+
+     If this field is not NULL, then simply call it with the
+     instruction value.  It will return the value of the operand.  If
+     the INVALID argument is not NULL, *INVALID will be set to
+     non-zero if this operand type can not actually be extracted from
+     this operand (i.e., the instruction does not match).  If the
+     operand is valid, *INVALID will not be changed.  */
+  unsigned long (* extract) PARAMS ((unsigned long instruction, int * invalid));
+
+  /* One bit syntax flags.  */
+  int flags;
+  
+  /* 有効範囲 imm6/sign8/imm13/imm26など 
+     例えば、xld.w [symbol+imm26]の有効範囲は26bit
+     		sld.w [symbol+imm13]の有効範囲は13bitとなる
+  */
+  int range;
+};
+
+/* Elements in the table are retrieved by indexing with values from
+   the operands field of the c33_opcodes table.  */
+
+extern const struct c33_operand c33_operands[];
+
+/* Values defined for the flags field of a struct c33_operand.  */
+
+/* This operand names a general purpose register */
+#define C33_OPERAND_REG		0x01
+#define	C33_OPERAND_SREG	0x02	/* special registers */
+#define	C33_OPERAND_IMM		0x04
+#define C33_OPERAND_SIGNED	0x08
+#define	C33_OPERAND_MEM		0x10	/* [symbol+imm32] */
+#define	C33_OPERAND_SPMEM	0x20	/* [%sp+imm6] */
+#define	C33_OPERAND_REGINC	0x40	/* [%rb]+ */
+#define	C33_OPERAND_SP		0x80
+#define	C33_OPERAND_LABEL	0x100	/* label+imm32 */
+#define	C33_OPERAND_RB		0x200	/* [%rb] , [%rb+imm]*/
+#define	C33_OPERAND_SYMBOL	0x400	/* symbol+imm32 */
+#define	C33_OPERAND_PC		0x800	/* jp sign8(8:1) sign(0) = 0 */
+/* >>> add tazaki 2002.06.19 */
+#define	C33_OPERAND_OFFSET_SYMBOL	0x1000	/* ext doff_hi(symbol),doff_li(symbol), etc... */
+#define C33_OPERAND_01		0x2000	/* Advanced Inst : class0 bit5,4 = ( 0,1 ) */
+#define C33_OPERAND_OP3_01	0x4000	/* Advanced Inst : class5 bit7,6 = ( 0,1 ) */
+#define C33_OPERAND_OP3_10	0x8000	/* Advanced Inst : class5 bit7,6 = ( 1,0 ) */
+#define C33_OPERAND_DPMEM	0x0003	/* Advanced Inst : [%dp+imm6] */
+#define C33_OPERAND_DP		0x0070	/* Advanced Inst : %dp        */
+#define C33_OPERAND_DP_SYMBOL	0xc000	/* Advanced Inst : [symbol+imm] */
+#define C33_OPERAND_DPSYMBOL6	0x3000	/* Advanced Inst : [%dp+dpoff_l(symbol)] */
+#define C33_OPERAND_DPSYMBOL6_2	0x1800	/* Advanced Inst : [%dp+dpoff_l(symbol)] */
+#define C33_OPERAND_COND	0x1400	/* Advanced Inst : ext cond */
+#define C33_OPERAND_OP_SHIFT	0x1200	/* Advanced Inst : ext OP,imm2 | ext %rb,OP,imm2 */
+#define C33_OPERAND_LD_SREG	0x10000	/* Advanced Inst : ld.w %sd,%rs */
+#define	C33_OPERAND_PUSHS_SREG	0x20000	/* special registers : pushs , pops */
+/* <<< add tazaki 2002.06.19 */
+
+/* add T.Tazaki 2004/07/23 >>> */
+#define	C33_XLDB_RD			0x40000		/* xld.b %rd,[symbol+imm]   */
+#define	C33_XLDB_WR			0x80000		/* xld.b [symbol+imm],%rs   */
+#define	C33_XLDH_RD			0x100000	/* xld.h %rd,[symbol+imm]   */
+#define	C33_XLDH_WR			0x200000	/* xld.h [symbol+imm],%rs   */
+#define	C33_XLDW_RD			0x400000	/* xld.w %rd,[symbol+imm]   */
+#define	C33_XLDW_WR			0x800000	/* xld.w [symbol+imm],%rs   */
+#define	C33_XLDUB_RD		0x1000000	/* xld.ub %rd,[symbol+imm]  */
+#define	C33_XLDUH_RD		0x2000000	/* xld.uh %rd, [symbol+imm] */
+#define	C33_XBTST			0x4000000	/* xbtst [symbol+imm],imm3  */
+#define	C33_XBCLR			0x8000000	/* xbclr [symbol+imm],imm3  */
+#define	C33_XBSET			0x10000000	/* xbset [symbol+imm],imm3  */
+#define	C33_XBNOT			0x20000000	/* xbnot [symbol+imm],imm3  */
+#define C33_OPERAND_26		0x40000000	/* [%rb+imm26]              */
+/* add T.Tazaki 2004/07/23 <<< */
+ 
+#endif /* C33 */
diff --git a/ld/Makefile.am b/ld/Makefile.am
index 0abc9b5..be1fd41 100644
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -678,6 +678,9 @@ evsta.c: $(srcdir)/emulparams/vsta.sh \
 ev850.c: $(srcdir)/emulparams/v850.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} v850 "$(tdir_v850)"
+ec33.c: $(srcdir)/emulparams/c33.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/c33.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} c33 "$(tdir_c33)"
 ew65.c: $(srcdir)/emulparams/w65.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/w65.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} w65 "$(tdir_w65)"
diff --git a/ld/Makefile.in b/ld/Makefile.in
index 0fa39ae..5651574 100644
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -1377,6 +1377,9 @@ evsta.c: $(srcdir)/emulparams/vsta.sh \
 ev850.c: $(srcdir)/emulparams/v850.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/v850.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} v850 "$(tdir_v850)"
+ec33.c: $(srcdir)/emulparams/c33.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/c33.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} c33 "$(tdir_c33)"
 ew65.c: $(srcdir)/emulparams/w65.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/w65.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} w65 "$(tdir_w65)"
diff --git a/ld/configure.tgt b/ld/configure.tgt
index c22eee7..89eee7d 100644
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -287,6 +287,7 @@ rs6000-*-aix*)		targ_emul=aixrs6 ;;
 tic30-*-*aout*)		targ_emul=tic30aout ;;
 tic30-*-*coff*)		targ_emul=tic30coff ;;
 tic80-*-*)		targ_emul=tic80coff ;;
+c33-*-*)		targ_emul=c33 ;;
 v850-*-*)		targ_emul=v850 ;;
 v850e-*-*)		targ_emul=v850 ;;
 v850ea-*-*)		targ_emul=v850 ;;
diff --git a/ld/emulparams/c33.sh b/ld/emulparams/c33.sh
new file mode 100644
index 0000000..fe0146e
--- /dev/null
+++ b/ld/emulparams/c33.sh
@@ -0,0 +1,10 @@
+MACHINE=
+SCRIPT_NAME=c33
+OUTPUT_FORMAT="elf32-c33"
+TEXT_START_ADDR=0xc00000
+SDATA_START_ADDR="ALIGN (4)"
+ARCH=c33
+MAXPAGESIZE=256
+ENTRY=_start
+EMBEDDED=yes
+TEMPLATE_NAME=c33
diff --git a/ld/emultempl/c33.em b/ld/emultempl/c33.em
new file mode 100644
index 0000000..6635e09
--- /dev/null
+++ b/ld/emultempl/c33.em
@@ -0,0 +1,128 @@
+# This shell script emits a C file. -*- C -*-
+# It does some substitutions.
+cat >e${EMULATION_NAME}.c <<EOF
+/* This file is is generated by a shell script.  DO NOT EDIT! */
+
+/* emulate the original gld for the given ${EMULATION_NAME}
+   Copyright (C) 1991, 93, 94, 95, 96, 1999 Free Software Foundation, Inc.
+   Written by Steve Chamberlain steve@cygnus.com
+
+This file is part of GLD, the Gnu Linker.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#define TARGET_IS_${EMULATION_NAME}
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+
+#include "ld.h"
+#include "ldmain.h"
+#include "ldemul.h"
+#include "ldfile.h"
+#include "ldmisc.h"
+
+static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
+static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
+
+static void
+gld${EMULATION_NAME}_before_parse()
+{
+#ifndef TARGET_			/* I.e., if not generic.  */
+  ldfile_set_output_arch ("`echo ${ARCH}`");
+#endif /* not TARGET_ */
+}
+
+static char *
+gld${EMULATION_NAME}_get_script(isfile)
+     int *isfile;
+EOF
+
+if test -n "$COMPILE_IN"
+then
+# Scripts compiled in.
+
+# sed commands to quote an ld script as a C string.
+sc="-f stringify.sed"
+
+cat >>e${EMULATION_NAME}.c <<EOF
+{			     
+  *isfile = 0;
+
+  if (link_info.relocateable == true && config.build_constructors == true)
+    return
+EOF
+sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
+echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
+echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
+echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
+echo '  ; else return'                                     >> e${EMULATION_NAME}.c
+sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
+echo '; }'                                                 >> e${EMULATION_NAME}.c
+
+else
+# Scripts read from the filesystem.
+
+cat >>e${EMULATION_NAME}.c <<EOF
+{			     
+  *isfile = 1;
+
+  if (link_info.relocateable == true && config.build_constructors == true)
+    return "ldscripts/${EMULATION_NAME}.xu";
+  else if (link_info.relocateable == true)
+    return "ldscripts/${EMULATION_NAME}.xr";
+  else if (!config.text_read_only)
+    return "ldscripts/${EMULATION_NAME}.xbn";
+  else if (!config.magic_demand_paged)
+    return "ldscripts/${EMULATION_NAME}.xn";
+  else
+    return "ldscripts/${EMULATION_NAME}.x";
+}
+EOF
+
+fi
+
+cat >>e${EMULATION_NAME}.c <<EOF
+
+struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
+{
+  gld${EMULATION_NAME}_before_parse,
+  syslib_default,
+  hll_default,
+  after_parse_default,
+  after_open_default,
+  after_allocation_default,
+  set_output_arch_default,
+  ldemul_default_target,
+  before_allocation_default,
+  gld${EMULATION_NAME}_get_script,
+  "${EMULATION_NAME}",
+  "${OUTPUT_FORMAT}",
+  NULL,	/* finish */
+  NULL,	/* create output section statements */
+  NULL,	/* open dynamic archive */
+  NULL,	/* place orphan */
+  NULL,	/* set symbols */
+  NULL,	/* parse args */
+  NULL,	/* unrecognized file */
+  NULL,	/* list options */
+  NULL,	/* recognized file */
+  NULL 	/* find_potential_libraries */
+};
+EOF
diff --git a/ld/ldlang.c b/ld/ldlang.c
index 8f0c607..79ca963 100644
--- a/ld/ldlang.c
+++ b/ld/ldlang.c
@@ -42,8 +42,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 
 /* FORWARDS */
 static lang_statement_union_type *new_statement PARAMS ((enum statement_enum,
-							 size_t,
-							 lang_statement_list_type*));
+                             size_t,
+                             lang_statement_list_type*));
 
 
 /* LOCALS */
@@ -65,29 +65,29 @@ static struct lang_phdr *lang_phdr_list;
 
 static void lang_for_each_statement_worker
   PARAMS ((void (*func) (lang_statement_union_type *),
-	   lang_statement_union_type *s));
+       lang_statement_union_type *s));
 static lang_input_statement_type *new_afile
   PARAMS ((const char *name, lang_input_file_enum_type file_type,
-	   const char *target, boolean add_to_list));
+       const char *target, boolean add_to_list));
 static void init_os PARAMS ((lang_output_section_statement_type *s));
 static void exp_init_os PARAMS ((etree_type *));
 static void section_already_linked PARAMS ((bfd *, asection *, PTR));
 static struct bfd_hash_entry *already_linked_newfunc
   PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
-	   const char *string));
+       const char *string));
 static void already_linked_table_init PARAMS ((void));
 static void already_linked_table_free PARAMS ((void));
 static boolean wildcardp PARAMS ((const char *));
 static lang_statement_union_type *wild_sort
   PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
-	   asection *));
+       asection *));
 static lang_input_statement_type *lookup_name PARAMS ((const char *name));
 static void load_symbols PARAMS ((lang_input_statement_type *entry,
-				  lang_statement_list_type *));
+                  lang_statement_list_type *));
 static void wild PARAMS ((lang_wild_statement_type *s,
-			  const char *section, const char *file,
-			  const char *target,
-			  lang_output_section_statement_type *output));
+              const char *section, const char *file,
+              const char *target,
+              lang_output_section_statement_type *output));
 static bfd *open_output PARAMS ((const char *name));
 static void ldlang_open_output PARAMS ((lang_statement_union_type *statement));
 static void open_input_bfds
@@ -96,15 +96,17 @@ static void lang_reasonable_defaults PARAMS ((void));
 static void lang_place_undefineds PARAMS ((void));
 static void map_input_to_output_sections
   PARAMS ((lang_statement_union_type *s,
-	   const char *target,
-	   lang_output_section_statement_type *output_section_statement));
+       const char *target,
+       lang_output_section_statement_type *output_section_statement));
 static void print_output_section_statement
   PARAMS ((lang_output_section_statement_type *output_section_statement));
 static void print_assignment
   PARAMS ((lang_assignment_statement_type *assignment,
-	   lang_output_section_statement_type *output_section));
+       lang_output_section_statement_type *output_section));
 static void print_input_statement PARAMS ((lang_input_statement_type *statm));
 static boolean print_one_symbol PARAMS ((struct bfd_link_hash_entry *, PTR));
+static boolean c33_print_one_symbol PARAMS ((struct bfd_link_hash_entry *, PTR));
+static void c33_bfd_hash_traverse PARAMS ((struct bfd_hash_table *, boolean (*) (struct bfd_hash_entry *, PTR), PTR));
 static void print_input_section PARAMS ((lang_input_section_type *in));
 static void print_fill_statement PARAMS ((lang_fill_statement_type *fill));
 static void print_data_statement PARAMS ((lang_data_statement_type *data));
@@ -113,22 +115,22 @@ static void print_reloc_statement PARAMS ((lang_reloc_statement_type *reloc));
 static void print_padding_statement PARAMS ((lang_padding_statement_type *s));
 static void print_wild_statement
   PARAMS ((lang_wild_statement_type *w,
-	   lang_output_section_statement_type *os));
+       lang_output_section_statement_type *os));
 static void print_group
   PARAMS ((lang_group_statement_type *, lang_output_section_statement_type *));
 static void print_statement PARAMS ((lang_statement_union_type *s,
-				     lang_output_section_statement_type *os));
+                     lang_output_section_statement_type *os));
 static void print_statement_list PARAMS ((lang_statement_union_type *s,
-					  lang_output_section_statement_type *os));
+                      lang_output_section_statement_type *os));
 static void print_statements PARAMS ((void));
 static bfd_vma insert_pad PARAMS ((lang_statement_union_type **this_ptr,
-				   fill_type fill, unsigned int power,
-				   asection *output_section_statement,
-				   bfd_vma dot));
+                   fill_type fill, unsigned int power,
+                   asection *output_section_statement,
+                   bfd_vma dot));
 static bfd_vma size_input_section
   PARAMS ((lang_statement_union_type **this_ptr,
-	   lang_output_section_statement_type *output_section_statement,
-	   fill_type fill, bfd_vma dot, boolean relax));
+       lang_output_section_statement_type *output_section_statement,
+       fill_type fill, bfd_vma dot, boolean relax));
 static void lang_finish PARAMS ((void));
 static void ignore_bfd_errors PARAMS ((const char *, ...));
 static void lang_check PARAMS ((void));
@@ -147,14 +149,14 @@ static void lang_do_version_exports_section PARAMS ((void));
 static void lang_check_section_addresses PARAMS ((void));
 
 typedef void (*callback_t) PARAMS ((lang_wild_statement_type *,
-				    asection *, lang_input_statement_type *,
-				    void *));
+                    asection *, lang_input_statement_type *,
+                    void *));
 static void walk_wild_section
   PARAMS ((lang_wild_statement_type *, const char *,
-	   lang_input_statement_type *, callback_t, void *));
+       lang_input_statement_type *, callback_t, void *));
 static void walk_wild_file
   PARAMS ((lang_wild_statement_type *, const char *,
-	   lang_input_statement_type *, callback_t, void *));
+       lang_input_statement_type *, callback_t, void *));
 
 static int    get_target PARAMS ((const bfd_target *, void *));
 static void   stricpy PARAMS ((char *, char *));
@@ -162,7 +164,7 @@ static void   strcut PARAMS ((char *, char *));
 static int    name_compare PARAMS ((char *, char *));
 static int    closest_target_match PARAMS ((const bfd_target *, void *));
 static char * get_first_input_target PARAMS ((void));
-					
+                    
 /* EXPORTS */
 lang_output_section_statement_type *abs_output_section;
 lang_statement_list_type lang_output_section_statement;
@@ -218,16 +220,16 @@ walk_wild_section (ptr, section, file, callback, data)
       struct name_list *list_tmp;
       for (list_tmp = ptr->exclude_filename_list; list_tmp; list_tmp = list_tmp->next)
         {
-	  boolean match;
+      boolean match;
 
-	  if (wildcardp (list_tmp->name))
-	    match = fnmatch (list_tmp->name, file->filename, 0) == 0 ? true : false;
-	  else
-	    match = strcmp (list_tmp->name, file->filename) == 0 ? true : false;
+      if (wildcardp (list_tmp->name))
+        match = fnmatch (list_tmp->name, file->filename, 0) == 0 ? true : false;
+      else
+        match = strcmp (list_tmp->name, file->filename) == 0 ? true : false;
 
-	  if (match)
-	    return;
-	}
+      if (match)
+        return;
+    }
     }
 
   if (file->just_syms_flag == false)
@@ -236,30 +238,30 @@ walk_wild_section (ptr, section, file, callback, data)
       boolean wildcard;
 
       if (section == NULL)
-	wildcard = false;
+    wildcard = false;
       else
-	wildcard = wildcardp (section);
+    wildcard = wildcardp (section);
 
       for (s = file->the_bfd->sections; s != NULL; s = s->next)
-	{
-	  boolean match;
+    {
+      boolean match;
 
-	  if (section == NULL)
-	    match = true;
-	  else
-	    {
-	      const char *name;
+      if (section == NULL)
+        match = true;
+      else
+        {
+          const char *name;
 
-	      name = bfd_get_section_name (file->the_bfd, s);
-	      if (wildcard)
-		match = fnmatch (section, name, 0) == 0 ? true : false;
-	      else
-		match = strcmp (section, name) == 0 ? true : false;
-	    }
+          name = bfd_get_section_name (file->the_bfd, s);
+          if (wildcard)
+        match = fnmatch (section, name, 0) == 0 ? true : false;
+          else
+        match = strcmp (section, name) == 0 ? true : false;
+        }
 
-	  if (match)
-	    (*callback) (ptr, s, file, data);
-	}
+      if (match)
+        (*callback) (ptr, s, file, data);
+    }
     }
 }
 
@@ -281,24 +283,24 @@ walk_wild_file (s, section, f, callback, data)
       bfd *member;
 
       /* This is an archive file.  We must map each member of the
-	 archive separately.  */
+     archive separately.  */
       member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
       while (member != NULL)
-	{
-	  /* When lookup_name is called, it will call the add_symbols
-	     entry point for the archive.  For each element of the
-	     archive which is included, BFD will call ldlang_add_file,
-	     which will set the usrdata field of the member to the
-	     lang_input_statement.  */
-	  if (member->usrdata != NULL)
-	    {
-	      walk_wild_section (s, section,
-				 (lang_input_statement_type *) member->usrdata,
-				 callback, data);
-	    }
+    {
+      /* When lookup_name is called, it will call the add_symbols
+         entry point for the archive.  For each element of the
+         archive which is included, BFD will call ldlang_add_file,
+         which will set the usrdata field of the member to the
+         lang_input_statement.  */
+      if (member->usrdata != NULL)
+        {
+          walk_wild_section (s, section,
+                 (lang_input_statement_type *) member->usrdata,
+                 callback, data);
+        }
 
-	  member = bfd_openr_next_archived_file (f->the_bfd, member);
-	}
+      member = bfd_openr_next_archived_file (f->the_bfd, member);
+    }
     }
 }
 
@@ -314,17 +316,17 @@ walk_wild (s, section, file, callback, data)
     {
       /* Perform the iteration over all files in the list.  */
       LANG_FOR_EACH_INPUT_STATEMENT (f)
-	{
-	  walk_wild_file (s, section, f, callback, data);
-	}
+    {
+      walk_wild_file (s, section, f, callback, data);
+    }
     }
   else if (wildcardp (file))
     {
       LANG_FOR_EACH_INPUT_STATEMENT (f)
-	{
-	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
-	    walk_wild_file (s, section, f, callback, data);
-	}
+    {
+      if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
+        walk_wild_file (s, section, f, callback, data);
+    }
     }
   else
     {
@@ -351,40 +353,40 @@ lang_for_each_statement_worker (func, s)
       func (s);
 
       switch (s->header.type)
-	{
-	case lang_constructors_statement_enum:
-	  lang_for_each_statement_worker (func, constructor_list.head);
-	  break;
-	case lang_output_section_statement_enum:
-	  lang_for_each_statement_worker
-	    (func,
-	     s->output_section_statement.children.head);
-	  break;
-	case lang_wild_statement_enum:
-	  lang_for_each_statement_worker
-	    (func,
-	     s->wild_statement.children.head);
-	  break;
-	case lang_group_statement_enum:
-	  lang_for_each_statement_worker (func,
-					  s->group_statement.children.head);
-	  break;
-	case lang_data_statement_enum:
-	case lang_reloc_statement_enum:
-	case lang_object_symbols_statement_enum:
-	case lang_output_statement_enum:
-	case lang_target_statement_enum:
-	case lang_input_section_enum:
-	case lang_input_statement_enum:
-	case lang_assignment_statement_enum:
-	case lang_padding_statement_enum:
-	case lang_address_statement_enum:
-	case lang_fill_statement_enum:
-	  break;
-	default:
-	  FAIL ();
-	  break;
-	}
+    {
+    case lang_constructors_statement_enum:
+      lang_for_each_statement_worker (func, constructor_list.head);
+      break;
+    case lang_output_section_statement_enum:
+      lang_for_each_statement_worker
+        (func,
+         s->output_section_statement.children.head);
+      break;
+    case lang_wild_statement_enum:
+      lang_for_each_statement_worker
+        (func,
+         s->wild_statement.children.head);
+      break;
+    case lang_group_statement_enum:
+      lang_for_each_statement_worker (func,
+                      s->group_statement.children.head);
+      break;
+    case lang_data_statement_enum:
+    case lang_reloc_statement_enum:
+    case lang_object_symbols_statement_enum:
+    case lang_output_statement_enum:
+    case lang_target_statement_enum:
+    case lang_input_section_enum:
+    case lang_input_statement_enum:
+    case lang_assignment_statement_enum:
+    case lang_padding_statement_enum:
+    case lang_address_statement_enum:
+    case lang_fill_statement_enum:
+      break;
+    default:
+      FAIL ();
+      break;
+    }
     }
 }
 
@@ -393,7 +395,7 @@ lang_for_each_statement (func)
      void (*func) PARAMS ((lang_statement_union_type *));
 {
   lang_for_each_statement_worker (func,
-				  statement_list.head);
+                  statement_list.head);
 }
 
 /*----------------------------------------------------------------------*/
@@ -452,7 +454,7 @@ new_afile (name, file_type, target, add_to_list)
   else
     {
       p = ((lang_input_statement_type *)
-	   stat_alloc (sizeof (lang_input_statement_type)));
+       stat_alloc (sizeof (lang_input_statement_type)));
       p->header.next = NULL;
     }
 
@@ -520,8 +522,8 @@ new_afile (name, file_type, target, add_to_list)
   p->whole_archive = whole_archive;
   p->loaded = false;
   lang_statement_append (&input_file_chain,
-			 (lang_statement_union_type *) p,
-			 &p->next_real_file);
+             (lang_statement_union_type *) p,
+             &p->next_real_file);
   return p;
 }
 
@@ -549,8 +551,8 @@ lang_init ()
   lang_list_init (&lang_output_section_statement);
   lang_list_init (&file_chain);
   first_file = lang_add_input_file ((char *) NULL,
-				    lang_input_file_is_marker_enum,
-				    (char *) NULL);
+                    lang_input_file_is_marker_enum,
+                    (char *) NULL);
   abs_output_section = lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);
 
   abs_output_section->bfd_section = bfd_abs_section_ptr;
@@ -582,9 +584,9 @@ lang_memory_region_lookup (name)
        p = p->next)
     {
       if (strcmp (p->name, name) == 0)
-	{
-	  return p;
-	}
+    {
+      return p;
+    }
     }
 
 #if 0
@@ -597,9 +599,9 @@ lang_memory_region_lookup (name)
   if (strcmp (name, "*default*") == 0)
     {
       if (lang_memory_region_list != (lang_memory_region_type *) NULL)
-	{
-	  return lang_memory_region_list;
-	}
+    {
+      return lang_memory_region_list;
+    }
     }
 #endif
 
@@ -641,10 +643,10 @@ lang_memory_default (section)
        p = p->next)
     {
       if ((p->flags & sec_flags) != 0
-	  && (p->not_flags & sec_flags) == 0)
-	{
-	  return p;
-	}
+      && (p->not_flags & sec_flags) == 0)
+    {
+      return p;
+    }
     }
   return lang_memory_region_lookup ("*default*");
 }
@@ -662,9 +664,9 @@ lang_output_section_find (name)
     {
       lookup = &u->output_section_statement;
       if (strcmp (name, lookup->name) == 0)
-	{
-	  return lookup;
-	}
+    {
+      return lookup;
+    }
     }
   return (lang_output_section_statement_type *) NULL;
 }
@@ -680,7 +682,7 @@ lang_output_section_statement_lookup (name)
     {
 
       lookup = (lang_output_section_statement_type *)
-	new_stat (lang_output_section_statement, stat_ptr);
+    new_stat (lang_output_section_statement, stat_ptr);
       lookup->region = (lang_memory_region_type *) NULL;
       lookup->lma_region = (lang_memory_region_type *) NULL;
       lookup->fill = 0;
@@ -702,8 +704,8 @@ lang_output_section_statement_lookup (name)
       lookup->phdrs = NULL;
 
       lang_statement_append (&lang_output_section_statement,
-			     (lang_statement_union_type *) lookup,
-			     &lookup->next);
+                 (lang_statement_union_type *) lookup,
+                 &lookup->next);
     }
   return lookup;
 }
@@ -728,6 +730,7 @@ lang_map_flags (flag)
     minfo ("l");
 }
 
+
 void
 lang_map ()
 {
@@ -735,7 +738,7 @@ lang_map ()
 
   minfo (_("\nMemory Configuration\n\n"));
   fprintf (config.map_file, "%-16s %-18s %-18s %s\n",
-	   _("Name"), _("Origin"), _("Length"), _("Attributes"));
+       _("Name"), _("Origin"), _("Length"), _("Attributes"));
 
   for (m = lang_memory_region_list;
        m != (lang_memory_region_type *) NULL;
@@ -750,35 +753,34 @@ lang_map ()
       minfo ("0x%s ", buf);
       len = strlen (buf);
       while (len < 16)
-	{
-	  print_space ();
-	  ++len;
-	}
+    {
+      print_space ();
+      ++len;
+    }
 
       minfo ("0x%V", m->length);
       if (m->flags || m->not_flags)
-	{
+    {
 #ifndef BFD64
-	  minfo ("        ");
+      minfo ("        ");
 #endif
-	  if (m->flags)
-	    {
-	      print_space ();
-	      lang_map_flags (m->flags);
-	    }
+      if (m->flags)
+        {
+          print_space ();
+          lang_map_flags (m->flags);
+        }
 
-	  if (m->not_flags)
-	    {
-	      minfo (" !");
-	      lang_map_flags (m->not_flags);
-	    }
-	}
+      if (m->not_flags)
+        {
+          minfo (" !");
+          lang_map_flags (m->not_flags);
+        }
+    }
 
       print_nl ();
     }
 
   fprintf (config.map_file, _("\nLinker script and memory map\n\n"));
-
   print_statements ();
 }
 
@@ -797,7 +799,7 @@ init_os (s)
     einfo (_("%P%F: Illegal use of `%s' section"), DISCARD_SECTION_NAME);
 
   new = ((section_userdata_type *)
-	 stat_alloc (sizeof (section_userdata_type)));
+     stat_alloc (sizeof (section_userdata_type)));
 
   s->bfd_section = bfd_get_section_by_name (output_bfd, s->name);
   if (s->bfd_section == (asection *) NULL)
@@ -805,7 +807,7 @@ init_os (s)
   if (s->bfd_section == (asection *) NULL)
     {
       einfo (_("%P%F: output format %s cannot represent section called %s\n"),
-	     output_bfd->xvec->name, s->name);
+         output_bfd->xvec->name, s->name);
     }
   s->bfd_section->output_section = s->bfd_section;
 
@@ -850,18 +852,18 @@ exp_init_os (exp)
 
     case etree_name:
       switch (exp->type.node_code)
-	{
-	case ADDR:
-	case LOADADDR:
-	case SIZEOF:
-	  {
-	    lang_output_section_statement_type *os;
-
-	    os = lang_output_section_find (exp->name.name);
-	    if (os != NULL && os->bfd_section == NULL)
-	      init_os (os);
-	  }
-	}
+    {
+    case ADDR:
+    case LOADADDR:
+    case SIZEOF:
+      {
+        lang_output_section_statement_type *os;
+
+        os = lang_output_section_find (exp->name.name);
+        if (os != NULL && os->bfd_section == NULL)
+          init_os (os);
+      }
+    }
       break;
 
     default:
@@ -952,54 +954,54 @@ section_already_linked (abfd, sec, data)
   for (l = already_linked_list->entry;  l != NULL; l = l->next)
     {
       if (sec->comdat == NULL
-	  || l->sec->comdat == NULL
-	  || strcmp (sec->comdat->name, l->sec->comdat->name) == 0)
-	{
-	  /* The section has already been linked.  See if we should
+      || l->sec->comdat == NULL
+      || strcmp (sec->comdat->name, l->sec->comdat->name) == 0)
+    {
+      /* The section has already been linked.  See if we should
              issue a warning.  */
-	  switch (flags & SEC_LINK_DUPLICATES)
-	    {
-	    default:
-	      abort ();
-
-	    case SEC_LINK_DUPLICATES_DISCARD:
-	      break;
-
-	    case SEC_LINK_DUPLICATES_ONE_ONLY:
-	      if (sec->comdat == NULL)
-		einfo (_("%P: %B: warning: ignoring duplicate section `%s'\n"),
-		       abfd, name);
-	      else
-		einfo (_("%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"),
-		       abfd, name, sec->comdat->name);
-	      break;
-
-	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
-	      /* FIXME: We should really dig out the contents of both
+      switch (flags & SEC_LINK_DUPLICATES)
+        {
+        default:
+          abort ();
+
+        case SEC_LINK_DUPLICATES_DISCARD:
+          break;
+
+        case SEC_LINK_DUPLICATES_ONE_ONLY:
+          if (sec->comdat == NULL)
+        einfo (_("%P: %B: warning: ignoring duplicate section `%s'\n"),
+               abfd, name);
+          else
+        einfo (_("%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"),
+               abfd, name, sec->comdat->name);
+          break;
+
+        case SEC_LINK_DUPLICATES_SAME_CONTENTS:
+          /* FIXME: We should really dig out the contents of both
                  sections and memcmp them.  The COFF/PE spec says that
                  the Microsoft linker does not implement this
                  correctly, so I'm not going to bother doing it
                  either.  */
-	      /* Fall through.  */
-	    case SEC_LINK_DUPLICATES_SAME_SIZE:
-	      if (bfd_section_size (abfd, sec)
-		  != bfd_section_size (l->sec->owner, l->sec))
-		einfo (_("%P: %B: warning: duplicate section `%s' has different size\n"),
-		       abfd, name);
-	      break;
-	    }
+          /* Fall through.  */
+        case SEC_LINK_DUPLICATES_SAME_SIZE:
+          if (bfd_section_size (abfd, sec)
+          != bfd_section_size (l->sec->owner, l->sec))
+        einfo (_("%P: %B: warning: duplicate section `%s' has different size\n"),
+               abfd, name);
+          break;
+        }
 
-	  /* Set the output_section field so that wild_doit does not
-	     create a lang_input_section structure for this section.
-	     Since there might be a symbol in the section being
-	     discarded, we must retain a pointer to the section which
-	     we are really going to use.  */
-	  sec->output_section = bfd_abs_section_ptr;
-	  if (sec->comdat != NULL)
-	    sec->comdat->sec = l->sec;
+      /* Set the output_section field so that wild_doit does not
+         create a lang_input_section structure for this section.
+         Since there might be a symbol in the section being
+         discarded, we must retain a pointer to the section which
+         we are really going to use.  */
+      sec->output_section = bfd_abs_section_ptr;
+      if (sec->comdat != NULL)
+        sec->comdat->sec = l->sec;
 
-	  return;
-	}
+      return;
+    }
     }
 
   /* This is the first section with this name.  Record it.  Allocate
@@ -1034,8 +1036,8 @@ static void
 already_linked_table_init ()
 {
   if (! bfd_hash_table_init_n (&already_linked_table,
-			       already_linked_newfunc,
-			       42))
+                   already_linked_newfunc,
+                   42))
     einfo (_("%P%F: Failed to create hash table\n"));
 }
 
@@ -1065,8 +1067,8 @@ wildcardp (pattern)
 
   for (s = pattern; *s != '\0'; ++s)
     if (*s == '?'
-	|| *s == '*'
-	|| *s == '[')
+    || *s == '*'
+    || *s == '[')
       return true;
   return false;
 }
@@ -1109,10 +1111,10 @@ wild_doit (ptr, section, output, file)
   if (discard)
     {
       if (section->output_section == NULL)
-	{
-	  /* This prevents future calls from assigning this section.  */
-	  section->output_section = bfd_abs_section_ptr;
-	}
+    {
+      /* This prevents future calls from assigning this section.  */
+      section->output_section = bfd_abs_section_ptr;
+    }
       return;
     }
 
@@ -1123,12 +1125,12 @@ wild_doit (ptr, section, output, file)
       flagword flags;
 
       if (output->bfd_section == NULL)
-	{
-	  init_os (output);
-	  first = true;
-	}
+    {
+      init_os (output);
+      first = true;
+    }
       else
-	first = false;
+    first = false;
 
       /* Add a section reference to the list */
       new = new_stat (lang_input_section, ptr);
@@ -1140,62 +1142,62 @@ wild_doit (ptr, section, output, file)
       flags = section->flags;
 
       /* We don't copy the SEC_NEVER_LOAD flag from an input section
-	 to an output section, because we want to be able to include a
-	 SEC_NEVER_LOAD section in the middle of an otherwise loaded
-	 section (I don't know why we want to do this, but we do).
-	 build_link_order in ldwrite.c handles this case by turning
-	 the embedded SEC_NEVER_LOAD section into a fill.  */
+     to an output section, because we want to be able to include a
+     SEC_NEVER_LOAD section in the middle of an otherwise loaded
+     section (I don't know why we want to do this, but we do).
+     build_link_order in ldwrite.c handles this case by turning
+     the embedded SEC_NEVER_LOAD section into a fill.  */
 
       flags &= ~ SEC_NEVER_LOAD;
 
       /* If final link, don't copy the SEC_LINK_ONCE flags, they've
-	 already been processed.  One reason to do this is that on pe
-	 format targets, .text$foo sections go into .text and it's odd
-	 to see .text with SEC_LINK_ONCE set.  */
+     already been processed.  One reason to do this is that on pe
+     format targets, .text$foo sections go into .text and it's odd
+     to see .text with SEC_LINK_ONCE set.  */
 
       if (! link_info.relocateable)
-	flags &= ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES);
+    flags &= ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES);
 
       /* If this is not the first input section, and the SEC_READONLY
          flag is not currently set, then don't set it just because the
          input section has it set.  */
 
       if (! first && (section->output_section->flags & SEC_READONLY) == 0)
-	flags &= ~ SEC_READONLY;
+    flags &= ~ SEC_READONLY;
 
       section->output_section->flags |= flags;
 
       /* If SEC_READONLY is not set in the input section, then clear
          it from the output section.  */
       if ((section->flags & SEC_READONLY) == 0)
-	section->output_section->flags &= ~SEC_READONLY;
+    section->output_section->flags &= ~SEC_READONLY;
 
       switch (output->sectype)
-	{
-	case normal_section:
-	  break;
-	case dsect_section:
-	case copy_section:
-	case info_section:
-	case overlay_section:
-	  output->bfd_section->flags &= ~SEC_ALLOC;
-	  break;
-	case noload_section:
-	  output->bfd_section->flags &= ~SEC_LOAD;
-	  output->bfd_section->flags |= SEC_NEVER_LOAD;
-	  break;
-	}
+    {
+    case normal_section:
+      break;
+    case dsect_section:
+    case copy_section:
+    case info_section:
+    case overlay_section:
+      output->bfd_section->flags &= ~SEC_ALLOC;
+      break;
+    case noload_section:
+      output->bfd_section->flags &= ~SEC_LOAD;
+      output->bfd_section->flags |= SEC_NEVER_LOAD;
+      break;
+    }
 
       /* Copy over SEC_SMALL_DATA.  */
       if (section->flags & SEC_SMALL_DATA)
-	section->output_section->flags |= SEC_SMALL_DATA;
+    section->output_section->flags |= SEC_SMALL_DATA;
 
       if (section->alignment_power > output->bfd_section->alignment_power)
-	output->bfd_section->alignment_power = section->alignment_power;
+    output->bfd_section->alignment_power = section->alignment_power;
 
       /* If supplied an aligment, then force it.  */
       if (output->section_alignment != -1)
-	output->bfd_section->alignment_power = output->section_alignment;
+    output->bfd_section->alignment_power = output->section_alignment;
     }
 }
 
@@ -1222,79 +1224,79 @@ wild_sort (wild, file, section)
       lang_input_section_type *ls;
 
       if (l->header.type != lang_input_section_enum)
-	continue;
+    continue;
       ls = &l->input_section;
 
       /* Sorting by filename takes precedence over sorting by section
          name.  */
 
       if (wild->filenames_sorted)
-	{
-	  const char *fn, *ln;
-	  boolean fa, la;
-	  int i;
+    {
+      const char *fn, *ln;
+      boolean fa, la;
+      int i;
 
-	  /* The PE support for the .idata section as generated by
+      /* The PE support for the .idata section as generated by
              dlltool assumes that files will be sorted by the name of
              the archive and then the name of the file within the
              archive.  */
 
-	  if (file->the_bfd != NULL
-	      && bfd_my_archive (file->the_bfd) != NULL)
-	    {
-	      fn = bfd_get_filename (bfd_my_archive (file->the_bfd));
-	      fa = true;
-	    }
-	  else
-	    {
-	      fn = file->filename;
-	      fa = false;
-	    }
+      if (file->the_bfd != NULL
+          && bfd_my_archive (file->the_bfd) != NULL)
+        {
+          fn = bfd_get_filename (bfd_my_archive (file->the_bfd));
+          fa = true;
+        }
+      else
+        {
+          fn = file->filename;
+          fa = false;
+        }
 
-	  if (ls->ifile->the_bfd != NULL
-	      && bfd_my_archive (ls->ifile->the_bfd) != NULL)
-	    {
-	      ln = bfd_get_filename (bfd_my_archive (ls->ifile->the_bfd));
-	      la = true;
-	    }
-	  else
-	    {
-	      ln = ls->ifile->filename;
-	      la = false;
-	    }
+      if (ls->ifile->the_bfd != NULL
+          && bfd_my_archive (ls->ifile->the_bfd) != NULL)
+        {
+          ln = bfd_get_filename (bfd_my_archive (ls->ifile->the_bfd));
+          la = true;
+        }
+      else
+        {
+          ln = ls->ifile->filename;
+          la = false;
+        }
 
-	  i = strcmp (fn, ln);
-	  if (i > 0)
-	    continue;
-	  else if (i < 0)
-	    break;
+      i = strcmp (fn, ln);
+      if (i > 0)
+        continue;
+      else if (i < 0)
+        break;
 
-	  if (fa || la)
-	    {
-	      if (fa)
-		fn = file->filename;
-	      if (la)
-		ln = ls->ifile->filename;
-
-	      i = strcmp (fn, ln);
-	      if (i > 0)
-		continue;
-	      else if (i < 0)
-		break;
-	    }
-	}
+      if (fa || la)
+        {
+          if (fa)
+        fn = file->filename;
+          if (la)
+        ln = ls->ifile->filename;
+
+          i = strcmp (fn, ln);
+          if (i > 0)
+        continue;
+          else if (i < 0)
+        break;
+        }
+    }
 
       /* Here either the files are not sorted by name, or we are
          looking at the sections for this file.  */
 
       if (wild->sections_sorted)
-	{
-	  if (strcmp (section_name,
-		      bfd_get_section_name (ls->ifile->the_bfd,
-					    ls->section))
-	      < 0)
-	    break;
-	}
+    {
+      if (strcmp (section_name,
+              bfd_get_section_name (ls->ifile->the_bfd,
+                        ls->section))
+          < 0)
+        break;
+    }
     }
 
   return l;
@@ -1326,8 +1328,8 @@ output_section_callback (ptr, section, file, output)
   
   if (before == NULL)
     wild_doit (&ptr->children, section, 
-	       (lang_output_section_statement_type *) output, 
-	       file);
+           (lang_output_section_statement_type *) output, 
+           file);
   else
     {
       lang_statement_list_type list;
@@ -1335,23 +1337,23 @@ output_section_callback (ptr, section, file, output)
       
       lang_list_init (&list);
       wild_doit (&list, section, 
-		 (lang_output_section_statement_type *) output, 
-		 file);
+         (lang_output_section_statement_type *) output, 
+         file);
       
       /* If we are discarding the section, LIST.HEAD will
-	 be NULL.  */
+     be NULL.  */
       if (list.head != NULL)
-	{
-	  ASSERT (list.head->next == NULL);
-	  
-	  for (pp = &ptr->children.head;
-	       *pp != before;
-	       pp = &(*pp)->next)
-	    ASSERT (*pp != NULL);
-	  
-	  list.head->next = *pp;
-	  *pp = list.head;
-	}
+    {
+      ASSERT (list.head->next == NULL);
+      
+      for (pp = &ptr->children.head;
+           *pp != before;
+           pp = &(*pp)->next)
+        ASSERT (*pp != NULL);
+      
+      list.head->next = *pp;
+      *pp = list.head;
+    }
     }
 }
 
@@ -1370,16 +1372,16 @@ lookup_name (name)
        search = (lang_input_statement_type *) search->next_real_file)
     {
       if (search->filename == (char *) NULL && name == (char *) NULL)
-	return search;
+    return search;
       if (search->filename != (char *) NULL
-	  && name != (char *) NULL
-	  && strcmp (search->filename, name) == 0)
-	break;
+      && name != (char *) NULL
+      && strcmp (search->filename, name) == 0)
+    break;
     }
 
   if (search == (lang_input_statement_type *) NULL)
     search = new_afile (name, lang_input_file_is_file_enum, default_target,
-			false);
+            false);
 
   /* If we have already added this file, or this file is not real
      (FIXME: can that ever actually happen?) or the name is NULL
@@ -1416,18 +1418,18 @@ load_symbols (entry, place)
 
       err = bfd_get_error ();
       if (err == bfd_error_file_ambiguously_recognized)
-	{
-	  char **p;
-
-	  einfo (_("%B: file not recognized: %E\n"), entry->the_bfd);
-	  einfo (_("%B: matching formats:"), entry->the_bfd);
-	  for (p = matching; *p != NULL; p++)
-	    einfo (" %s", *p);
-	  einfo ("%F\n");
-	}
+    {
+      char **p;
+
+      einfo (_("%B: file not recognized: %E\n"), entry->the_bfd);
+      einfo (_("%B: matching formats:"), entry->the_bfd);
+      for (p = matching; *p != NULL; p++)
+        einfo (" %s", *p);
+      einfo ("%F\n");
+    }
       else if (err != bfd_error_file_not_recognized
-	       || place == NULL)
-	einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
+           || place == NULL)
+    einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
 
       bfd_close (entry->the_bfd);
       entry->the_bfd = NULL;
@@ -1435,7 +1437,7 @@ load_symbols (entry, place)
       /* See if the emulation has some special knowledge.  */
 
       if (ldemul_unrecognized_file (entry))
-	return;
+    return;
 
       /* Try to interpret the file as a linker script.  */
 
@@ -1469,32 +1471,32 @@ load_symbols (entry, place)
     case bfd_object:
       ldlang_add_file (entry);
       if (trace_files || trace_file_tries)
-	info_msg ("%I\n", entry);
+    info_msg ("%I\n", entry);
       break;
 
     case bfd_archive:
       if (entry->whole_archive)
-	{
-	  bfd *member = bfd_openr_next_archived_file (entry->the_bfd,
-						      (bfd *) NULL);
-	  while (member != NULL)
-	    {
-	      if (! bfd_check_format (member, bfd_object))
-		einfo (_("%F%B: object %B in archive is not object\n"),
-		       entry->the_bfd, member);
-	      if (! ((*link_info.callbacks->add_archive_element)
-		     (&link_info, member, "--whole-archive")))
-		abort ();
-	      if (! bfd_link_add_symbols (member, &link_info))
-		einfo (_("%F%B: could not read symbols: %E\n"), member);
-	      member = bfd_openr_next_archived_file (entry->the_bfd,
-						     member);
-	    }
+    {
+      bfd *member = bfd_openr_next_archived_file (entry->the_bfd,
+                              (bfd *) NULL);
+      while (member != NULL)
+        {
+          if (! bfd_check_format (member, bfd_object))
+        einfo (_("%F%B: object %B in archive is not object\n"),
+               entry->the_bfd, member);
+          if (! ((*link_info.callbacks->add_archive_element)
+             (&link_info, member, "--whole-archive")))
+        abort ();
+          if (! bfd_link_add_symbols (member, &link_info))
+        einfo (_("%F%B: could not read symbols: %E\n"), member);
+          member = bfd_openr_next_archived_file (entry->the_bfd,
+                             member);
+        }
 
-	  entry->loaded = true;
+      entry->loaded = true;
 
-	  return;
-	}
+      return;
+    }
     }
 
   if (! bfd_link_add_symbols (entry->the_bfd, &link_info))
@@ -1552,7 +1554,7 @@ stricpy (dest, src)
   while ((c = * src ++) != 0)
     {
       if (isupper ((unsigned char) c))
-	c = tolower (c);
+    c = tolower (c);
 
       * dest ++ = c;
     }
@@ -1574,7 +1576,7 @@ strcut (haystack, needle)
       char * src;
 
       for (src = haystack + strlen (needle); * src;)
-	* haystack ++ = * src ++;
+    * haystack ++ = * src ++;
       
       * haystack = 0;
     }
@@ -1610,8 +1612,8 @@ name_compare (first, second)
   for (result = 0; copy1 [result] == copy2 [result]; result ++)
     if (copy1 [result] == 0)
       {
-	result *= 10;
-	break;
+    result *= 10;
+    break;
       }
   
   free (copy1);
@@ -1668,19 +1670,19 @@ get_first_input_target ()
   LANG_FOR_EACH_INPUT_STATEMENT (s)
     {
       if (s->header.type == lang_input_statement_enum
-	  && s->real)
-	{
-	  ldfile_open_file (s);
-	  
-	  if (s->the_bfd != NULL
-	      && bfd_check_format (s->the_bfd, bfd_object))
-	    {
-	      target = bfd_get_target (s->the_bfd);
-	  
-	      if (target != NULL)
-		break;
-	    }
-	}
+      && s->real)
+    {
+      ldfile_open_file (s);
+      
+      if (s->the_bfd != NULL
+          && bfd_check_format (s->the_bfd, bfd_object))
+        {
+          target = bfd_get_target (s->the_bfd);
+      
+          if (target != NULL)
+        break;
+        }
+    }
     }
   
   return target;
@@ -1699,17 +1701,17 @@ open_output (name)
     {
       /* No - has the current target been set to something other than the default ?  */
       if (current_target != default_target)
-	output_target = current_target;
+    output_target = current_target;
 
       /* No - can we determine the format of the first input file ? */
       else
-	{
-	  output_target = get_first_input_target ();
+    {
+      output_target = get_first_input_target ();
 
-	  /* Failed - use the default output target.  */
-	  if (output_target == NULL)
-	    output_target = default_target;
-	}
+      /* Failed - use the default output target.  */
+      if (output_target == NULL)
+        output_target = default_target;
+    }
     }
   
   /* Has the user requested a particular endianness on the command line ?  */
@@ -1722,33 +1724,33 @@ open_output (name)
       target = bfd_search_for_target (get_target, (void *) output_target);
 
       if (command_line.endian == ENDIAN_BIG)
-	desired_endian = BFD_ENDIAN_BIG;
+    desired_endian = BFD_ENDIAN_BIG;
       else
-	desired_endian = BFD_ENDIAN_LITTLE;
+    desired_endian = BFD_ENDIAN_LITTLE;
       
       /* See if the target has the wrong endianness.  This should not happen
-	 if the linker script has provided big and little endian alternatives,
-	 but some scrips don't do this.  */
+     if the linker script has provided big and little endian alternatives,
+     but some scrips don't do this.  */
       if (target->byteorder != desired_endian)
-	{
-	  /* If it does, then see if the target provides
-	     an alternative with the correct endianness.  */
-	  if (target->alternative_target != NULL
-	      && (target->alternative_target->byteorder == desired_endian))
-	    output_target = target->alternative_target->name;
-	  else
-	    {
-	      /* Try to find a target as similar as possible to the default
-		 target, but which has the desired endian characteristic.  */
-	      (void) bfd_search_for_target (closest_target_match, (void *) target);
-	      
-	      /* Oh dear - we could not find any targets that satisfy our requirements.  */
-	      if (winner == NULL)
-		einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
-	      else
-		output_target = winner->name;
-	    }
-	}
+    {
+      /* If it does, then see if the target provides
+         an alternative with the correct endianness.  */
+      if (target->alternative_target != NULL
+          && (target->alternative_target->byteorder == desired_endian))
+        output_target = target->alternative_target->name;
+      else
+        {
+          /* Try to find a target as similar as possible to the default
+         target, but which has the desired endian characteristic.  */
+          (void) bfd_search_for_target (closest_target_match, (void *) target);
+          
+          /* Oh dear - we could not find any targets that satisfy our requirements.  */
+          if (winner == NULL)
+        einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
+          else
+        output_target = winner->name;
+        }
+    }
     }
       
   output = bfd_openw (name, output_target);
@@ -1756,7 +1758,7 @@ open_output (name)
   if (output == (bfd *) NULL)
     {
       if (bfd_get_error () == bfd_error_invalid_target)
-	einfo (_("%P%F: target %s not found\n"), output_target);
+    einfo (_("%P%F: target %s not found\n"), output_target);
 
       einfo (_("%P%F: cannot open output file %s: %E\n"), name);
     }
@@ -1768,8 +1770,8 @@ open_output (name)
   if (! bfd_set_format (output, bfd_object))
     einfo (_("%P%F:%s: can not make object file: %E\n"), name);
   if (! bfd_set_arch_mach (output,
-			   ldfile_output_architecture,
-			   ldfile_output_machine))
+               ldfile_output_architecture,
+               ldfile_output_machine))
     einfo (_("%P%F:%s: can not set architecture: %E\n"), name);
 
   link_info.hash = bfd_link_hash_table_create (output);
@@ -1791,17 +1793,17 @@ ldlang_open_output (statement)
       output_bfd = open_output (statement->output_statement.name);
       ldemul_set_output_arch ();
       if (config.magic_demand_paged && !link_info.relocateable)
-	output_bfd->flags |= D_PAGED;
+    output_bfd->flags |= D_PAGED;
       else
-	output_bfd->flags &= ~D_PAGED;
+    output_bfd->flags &= ~D_PAGED;
       if (config.text_read_only)
-	output_bfd->flags |= WP_TEXT;
+    output_bfd->flags |= WP_TEXT;
       else
-	output_bfd->flags &= ~WP_TEXT;
+    output_bfd->flags &= ~WP_TEXT;
       if (link_info.traditional_format)
-	output_bfd->flags |= BFD_TRADITIONAL_FORMAT;
+    output_bfd->flags |= BFD_TRADITIONAL_FORMAT;
       else
-	output_bfd->flags &= ~BFD_TRADITIONAL_FORMAT;
+    output_bfd->flags &= ~BFD_TRADITIONAL_FORMAT;
       break;
 
     case lang_target_statement_enum:
@@ -1822,69 +1824,69 @@ open_input_bfds (s, force)
   for (; s != (lang_statement_union_type *) NULL; s = s->next)
     {
       switch (s->header.type)
-	{
-	case lang_constructors_statement_enum:
-	  open_input_bfds (constructor_list.head, force);
-	  break;
-	case lang_output_section_statement_enum:
-	  open_input_bfds (s->output_section_statement.children.head, force);
-	  break;
-	case lang_wild_statement_enum:
-	  /* Maybe we should load the file's symbols */
-	  if (s->wild_statement.filename
-	      && ! wildcardp (s->wild_statement.filename))
-	    (void) lookup_name (s->wild_statement.filename);
-	  open_input_bfds (s->wild_statement.children.head, force);
-	  break;
-	case lang_group_statement_enum:
-	  {
-	    struct bfd_link_hash_entry *undefs;
-
-	    /* We must continually search the entries in the group
+    {
+    case lang_constructors_statement_enum:
+      open_input_bfds (constructor_list.head, force);
+      break;
+    case lang_output_section_statement_enum:
+      open_input_bfds (s->output_section_statement.children.head, force);
+      break;
+    case lang_wild_statement_enum:
+      /* Maybe we should load the file's symbols */
+      if (s->wild_statement.filename
+          && ! wildcardp (s->wild_statement.filename))
+        (void) lookup_name (s->wild_statement.filename);
+      open_input_bfds (s->wild_statement.children.head, force);
+      break;
+    case lang_group_statement_enum:
+      {
+        struct bfd_link_hash_entry *undefs;
+
+        /* We must continually search the entries in the group
                until no new symbols are added to the list of undefined
                symbols.  */
 
-	    do
-	      {
-		undefs = link_info.hash->undefs_tail;
-		open_input_bfds (s->group_statement.children.head, true);
-	      }
-	    while (undefs != link_info.hash->undefs_tail);
-	  }
-	  break;
-	case lang_target_statement_enum:
-	  current_target = s->target_statement.target;
-	  break;
-	case lang_input_statement_enum:
-	  if (s->input_statement.real)
-	    {
-	      lang_statement_list_type add;
+        do
+          {
+        undefs = link_info.hash->undefs_tail;
+        open_input_bfds (s->group_statement.children.head, true);
+          }
+        while (undefs != link_info.hash->undefs_tail);
+      }
+      break;
+    case lang_target_statement_enum:
+      current_target = s->target_statement.target;
+      break;
+    case lang_input_statement_enum:
+      if (s->input_statement.real)
+        {
+          lang_statement_list_type add;
 
-	      s->input_statement.target = current_target;
+          s->input_statement.target = current_target;
 
-	      /* If we are being called from within a group, and this
+          /* If we are being called from within a group, and this
                  is an archive which has already been searched, then
                  force it to be researched.  */
-	      if (force
-		  && s->input_statement.loaded
-		  && bfd_check_format (s->input_statement.the_bfd,
-				       bfd_archive))
-		s->input_statement.loaded = false;
+          if (force
+          && s->input_statement.loaded
+          && bfd_check_format (s->input_statement.the_bfd,
+                       bfd_archive))
+        s->input_statement.loaded = false;
 
-	      lang_list_init (&add);
+          lang_list_init (&add);
 
-	      load_symbols (&s->input_statement, &add);
+          load_symbols (&s->input_statement, &add);
 
-	      if (add.head != NULL)
-		{
-		  *add.tail = s->next;
-		  s->next = add.head;
-		}
-	    }
-	  break;
-	default:
-	  break;
-	}
+          if (add.head != NULL)
+        {
+          *add.tail = s->next;
+          s->next = add.head;
+        }
+        }
+      break;
+    default:
+      break;
+    }
     }
 }
 
@@ -1905,7 +1907,7 @@ lang_reasonable_defaults ()
     {
       lang_wild_statement_type *new =
       new_stat (lang_wild_statement,
-		&default_common_section->children);
+        &default_common_section->children);
 
       new->section_name = "COMMON";
       new->filename = (char *) NULL;
@@ -1958,13 +1960,13 @@ lang_place_undefineds ()
 
       h = bfd_link_hash_lookup (link_info.hash, ptr->name, true, false, true);
       if (h == (struct bfd_link_hash_entry *) NULL)
-	einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
+    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
       if (h->type == bfd_link_hash_new)
-	{
-	  h->type = bfd_link_hash_undefined;
-	  h->u.undef.abfd = NULL;
-	  bfd_link_add_undef (link_info.hash, h);
-	}
+    {
+      h->type = bfd_link_hash_undefined;
+      h->u.undef.abfd = NULL;
+      bfd_link_add_undef (link_info.hash, h);
+    }
     }
 }
 
@@ -1978,71 +1980,71 @@ map_input_to_output_sections (s, target, output_section_statement)
   for (; s != (lang_statement_union_type *) NULL; s = s->next)
     {
       switch (s->header.type)
-	{
-
-
-	case lang_wild_statement_enum:
-	  wild (&s->wild_statement, s->wild_statement.section_name,
-		s->wild_statement.filename, target,
-		output_section_statement);
-
-	  break;
-	case lang_constructors_statement_enum:
-	  map_input_to_output_sections (constructor_list.head,
-					target,
-					output_section_statement);
-	  break;
-	case lang_output_section_statement_enum:
-	  map_input_to_output_sections (s->output_section_statement.children.head,
-					target,
-					&s->output_section_statement);
-	  break;
-	case lang_output_statement_enum:
-	  break;
-	case lang_target_statement_enum:
-	  target = s->target_statement.target;
-	  break;
-	case lang_group_statement_enum:
-	  map_input_to_output_sections (s->group_statement.children.head,
-					target,
-					output_section_statement);
-	  break;
-	case lang_fill_statement_enum:
-	case lang_input_section_enum:
-	case lang_object_symbols_statement_enum:
-	case lang_data_statement_enum:
-	case lang_reloc_statement_enum:
-	case lang_padding_statement_enum:
-	case lang_input_statement_enum:
-	  if (output_section_statement != NULL
-	      && output_section_statement->bfd_section == NULL)
-	    init_os (output_section_statement);
-	  break;
-	case lang_assignment_statement_enum:
-	  if (output_section_statement != NULL
-	      && output_section_statement->bfd_section == NULL)
-	    init_os (output_section_statement);
-
-	  /* Make sure that any sections mentioned in the assignment
+    {
+
+
+    case lang_wild_statement_enum:
+      wild (&s->wild_statement, s->wild_statement.section_name,
+        s->wild_statement.filename, target,
+        output_section_statement);
+
+      break;
+    case lang_constructors_statement_enum:
+      map_input_to_output_sections (constructor_list.head,
+                    target,
+                    output_section_statement);
+      break;
+    case lang_output_section_statement_enum:
+      map_input_to_output_sections (s->output_section_statement.children.head,
+                    target,
+                    &s->output_section_statement);
+      break;
+    case lang_output_statement_enum:
+      break;
+    case lang_target_statement_enum:
+      target = s->target_statement.target;
+      break;
+    case lang_group_statement_enum:
+      map_input_to_output_sections (s->group_statement.children.head,
+                    target,
+                    output_section_statement);
+      break;
+    case lang_fill_statement_enum:
+    case lang_input_section_enum:
+    case lang_object_symbols_statement_enum:
+    case lang_data_statement_enum:
+    case lang_reloc_statement_enum:
+    case lang_padding_statement_enum:
+    case lang_input_statement_enum:
+      if (output_section_statement != NULL
+          && output_section_statement->bfd_section == NULL)
+        init_os (output_section_statement);
+      break;
+    case lang_assignment_statement_enum:
+      if (output_section_statement != NULL
+          && output_section_statement->bfd_section == NULL)
+        init_os (output_section_statement);
+
+      /* Make sure that any sections mentioned in the assignment
              are initialized.  */
-	  exp_init_os (s->assignment_statement.exp);
-	  break;
-	case lang_afile_asection_pair_statement_enum:
-	  FAIL ();
-	  break;
-	case lang_address_statement_enum:
-	  /* Mark the specified section with the supplied address */
-	  {
-	    lang_output_section_statement_type *os =
-	      lang_output_section_statement_lookup
-		(s->address_statement.section_name);
-
-	    if (os->bfd_section == NULL)
-	      init_os (os);
-	    os->addr_tree = s->address_statement.address;
-	  }
-	  break;
-	}
+      exp_init_os (s->assignment_statement.exp);
+      break;
+    case lang_afile_asection_pair_statement_enum:
+      FAIL ();
+      break;
+    case lang_address_statement_enum:
+      /* Mark the specified section with the supplied address */
+      {
+        lang_output_section_statement_type *os =
+          lang_output_section_statement_lookup
+        (s->address_statement.section_name);
+
+        if (os->bfd_section == NULL)
+          init_os (os);
+        os->addr_tree = s->address_statement.address;
+      }
+      break;
+    }
     }
 }
 
@@ -2055,41 +2057,50 @@ print_output_section_statement (output_section_statement)
 
   if (output_section_statement != abs_output_section)
     {
+
+/* add D.Fujimoto 2006/06/12 >>> display message for debugging sections */
+      if (strncmp (output_section_statement->name, ".stab", sizeof(".stab") - 1) == 0 ||
+          strncmp (output_section_statement->name, ".comment", sizeof(".comment") - 1) == 0) {
+        minfo("\n*** Section %s will not be loaded to the target ***\n", output_section_statement->name);
+      }
+/* add D.Fujimoto 2006/06/12 <<< display message for debugging sections */
+
       minfo ("\n%s", output_section_statement->name);
 
       if (section != NULL)
-	{
-	  print_dot = section->vma;
+    {
+      print_dot = section->vma;
 
-	  len = strlen (output_section_statement->name);
-	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
-	    {
-	      print_nl ();
-	      len = 0;
-	    }
-	  while (len < SECTION_NAME_MAP_LENGTH)
-	    {
-	      print_space ();
-	      ++len;
-	    }
+      len = strlen (output_section_statement->name);
+      if (len >= SECTION_NAME_MAP_LENGTH - 1)
+        {
+          print_nl ();
+          len = 0;
+        }
+      while (len < SECTION_NAME_MAP_LENGTH)
+        {
+          print_space ();
+          ++len;
+        }
 
-	  minfo ("0x%V %W", section->vma, section->_raw_size);
+      minfo ("0x%V %W", section->vma, section->_raw_size);
 
-	  if (output_section_statement->load_base != NULL)
-	    {
-	      bfd_vma addr;
 
-	      addr = exp_get_abs_int (output_section_statement->load_base, 0,
-				      "load base", lang_final_phase_enum);
-	      minfo (_(" load address 0x%V"), addr);
-	    }
-	}
+      if (output_section_statement->load_base != NULL)
+        {
+          bfd_vma addr;
+
+          addr = exp_get_abs_int (output_section_statement->load_base, 0,
+                      "load base", lang_final_phase_enum);
+          minfo (_(" load address 0x%V"), addr);
+        }
+    }
 
       print_nl ();
     }
 
   print_statement_list (output_section_statement->children.head,
-			output_section_statement);
+            output_section_statement);
 }
 
 static void
@@ -2104,7 +2115,7 @@ print_assignment (assignment, output_section)
     print_space ();
 
   result = exp_fold_tree (assignment->exp->assign.src, output_section,
-			  lang_final_phase_enum, print_dot, &print_dot);
+              lang_final_phase_enum, print_dot, &print_dot);
   if (result.valid_p)
     minfo ("0x%V", result.value + result.section->bfd_section->vma);
   else
@@ -2149,11 +2160,11 @@ print_one_symbol (hash_entry, ptr)
       int i;
 
       for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
-	print_space ();
+    print_space ();
       minfo ("0x%V   ",
-	     (hash_entry->u.def.value
-	      + hash_entry->u.def.section->output_offset
-	      + hash_entry->u.def.section->output_section->vma));
+         (hash_entry->u.def.value
+          + hash_entry->u.def.section->output_offset
+          + hash_entry->u.def.section->output_section->vma));
 
       minfo ("             %T\n", hash_entry->root.string);
     }
@@ -2170,7 +2181,7 @@ print_input_section (in)
   asection *i = in->section;
   bfd_size_type size = i->_cooked_size != 0 ? i->_cooked_size : i->_raw_size;
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine);
+                        ldfile_output_machine);
   if (size != 0)
     {
       print_space ();
@@ -2178,49 +2189,162 @@ print_input_section (in)
       minfo ("%s", i->name);
 
       if (i->output_section != NULL)
-	{
-	  int len;
+    {
+      int len;
 
-	  len = 1 + strlen (i->name);
-	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
-	    {
-	      print_nl ();
-	      len = 0;
-	    }
-	  while (len < SECTION_NAME_MAP_LENGTH)
-	    {
-	      print_space ();
-	      ++len;
-	    }
+      len = 1 + strlen (i->name);
+      if (len >= SECTION_NAME_MAP_LENGTH - 1)
+        {
+          print_nl ();
+          len = 0;
+        }
+      while (len < SECTION_NAME_MAP_LENGTH)
+        {
+          print_space ();
+          ++len;
+        }
 
-	  minfo ("0x%V %W %B\n",
-		 i->output_section->vma + i->output_offset, size / opb,
-		 i->owner);
+      minfo ("0x%V %W %B\n",
+         i->output_section->vma + i->output_offset, size / opb,
+         i->owner);
 
-	  if (i->_cooked_size != 0 && i->_cooked_size != i->_raw_size)
-	    {
-	      len = SECTION_NAME_MAP_LENGTH + 3;
+
+      if (i->_cooked_size != 0 && i->_cooked_size != i->_raw_size)
+        {
+          len = SECTION_NAME_MAP_LENGTH + 3;
 #ifdef BFD64
-	      len += 16;
+          len += 16;
 #else
-	      len += 8;
+          len += 8;
 #endif
-	      while (len > 0)
+          while (len > 0)
+        {
+          print_space ();
+          --len;
+        }
+
+          minfo (_("%W (size before relaxing)\n"), i->_raw_size);
+        }
+
+/* output symbol for sequential of address : change T.Tazaki 2005/06/16 >>> */
+
+/* del 
+      bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) i);
+*/
+      c33_bfd_hash_traverse (&link_info.hash->table,
+		     ((boolean (*) PARAMS ((struct bfd_hash_entry *, PTR)))
+		      c33_print_one_symbol),
+		     (PTR) i);
+
+/* output symbol for sequential of address : change T.Tazaki 2005/06/16 <<< */
+
+
+      print_dot = i->output_section->vma + i->output_offset + size / opb;
+    }
+    }
+}
+
+/* output symbol for sequential of address : change T.Tazaki 2005/06/16 >>> */
+
+#define C33_SYMBOL_MAX 3000
+
+static int c33_iSymbolIndex = 0;
+static unsigned long c33_ulSymbolAddr[C33_SYMBOL_MAX + 10];
+static char c33_szSymbol[C33_SYMBOL_MAX + 10][300];
+static unsigned long c33_ulSymbolAddr2[C33_SYMBOL_MAX + 10];
+static char c33_szSymbol2[C33_SYMBOL_MAX + 10][300];
+
+static void
+c33_bfd_hash_traverse (table, func, info)
+     struct bfd_hash_table *table;
+     boolean (*func) PARAMS ((struct bfd_hash_entry *, PTR));
+     PTR info;
+{
+  unsigned int i;
+  unsigned int j;
+  unsigned int k;
+  int iMinIndex = 0;
+  unsigned long ulMinAddr = 0;
+
+  c33_iSymbolIndex = 0;	/* initialize output symbol index */
+
+    for (i = 0; i < table->size; i++)
+    {
+        struct bfd_hash_entry *p;
+
+        for (p = table->table[i]; p != NULL; p = p->next)
 		{
-		  print_space ();
-		  --len;
+		    if (! (*func) (p, info))	/* c33_print_one_symbol() */
+				    return;
 		}
+    }
 
-	      minfo (_("%W (size before relaxing)\n"), i->_raw_size);
-	    }
+    /* sort symbol address */
+    
+    for( j = 0; j < c33_iSymbolIndex; ++j )
+    {
+    	iMinIndex = 0;
+	    ulMinAddr = c33_ulSymbolAddr[ iMinIndex ];
+	    
+	    for( k = 0; k < c33_iSymbolIndex; ++k )
+	    {
+		    if( ulMinAddr > c33_ulSymbolAddr[ k ] )
+		    {
+				ulMinAddr = c33_ulSymbolAddr[ k ];
+				iMinIndex = k;
+			}
+		}
+		c33_ulSymbolAddr2[ j ] = c33_ulSymbolAddr[ iMinIndex ];
+		strcpy( c33_szSymbol2[ j ], c33_szSymbol[ iMinIndex ] );
+
+		c33_ulSymbolAddr[ iMinIndex ] = 0xffffffff;	/* max set */
+	}
 
-	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) i);
+	/* symbol output */
+	
+    for( j = 0; j < c33_iSymbolIndex; ++j )
+    {
+	      for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
+	            print_space ();
+	      minfo ("0x%V   ", c33_ulSymbolAddr2[ j ] );
+	      minfo ("             %T\n", c33_szSymbol2[ j ] );
 
-	  print_dot = i->output_section->vma + i->output_offset + size / opb;
 	}
-    }
+
 }
 
+
+static boolean 
+c33_print_one_symbol (hash_entry, ptr)
+     struct bfd_link_hash_entry *hash_entry;
+     PTR ptr;
+{
+  asection *sec = (asection *) ptr;
+
+  if ((hash_entry->type == bfd_link_hash_defined
+       || hash_entry->type == bfd_link_hash_defweak)
+      && sec == hash_entry->u.def.section)
+    {
+
+		/* set symbol address and symbol name to dim. */
+		if( c33_iSymbolIndex < C33_SYMBOL_MAX )
+		{
+			
+
+			c33_ulSymbolAddr[ c33_iSymbolIndex ] = (hash_entry->u.def.value
+				          + hash_entry->u.def.section->output_offset
+				          + hash_entry->u.def.section->output_section->vma);
+		        strcpy( c33_szSymbol[ c33_iSymbolIndex ],hash_entry->root.string );
+
+			++c33_iSymbolIndex;
+
+	    }
+	}
+  return true;
+}
+
+/* output symbol for sequential of address : change T.Tazaki 2005/06/16 <<< */
+
 static void
 print_fill_statement (fill)
      lang_fill_statement_type * fill;
@@ -2237,7 +2361,7 @@ print_data_statement (data)
   bfd_size_type size;
   const char *name;
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine);
+                        ldfile_output_machine);
 
   for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
     print_space ();
@@ -2308,7 +2432,7 @@ print_reloc_statement (reloc)
   bfd_vma addr;
   bfd_size_type size;
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine); 
+                        ldfile_output_machine); 
 
   for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
     print_space ();
@@ -2340,7 +2464,7 @@ print_padding_statement (s)
   int len;
   bfd_vma addr;
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine); 
+                        ldfile_output_machine); 
 
   minfo (" *fill*");
 
@@ -2439,6 +2563,8 @@ print_statement (s, os)
      lang_statement_union_type *s;
      lang_output_section_statement_type *os;
 {
+
+
   switch (s->header.type)
     {
     default:
@@ -2447,13 +2573,13 @@ print_statement (s, os)
       break;
     case lang_constructors_statement_enum:
       if (constructor_list.head != NULL)
-	{
-	  if (constructors_sorted)
-	    minfo (" SORT (CONSTRUCTORS)\n");
-	  else
-	    minfo (" CONSTRUCTORS\n");
-	  print_statement_list (constructor_list.head, os);
-	}
+    {
+      if (constructors_sorted)
+        minfo (" SORT (CONSTRUCTORS)\n");
+      else
+        minfo (" CONSTRUCTORS\n");
+      print_statement_list (constructor_list.head, os);
+    }
       break;
     case lang_wild_statement_enum:
       print_wild_statement (&s->wild_statement, os);
@@ -2491,7 +2617,7 @@ print_statement (s, os)
     case lang_output_statement_enum:
       minfo ("OUTPUT(%s", s->output_statement.name);
       if (output_target != NULL)
-	minfo (" %s", output_target);
+    minfo (" %s", output_target);
       minfo (")\n");
       break;
     case lang_input_statement_enum:
@@ -2531,10 +2657,10 @@ dprint_statement (s, n)
   else
     {
       while (s && --n >= 0)
-	{
-	  print_statement (s, abs_output_section);
-	  s = s->next;
-	}
+    {
+      print_statement (s, abs_output_section);
+      s = s->next;
+    }
     }
 
   config.map_file = map_save;
@@ -2557,14 +2683,14 @@ insert_pad (this_ptr, fill, power, output_section_statement, dot)
      */
 
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine); 
+                        ldfile_output_machine); 
   unsigned int alignment_needed = align_power (dot, power) - dot;
 
   if (alignment_needed != 0)
     {
       lang_statement_union_type *new =
-	((lang_statement_union_type *)
-	 stat_alloc (sizeof (lang_padding_statement_type)));
+    ((lang_statement_union_type *)
+     stat_alloc (sizeof (lang_padding_statement_type)));
 
       /* Link into existing chain */
       new->header.next = *this_ptr;
@@ -2572,7 +2698,7 @@ insert_pad (this_ptr, fill, power, output_section_statement, dot)
       new->header.type = lang_padding_statement_enum;
       new->padding_statement.output_section = output_section_statement;
       new->padding_statement.output_offset =
-	dot - output_section_statement->vma;
+    dot - output_section_statement->vma;
       new->padding_statement.fill = fill;
       new->padding_statement.size = alignment_needed * opb;
     }
@@ -2600,27 +2726,27 @@ size_input_section (this_ptr, output_section_statement, fill, dot, relax)
   lang_input_section_type *is = &((*this_ptr)->input_section);
   asection *i = is->section;
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine); 
+                        ldfile_output_machine); 
 
   if (is->ifile->just_syms_flag == false)
     {
       if (output_section_statement->subsection_alignment != -1)
        i->alignment_power =
-	output_section_statement->subsection_alignment;
+    output_section_statement->subsection_alignment;
 
       dot = insert_pad (this_ptr, fill, i->alignment_power,
-			output_section_statement->bfd_section, dot);
+            output_section_statement->bfd_section, dot);
 
       /* Remember where in the output section this input section goes */
 
       i->output_offset = dot - output_section_statement->bfd_section->vma;
 
       /* Mark how big the output section must be to contain this now
-	 */
+     */
       if (i->_cooked_size != 0)
-	dot += i->_cooked_size / opb;
+    dot += i->_cooked_size / opb;
       else
-	dot += i->_raw_size / opb;
+    dot += i->_raw_size / opb;
       output_section_statement->bfd_section->_raw_size = 
         (dot - output_section_statement->bfd_section->vma) * opb;
     }
@@ -2652,42 +2778,42 @@ lang_check_section_addresses ()
       
       /* Ignore sections which are not loaded or which have no contents.  */
       if (IGNORE_SECTION (output_bfd, s))
-	continue;
+    continue;
       
       /* Once we reach section 's' stop our seach.  This prevents two
-	 warning messages from being produced, one for 'section A overlaps
-	 section B' and one for 'section B overlaps section A'.  */
+     warning messages from being produced, one for 'section A overlaps
+     section B' and one for 'section B overlaps section A'.  */
       for (os = output_bfd->sections; os != s; os = os->next)
-	{
-	  bfd_vma s_start;
-	  bfd_vma s_end;
-	  bfd_vma os_start;
-	  bfd_vma os_end;
-	  
-	  /* Only consider loadable sections with real contents.  */
-	  if (IGNORE_SECTION (output_bfd, os))
-	    continue;
-
-	  /* We must check the sections' LMA addresses not their
-	     VMA addresses because overlay sections can have
-	     overlapping VMAs but they must have distinct LMAs.  */
-	  s_start  = bfd_section_lma (output_bfd, s);
-	  os_start = bfd_section_lma (output_bfd, os);
-	  s_end    = s_start  + bfd_section_size (output_bfd, s) / opb - 1;
-	  os_end   = os_start + bfd_section_size (output_bfd, os) / opb - 1;
-	  
-	  /* Look for an overlap.  */
-	  if ((s_end < os_start) || (s_start > os_end))
-	    continue;
-	  
-	  einfo (
+    {
+      bfd_vma s_start;
+      bfd_vma s_end;
+      bfd_vma os_start;
+      bfd_vma os_end;
+      
+      /* Only consider loadable sections with real contents.  */
+      if (IGNORE_SECTION (output_bfd, os))
+        continue;
+
+      /* We must check the sections' LMA addresses not their
+         VMA addresses because overlay sections can have
+         overlapping VMAs but they must have distinct LMAs.  */
+      s_start  = bfd_section_lma (output_bfd, s);
+      os_start = bfd_section_lma (output_bfd, os);
+      s_end    = s_start  + bfd_section_size (output_bfd, s) / opb - 1;
+      os_end   = os_start + bfd_section_size (output_bfd, os) / opb - 1;
+      
+      /* Look for an overlap.  */
+      if ((s_end < os_start) || (s_start > os_end))
+        continue;
+      
+      einfo (
 _("%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"),
-		 s->name, s_start, s_end, os->name, os_start, os_end);
-	  
-	  /* Once we have found one overlap for this section,
-	     stop looking for others.  */
-	  break;
-	}
+         s->name, s_start, s_end, os->name, os_start, os_end);
+      
+      /* Once we have found one overlap for this section,
+         stop looking for others.  */
+      break;
+    }
     }
 }
 
@@ -2745,153 +2871,153 @@ lang_size_sections (s, output_section_statement, prev, fill, dot, relax)
      boolean relax;
 {
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine);
+                        ldfile_output_machine);
 
   /* Size up the sections from their constituent parts.  */
   for (; s != (lang_statement_union_type *) NULL; s = s->next)
     {
       switch (s->header.type)
-	{
-	case lang_output_section_statement_enum:
-	  {
-	    bfd_vma after;
-	    lang_output_section_statement_type *os = &s->output_section_statement;
-
-	    if (os->bfd_section == NULL)
-	      /* This section was never actually created.  */
-	      break;
-
-	    /* If this is a COFF shared library section, use the size and
-	       address from the input section.  FIXME: This is COFF
-	       specific; it would be cleaner if there were some other way
-	       to do this, but nothing simple comes to mind.  */
-	    if ((os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
-	      {
-		asection * input;
-
-		if (os->children.head == NULL
-		    || os->children.head->next != NULL
-		    || os->children.head->header.type != lang_input_section_enum)
-		  einfo (_("%P%X: Internal error on COFF shared library section %s\n"),
-			 os->name);
-
-		input = os->children.head->input_section.section;
-		bfd_set_section_vma (os->bfd_section->owner,
-				     os->bfd_section,
-				     bfd_section_vma (input->owner, input));
-		os->bfd_section->_raw_size = input->_raw_size;
-		break;
-	      }
-
-	    if (bfd_is_abs_section (os->bfd_section))
-	      {
-		/* No matter what happens, an abs section starts at zero.  */
-		ASSERT (os->bfd_section->vma == 0);
-	      }
-	    else
-	      {
-		if (os->addr_tree == (etree_type *) NULL)
-		  {
-		    /* No address specified for this section, get one
-		       from the region specification.  */
-		    if (os->region == (lang_memory_region_type *) NULL
-			|| (((bfd_get_section_flags (output_bfd, os->bfd_section)
-			      & (SEC_ALLOC | SEC_LOAD)) != 0)
-			    && os->region->name[0] == '*'
-			    && strcmp (os->region->name, "*default*") == 0))
-		      {
-			os->region = lang_memory_default (os->bfd_section);
-		      }
-
-		    /* If a loadable section is using the default memory
-		       region, and some non default memory regions were
-		       defined, issue a warning.  */
-		    if ((bfd_get_section_flags (output_bfd, os->bfd_section)
-			 & (SEC_ALLOC | SEC_LOAD)) != 0
-			&& ! link_info.relocateable
-			&& strcmp (os->region->name, "*default*") == 0
-			&& lang_memory_region_list != NULL
-			&& (strcmp (lang_memory_region_list->name, "*default*") != 0
-			    || lang_memory_region_list->next != NULL))
-		      einfo (_("%P: warning: no memory region specified for section `%s'\n"),
-			     bfd_get_section_name (output_bfd, os->bfd_section));
-
-		    dot = os->region->current;
+    {
+    case lang_output_section_statement_enum:
+      {
+        bfd_vma after;
+        lang_output_section_statement_type *os = &s->output_section_statement;
+
+        if (os->bfd_section == NULL)
+          /* This section was never actually created.  */
+          break;
+
+        /* If this is a COFF shared library section, use the size and
+           address from the input section.  FIXME: This is COFF
+           specific; it would be cleaner if there were some other way
+           to do this, but nothing simple comes to mind.  */
+        if ((os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
+          {
+        asection * input;
+
+        if (os->children.head == NULL
+            || os->children.head->next != NULL
+            || os->children.head->header.type != lang_input_section_enum)
+          einfo (_("%P%X: Internal error on COFF shared library section %s\n"),
+             os->name);
+
+        input = os->children.head->input_section.section;
+        bfd_set_section_vma (os->bfd_section->owner,
+                     os->bfd_section,
+                     bfd_section_vma (input->owner, input));
+        os->bfd_section->_raw_size = input->_raw_size;
+        break;
+          }
+
+        if (bfd_is_abs_section (os->bfd_section))
+          {
+        /* No matter what happens, an abs section starts at zero.  */
+        ASSERT (os->bfd_section->vma == 0);
+          }
+        else
+          {
+        if (os->addr_tree == (etree_type *) NULL)
+          {
+            /* No address specified for this section, get one
+               from the region specification.  */
+            if (os->region == (lang_memory_region_type *) NULL
+            || (((bfd_get_section_flags (output_bfd, os->bfd_section)
+                  & (SEC_ALLOC | SEC_LOAD)) != 0)
+                && os->region->name[0] == '*'
+                && strcmp (os->region->name, "*default*") == 0))
+              {
+            os->region = lang_memory_default (os->bfd_section);
+              }
+
+            /* If a loadable section is using the default memory
+               region, and some non default memory regions were
+               defined, issue a warning.  */
+            if ((bfd_get_section_flags (output_bfd, os->bfd_section)
+             & (SEC_ALLOC | SEC_LOAD)) != 0
+            && ! link_info.relocateable
+            && strcmp (os->region->name, "*default*") == 0
+            && lang_memory_region_list != NULL
+            && (strcmp (lang_memory_region_list->name, "*default*") != 0
+                || lang_memory_region_list->next != NULL))
+              einfo (_("%P: warning: no memory region specified for section `%s'\n"),
+                 bfd_get_section_name (output_bfd, os->bfd_section));
+
+            dot = os->region->current;
  
-		    if (os->section_alignment == -1)
-		      {
-			bfd_vma olddot;
-
-			olddot = dot;
-			dot = align_power (dot, os->bfd_section->alignment_power);
-
-			if (dot != olddot && config.warn_section_align)
-			  einfo (_("%P: warning: changing start of section %s by %u bytes\n"),
-				 os->name, (unsigned int) (dot - olddot));
-		      }
-		  }
-		else
-		  {
-		    etree_value_type r;
-
-		    r = exp_fold_tree (os->addr_tree,
-				       abs_output_section,
-				       lang_allocating_phase_enum,
-				       dot, &dot);
-		    if (r.valid_p == false)
-		      {
-			einfo (_("%F%S: non constant address expression for section %s\n"),
-			       os->name);
-		      }
-		    dot = r.value + r.section->bfd_section->vma;
-		  }
-		
-		/* The section starts here.
-		   First, align to what the section needs.  */
-
-		if (os->section_alignment != -1)
-		  dot = align_power (dot, os->section_alignment);
-
-		bfd_set_section_vma (0, os->bfd_section, dot);
-		
-		os->bfd_section->output_offset = 0;
-	      }
-
-	    (void) lang_size_sections (os->children.head, os, &os->children.head,
-				       os->fill, dot, relax);
-	    
+            if (os->section_alignment == -1)
+              {
+            bfd_vma olddot;
+
+            olddot = dot;
+            dot = align_power (dot, os->bfd_section->alignment_power);
+
+            if (dot != olddot && config.warn_section_align)
+              einfo (_("%P: warning: changing start of section %s by %u bytes\n"),
+                 os->name, (unsigned int) (dot - olddot));
+              }
+          }
+        else
+          {
+            etree_value_type r;
+
+            r = exp_fold_tree (os->addr_tree,
+                       abs_output_section,
+                       lang_allocating_phase_enum,
+                       dot, &dot);
+            if (r.valid_p == false)
+              {
+            einfo (_("%F%S: non constant address expression for section %s\n"),
+                   os->name);
+              }
+            dot = r.value + r.section->bfd_section->vma;
+          }
+        
+        /* The section starts here.
+           First, align to what the section needs.  */
+
+        if (os->section_alignment != -1)
+          dot = align_power (dot, os->section_alignment);
+
+        bfd_set_section_vma (0, os->bfd_section, dot);
+        
+        os->bfd_section->output_offset = 0;
+          }
+
+        (void) lang_size_sections (os->children.head, os, &os->children.head,
+                       os->fill, dot, relax);
+        
             /* put the section within the requested block size, or align at
                the block boundary */
-	    after = ALIGN_N (os->bfd_section->vma
-			     + os->bfd_section->_raw_size / opb,
-			     /* The coercion here is important, see ld.h.  */
-			     (bfd_vma) os->block_value);
-
-	    if (bfd_is_abs_section (os->bfd_section))
-	      ASSERT (after == os->bfd_section->vma);
-	    else
-	      os->bfd_section->_raw_size = 
+        after = ALIGN_N (os->bfd_section->vma
+                 + os->bfd_section->_raw_size / opb,
+                 /* The coercion here is important, see ld.h.  */
+                 (bfd_vma) os->block_value);
+
+        if (bfd_is_abs_section (os->bfd_section))
+          ASSERT (after == os->bfd_section->vma);
+        else
+          os->bfd_section->_raw_size = 
                 (after - os->bfd_section->vma) * opb;
-	    dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
-	    os->processed = true;
-
-	    /* Update dot in the region ?
-	       We only do this if the section is going to be allocated,
-	       since unallocated sections do not contribute to the region's
-	       overall size in memory.
-	       
-	       If the SEC_NEVER_LOAD bit is not set, it will affect the
-	       addresses of sections after it. We have to update
-	       dot.  */
-	    if (os->region != (lang_memory_region_type *) NULL
-		&& ((bfd_get_section_flags (output_bfd, os->bfd_section)
-		     & SEC_NEVER_LOAD) == 0
-		    || (bfd_get_section_flags (output_bfd, os->bfd_section)
-			& (SEC_ALLOC | SEC_LOAD))))
-	      {
-		os->region->current = dot;
-		
-		/* Make sure the new address is within the region.  */
+        dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
+        os->processed = true;
+
+        /* Update dot in the region ?
+           We only do this if the section is going to be allocated,
+           since unallocated sections do not contribute to the region's
+           overall size in memory.
+           
+           If the SEC_NEVER_LOAD bit is not set, it will affect the
+           addresses of sections after it. We have to update
+           dot.  */
+        if (os->region != (lang_memory_region_type *) NULL
+        && ((bfd_get_section_flags (output_bfd, os->bfd_section)
+             & SEC_NEVER_LOAD) == 0
+            || (bfd_get_section_flags (output_bfd, os->bfd_section)
+            & (SEC_ALLOC | SEC_LOAD))))
+          {
+        os->region->current = dot;
+        
+        /* Make sure the new address is within the region.  */
                 os_region_check (os, os->region, os->addr_tree, 
                                  os->bfd_section->vma);
 
@@ -2920,193 +3046,193 @@ lang_size_sections (s, output_section_statement, prev, fill, dot, relax)
                           }
                       }
                   }
-	      }
-	  }
-	  break;
-
-	case lang_constructors_statement_enum:
-	  dot = lang_size_sections (constructor_list.head,
-				    output_section_statement,
-				    &s->wild_statement.children.head,
-				    fill,
-				    dot, relax);
-	  break;
-
-	case lang_data_statement_enum:
-	  {
-	    unsigned int size = 0;
-
-	    s->data_statement.output_vma = dot - output_section_statement->bfd_section->vma;
-	    s->data_statement.output_section =
-	      output_section_statement->bfd_section;
-
-	    switch (s->data_statement.type)
-	      {
+          }
+      }
+      break;
+
+    case lang_constructors_statement_enum:
+      dot = lang_size_sections (constructor_list.head,
+                    output_section_statement,
+                    &s->wild_statement.children.head,
+                    fill,
+                    dot, relax);
+      break;
+
+    case lang_data_statement_enum:
+      {
+        unsigned int size = 0;
+
+        s->data_statement.output_vma = dot - output_section_statement->bfd_section->vma;
+        s->data_statement.output_section =
+          output_section_statement->bfd_section;
+
+        switch (s->data_statement.type)
+          {
               default:
                 abort();
-	      case QUAD:
-	      case SQUAD:
-		size = QUAD_SIZE;
-		break;
-	      case LONG:
-		size = LONG_SIZE;
-		break;
-	      case SHORT:
-		size = SHORT_SIZE;
-		break;
-	      case BYTE:
-		size = BYTE_SIZE;
-		break;
-	      }
+          case QUAD:
+          case SQUAD:
+        size = QUAD_SIZE;
+        break;
+          case LONG:
+        size = LONG_SIZE;
+        break;
+          case SHORT:
+        size = SHORT_SIZE;
+        break;
+          case BYTE:
+        size = BYTE_SIZE;
+        break;
+          }
             if (size < opb)
               size = opb;
-	    dot += size / opb;
-	    output_section_statement->bfd_section->_raw_size += size;
-	    /* The output section gets contents, and then we inspect for
-	       any flags set in the input script which override any ALLOC.  */
-	    output_section_statement->bfd_section->flags |= SEC_HAS_CONTENTS;
-	    if (!(output_section_statement->flags & SEC_NEVER_LOAD)) {
-	      output_section_statement->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
-	    }
-	  }
-	  break;
-
-	case lang_reloc_statement_enum:
-	  {
-	    int size;
-
-	    s->reloc_statement.output_vma =
-	      dot - output_section_statement->bfd_section->vma;
-	    s->reloc_statement.output_section =
-	      output_section_statement->bfd_section;
-	    size = bfd_get_reloc_size (s->reloc_statement.howto);
-	    dot += size / opb;
-	    output_section_statement->bfd_section->_raw_size += size;
-	  }
-	  break;
+        dot += size / opb;
+        output_section_statement->bfd_section->_raw_size += size;
+        /* The output section gets contents, and then we inspect for
+           any flags set in the input script which override any ALLOC.  */
+        output_section_statement->bfd_section->flags |= SEC_HAS_CONTENTS;
+        if (!(output_section_statement->flags & SEC_NEVER_LOAD)) {
+          output_section_statement->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
+        }
+      }
+      break;
+
+    case lang_reloc_statement_enum:
+      {
+        int size;
+
+        s->reloc_statement.output_vma =
+          dot - output_section_statement->bfd_section->vma;
+        s->reloc_statement.output_section =
+          output_section_statement->bfd_section;
+        size = bfd_get_reloc_size (s->reloc_statement.howto);
+        dot += size / opb;
+        output_section_statement->bfd_section->_raw_size += size;
+      }
+      break;
      
-	case lang_wild_statement_enum:
-
-	  dot = lang_size_sections (s->wild_statement.children.head,
-				    output_section_statement,
-				    &s->wild_statement.children.head,
-
-				    fill, dot, relax);
-
-	  break;
-
-	case lang_object_symbols_statement_enum:
-	  link_info.create_object_symbols_section =
-	    output_section_statement->bfd_section;
-	  break;
-	case lang_output_statement_enum:
-	case lang_target_statement_enum:
-	  break;
-	case lang_input_section_enum:
-	  {
-	    asection *i;
-
-	    i = (*prev)->input_section.section;
-	    if (! relax)
-	      {
-		if (i->_cooked_size == 0)
-		  i->_cooked_size = i->_raw_size;
-	      }
-	    else
-	      {
-		boolean again;
-
-		if (! bfd_relax_section (i->owner, i, &link_info, &again))
-		  einfo (_("%P%F: can't relax section: %E\n"));
-		if (again)
-		  relax_again = true;
-	      }
-	    dot = size_input_section (prev,
-				      output_section_statement,
-				      output_section_statement->fill,
-				      dot, relax);
-	  }
-	  break;
-	case lang_input_statement_enum:
-	  break;
-	case lang_fill_statement_enum:
-	  s->fill_statement.output_section = output_section_statement->bfd_section;
-
-	  fill = s->fill_statement.fill;
-	  break;
-	case lang_assignment_statement_enum:
-	  {
-	    bfd_vma newdot = dot;
-
-	    exp_fold_tree (s->assignment_statement.exp,
-			   output_section_statement,
-			   lang_allocating_phase_enum,
-			   dot,
-			   &newdot);
-
-	    if (newdot != dot)
-	      {
-		/* The assignment changed dot.  Insert a pad.  */
-		if (output_section_statement == abs_output_section)
-		  {
-		    /* If we don't have an output section, then just adjust
-		       the default memory address.  */
-		    lang_memory_region_lookup ("*default*")->current = newdot;
-		  }
-		else if (!relax)
-		  {
-		    lang_statement_union_type *new =
-		      ((lang_statement_union_type *)
-		       stat_alloc (sizeof (lang_padding_statement_type)));
-
-		    /* Link into existing chain.  */
-		    new->header.next = *prev;
-		    *prev = new;
-		    new->header.type = lang_padding_statement_enum;
-		    new->padding_statement.output_section =
-		      output_section_statement->bfd_section;
-		    new->padding_statement.output_offset =
-		      dot - output_section_statement->bfd_section->vma;
-		    new->padding_statement.fill = fill;
-		    new->padding_statement.size = (newdot - dot) * opb;
-		    output_section_statement->bfd_section->_raw_size +=
-		      new->padding_statement.size;
-		  }
-
-		dot = newdot;
-	      }
-	  }
-	  break;
-
-	case lang_padding_statement_enum:
-	  /* If we are relaxing, and this is not the first pass, some
-	     padding statements may have been inserted during previous
-	     passes.  We may have to move the padding statement to a new
-	     location if dot has a different value at this point in this
-	     pass than it did at this point in the previous pass.  */
-	  s->padding_statement.output_offset =
-	    dot - output_section_statement->bfd_section->vma;
-	  dot += s->padding_statement.size / opb;
-	  output_section_statement->bfd_section->_raw_size +=
-	    s->padding_statement.size;
-	  break;
-
-	case lang_group_statement_enum:
-	  dot = lang_size_sections (s->group_statement.children.head,
-				    output_section_statement,
-				    &s->group_statement.children.head,
-				    fill, dot, relax);
-	  break;
-
-	default:
-	  FAIL ();
-	  break;
-
-	  /* This can only get here when relaxing is turned on.  */
-
-	case lang_address_statement_enum:
-	  break;
-	}
+    case lang_wild_statement_enum:
+
+      dot = lang_size_sections (s->wild_statement.children.head,
+                    output_section_statement,
+                    &s->wild_statement.children.head,
+
+                    fill, dot, relax);
+
+      break;
+
+    case lang_object_symbols_statement_enum:
+      link_info.create_object_symbols_section =
+        output_section_statement->bfd_section;
+      break;
+    case lang_output_statement_enum:
+    case lang_target_statement_enum:
+      break;
+    case lang_input_section_enum:
+      {
+        asection *i;
+
+        i = (*prev)->input_section.section;
+        if (! relax)
+          {
+        if (i->_cooked_size == 0)
+          i->_cooked_size = i->_raw_size;
+          }
+        else
+          {
+        boolean again;
+
+        if (! bfd_relax_section (i->owner, i, &link_info, &again))
+          einfo (_("%P%F: can't relax section: %E\n"));
+        if (again)
+          relax_again = true;
+          }
+        dot = size_input_section (prev,
+                      output_section_statement,
+                      output_section_statement->fill,
+                      dot, relax);
+      }
+      break;
+    case lang_input_statement_enum:
+      break;
+    case lang_fill_statement_enum:
+      s->fill_statement.output_section = output_section_statement->bfd_section;
+
+      fill = s->fill_statement.fill;
+      break;
+    case lang_assignment_statement_enum:
+      {
+        bfd_vma newdot = dot;
+
+        exp_fold_tree (s->assignment_statement.exp,
+               output_section_statement,
+               lang_allocating_phase_enum,
+               dot,
+               &newdot);
+
+        if (newdot != dot)
+          {
+        /* The assignment changed dot.  Insert a pad.  */
+        if (output_section_statement == abs_output_section)
+          {
+            /* If we don't have an output section, then just adjust
+               the default memory address.  */
+            lang_memory_region_lookup ("*default*")->current = newdot;
+          }
+        else if (!relax)
+          {
+            lang_statement_union_type *new =
+              ((lang_statement_union_type *)
+               stat_alloc (sizeof (lang_padding_statement_type)));
+
+            /* Link into existing chain.  */
+            new->header.next = *prev;
+            *prev = new;
+            new->header.type = lang_padding_statement_enum;
+            new->padding_statement.output_section =
+              output_section_statement->bfd_section;
+            new->padding_statement.output_offset =
+              dot - output_section_statement->bfd_section->vma;
+            new->padding_statement.fill = fill;
+            new->padding_statement.size = (newdot - dot) * opb;
+            output_section_statement->bfd_section->_raw_size +=
+              new->padding_statement.size;
+          }
+
+        dot = newdot;
+          }
+      }
+      break;
+
+    case lang_padding_statement_enum:
+      /* If we are relaxing, and this is not the first pass, some
+         padding statements may have been inserted during previous
+         passes.  We may have to move the padding statement to a new
+         location if dot has a different value at this point in this
+         pass than it did at this point in the previous pass.  */
+      s->padding_statement.output_offset =
+        dot - output_section_statement->bfd_section->vma;
+      dot += s->padding_statement.size / opb;
+      output_section_statement->bfd_section->_raw_size +=
+        s->padding_statement.size;
+      break;
+
+    case lang_group_statement_enum:
+      dot = lang_size_sections (s->group_statement.children.head,
+                    output_section_statement,
+                    &s->group_statement.children.head,
+                    fill, dot, relax);
+      break;
+
+    default:
+      FAIL ();
+      break;
+
+      /* This can only get here when relaxing is turned on.  */
+
+    case lang_address_statement_enum:
+      break;
+    }
       prev = &s->header.next;
     }
   return dot;
@@ -3120,70 +3246,70 @@ lang_do_assignments (s, output_section_statement, fill, dot)
      bfd_vma dot;
 {
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine); 
+                        ldfile_output_machine); 
 
   for (; s != (lang_statement_union_type *) NULL; s = s->next)
     {
       switch (s->header.type)
-	{
-	case lang_constructors_statement_enum:
-	  dot = lang_do_assignments (constructor_list.head,
-				     output_section_statement,
-				     fill,
-				     dot);
-	  break;
-
-	case lang_output_section_statement_enum:
-	  {
-	    lang_output_section_statement_type *os =
-	      &(s->output_section_statement);
-
-	    if (os->bfd_section != NULL)
-	      {
-		dot = os->bfd_section->vma;
-		(void) lang_do_assignments (os->children.head, os,
-					    os->fill, dot);
-		dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
-
-	      }
-	    if (os->load_base) 
-	      {
-		/* If nothing has been placed into the output section then
-		   it won't have a bfd_section. */
-		if (os->bfd_section) 
-		  {
-		    os->bfd_section->lma 
-		      = exp_get_abs_int(os->load_base, 0,"load base", lang_final_phase_enum);
-		  }
-	      }
-	  }
-	  break;
-	case lang_wild_statement_enum:
-
-	  dot = lang_do_assignments (s->wild_statement.children.head,
-				     output_section_statement,
-				     fill, dot);
-
-	  break;
-
-	case lang_object_symbols_statement_enum:
-	case lang_output_statement_enum:
-	case lang_target_statement_enum:
+    {
+    case lang_constructors_statement_enum:
+      dot = lang_do_assignments (constructor_list.head,
+                     output_section_statement,
+                     fill,
+                     dot);
+      break;
+
+    case lang_output_section_statement_enum:
+      {
+        lang_output_section_statement_type *os =
+          &(s->output_section_statement);
+
+        if (os->bfd_section != NULL)
+          {
+        dot = os->bfd_section->vma;
+        (void) lang_do_assignments (os->children.head, os,
+                        os->fill, dot);
+        dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
+
+          }
+        if (os->load_base) 
+          {
+        /* If nothing has been placed into the output section then
+           it won't have a bfd_section. */
+        if (os->bfd_section) 
+          {
+            os->bfd_section->lma 
+              = exp_get_abs_int(os->load_base, 0,"load base", lang_final_phase_enum);
+          }
+          }
+      }
+      break;
+    case lang_wild_statement_enum:
+
+      dot = lang_do_assignments (s->wild_statement.children.head,
+                     output_section_statement,
+                     fill, dot);
+
+      break;
+
+    case lang_object_symbols_statement_enum:
+    case lang_output_statement_enum:
+    case lang_target_statement_enum:
 #if 0
-	case lang_common_statement_enum:
+    case lang_common_statement_enum:
 #endif
-	  break;
-	case lang_data_statement_enum:
-	  {
-	    etree_value_type value;
-
-	    value = exp_fold_tree (s->data_statement.exp,
-				   abs_output_section,
-				   lang_final_phase_enum, dot, &dot);
-	    s->data_statement.value = value.value;
-	    if (value.valid_p == false)
-	      einfo (_("%F%P: invalid data statement\n"));
-	  }
+      break;
+    case lang_data_statement_enum:
+      {
+        etree_value_type value;
+
+        value = exp_fold_tree (s->data_statement.exp,
+                   abs_output_section,
+                   lang_final_phase_enum, dot, &dot);
+        s->data_statement.value = value.value;
+        if (value.valid_p == false)
+          einfo (_("%F%P: invalid data statement\n"));
+      }
           {
             unsigned int size;
             switch (s->data_statement.type)
@@ -3208,65 +3334,65 @@ lang_do_assignments (s, output_section_statement, fill, dot)
               size = opb;
             dot += size / opb;
           }
-	  break;
-
-	case lang_reloc_statement_enum:
-	  {
-	    etree_value_type value;
-
-	    value = exp_fold_tree (s->reloc_statement.addend_exp,
-				   abs_output_section,
-				   lang_final_phase_enum, dot, &dot);
-	    s->reloc_statement.addend_value = value.value;
-	    if (value.valid_p == false)
-	      einfo (_("%F%P: invalid reloc statement\n"));
-	  }
-	  dot += bfd_get_reloc_size (s->reloc_statement.howto) / opb;
-	  break;
-
-	case lang_input_section_enum:
-	  {
-	    asection *in = s->input_section.section;
-
-	    if (in->_cooked_size != 0)
-	      dot += in->_cooked_size / opb;
-	    else
-	      dot += in->_raw_size / opb;
-	  }
-	  break;
-
-	case lang_input_statement_enum:
-	  break;
-	case lang_fill_statement_enum:
-	  fill = s->fill_statement.fill;
-	  break;
-	case lang_assignment_statement_enum:
-	  {
-	    exp_fold_tree (s->assignment_statement.exp,
-			   output_section_statement,
-			   lang_final_phase_enum,
-			   dot,
-			   &dot);
-	  }
-
-	  break;
-	case lang_padding_statement_enum:
-	  dot += s->padding_statement.size / opb;
-	  break;
-
-	case lang_group_statement_enum:
-	  dot = lang_do_assignments (s->group_statement.children.head,
-				     output_section_statement,
-				     fill, dot);
-
-	  break;
-
-	default:
-	  FAIL ();
-	  break;
-	case lang_address_statement_enum:
-	  break;
-	}
+      break;
+
+    case lang_reloc_statement_enum:
+      {
+        etree_value_type value;
+
+        value = exp_fold_tree (s->reloc_statement.addend_exp,
+                   abs_output_section,
+                   lang_final_phase_enum, dot, &dot);
+        s->reloc_statement.addend_value = value.value;
+        if (value.valid_p == false)
+          einfo (_("%F%P: invalid reloc statement\n"));
+      }
+      dot += bfd_get_reloc_size (s->reloc_statement.howto) / opb;
+      break;
+
+    case lang_input_section_enum:
+      {
+        asection *in = s->input_section.section;
+
+        if (in->_cooked_size != 0)
+          dot += in->_cooked_size / opb;
+        else
+          dot += in->_raw_size / opb;
+      }
+      break;
+
+    case lang_input_statement_enum:
+      break;
+    case lang_fill_statement_enum:
+      fill = s->fill_statement.fill;
+      break;
+    case lang_assignment_statement_enum:
+      {
+        exp_fold_tree (s->assignment_statement.exp,
+               output_section_statement,
+               lang_final_phase_enum,
+               dot,
+               &dot);
+      }
+
+      break;
+    case lang_padding_statement_enum:
+      dot += s->padding_statement.size / opb;
+      break;
+
+    case lang_group_statement_enum:
+      dot = lang_do_assignments (s->group_statement.children.head,
+                     output_section_statement,
+                     fill, dot);
+
+      break;
+
+    default:
+      FAIL ();
+      break;
+    case lang_address_statement_enum:
+      break;
+    }
 
     }
   return dot;
@@ -3299,25 +3425,25 @@ lang_set_startof ()
       sprintf (buf, ".startof.%s", secname);
       h = bfd_link_hash_lookup (link_info.hash, buf, false, false, true);
       if (h != NULL && h->type == bfd_link_hash_undefined)
-	{
-	  h->type = bfd_link_hash_defined;
-	  h->u.def.value = bfd_get_section_vma (output_bfd, s);
-	  h->u.def.section = bfd_abs_section_ptr;
-	}
+    {
+      h->type = bfd_link_hash_defined;
+      h->u.def.value = bfd_get_section_vma (output_bfd, s);
+      h->u.def.section = bfd_abs_section_ptr;
+    }
 
       sprintf (buf, ".sizeof.%s", secname);
       h = bfd_link_hash_lookup (link_info.hash, buf, false, false, true);
       if (h != NULL && h->type == bfd_link_hash_undefined)
-	{
+    {
           unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-							ldfile_output_machine);
-	  h->type = bfd_link_hash_defined;
-	  if (s->_cooked_size != 0)
-	    h->u.def.value = s->_cooked_size / opb;
-	  else
-	    h->u.def.value = s->_raw_size / opb;
-	  h->u.def.section = bfd_abs_section_ptr;
-	}
+                            ldfile_output_machine);
+      h->type = bfd_link_hash_defined;
+      if (s->_cooked_size != 0)
+        h->u.def.value = s->_cooked_size / opb;
+      else
+        h->u.def.value = s->_raw_size / opb;
+      h->u.def.section = bfd_abs_section_ptr;
+    }
 
       free (buf);
     }
@@ -3337,7 +3463,7 @@ lang_finish ()
   if (entry_symbol == (char *) NULL)
     {
       /* No entry has been specified.  Look for start, but don't warn
-	 if we don't find it.  */
+     if we don't find it.  */
       entry_symbol = "start";
       warn = false;
     }
@@ -3345,17 +3471,17 @@ lang_finish ()
   h = bfd_link_hash_lookup (link_info.hash, entry_symbol, false, false, true);
   if (h != (struct bfd_link_hash_entry *) NULL
       && (h->type == bfd_link_hash_defined
-	  || h->type == bfd_link_hash_defweak)
+      || h->type == bfd_link_hash_defweak)
       && h->u.def.section->output_section != NULL)
     {
       bfd_vma val;
 
       val = (h->u.def.value
-	     + bfd_get_section_vma (output_bfd,
-				    h->u.def.section->output_section)
-	     + h->u.def.section->output_offset);
+         + bfd_get_section_vma (output_bfd,
+                    h->u.def.section->output_section)
+         + h->u.def.section->output_offset);
       if (! bfd_set_start_address (output_bfd, val))
-	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol);
+    einfo (_("%P%F:%s: can't set start address\n"), entry_symbol);
     }
   else
     {
@@ -3366,34 +3492,34 @@ lang_finish ()
          number.  */
       val = bfd_scan_vma (entry_symbol, &send, 0);
       if (*send == '\0')
-	{
-	  if (! bfd_set_start_address (output_bfd, val))
-	    einfo (_("%P%F: can't set start address\n"));
-	}
+    {
+      if (! bfd_set_start_address (output_bfd, val))
+        einfo (_("%P%F: can't set start address\n"));
+    }
       else
-	{
-	  asection *ts;
+    {
+      asection *ts;
 
-	  /* Can't find the entry symbol, and it's not a number.  Use
-	     the first address in the text section.  */
-	  ts = bfd_get_section_by_name (output_bfd, ".text");
-	  if (ts != (asection *) NULL)
-	    {
-	      if (warn)
-		einfo (_("%P: warning: cannot find entry symbol %s; defaulting to %V\n"),
-		       entry_symbol, bfd_get_section_vma (output_bfd, ts));
-	      if (! bfd_set_start_address (output_bfd,
-					   bfd_get_section_vma (output_bfd,
-								ts)))
-		einfo (_("%P%F: can't set start address\n"));
-	    }
-	  else
-	    {
-	      if (warn)
-		einfo (_("%P: warning: cannot find entry symbol %s; not setting start address\n"),
-		       entry_symbol);
-	    }
-	}
+      /* Can't find the entry symbol, and it's not a number.  Use
+         the first address in the text section.  */
+      ts = bfd_get_section_by_name (output_bfd, ".text");
+      if (ts != (asection *) NULL)
+        {
+          if (warn)
+        einfo (_("%P: warning: cannot find entry symbol %s; defaulting to %V\n"),
+               entry_symbol, bfd_get_section_vma (output_bfd, ts));
+          if (! bfd_set_start_address (output_bfd,
+                       bfd_get_section_vma (output_bfd,
+                                ts)))
+        einfo (_("%P%F: can't set start address\n"));
+        }
+      else
+        {
+          if (warn)
+        einfo (_("%P: warning: cannot find entry symbol %s; not setting start address\n"),
+               entry_symbol);
+        }
+    }
     }
 }
 
@@ -3428,34 +3554,34 @@ lang_check ()
     {
       input_bfd = file->input_statement.the_bfd;
       compatible = bfd_arch_get_compatible (input_bfd,
-					    output_bfd);
+                        output_bfd);
       if (compatible == NULL)
-	{
-	  if (command_line.warn_mismatch)
-	    einfo (_("%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"),
-		   bfd_printable_name (input_bfd), input_bfd,
-		   bfd_printable_name (output_bfd));
-	}
+    {
+      if (command_line.warn_mismatch)
+        einfo (_("%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"),
+           bfd_printable_name (input_bfd), input_bfd,
+           bfd_printable_name (output_bfd));
+    }
       else
-	{
-	  bfd_error_handler_type pfn = NULL;
+    {
+      bfd_error_handler_type pfn = NULL;
 
-	  /* If we aren't supposed to warn about mismatched input
+      /* If we aren't supposed to warn about mismatched input
              files, temporarily set the BFD error handler to a
              function which will do nothing.  We still want to call
              bfd_merge_private_bfd_data, since it may set up
              information which is needed in the output file.  */
-	  if (! command_line.warn_mismatch)
-	    pfn = bfd_set_error_handler (ignore_bfd_errors);
-	  if (! bfd_merge_private_bfd_data (input_bfd, output_bfd))
-	    {
-	      if (command_line.warn_mismatch)
-		einfo (_("%E%X: failed to merge target specific data of file %B\n"),
-		       input_bfd);
-	    }
-	  if (! command_line.warn_mismatch)
-	    bfd_set_error_handler (pfn);
-	}
+      if (! command_line.warn_mismatch)
+        pfn = bfd_set_error_handler (ignore_bfd_errors);
+      if (! bfd_merge_private_bfd_data (input_bfd, output_bfd))
+        {
+          if (command_line.warn_mismatch)
+        einfo (_("%E%X: failed to merge target specific data of file %B\n"),
+               input_bfd);
+        }
+      if (! command_line.warn_mismatch)
+        bfd_set_error_handler (pfn);
+    }
     }
 }
 
@@ -3477,8 +3603,8 @@ lang_common ()
       int power;
 
       for (power = 4; power >= 0; power--)
-	bfd_link_hash_traverse (link_info.hash, lang_one_common,
-				(PTR) &power);
+    bfd_link_hash_traverse (link_info.hash, lang_one_common,
+                (PTR) &power);
     }
 }
 
@@ -3493,7 +3619,7 @@ lang_one_common (h, info)
   bfd_vma size;
   asection *section;
   unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
-						ldfile_output_machine); 
+                        ldfile_output_machine); 
 
   if (h->type != bfd_link_hash_common)
     return true;
@@ -3509,7 +3635,7 @@ lang_one_common (h, info)
 
   /* Increase the size of the section.  */
   section->_cooked_size = ALIGN_N ((section->_cooked_size + opb - 1) / opb,
-				   (bfd_size_type) (1 << power_of_two)) * opb;
+                   (bfd_size_type) (1 << power_of_two)) * opb;
 
   /* Adjust the alignment if necessary.  */
   if (power_of_two > section->alignment_power)
@@ -3536,11 +3662,11 @@ lang_one_common (h, info)
       char buf[50];
 
       if (! header_printed)
-	{
-	  minfo (_("\nAllocating common symbols\n"));
-	  minfo (_("Common symbol       size              file\n\n"));
-	  header_printed = true;
-	}
+    {
+      minfo (_("\nAllocating common symbols\n"));
+      minfo (_("Common symbol       size              file\n\n"));
+      header_printed = true;
+    }
 
       name = demangle (h->root.string);
       minfo ("%s", name);
@@ -3548,29 +3674,29 @@ lang_one_common (h, info)
       free (name);
 
       if (len >= 19)
-	{
-	  print_nl ();
-	  len = 0;
-	}
+    {
+      print_nl ();
+      len = 0;
+    }
       while (len < 20)
-	{
-	  print_space ();
-	  ++len;
-	}
+    {
+      print_space ();
+      ++len;
+    }
 
       minfo ("0x");
       if (size <= 0xffffffff)
-	sprintf (buf, "%lx", (unsigned long) size);
+    sprintf (buf, "%lx", (unsigned long) size);
       else
-	sprintf_vma (buf, size);
+    sprintf_vma (buf, size);
       minfo ("%s", buf);
       len = strlen (buf);
 
       while (len < 16)
-	{
-	  print_space ();
-	  ++len;
-	}
+    {
+      print_space ();
+      ++len;
+    }
 
       minfo ("%B\n", section->owner);
     }
@@ -3593,57 +3719,57 @@ lang_place_orphans ()
       asection *s;
 
       for (s = file->the_bfd->sections;
-	   s != (asection *) NULL;
-	   s = s->next)
-	{
-	  if (s->output_section == (asection *) NULL)
-	    {
-	      /* This section of the file is not attatched, root
-	         around for a sensible place for it to go */
+       s != (asection *) NULL;
+       s = s->next)
+    {
+      if (s->output_section == (asection *) NULL)
+        {
+          /* This section of the file is not attatched, root
+             around for a sensible place for it to go */
 
-	      if (file->just_syms_flag)
-		{
-		  /* We are only retrieving symbol values from this
+          if (file->just_syms_flag)
+        {
+          /* We are only retrieving symbol values from this
                      file.  We want the symbols to act as though the
                      values in the file are absolute.  */
-		  s->output_section = bfd_abs_section_ptr;
-		  s->output_offset = s->vma;
-		}
-	      else if (strcmp (s->name, "COMMON") == 0)
-		{
-		  /* This is a lonely common section which must have
-		     come from an archive.  We attach to the section
-		     with the wildcard.  */
-		  if (! link_info.relocateable
-		      || command_line.force_common_definition)
-		    {
-		      if (default_common_section == NULL)
-			{
+          s->output_section = bfd_abs_section_ptr;
+          s->output_offset = s->vma;
+        }
+          else if (strcmp (s->name, "COMMON") == 0)
+        {
+          /* This is a lonely common section which must have
+             come from an archive.  We attach to the section
+             with the wildcard.  */
+          if (! link_info.relocateable
+              || command_line.force_common_definition)
+            {
+              if (default_common_section == NULL)
+            {
 #if 0
-			  /* This message happens when using the
+              /* This message happens when using the
                              svr3.ifile linker script, so I have
                              disabled it.  */
-			  info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
+              info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
 #endif
-			  default_common_section =
-			    lang_output_section_statement_lookup (".bss");
+              default_common_section =
+                lang_output_section_statement_lookup (".bss");
 
-			}
-		      wild_doit (&default_common_section->children, s,
-				 default_common_section, file);
-		    }
-		}
-	      else if (ldemul_place_orphan (file, s))
-		;
-	      else
-		{
-		  lang_output_section_statement_type *os =
-		  lang_output_section_statement_lookup (s->name);
+            }
+              wild_doit (&default_common_section->children, s,
+                 default_common_section, file);
+            }
+        }
+          else if (ldemul_place_orphan (file, s))
+        ;
+          else
+        {
+          lang_output_section_statement_type *os =
+          lang_output_section_statement_lookup (s->name);
 
-		  wild_doit (&os->children, s, os, file);
-		}
-	    }
-	}
+          wild_doit (&os->children, s, os, file);
+        }
+        }
+    }
     }
 }
 
@@ -3660,32 +3786,32 @@ lang_set_flags (ptr, flags, invert)
   while (*flags)
     {
       switch (*flags)
-	{
-	case 'A': case 'a':
-	  *ptr_flags |= SEC_ALLOC;
-	  break;
-
-	case 'R': case 'r':
-	  *ptr_flags |= SEC_READONLY;
-	  break;
-
-	case 'W': case 'w':
-	  *ptr_flags |= SEC_DATA;
-	  break;
-
-	case 'X': case 'x':
-	  *ptr_flags |= SEC_CODE;
-	  break;
-
-	case 'L': case 'l':
-	case 'I': case 'i':
-	  *ptr_flags |= SEC_LOAD;
-	  break;
-
-	default:
-	  einfo (_("%P%F: invalid syntax in flags\n"));
-	  break;
-	}
+    {
+    case 'A': case 'a':
+      *ptr_flags |= SEC_ALLOC;
+      break;
+
+    case 'R': case 'r':
+      *ptr_flags |= SEC_READONLY;
+      break;
+
+    case 'W': case 'w':
+      *ptr_flags |= SEC_DATA;
+      break;
+
+    case 'X': case 'x':
+      *ptr_flags |= SEC_CODE;
+      break;
+
+    case 'L': case 'l':
+    case 'I': case 'i':
+      *ptr_flags |= SEC_LOAD;
+      break;
+
+    default:
+      einfo (_("%P%F: invalid syntax in flags\n"));
+      break;
+    }
       flags++;
     }
 }
@@ -3732,11 +3858,11 @@ lang_for_each_input_section (func)
       asection * s;
 
       for (s = f->the_bfd->sections;
-	   s != (asection *) NULL;
-	   s = s->next)
-	{
-	  func (f->the_bfd, s);
-	}
+       s != (asection *) NULL;
+       s = s->next)
+    {
+      func (f->the_bfd, s);
+    }
     }
 }
 
@@ -3749,8 +3875,8 @@ ldlang_add_file (entry)
   bfd **pp;
 
   lang_statement_append (&file_chain,
-			 (lang_statement_union_type *) entry,
-			 &entry->next);
+             (lang_statement_union_type *) entry,
+             &entry->next);
 
   /* The BFD linker needs to have a list of all input BFDs involved in
      a link.  */
@@ -3806,7 +3932,7 @@ topower (x)
   for (l = 0; l < 32; l++) 
     {
       if (i >= (unsigned int) x)
-	return l;
+    return l;
       i <<= 1;
     }
 
@@ -3815,8 +3941,8 @@ topower (x)
 
 lang_output_section_statement_type *
 lang_enter_output_section_statement (output_section_statement_name,
-				     address_exp, sectype, block_value,
-				     align, subalign, ebase)
+                     address_exp, sectype, block_value,
+                     align, subalign, ebase)
      const char *output_section_statement_name;
      etree_type * address_exp;
      enum section_type sectype;
@@ -3854,11 +3980,11 @@ lang_enter_output_section_statement (output_section_statement_name,
 
   os->subsection_alignment = topower(
    exp_get_value_int(subalign, -1,
-		     "subsection alignment",
-		     0));
+             "subsection alignment",
+             0));
   os->section_alignment = topower(
    exp_get_value_int(align, -1,
-		     "section alignment", 0));
+             "section alignment", 0));
 
   os->load_base = ebase;
   return os;
@@ -3926,24 +4052,24 @@ lang_gc_sections_1 (s)
   for (; s != (lang_statement_union_type *) NULL; s = s->next)
     {
       switch (s->header.type)
-	{
-	case lang_wild_statement_enum:
-	  lang_gc_wild (&s->wild_statement,
-			s->wild_statement.section_name,
-			s->wild_statement.filename);
-	  break;
-	case lang_constructors_statement_enum:
-	  lang_gc_sections_1 (constructor_list.head);
-	  break;
-	case lang_output_section_statement_enum:
-	  lang_gc_sections_1 (s->output_section_statement.children.head);
-	  break;
-	case lang_group_statement_enum:
-	  lang_gc_sections_1 (s->group_statement.children.head);
-	  break;
-	default:
-	  break;
-	}
+    {
+    case lang_wild_statement_enum:
+      lang_gc_wild (&s->wild_statement,
+            s->wild_statement.section_name,
+            s->wild_statement.filename);
+      break;
+    case lang_constructors_statement_enum:
+      lang_gc_sections_1 (constructor_list.head);
+      break;
+    case lang_output_section_statement_enum:
+      lang_gc_sections_1 (s->output_section_statement.children.head);
+      break;
+    case lang_group_statement_enum:
+      lang_gc_sections_1 (s->group_statement.children.head);
+      break;
+    default:
+      break;
+    }
     }
 }
 
@@ -3972,15 +4098,15 @@ lang_gc_sections ()
   for (; ulist; ulist = ulist->next)
     {
       h = bfd_link_hash_lookup (link_info.hash, ulist->name, 
-				false, false, false);
+                false, false, false);
 
       if (h != (struct bfd_link_hash_entry *) NULL
           && (h->type == bfd_link_hash_defined
               || h->type == bfd_link_hash_defweak)
-	  && ! bfd_is_abs_section (h->u.def.section))
-	{
-	  h->u.def.section->flags |= SEC_KEEP;
-	}
+      && ! bfd_is_abs_section (h->u.def.section))
+    {
+      h->u.def.section->flags |= SEC_KEEP;
+    }
     }
 
   bfd_gc_sections (output_bfd, &link_info);
@@ -3992,7 +4118,7 @@ lang_process ()
   lang_reasonable_defaults ();
   current_target = default_target;
 
-  lang_for_each_statement (ldlang_open_output);	/* Open the output file */
+  lang_for_each_statement (ldlang_open_output); /* Open the output file */
 
   ldemul_create_output_section_statements ();
 
@@ -4035,7 +4161,7 @@ lang_process ()
      to the correct output sections
      */
   map_input_to_output_sections (statement_list.head, (char *) NULL,
-				(lang_output_section_statement_type *) NULL);
+                (lang_output_section_statement_type *) NULL);
 
 
   /* Find any sections not attached explicitly and handle them */
@@ -4051,42 +4177,42 @@ lang_process ()
   if (command_line.relax)
     {
       /* First time round is a trial run to get the 'worst case'
-	 addresses of the objects if there was no relaxing.  */
+     addresses of the objects if there was no relaxing.  */
       lang_size_sections (statement_list.head,
-			  abs_output_section,
-			  &(statement_list.head), 0, (bfd_vma) 0, false);
+              abs_output_section,
+              &(statement_list.head), 0, (bfd_vma) 0, false);
 
       /* Keep relaxing until bfd_relax_section gives up.  */
       do
-	{
-	  reset_memory_regions ();
-
-	  relax_again = false;
-
-	  /* Note: pe-dll.c does something like this also.  If you find
-	     you need to change this code, you probably need to change
-	     pe-dll.c also.  DJ */
-
-	  /* Do all the assignments with our current guesses as to
-	     section sizes.  */
-	  lang_do_assignments (statement_list.head,
-			       abs_output_section,
-			       (fill_type) 0, (bfd_vma) 0);
-
-	  /* Perform another relax pass - this time we know where the
-	     globals are, so can make better guess.  */
-	  lang_size_sections (statement_list.head,
-			      abs_output_section,
-			      &(statement_list.head), 0, (bfd_vma) 0, true);
-	}
+    {
+      reset_memory_regions ();
+
+      relax_again = false;
+
+      /* Note: pe-dll.c does something like this also.  If you find
+         you need to change this code, you probably need to change
+         pe-dll.c also.  DJ */
+
+      /* Do all the assignments with our current guesses as to
+         section sizes.  */
+      lang_do_assignments (statement_list.head,
+                   abs_output_section,
+                   (fill_type) 0, (bfd_vma) 0);
+
+      /* Perform another relax pass - this time we know where the
+         globals are, so can make better guess.  */
+      lang_size_sections (statement_list.head,
+                  abs_output_section,
+                  &(statement_list.head), 0, (bfd_vma) 0, true);
+    }
       while (relax_again);
     }
   else
     {
       /* Size up the sections.  */
       lang_size_sections (statement_list.head,
-			  abs_output_section,
-			  &(statement_list.head), 0, (bfd_vma) 0, false);
+              abs_output_section,
+              &(statement_list.head), 0, (bfd_vma) 0, false);
     }
 
   /* See if anything special should be done now we know how big
@@ -4100,8 +4226,8 @@ lang_process ()
      of all the symbols */
 
   lang_do_assignments (statement_list.head,
-		       abs_output_section,
-		       (fill_type) 0, (bfd_vma) 0);
+               abs_output_section,
+               (fill_type) 0, (bfd_vma) 0);
 
   /* Make sure that the section addresses make sense.  */
   if (! link_info.relocateable
@@ -4118,7 +4244,7 @@ lang_process ()
 
 void
 lang_add_wild (section_name, sections_sorted, filename, filenames_sorted,
-	       keep_sections, exclude_filename_list)
+           keep_sections, exclude_filename_list)
      const char *const section_name;
      boolean sections_sorted;
      const char *const filename;
@@ -4127,7 +4253,7 @@ lang_add_wild (section_name, sections_sorted, filename, filenames_sorted,
      struct name_list *exclude_filename_list;
 {
   lang_wild_statement_type *new = new_stat (lang_wild_statement,
-					    stat_ptr);
+                        stat_ptr);
 
   if (section_name != (char *) NULL && strcmp (section_name, "COMMON") == 0)
     {
@@ -4181,7 +4307,7 @@ lang_add_target (name)
      CONST char *name;
 {
   lang_target_statement_type *new = new_stat (lang_target_statement,
-					      stat_ptr);
+                          stat_ptr);
 
   new->target = name;
 
@@ -4194,11 +4320,11 @@ lang_add_map (name)
   while (*name)
     {
       switch (*name)
-	{
-	  case 'F':
-	  map_option_f = true;
-	  break;
-	}
+    {
+      case 'F':
+      map_option_f = true;
+      break;
+    }
       name++;
     }
 }
@@ -4208,7 +4334,7 @@ lang_add_fill (exp)
      int exp;
 {
   lang_fill_statement_type *new = new_stat (lang_fill_statement,
-					    stat_ptr);
+                        stat_ptr);
 
   new->fill = exp;
 }
@@ -4220,7 +4346,7 @@ lang_add_data (type, exp)
 {
 
   lang_data_statement_type *new = new_stat (lang_data_statement,
-					    stat_ptr);
+                        stat_ptr);
 
   new->exp = exp;
   new->type = type;
@@ -4260,7 +4386,7 @@ lang_add_assignment (exp)
      etree_type * exp;
 {
   lang_assignment_statement_type *new = new_stat (lang_assignment_statement,
-						  stat_ptr);
+                          stat_ptr);
 
   new->exp = exp;
   return new;
@@ -4342,9 +4468,9 @@ lang_abs_symbol_at_beginning_of (secname, name)
 
       sec = bfd_get_section_by_name (output_bfd, secname);
       if (sec == (asection *) NULL)
-	h->u.def.value = 0;
+    h->u.def.value = 0;
       else
-	h->u.def.value = bfd_get_section_vma (output_bfd, sec);
+    h->u.def.value = bfd_get_section_vma (output_bfd, sec);
 
       h->u.def.section = bfd_abs_section_ptr;
     }
@@ -4376,10 +4502,10 @@ lang_abs_symbol_at_end_of (secname, name)
 
       sec = bfd_get_section_by_name (output_bfd, secname);
       if (sec == (asection *) NULL)
-	h->u.def.value = 0;
+    h->u.def.value = 0;
       else
-	h->u.def.value = (bfd_get_section_vma (output_bfd, sec)
-			  + bfd_section_size (output_bfd, sec) /
+    h->u.def.value = (bfd_get_section_vma (output_bfd, sec)
+              + bfd_section_size (output_bfd, sec) /
                           bfd_octets_per_byte (output_bfd));
 
       h->u.def.section = bfd_abs_section_ptr;
@@ -4408,11 +4534,11 @@ lang_add_output_format (format, big, little, from_script)
   if (output_target == NULL || !from_script)
     {
       if (command_line.endian == ENDIAN_BIG
-	  && big != NULL)
-	format = big;
+      && big != NULL)
+    format = big;
       else if (command_line.endian == ENDIAN_LITTLE
-	       && little != NULL)
-	format = little;
+           && little != NULL)
+    format = little;
 
       output_target = format;
     }
@@ -4460,7 +4586,7 @@ lang_new_phdr (name, type, filehdr, phdrs, at, flags)
   n->next = NULL;
   n->name = name;
   n->type = exp_get_value_int (type, 0, "program header type",
-			       lang_final_phase_enum);
+                   lang_final_phase_enum);
   n->filehdr = filehdr;
   n->phdrs = phdrs;
   n->at = at;
@@ -4494,64 +4620,64 @@ lang_record_phdrs ()
 
       c = 0;
       for (u = lang_output_section_statement.head;
-	   u != NULL;
-	   u = u->output_section_statement.next)
-	{
-	  lang_output_section_statement_type *os;
-	  struct lang_output_section_phdr_list *pl;
-
-	  os = &u->output_section_statement;
-
-	  pl = os->phdrs;
-	  if (pl != NULL)
-	    last = pl;
-	  else
-	    {
-	      if (os->sectype == noload_section
-		  || os->bfd_section == NULL
-		  || (os->bfd_section->flags & SEC_ALLOC) == 0)
-		continue;
-	      pl = last;
-	    }
+       u != NULL;
+       u = u->output_section_statement.next)
+    {
+      lang_output_section_statement_type *os;
+      struct lang_output_section_phdr_list *pl;
 
-	  if (os->bfd_section == NULL)
-	    continue;
+      os = &u->output_section_statement;
 
-	  for (; pl != NULL; pl = pl->next)
-	    {
-	      if (strcmp (pl->name, l->name) == 0)
-		{
-		  if (c >= alc)
-		    {
-		      alc *= 2;
-		      secs = ((asection **)
-			      xrealloc (secs, alc * sizeof (asection *)));
-		    }
-		  secs[c] = os->bfd_section;
-		  ++c;
-		  pl->used = true;
-		}
-	    }
-	}
+      pl = os->phdrs;
+      if (pl != NULL)
+        last = pl;
+      else
+        {
+          if (os->sectype == noload_section
+          || os->bfd_section == NULL
+          || (os->bfd_section->flags & SEC_ALLOC) == 0)
+        continue;
+          pl = last;
+        }
+
+      if (os->bfd_section == NULL)
+        continue;
+
+      for (; pl != NULL; pl = pl->next)
+        {
+          if (strcmp (pl->name, l->name) == 0)
+        {
+          if (c >= alc)
+            {
+              alc *= 2;
+              secs = ((asection **)
+                  xrealloc (secs, alc * sizeof (asection *)));
+            }
+          secs[c] = os->bfd_section;
+          ++c;
+          pl->used = true;
+        }
+        }
+    }
 
       if (l->flags == NULL)
-	flags = 0;
+    flags = 0;
       else
-	flags = exp_get_vma (l->flags, 0, "phdr flags",
-			     lang_final_phase_enum);
+    flags = exp_get_vma (l->flags, 0, "phdr flags",
+                 lang_final_phase_enum);
 
       if (l->at == NULL)
-	at = 0;
+    at = 0;
       else
-	at = exp_get_vma (l->at, 0, "phdr load address",
-			  lang_final_phase_enum);
+    at = exp_get_vma (l->at, 0, "phdr load address",
+              lang_final_phase_enum);
 
       if (! bfd_record_phdr (output_bfd, l->type,
-			     l->flags == NULL ? false : true,
-			     flags,
-			     l->at == NULL ? false : true,
-			     at, l->filehdr, l->phdrs, c, secs))
-	einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
+                 l->flags == NULL ? false : true,
+                 flags,
+                 l->at == NULL ? false : true,
+                 at, l->filehdr, l->phdrs, c, secs))
+    einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
     }
 
   free (secs);
@@ -4564,14 +4690,14 @@ lang_record_phdrs ()
       struct lang_output_section_phdr_list *pl;
 
       if (u->output_section_statement.bfd_section == NULL)
-	continue;
+    continue;
 
       for (pl = u->output_section_statement.phdrs;
-	   pl != NULL;
-	   pl = pl->next)
-	if (! pl->used && strcmp (pl->name, "NONE") != 0)
-	  einfo (_("%X%P: section `%s' assigned to non-existent phdr `%s'\n"),
-		 u->output_section_statement.name, pl->name);
+       pl != NULL;
+       pl = pl->next)
+    if (! pl->used && strcmp (pl->name, "NONE") != 0)
+      einfo (_("%X%P: section `%s' assigned to non-existent phdr `%s'\n"),
+         u->output_section_statement.name, pl->name);
     }
 }
 
@@ -4626,9 +4752,9 @@ lang_enter_overlay (vma_expr, lma_expr, nocrossrefs)
 {
   /* The grammar should prevent nested overlays from occurring.  */
   ASSERT (overlay_vma == NULL
-	  && overlay_lma == NULL
-	  && overlay_list == NULL
-	  && overlay_max == NULL);
+      && overlay_lma == NULL
+      && overlay_list == NULL
+      && overlay_max == NULL);
 
   overlay_vma = vma_expr;
   overlay_lma = lma_expr;
@@ -4646,7 +4772,7 @@ lang_enter_overlay_section (name)
   etree_type *size;
 
   lang_enter_output_section_statement (name, overlay_vma, normal_section,
-				       0, 0, 0, overlay_lma);
+                       0, 0, 0, overlay_lma);
 
   /* If this is the first section, then base the VMA and LMA of future
      sections on this one.  This will work correctly even if `.' is
@@ -4705,14 +4831,14 @@ lang_leave_overlay_section (fill, phdrs)
   buf = xmalloc (strlen (clean) + sizeof "__load_start_");
   sprintf (buf, "__load_start_%s", clean);
   lang_add_assignment (exp_assop ('=', buf,
-				  exp_nameop (LOADADDR, name)));
+                  exp_nameop (LOADADDR, name)));
 
   buf = xmalloc (strlen (clean) + sizeof "__load_stop_");
   sprintf (buf, "__load_stop_%s", clean);
   lang_add_assignment (exp_assop ('=', buf,
-				  exp_binop ('+',
-					     exp_nameop (LOADADDR, name),
-					     exp_nameop (SIZEOF, name))));
+                  exp_binop ('+',
+                         exp_nameop (LOADADDR, name),
+                         exp_nameop (SIZEOF, name))));
 
   free (clean);
 }
@@ -4750,23 +4876,23 @@ lang_leave_overlay (fill, memspec, phdrs, lma_memspec)
       struct overlay_list *next;
 
       if (fill != 0 && l->os->fill == 0)
-	l->os->fill = fill;
+    l->os->fill = fill;
       if (region != NULL && l->os->region == NULL)
-	l->os->region = region;
+    l->os->region = region;
       if (lma_region != NULL && l->os->lma_region == NULL)
         l->os->lma_region = lma_region;
       if (phdrs != NULL && l->os->phdrs == NULL)
-	l->os->phdrs = phdrs;
+    l->os->phdrs = phdrs;
 
       if (overlay_nocrossrefs)
-	{
-	  struct lang_nocrossref *nc;
+    {
+      struct lang_nocrossref *nc;
 
-	  nc = (struct lang_nocrossref *) xmalloc (sizeof *nc);
-	  nc->name = l->os->name;
-	  nc->next = nocrossref;
-	  nocrossref = nc;
-	}
+      nc = (struct lang_nocrossref *) xmalloc (sizeof *nc);
+      nc->name = l->os->name;
+      nc->next = nocrossref;
+      nocrossref = nc;
+    }
 
       next = l->next;
       free (l);
@@ -4778,7 +4904,7 @@ lang_leave_overlay (fill, memspec, phdrs, lma_memspec)
 
   /* Update . for the end of the overlay.  */
   lang_add_assignment (exp_assop ('=', ".",
-				  exp_binop ('+', overlay_vma, overlay_max)));
+                  exp_binop ('+', overlay_vma, overlay_max)));
 
   overlay_vma = NULL;
   overlay_lma = NULL;
@@ -4818,7 +4944,7 @@ lang_vers_match_lang_cplusplus (expr, sym)
   if (!alt_sym)
     {
       /* cplus_demangle (also) returns NULL when it is not a C++ symbol.
-	 Should we early out false in this case?  */
+     Should we early out false in this case?  */
       result = fnmatch (expr->pattern, sym, 0) == 0;
     }
   else
@@ -4845,7 +4971,7 @@ lang_vers_match_lang_java (expr, sym)
   if (!alt_sym)
     {
       /* cplus_demangle (also) returns NULL when it is not a Java symbol.
-	 Should we early out false in this case?  */
+     Should we early out false in this case?  */
       result = fnmatch (expr->pattern, sym, 0) == 0;
     }
   else
@@ -4880,7 +5006,7 @@ lang_new_vers_regex (orig, new, lang)
   else
     {
       einfo (_("%X%P: unknown language `%s' in version information\n"),
-	     lang);
+         lang);
       ret->match = lang_vers_match_lang_c;
     }
 
@@ -4936,27 +5062,27 @@ lang_register_vers_node (name, version, deps)
   for (e1 = version->globals; e1 != NULL; e1 = e1->next)
     {
       for (t = lang_elf_version_info; t != NULL; t = t->next)
-	{
-	  struct bfd_elf_version_expr *e2;
+    {
+      struct bfd_elf_version_expr *e2;
 
-	  for (e2 = t->locals; e2 != NULL; e2 = e2->next)
-	    if (strcmp (e1->pattern, e2->pattern) == 0)
-	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
-		     e1->pattern);
-	}
+      for (e2 = t->locals; e2 != NULL; e2 = e2->next)
+        if (strcmp (e1->pattern, e2->pattern) == 0)
+          einfo (_("%X%P: duplicate expression `%s' in version information\n"),
+             e1->pattern);
+    }
     }
 
   for (e1 = version->locals; e1 != NULL; e1 = e1->next)
     {
       for (t = lang_elf_version_info; t != NULL; t = t->next)
-	{
-	  struct bfd_elf_version_expr *e2;
+    {
+      struct bfd_elf_version_expr *e2;
 
-	  for (e2 = t->globals; e2 != NULL; e2 = e2->next)
-	    if (strcmp (e1->pattern, e2->pattern) == 0)
-	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
-		     e1->pattern);
-	}
+      for (e2 = t->globals; e2 != NULL; e2 = e2->next)
+        if (strcmp (e1->pattern, e2->pattern) == 0)
+          einfo (_("%X%P: duplicate expression `%s' in version information\n"),
+             e1->pattern);
+    }
     }
 
   version->deps = deps;
@@ -4985,10 +5111,10 @@ lang_add_vers_depend (list, name)
   for (t = lang_elf_version_info; t != NULL; t = t->next)
     {
       if (strcmp (t->name, name) == 0)
-	{
-	  ret->version_needed = t;
-	  return ret;
-	}
+    {
+      ret->version_needed = t;
+      return ret;
+    }
     }
 
   einfo (_("%X%P: unable to find version dependency `%s'\n"), name);
@@ -5013,23 +5139,23 @@ lang_do_version_exports_section ()
       len = bfd_section_size (is->the_bfd, sec);
       contents = xmalloc (len);
       if (!bfd_get_section_contents (is->the_bfd, sec, contents, 0, len))
-	einfo (_("%X%P: unable to read .exports section contents"), sec);
+    einfo (_("%X%P: unable to read .exports section contents"), sec);
 
       p = contents;
       while (p < contents+len)
-	{
-	  greg = lang_new_vers_regex (greg, p, NULL);
-	  p = strchr (p, '\0') + 1;
-	}
+    {
+      greg = lang_new_vers_regex (greg, p, NULL);
+      p = strchr (p, '\0') + 1;
+    }
 
       /* Do not free the contents, as we used them creating the regex.  */
 
       /* Do not include this section in the link.  */
       bfd_set_section_flags (is->the_bfd, sec,
-	bfd_get_section_flags (is->the_bfd, sec) | SEC_EXCLUDE);
+    bfd_get_section_flags (is->the_bfd, sec) | SEC_EXCLUDE);
     }
 
   lreg = lang_new_vers_regex (NULL, "*", NULL);
   lang_register_vers_node (command_line.version_exports_section,
-			   lang_new_vers_node (greg, lreg), NULL);
+               lang_new_vers_node (greg, lreg), NULL);
 }
diff --git a/ld/ldmain.c b/ld/ldmain.c
index 676eeba..da117b6 100644
--- a/ld/ldmain.c
+++ b/ld/ldmain.c
@@ -41,9 +41,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 #include "ldfile.h"
 #include "ldctor.h"
 
+int g_iAdvance = 0;     /* add T.Tazaki 2003/05/14 */
+int g_iPE      = 0;     /* add T.Tazaki 2003/11/18 */
+/* >>>>> DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+///* add architecture number 2003/05/14 T.Tazaki */
+//#define EM_SE_C33      107      /* S1C33 Family of Seiko Epson processor */
+/* <<<<< DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+
 /* Somewhere above, sys/stat.h got included . . . . */
 #if !defined(S_ISDIR) && defined(S_IFDIR)
-#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
 #endif
 
 #include <string.h>
@@ -94,41 +101,41 @@ ld_config_type config;
 static void remove_output PARAMS ((void));
 static boolean check_for_scripts_dir PARAMS ((char *dir));
 static boolean add_archive_element PARAMS ((struct bfd_link_info *, bfd *,
-					    const char *));
+                        const char *));
 static boolean multiple_definition PARAMS ((struct bfd_link_info *,
-					    const char *,
-					    bfd *, asection *, bfd_vma,
-					    bfd *, asection *, bfd_vma));
+                        const char *,
+                        bfd *, asection *, bfd_vma,
+                        bfd *, asection *, bfd_vma));
 static boolean multiple_common PARAMS ((struct bfd_link_info *,
-					const char *, bfd *,
-					enum bfd_link_hash_type, bfd_vma,
-					bfd *, enum bfd_link_hash_type,
-					bfd_vma));
+                    const char *, bfd *,
+                    enum bfd_link_hash_type, bfd_vma,
+                    bfd *, enum bfd_link_hash_type,
+                    bfd_vma));
 static boolean add_to_set PARAMS ((struct bfd_link_info *,
-				   struct bfd_link_hash_entry *,
-				   bfd_reloc_code_real_type,
-				   bfd *, asection *, bfd_vma));
+                   struct bfd_link_hash_entry *,
+                   bfd_reloc_code_real_type,
+                   bfd *, asection *, bfd_vma));
 static boolean constructor_callback PARAMS ((struct bfd_link_info *,
-					     boolean constructor,
-					     const char *name,
-					     bfd *, asection *, bfd_vma));
+                         boolean constructor,
+                         const char *name,
+                         bfd *, asection *, bfd_vma));
 static boolean warning_callback PARAMS ((struct bfd_link_info *,
-					 const char *, const char *, bfd *,
-					 asection *, bfd_vma));
+                     const char *, const char *, bfd *,
+                     asection *, bfd_vma));
 static void warning_find_reloc PARAMS ((bfd *, asection *, PTR));
 static boolean undefined_symbol PARAMS ((struct bfd_link_info *,
-					 const char *, bfd *,
-					 asection *, bfd_vma, boolean));
+                     const char *, bfd *,
+                     asection *, bfd_vma, boolean));
 static boolean reloc_overflow PARAMS ((struct bfd_link_info *, const char *,
-				       const char *, bfd_vma,
-				       bfd *, asection *, bfd_vma));
+                       const char *, bfd_vma,
+                       bfd *, asection *, bfd_vma));
 static boolean reloc_dangerous PARAMS ((struct bfd_link_info *, const char *,
-					bfd *, asection *, bfd_vma));
+                    bfd *, asection *, bfd_vma));
 static boolean unattached_reloc PARAMS ((struct bfd_link_info *,
-					 const char *, bfd *, asection *,
-					 bfd_vma));
+                     const char *, bfd *, asection *,
+                     bfd_vma));
 static boolean notice PARAMS ((struct bfd_link_info *, const char *,
-			       bfd *, asection *, bfd_vma));
+                   bfd *, asection *, bfd_vma));
 
 static struct bfd_link_callbacks link_callbacks =
 {
@@ -153,9 +160,9 @@ remove_output ()
   if (output_filename) 
     {
       if (output_bfd && output_bfd->iostream)
-	fclose((FILE *)(output_bfd->iostream));
+    fclose((FILE *)(output_bfd->iostream));
       if (delete_output_file_on_failure)
-	unlink (output_filename);
+    unlink (output_filename);
     }
 }
 
@@ -166,6 +173,9 @@ main (argc, argv)
 {
   char *emulation;
   long start_time = get_run_time ();
+/* >>>>> DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+//  FILE *fpOut;      /* ELF file write file pointer   add T.Tazaki 2003/05/14 */
+/* <<<<< DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
 
 #if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
   setlocale (LC_MESSAGES, "");
@@ -258,13 +268,13 @@ main (argc, argv)
   if (link_info.relocateable)
     {
       if (command_line.gc_sections)
-	einfo ("%P%F: --gc-sections and -r may not be used together\n");
+    einfo ("%P%F: --gc-sections and -r may not be used together\n");
       if (link_info.mpc860c0)
-	einfo (_("%P%F: -r and --mpc860c0 may not be used together\n"));
+    einfo (_("%P%F: -r and --mpc860c0 may not be used together\n"));
       else if (command_line.relax)
-	einfo (_("%P%F: --relax and -r may not be used together\n"));
+    einfo (_("%P%F: --relax and -r may not be used together\n"));
       if (link_info.shared)
-	einfo (_("%P%F: -r and -shared may not be used together\n"));
+    einfo (_("%P%F: -r and -shared may not be used together\n"));
     }
 
   /* Treat ld -r -s as ld -r -S -x (i.e., strip all local symbols).  I
@@ -274,7 +284,7 @@ main (argc, argv)
     {
       link_info.strip = strip_debugger;
       if (link_info.discard == discard_none)
-	link_info.discard = discard_all;
+    link_info.discard = discard_all;
     }
 
   /* This essentially adds another -L directory so this must be done after
@@ -288,19 +298,19 @@ main (argc, argv)
       char *s = ldemul_get_script (&isfile);
 
       if (isfile)
-	ldfile_open_command_file (s);
+    ldfile_open_command_file (s);
       else
-	{
-	  if (trace_file_tries)
-	    {
-	      info_msg (_("using internal linker script:\n"));
-	      info_msg ("==================================================\n");
-	      info_msg (s);
-	      info_msg ("\n==================================================\n");
-	    }
-	  lex_string = s;
-	  lex_redirect (s);
-	}
+    {
+      if (trace_file_tries)
+        {
+          info_msg (_("using internal linker script:\n"));
+          info_msg ("==================================================\n");
+          info_msg (s);
+          info_msg ("\n==================================================\n");
+        }
+      lex_string = s;
+      lex_redirect (s);
+    }
       parser_input = input_script;
       yyparse ();
       lex_string = NULL;
@@ -311,7 +321,7 @@ main (argc, argv)
   if (lang_has_input_file == false)
     {
       if (version_printed)
-	xexit (0);
+    xexit (0);
       einfo (_("%P%F: no input files\n"));
     }
 
@@ -326,19 +336,19 @@ main (argc, argv)
   if (config.map_filename)
     {
       if (strcmp (config.map_filename, "-") == 0)
-	{
-	  config.map_file = stdout;
-	}
+    {
+      config.map_file = stdout;
+    }
       else
-	{
-	  config.map_file = fopen (config.map_filename, FOPEN_WT);
-	  if (config.map_file == (FILE *) NULL)
-	    {
-	      bfd_set_error (bfd_error_system_call);
-	      einfo (_("%P%F: cannot open map file %s: %E\n"),
-		     config.map_filename);
-	    }
-	}
+    {
+      config.map_file = fopen (config.map_filename, FOPEN_WT);
+      if (config.map_file == (FILE *) NULL)
+        {
+          bfd_set_error (bfd_error_system_call);
+          einfo (_("%P%F: cannot open map file %s: %E\n"),
+             config.map_filename);
+        }
+    }
     }
 
 
@@ -354,9 +364,9 @@ main (argc, argv)
       asection *found = bfd_get_section_by_name (output_bfd, ".text");
 
       if (found != (asection *) NULL)
-	{
-	  found->flags |= SEC_READONLY;
-	}
+    {
+      found->flags |= SEC_READONLY;
+    }
     }
 
   if (link_info.relocateable)
@@ -366,12 +376,17 @@ main (argc, argv)
 
   ldwrite ();
 
+/* del T.Tazaki 2003/06/24 >>> : Map file output after bfd close. 
+                               : symbol with underbar modify */
+//#if 0	/* add T.Tazaki 2003/11/19 bug fix */
   if (config.map_file != NULL)
     lang_map ();
   if (command_line.cref)
     output_cref (config.map_file != NULL ? config.map_file : stdout);
   if (nocrossref_list != NULL)
     check_nocrossrefs ();
+//#endif
+/* del T.Tazaki 2003/06/24 <<< */
 
   /* Even if we're producing relocateable output, some non-fatal errors should
      be reported in the exit status.  (What non-fatal errors, if any, do we
@@ -380,10 +395,10 @@ main (argc, argv)
   if (config.make_executable == false && force_make_executable == false)
     {
       if (trace_files == true)
-	{
-	  einfo (_("%P: link errors found, deleting executable `%s'\n"),
-		 output_filename);
-	}
+    {
+      einfo (_("%P: link errors found, deleting executable `%s'\n"),
+         output_filename);
+    }
 
       /* The file will be removed by remove_output.  */
 
@@ -392,50 +407,98 @@ main (argc, argv)
   else
     {
       if (! bfd_close (output_bfd))
-	einfo (_("%F%B: final close failed: %E\n"), output_bfd);
+    einfo (_("%F%B: final close failed: %E\n"), output_bfd);
+
+/* add T.Tazaki 2003/06/24 >>>  : Map file output after bfd close.  
+                                : symbol with underbar modify */
+#if 0	/* del T.Tazaki 2003/11/19 bug fix */
+  if (config.map_file != NULL)
+    lang_map ();
+  if (command_line.cref)
+    output_cref (config.map_file != NULL ? config.map_file : stdout);
+  if (nocrossref_list != NULL)
+    check_nocrossrefs ();
+#endif    
+/* add T.Tazaki 2003/06/24 <<< */
+
+/* >>>>> DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+///* add T.Tazaki 2003/05/14 >>> */
+//    fpOut = fopen( output_filename,"r+b" );
+//    if( fpOut != NULL )
+//    {
+//        /* e_machine number set */
+//        fseek( fpOut, 18, SEEK_SET );
+//        fputc( EM_SE_C33, fpOut );
+/* <<<<< DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+
+/* >>>>> DELETED D.Fujimoto 2007/10/01 macro flag output moved to bfd/elf32-c33.c */
+//        /* Advanced macro mode ? */
+//        if( g_iAdvance == 1 )
+//        {
+//            /* ELF header : e_flags bit31-28=CPU flag set */
+//            /*  flag = 0x0  : Standard macro */
+//	        /*  flag = 'A'  : Advanced macro */
+//	        /*  flag = 'P'  : PE macro */
+//           fseek( fpOut, 39, SEEK_SET );
+//           fputc( 'A', fpOut );
+//        }
+//        else if ( g_iPE == 1 )			/* add T.Tazaki 2003/11/18 */
+//        {
+//           fseek( fpOut, 39, SEEK_SET );
+//           fputc( 'P', fpOut );
+//        }
+/* <<<<< DELETED D.Fujimoto 2007/10/01 macro flag output moved to bfd/elf32-c33.c */
+
+/* >>>>> DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+//        fclose( fpOut );
+//    }
+//
+///* add T.Tazaki 2003/05/14 <<< */
+/* <<<<< DELETED D.Fujimoto 2007/10/15 e_machine set in elf.c */
+
 
       /* If the --force-exe-suffix is enabled, and we're making an
-	 executable file and it doesn't end in .exe, copy it to one which does. */
+     executable file and it doesn't end in .exe, copy it to one which does. */
 
       if (! link_info.relocateable && command_line.force_exe_suffix)
-	{
-	  int len = strlen (output_filename);
-	  if (len < 4 
-	      || (strcasecmp (output_filename + len - 4, ".exe") != 0
-		  && strcasecmp (output_filename + len - 4, ".dll") != 0))
-	    {
-	      FILE *src;
-	      FILE *dst;
-	      const int bsize = 4096;
-	      char *buf = xmalloc (bsize);
-	      int l;
-	      char *dst_name = xmalloc (len + 5);
-	      strcpy (dst_name, output_filename);
-	      strcat (dst_name, ".exe");
-	      src = fopen (output_filename, FOPEN_RB);
-	      dst = fopen (dst_name, FOPEN_WB);
-
-	      if (!src)
-		einfo (_("%X%P: unable to open for source of copy `%s'\n"), output_filename);
-	      if (!dst)
-		einfo (_("%X%P: unable to open for destination of copy `%s'\n"), dst_name);
-	      while ((l = fread (buf, 1, bsize, src)) > 0)
-		{
-		  int done = fwrite (buf, 1, l, dst);
-		  if (done != l)
-		    {
-		      einfo (_("%P: Error writing file `%s'\n"), dst_name);
-		    }
-		}
-	      fclose (src);
-	      if (fclose (dst) == EOF)
-		{
-		  einfo (_("%P: Error closing file `%s'\n"), dst_name);
-		}
-	      free (dst_name);
-	      free (buf);
-	    }
-	}
+    {
+      int len = strlen (output_filename);
+      if (len < 4 
+          || (strcasecmp (output_filename + len - 4, ".exe") != 0
+          && strcasecmp (output_filename + len - 4, ".dll") != 0))
+        {
+          FILE *src;
+          FILE *dst;
+          const int bsize = 4096;
+          char *buf = xmalloc (bsize);
+          int l;
+          char *dst_name = xmalloc (len + 5);
+          strcpy (dst_name, output_filename);
+          strcat (dst_name, ".exe");
+          src = fopen (output_filename, FOPEN_RB);
+          dst = fopen (dst_name, FOPEN_WB);
+
+          if (!src)
+        einfo (_("%X%P: unable to open for source of copy `%s'\n"), output_filename);
+          if (!dst)
+        einfo (_("%X%P: unable to open for destination of copy `%s'\n"), dst_name);
+          while ((l = fread (buf, 1, bsize, src)) > 0)
+        {
+          int done = fwrite (buf, 1, l, dst);
+          if (done != l)
+            {
+              einfo (_("%P: Error writing file `%s'\n"), dst_name);
+            }
+        }
+          fclose (src);
+          if (fclose (dst) == EOF)
+        {
+          einfo (_("%P: Error closing file `%s'\n"), dst_name);
+        }
+          free (dst_name);
+          free (buf);
+        }
+    }
     }
 
   END_PROGRESS (program_name);
@@ -448,10 +511,10 @@ main (argc, argv)
       long run_time = get_run_time () - start_time;
 
       fprintf (stderr, _("%s: total time in link: %ld.%06ld\n"),
-	       program_name, run_time / 1000000, run_time % 1000000);
+           program_name, run_time / 1000000, run_time % 1000000);
 #ifdef HAVE_SBRK
       fprintf (stderr, _("%s: data size %ld\n"), program_name,
-	       (long) (lim - (char *) &environ));
+           (long) (lim - (char *) &environ));
 #endif
     }
 
@@ -480,45 +543,45 @@ get_emulation (argc, argv)
   for (i = 1; i < argc; i++)
     {
       if (!strncmp (argv[i], "-m", 2))
-	{
-	  if (argv[i][2] == '\0')
-	    {
-	      /* -m EMUL */
-	      if (i < argc - 1)
-		{
-		  emulation = argv[i + 1];
-		  i++;
-		}
-	      else
-		{
-		  einfo(_("%P%F: missing argument to -m\n"));
-		}
-	    }
-	  else if (strcmp (argv[i], "-mips1") == 0
-		   || strcmp (argv[i], "-mips2") == 0
-		   || strcmp (argv[i], "-mips3") == 0
-		   || strcmp (argv[i], "-mips4") == 0)
-	    {
-	      /* FIXME: The arguments -mips1, -mips2 and -mips3 are
-		 passed to the linker by some MIPS compilers.  They
-		 generally tell the linker to use a slightly different
-		 library path.  Perhaps someday these should be
-		 implemented as emulations; until then, we just ignore
-		 the arguments and hope that nobody ever creates
-		 emulations named ips1, ips2 or ips3.  */
-	    }
-	  else if (strcmp (argv[i], "-m486") == 0)
-	    {
-	      /* FIXME: The argument -m486 is passed to the linker on
-		 some Linux systems.  Hope that nobody creates an
-		 emulation named 486.  */
-	    }
-	  else
-	    {
-	      /* -mEMUL */
-	      emulation = &argv[i][2];
-	    }
-	}
+    {
+      if (argv[i][2] == '\0')
+        {
+          /* -m EMUL */
+          if (i < argc - 1)
+        {
+          emulation = argv[i + 1];
+          i++;
+        }
+          else
+        {
+          einfo(_("%P%F: missing argument to -m\n"));
+        }
+        }
+      else if (strcmp (argv[i], "-mips1") == 0
+           || strcmp (argv[i], "-mips2") == 0
+           || strcmp (argv[i], "-mips3") == 0
+           || strcmp (argv[i], "-mips4") == 0)
+        {
+          /* FIXME: The arguments -mips1, -mips2 and -mips3 are
+         passed to the linker by some MIPS compilers.  They
+         generally tell the linker to use a slightly different
+         library path.  Perhaps someday these should be
+         implemented as emulations; until then, we just ignore
+         the arguments and hope that nobody ever creates
+         emulations named ips1, ips2 or ips3.  */
+        }
+      else if (strcmp (argv[i], "-m486") == 0)
+        {
+          /* FIXME: The argument -m486 is passed to the linker on
+         some Linux systems.  Hope that nobody creates an
+         emulation named 486.  */
+        }
+      else
+        {
+          /* -mEMUL */
+          emulation = &argv[i][2];
+        }
+    }
     }
 
   return emulation;
@@ -564,7 +627,7 @@ set_scripts_dir ()
   size_t dirlen;
 
   if (check_for_scripts_dir (SCRIPTDIR))
-    return;			/* We've been installed normally.  */
+    return;         /* We've been installed normally.  */
 
   /* Look for "ldscripts" in the dir where our binary is.  */
   end = strrchr (program_name, '/');
@@ -592,14 +655,14 @@ set_scripts_dir ()
   dir[dirlen] = '\0';
 
   if (check_for_scripts_dir (dir))
-    return;			/* Don't free dir.  */
+    return;         /* Don't free dir.  */
 
   /* Look for "ldscripts" in <the dir where our binary is>/../lib.  */
   strcpy (dir + dirlen, "/../lib");
   if (check_for_scripts_dir (dir))
     return;
 
-  free (dir);			/* Well, we tried.  */
+  free (dir);           /* Well, we tried.  */
 }
 
 void
@@ -609,11 +672,11 @@ add_ysym (name)
   if (link_info.notice_hash == (struct bfd_hash_table *) NULL)
     {
       link_info.notice_hash = ((struct bfd_hash_table *)
-			       xmalloc (sizeof (struct bfd_hash_table)));
+                   xmalloc (sizeof (struct bfd_hash_table)));
       if (! bfd_hash_table_init_n (link_info.notice_hash,
-				   bfd_hash_newfunc,
-				   61))
-	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
+                   bfd_hash_newfunc,
+                   61))
+    einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
     }      
 
   if (bfd_hash_lookup (link_info.notice_hash, name, true, true)
@@ -630,11 +693,11 @@ add_wrap (name)
   if (link_info.wrap_hash == NULL)
     {
       link_info.wrap_hash = ((struct bfd_hash_table *)
-			     xmalloc (sizeof (struct bfd_hash_table)));
+                 xmalloc (sizeof (struct bfd_hash_table)));
       if (! bfd_hash_table_init_n (link_info.wrap_hash,
-				   bfd_hash_newfunc,
-				   61))
-	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
+                   bfd_hash_newfunc,
+                   61))
+    einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
     }
   if (bfd_hash_lookup (link_info.wrap_hash, name, true, true) == NULL)
     einfo (_("%P%F: bfd_hash_lookup failed: %E\n"));
@@ -663,7 +726,7 @@ add_keepsyms_file (filename)
     }
 
   link_info.keep_hash = ((struct bfd_hash_table *)
-			 xmalloc (sizeof (struct bfd_hash_table)));
+             xmalloc (sizeof (struct bfd_hash_table)));
   if (! bfd_hash_table_init (link_info.keep_hash, bfd_hash_newfunc))
     einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));
 
@@ -674,30 +737,30 @@ add_keepsyms_file (filename)
   while (c != EOF)
     {
       while (isspace (c))
-	c = getc (file);
+    c = getc (file);
 
       if (c != EOF)
-	{
-	  size_t len = 0;
-
-	  while (! isspace (c) && c != EOF)
-	    {
-	      buf[len] = c;
-	      ++len;
-	      if (len >= bufsize)
-		{
-		  bufsize *= 2;
-		  buf = xrealloc (buf, bufsize);
-		}
-	      c = getc (file);
-	    }
-
-	  buf[len] = '\0';
-
-	  if (bfd_hash_lookup (link_info.keep_hash, buf, true, true)
-	      == (struct bfd_hash_entry *) NULL)
-	    einfo (_("%P%F: bfd_hash_lookup for insertion failed: %E\n"));
-	}
+    {
+      size_t len = 0;
+
+      while (! isspace (c) && c != EOF)
+        {
+          buf[len] = c;
+          ++len;
+          if (len >= bufsize)
+        {
+          bufsize *= 2;
+          buf = xrealloc (buf, bufsize);
+        }
+          c = getc (file);
+        }
+
+      buf[len] = '\0';
+
+      if (bfd_hash_lookup (link_info.keep_hash, buf, true, true)
+          == (struct bfd_hash_entry *) NULL)
+        einfo (_("%P%F: bfd_hash_lookup for insertion failed: %E\n"));
+    }
     }
 
   if (link_info.strip != strip_none)
@@ -721,7 +784,7 @@ add_archive_element (info, abfd, name)
   lang_input_statement_type *input;
 
   input = ((lang_input_statement_type *)
-	   xmalloc (sizeof (lang_input_statement_type)));
+       xmalloc (sizeof (lang_input_statement_type)));
   input->filename = abfd->filename;
   input->local_sym_name = abfd->filename;
   input->the_bfd = abfd;
@@ -749,72 +812,72 @@ add_archive_element (info, abfd, name)
       h = bfd_link_hash_lookup (link_info.hash, name, false, false, true);
 
       if (h == NULL)
-	from = NULL;
+    from = NULL;
       else
-	{
-	  switch (h->type)
-	    {
-	    default:
-	      from = NULL;
-	      break;
-
-	    case bfd_link_hash_defined:
-	    case bfd_link_hash_defweak:
-	      from = h->u.def.section->owner;
-	      break;
-
-	    case bfd_link_hash_undefined:
-	    case bfd_link_hash_undefweak:
-	      from = h->u.undef.abfd;
-	      break;
-
-	    case bfd_link_hash_common:
-	      from = h->u.c.p->section->owner;
-	      break;
-	    }
-	}
+    {
+      switch (h->type)
+        {
+        default:
+          from = NULL;
+          break;
+
+        case bfd_link_hash_defined:
+        case bfd_link_hash_defweak:
+          from = h->u.def.section->owner;
+          break;
+
+        case bfd_link_hash_undefined:
+        case bfd_link_hash_undefweak:
+          from = h->u.undef.abfd;
+          break;
+
+        case bfd_link_hash_common:
+          from = h->u.c.p->section->owner;
+          break;
+        }
+    }
 
       if (! header_printed)
-	{
-	  char buf[100];
+    {
+      char buf[100];
 
-	  sprintf (buf, "%-29s %s\n\n", _("Archive member included"),
-		   _("because of file (symbol)"));
-	  minfo ("%s", buf);
-	  header_printed = true;
-	}
+      sprintf (buf, "%-29s %s\n\n", _("Archive member included"),
+           _("because of file (symbol)"));
+      minfo ("%s", buf);
+      header_printed = true;
+    }
 
       if (bfd_my_archive (abfd) == NULL)
-	{
-	  minfo ("%s", bfd_get_filename (abfd));
-	  len = strlen (bfd_get_filename (abfd));
-	}
+    {
+      minfo ("%s", bfd_get_filename (abfd));
+      len = strlen (bfd_get_filename (abfd));
+    }
       else
-	{
-	  minfo ("%s(%s)", bfd_get_filename (bfd_my_archive (abfd)),
-		 bfd_get_filename (abfd));
-	  len = (strlen (bfd_get_filename (bfd_my_archive (abfd)))
-		 + strlen (bfd_get_filename (abfd))
-		 + 2);
-	}
+    {
+      minfo ("%s(%s)", bfd_get_filename (bfd_my_archive (abfd)),
+         bfd_get_filename (abfd));
+      len = (strlen (bfd_get_filename (bfd_my_archive (abfd)))
+         + strlen (bfd_get_filename (abfd))
+         + 2);
+    }
 
       if (len >= 29)
-	{
-	  print_nl ();
-	  len = 0;
-	}
+    {
+      print_nl ();
+      len = 0;
+    }
       while (len < 30)
-	{
-	  print_space ();
-	  ++len;
-	}
+    {
+      print_space ();
+      ++len;
+    }
 
       if (from != NULL)
-	minfo ("%B ", from);
+    minfo ("%B ", from);
       if (h != NULL)
-	minfo ("(%T)\n", h->root.string);
+    minfo ("(%T)\n", h->root.string);
       else
-	minfo ("(%s)\n", name);
+    minfo ("(%s)\n", name);
     }
 
   if (trace_files || trace_file_tries)
@@ -847,15 +910,21 @@ multiple_definition (info, name, obfd, osec, oval, nbfd, nsec, nval)
        && ! bfd_is_abs_section (osec)
        && bfd_is_abs_section (osec->output_section))
       || (nsec->output_section != NULL
-	  && ! bfd_is_abs_section (nsec)
-	  && bfd_is_abs_section (nsec->output_section)))
+      && ! bfd_is_abs_section (nsec)
+      && bfd_is_abs_section (nsec->output_section)))
     return true;
 
+/* delete 2002.07.01 T.Tazaki mutiple difinition error */
+#if 0
+
   einfo (_("%X%C: multiple definition of `%T'\n"),
-	 nbfd, nsec, nval, name);
+     nbfd, nsec, nval, name);
   if (obfd != (bfd *) NULL)
     einfo (_("%D: first defined here\n"), obfd, osec, oval);
+
+#endif
   return true;
+
 }
 
 /* This is called when there is a definition of a common symbol, or
@@ -884,43 +953,43 @@ multiple_common (info, name, obfd, otype, osize, nbfd, ntype, nsize)
     {
       ASSERT (otype == bfd_link_hash_common);
       einfo (_("%B: warning: definition of `%T' overriding common\n"),
-	     nbfd, name);
+         nbfd, name);
       if (obfd != NULL)
-	einfo (_("%B: warning: common is here\n"), obfd);
+    einfo (_("%B: warning: common is here\n"), obfd);
     }
   else if (otype == bfd_link_hash_defined
-	   || otype == bfd_link_hash_defweak
-	   || otype == bfd_link_hash_indirect)
+       || otype == bfd_link_hash_defweak
+       || otype == bfd_link_hash_indirect)
     {
       ASSERT (ntype == bfd_link_hash_common);
       einfo (_("%B: warning: common of `%T' overridden by definition\n"),
-	     nbfd, name);
+         nbfd, name);
       if (obfd != NULL)
-	einfo (_("%B: warning: defined here\n"), obfd);
+    einfo (_("%B: warning: defined here\n"), obfd);
     }
   else
     {
       ASSERT (otype == bfd_link_hash_common && ntype == bfd_link_hash_common);
       if (osize > nsize)
-	{
-	  einfo (_("%B: warning: common of `%T' overridden by larger common\n"),
-		 nbfd, name);
-	  if (obfd != NULL)
-	    einfo (_("%B: warning: larger common is here\n"), obfd);
-	}
+    {
+      einfo (_("%B: warning: common of `%T' overridden by larger common\n"),
+         nbfd, name);
+      if (obfd != NULL)
+        einfo (_("%B: warning: larger common is here\n"), obfd);
+    }
       else if (nsize > osize)
-	{
-	  einfo (_("%B: warning: common of `%T' overriding smaller common\n"),
-		 nbfd, name);
-	  if (obfd != NULL)
-	    einfo (_("%B: warning: smaller common is here\n"), obfd);
-	}
+    {
+      einfo (_("%B: warning: common of `%T' overriding smaller common\n"),
+         nbfd, name);
+      if (obfd != NULL)
+        einfo (_("%B: warning: smaller common is here\n"), obfd);
+    }
       else
-	{
-	  einfo (_("%B: warning: multiple common of `%T'\n"), nbfd, name);
-	  if (obfd != NULL)
-	    einfo (_("%B: warning: previous common is here\n"), obfd);
-	}
+    {
+      einfo (_("%B: warning: multiple common of `%T'\n"), nbfd, name);
+      if (obfd != NULL)
+        einfo (_("%B: warning: previous common is here\n"), obfd);
+    }
     }
 
   return true;
@@ -942,7 +1011,7 @@ add_to_set (info, h, reloc, abfd, section, value)
 {
   if (config.warn_constructors)
     einfo (_("%P: warning: global constructor %s used\n"),
-	   h->root.string);
+       h->root.string);
 
   if (! config.build_constructors)
     return true;
@@ -954,8 +1023,8 @@ add_to_set (info, h, reloc, abfd, section, value)
       h->type = bfd_link_hash_undefined;
       h->u.undef.abfd = abfd;
       /* We don't call bfd_link_add_undef to add this to the list of
-	 undefined symbols because we are going to define it
-	 ourselves.  */
+     undefined symbols because we are going to define it
+     ourselves.  */
     }
 
   return true;
@@ -989,7 +1058,7 @@ constructor_callback (info, constructor, name, abfd, section, value)
      useful error message.  */
   if (bfd_reloc_type_lookup (output_bfd, BFD_RELOC_CTOR) == NULL
       && (link_info.relocateable
-	  || bfd_reloc_type_lookup (abfd, BFD_RELOC_CTOR) == NULL))
+      || bfd_reloc_type_lookup (abfd, BFD_RELOC_CTOR) == NULL))
     einfo (_("%P%F: BFD backend error: BFD_RELOC_CTOR unsupported\n"));
 
   s = set_name;
@@ -1008,8 +1077,8 @@ constructor_callback (info, constructor, name, abfd, section, value)
       h->type = bfd_link_hash_undefined;
       h->u.undef.abfd = abfd;
       /* We don't call bfd_link_add_undef to add this to the list of
-	 undefined symbols because we are going to define it
-	 ourselves.  */
+     undefined symbols because we are going to define it
+     ourselves.  */
     }
 
   ldctor_add_set_entry (h, BFD_RELOC_CTOR, name, section, value);
@@ -1058,29 +1127,29 @@ warning_callback (info, warning, symbol, abfd, section, address)
       struct warning_callback_info info;
 
       /* Look through the relocs to see if we can find a plausible
-	 address.  */
+     address.  */
 
       entry = (lang_input_statement_type *) abfd->usrdata;
       if (entry != NULL && entry->asymbols != NULL)
-	asymbols = entry->asymbols;
+    asymbols = entry->asymbols;
       else
-	{
-	  long symsize;
-	  long symbol_count;
-
-	  symsize = bfd_get_symtab_upper_bound (abfd);
-	  if (symsize < 0)
-	    einfo (_("%B%F: could not read symbols: %E\n"), abfd);
-	  asymbols = (asymbol **) xmalloc (symsize);
-	  symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
-	  if (symbol_count < 0)
-	    einfo (_("%B%F: could not read symbols: %E\n"), abfd);
-	  if (entry != NULL)
-	    {
-	      entry->asymbols = asymbols;
-	      entry->symbol_count = symbol_count;
-	    }
-	}
+    {
+      long symsize;
+      long symbol_count;
+
+      symsize = bfd_get_symtab_upper_bound (abfd);
+      if (symsize < 0)
+        einfo (_("%B%F: could not read symbols: %E\n"), abfd);
+      asymbols = (asymbol **) xmalloc (symsize);
+      symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
+      if (symbol_count < 0)
+        einfo (_("%B%F: could not read symbols: %E\n"), abfd);
+      if (entry != NULL)
+        {
+          entry->asymbols = asymbols;
+          entry->symbol_count = symbol_count;
+        }
+    }
 
       info.found = false;
       info.warning = warning;
@@ -1089,10 +1158,10 @@ warning_callback (info, warning, symbol, abfd, section, address)
       bfd_map_over_sections (abfd, warning_find_reloc, (PTR) &info);
 
       if (! info.found)
-	einfo ("%B: %s\n", abfd, warning);
+    einfo ("%B: %s\n", abfd, warning);
 
       if (entry == NULL)
-	free (asymbols);
+    free (asymbols);
     }
 
   return true;
@@ -1136,14 +1205,14 @@ warning_find_reloc (abfd, sec, iarg)
       arelent *q = *p;
 
       if (q->sym_ptr_ptr != NULL
-	  && *q->sym_ptr_ptr != NULL
-	  && strcmp (bfd_asymbol_name (*q->sym_ptr_ptr), info->symbol) == 0)
-	{
-	  /* We found a reloc for the symbol we are looking for.  */
-	  einfo ("%C: %s\n", abfd, sec, q->address, info->warning);
-	  info->found = true;
-	  break;
-	}
+      && *q->sym_ptr_ptr != NULL
+      && strcmp (bfd_asymbol_name (*q->sym_ptr_ptr), info->symbol) == 0)
+    {
+      /* We found a reloc for the symbol we are looking for.  */
+      einfo ("%C: %s\n", abfd, sec, q->address, info->warning);
+      info->found = true;
+      break;
+    }
     }
 
   free (relpp);
@@ -1173,18 +1242,18 @@ undefined_symbol (info, name, abfd, section, address, fatal)
       /* Only warn once about a particular undefined symbol.  */
 
       if (hash == NULL)
-	{
-	  hash = ((struct bfd_hash_table *)
-		  xmalloc (sizeof (struct bfd_hash_table)));
-	  if (! bfd_hash_table_init (hash, bfd_hash_newfunc))
-	    einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
-	}
+    {
+      hash = ((struct bfd_hash_table *)
+          xmalloc (sizeof (struct bfd_hash_table)));
+      if (! bfd_hash_table_init (hash, bfd_hash_newfunc))
+        einfo (_("%F%P: bfd_hash_table_init failed: %E\n"));
+    }
 
       if (bfd_hash_lookup (hash, name, false, false) != NULL)
-	return true;
+    return true;
 
       if (bfd_hash_lookup (hash, name, true, true) == NULL)
-	einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
+    einfo (_("%F%P: bfd_hash_lookup failed: %E\n"));
     }
 
   /* We never print more than a reasonable number of errors in a row
@@ -1196,35 +1265,35 @@ undefined_symbol (info, name, abfd, section, address, fatal)
     {
       error_count = 0;
       if (error_name != (char *) NULL)
-	free (error_name);
+    free (error_name);
       error_name = buystring (name);
     }
 
   if (section != NULL)
     {
       if (error_count < MAX_ERRORS_IN_A_ROW)
-	{
-	  einfo (_("%C: undefined reference to `%T'\n"),
-		 abfd, section, address, name);
-	  if (fatal)
-	    einfo ("%X");
-	}
+    {
+      einfo (_("%C: undefined reference to `%T'\n"),
+         abfd, section, address, name);
+      if (fatal)
+        einfo ("%X");
+    }
       else if (error_count == MAX_ERRORS_IN_A_ROW)
-	einfo (_("%D: more undefined references to `%T' follow\n"),
-	       abfd, section, address, name);
+    einfo (_("%D: more undefined references to `%T' follow\n"),
+           abfd, section, address, name);
     }
   else
     {
       if (error_count < MAX_ERRORS_IN_A_ROW)
-	{
-	  einfo (_("%B: undefined reference to `%T'\n"),
-		 abfd, name);
-	  if (fatal)
-	    einfo ("%X");
-	}
+    {
+      einfo (_("%B: undefined reference to `%T'\n"),
+         abfd, name);
+      if (fatal)
+        einfo ("%X");
+    }
       else if (error_count == MAX_ERRORS_IN_A_ROW)
-	einfo (_("%B: more undefined references to `%T' follow\n"),
-	       abfd, name);
+    einfo (_("%B: more undefined references to `%T' follow\n"),
+           abfd, name);
     }
 
   return true;
@@ -1307,12 +1376,12 @@ notice (info, name, abfd, section, value)
 {
   if (! info->notice_all
       || (info->notice_hash != NULL
-	  && bfd_hash_lookup (info->notice_hash, name, false, false) != NULL))
+      && bfd_hash_lookup (info->notice_hash, name, false, false) != NULL))
     {
       if (bfd_is_und_section (section))
-	einfo ("%B: reference to %s\n", abfd, name);
+    einfo ("%B: reference to %s\n", abfd, name);
       else
-	einfo ("%B: definition of %s\n", abfd, name);
+    einfo ("%B: definition of %s\n", abfd, name);
     }
 
   if (command_line.cref || nocrossref_list != NULL)
diff --git a/ld/ldver.c b/ld/ldver.c
index 5b600a2..aaef41b 100644
--- a/ld/ldver.c
+++ b/ld/ldver.c
@@ -26,14 +26,22 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 #include "ldemul.h"
 #include "ldmain.h"
 
+#define C33_LD_REVISION "2.15 <2008/05/22>"
+
 const char *ld_program_version = VERSION;
 
 void
 ldversion (noisy)
      int noisy;
 {
+/* change T.Tazaki 2002.01.31 >>> */
+/*
   fprintf (stdout, _("GNU ld version %s (with BFD %s)\n"),
-	   ld_program_version, BFD_VERSION);
+       ld_program_version, BFD_VERSION);
+*/
+  fprintf (stdout, _("GNU ld version %s (with BFD %s) (rev %s)\n"),
+       ld_program_version, BFD_VERSION, C33_LD_REVISION );
+/* change T.Tazaki 2002.01.31 <<< */
 
   if (noisy) 
     {
@@ -41,9 +49,9 @@ ldversion (noisy)
     
       printf (_("  Supported emulations:\n"));
       while (*ptr) 
-	{
-	  printf ("   %s\n", (*ptr)->emulation_name);
-	  ptr++;
-	}
+    {
+      printf ("   %s\n", (*ptr)->emulation_name);
+      ptr++;
+    }
     }
 }
diff --git a/ld/lexsup.c b/ld/lexsup.c
index e2aac47..c46ba36 100644
--- a/ld/lexsup.c
+++ b/ld/lexsup.c
@@ -48,7 +48,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 
 /* Somewhere above, sys/stat.h got included . . . . */
 #if !defined(S_ISDIR) && defined(S_IFDIR)
-#define	S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
 #endif
 
 /* Omit args to avoid the possibility of clashing with a system header
@@ -66,61 +66,61 @@ int parsing_defsym = 0;
 /* Codes used for the long options with no short synonyms.  150 isn't
    special; it's just an arbitrary non-ASCII char value.  */
 
-#define OPTION_ASSERT			150
-#define OPTION_CALL_SHARED		(OPTION_ASSERT + 1)
-#define OPTION_CREF			(OPTION_CALL_SHARED + 1)
-#define OPTION_DEFSYM			(OPTION_CREF + 1)
-#define OPTION_DEMANGLE			(OPTION_DEFSYM + 1)
-#define OPTION_DYNAMIC_LINKER		(OPTION_DEMANGLE + 1)
-#define OPTION_EB			(OPTION_DYNAMIC_LINKER + 1)
-#define OPTION_EL			(OPTION_EB + 1)
-#define OPTION_EMBEDDED_RELOCS		(OPTION_EL + 1)
-#define OPTION_EXPORT_DYNAMIC		(OPTION_EMBEDDED_RELOCS + 1)
-#define OPTION_HELP			(OPTION_EXPORT_DYNAMIC + 1)
-#define OPTION_IGNORE			(OPTION_HELP + 1)
-#define OPTION_MAP			(OPTION_IGNORE + 1)
-#define OPTION_NO_DEMANGLE		(OPTION_MAP + 1)
-#define OPTION_NO_KEEP_MEMORY		(OPTION_NO_DEMANGLE + 1)
-#define OPTION_NO_WARN_MISMATCH		(OPTION_NO_KEEP_MEMORY + 1)
-#define OPTION_NOINHIBIT_EXEC		(OPTION_NO_WARN_MISMATCH + 1)
-#define OPTION_NON_SHARED		(OPTION_NOINHIBIT_EXEC + 1)
-#define OPTION_NO_WHOLE_ARCHIVE		(OPTION_NON_SHARED + 1)
-#define OPTION_OFORMAT			(OPTION_NO_WHOLE_ARCHIVE + 1)
-#define OPTION_RELAX			(OPTION_OFORMAT + 1)
-#define OPTION_RETAIN_SYMBOLS_FILE	(OPTION_RELAX + 1)
-#define OPTION_RPATH			(OPTION_RETAIN_SYMBOLS_FILE + 1)
-#define OPTION_RPATH_LINK		(OPTION_RPATH + 1)
-#define OPTION_SHARED			(OPTION_RPATH_LINK + 1)
-#define OPTION_SONAME			(OPTION_SHARED + 1)
-#define OPTION_SORT_COMMON		(OPTION_SONAME + 1)
-#define OPTION_STATS			(OPTION_SORT_COMMON + 1)
-#define OPTION_SYMBOLIC			(OPTION_STATS + 1)
-#define OPTION_TASK_LINK		(OPTION_SYMBOLIC + 1)
-#define OPTION_TBSS			(OPTION_TASK_LINK + 1)
-#define OPTION_TDATA			(OPTION_TBSS + 1)
-#define OPTION_TTEXT			(OPTION_TDATA + 1)
-#define OPTION_TRADITIONAL_FORMAT	(OPTION_TTEXT + 1)
-#define OPTION_UR			(OPTION_TRADITIONAL_FORMAT + 1)
-#define OPTION_VERBOSE			(OPTION_UR + 1)
-#define OPTION_VERSION			(OPTION_VERBOSE + 1)
-#define OPTION_VERSION_SCRIPT		(OPTION_VERSION + 1)
-#define OPTION_VERSION_EXPORTS_SECTION	(OPTION_VERSION_SCRIPT + 1)
-#define OPTION_WARN_COMMON		(OPTION_VERSION_EXPORTS_SECTION + 1)
-#define OPTION_WARN_CONSTRUCTORS	(OPTION_WARN_COMMON + 1)
-#define OPTION_WARN_MULTIPLE_GP		(OPTION_WARN_CONSTRUCTORS + 1)
-#define OPTION_WARN_ONCE		(OPTION_WARN_MULTIPLE_GP + 1)
-#define OPTION_WARN_SECTION_ALIGN	(OPTION_WARN_ONCE + 1)
-#define OPTION_SPLIT_BY_RELOC		(OPTION_WARN_SECTION_ALIGN + 1)
-#define OPTION_SPLIT_BY_FILE 	    	(OPTION_SPLIT_BY_RELOC + 1)
-#define OPTION_WHOLE_ARCHIVE		(OPTION_SPLIT_BY_FILE + 1)
-#define OPTION_WRAP			(OPTION_WHOLE_ARCHIVE + 1)
-#define OPTION_FORCE_EXE_SUFFIX		(OPTION_WRAP + 1)
-#define OPTION_GC_SECTIONS		(OPTION_FORCE_EXE_SUFFIX + 1)
-#define OPTION_NO_GC_SECTIONS		(OPTION_GC_SECTIONS + 1)
-#define OPTION_CHECK_SECTIONS		(OPTION_NO_GC_SECTIONS + 1)
-#define OPTION_NO_CHECK_SECTIONS	(OPTION_CHECK_SECTIONS + 1)
+#define OPTION_ASSERT           150
+#define OPTION_CALL_SHARED      (OPTION_ASSERT + 1)
+#define OPTION_CREF         (OPTION_CALL_SHARED + 1)
+#define OPTION_DEFSYM           (OPTION_CREF + 1)
+#define OPTION_DEMANGLE         (OPTION_DEFSYM + 1)
+#define OPTION_DYNAMIC_LINKER       (OPTION_DEMANGLE + 1)
+#define OPTION_EB           (OPTION_DYNAMIC_LINKER + 1)
+#define OPTION_EL           (OPTION_EB + 1)
+#define OPTION_EMBEDDED_RELOCS      (OPTION_EL + 1)
+#define OPTION_EXPORT_DYNAMIC       (OPTION_EMBEDDED_RELOCS + 1)
+#define OPTION_HELP         (OPTION_EXPORT_DYNAMIC + 1)
+#define OPTION_IGNORE           (OPTION_HELP + 1)
+#define OPTION_MAP          (OPTION_IGNORE + 1)
+#define OPTION_NO_DEMANGLE      (OPTION_MAP + 1)
+#define OPTION_NO_KEEP_MEMORY       (OPTION_NO_DEMANGLE + 1)
+#define OPTION_NO_WARN_MISMATCH     (OPTION_NO_KEEP_MEMORY + 1)
+#define OPTION_NOINHIBIT_EXEC       (OPTION_NO_WARN_MISMATCH + 1)
+#define OPTION_NON_SHARED       (OPTION_NOINHIBIT_EXEC + 1)
+#define OPTION_NO_WHOLE_ARCHIVE     (OPTION_NON_SHARED + 1)
+#define OPTION_OFORMAT          (OPTION_NO_WHOLE_ARCHIVE + 1)
+#define OPTION_RELAX            (OPTION_OFORMAT + 1)
+#define OPTION_RETAIN_SYMBOLS_FILE  (OPTION_RELAX + 1)
+#define OPTION_RPATH            (OPTION_RETAIN_SYMBOLS_FILE + 1)
+#define OPTION_RPATH_LINK       (OPTION_RPATH + 1)
+#define OPTION_SHARED           (OPTION_RPATH_LINK + 1)
+#define OPTION_SONAME           (OPTION_SHARED + 1)
+#define OPTION_SORT_COMMON      (OPTION_SONAME + 1)
+#define OPTION_STATS            (OPTION_SORT_COMMON + 1)
+#define OPTION_SYMBOLIC         (OPTION_STATS + 1)
+#define OPTION_TASK_LINK        (OPTION_SYMBOLIC + 1)
+#define OPTION_TBSS         (OPTION_TASK_LINK + 1)
+#define OPTION_TDATA            (OPTION_TBSS + 1)
+#define OPTION_TTEXT            (OPTION_TDATA + 1)
+#define OPTION_TRADITIONAL_FORMAT   (OPTION_TTEXT + 1)
+#define OPTION_UR           (OPTION_TRADITIONAL_FORMAT + 1)
+#define OPTION_VERBOSE          (OPTION_UR + 1)
+#define OPTION_VERSION          (OPTION_VERBOSE + 1)
+#define OPTION_VERSION_SCRIPT       (OPTION_VERSION + 1)
+#define OPTION_VERSION_EXPORTS_SECTION  (OPTION_VERSION_SCRIPT + 1)
+#define OPTION_WARN_COMMON      (OPTION_VERSION_EXPORTS_SECTION + 1)
+#define OPTION_WARN_CONSTRUCTORS    (OPTION_WARN_COMMON + 1)
+#define OPTION_WARN_MULTIPLE_GP     (OPTION_WARN_CONSTRUCTORS + 1)
+#define OPTION_WARN_ONCE        (OPTION_WARN_MULTIPLE_GP + 1)
+#define OPTION_WARN_SECTION_ALIGN   (OPTION_WARN_ONCE + 1)
+#define OPTION_SPLIT_BY_RELOC       (OPTION_WARN_SECTION_ALIGN + 1)
+#define OPTION_SPLIT_BY_FILE            (OPTION_SPLIT_BY_RELOC + 1)
+#define OPTION_WHOLE_ARCHIVE        (OPTION_SPLIT_BY_FILE + 1)
+#define OPTION_WRAP         (OPTION_WHOLE_ARCHIVE + 1)
+#define OPTION_FORCE_EXE_SUFFIX     (OPTION_WRAP + 1)
+#define OPTION_GC_SECTIONS      (OPTION_FORCE_EXE_SUFFIX + 1)
+#define OPTION_NO_GC_SECTIONS       (OPTION_GC_SECTIONS + 1)
+#define OPTION_CHECK_SECTIONS       (OPTION_NO_GC_SECTIONS + 1)
+#define OPTION_NO_CHECK_SECTIONS    (OPTION_CHECK_SECTIONS + 1)
 #define OPTION_MPC860C0                 (OPTION_NO_CHECK_SECTIONS + 1)
-#define OPTION_NO_UNDEFINED		(OPTION_MPC860C0 + 1)
+#define OPTION_NO_UNDEFINED     (OPTION_MPC860C0 + 1)
 #define OPTION_INIT                     (OPTION_NO_UNDEFINED + 1)
 #define OPTION_FINI                     (OPTION_INIT + 1)
 
@@ -387,10 +387,10 @@ is_num (string, min, max, err)
   for (; *string; ++string)
     {
       if (! isdigit (*string))
-	{
-	  result = err;
-	  break;
-	}
+    {
+      result = err;
+      break;
+    }
       result = result * 10 + (*string - '0');
     }
   if (result < min || result > max)
@@ -411,6 +411,11 @@ parse_args (argc, argv)
   struct option longopts[OPTION_COUNT + 1];
   int last_optind;
 
+  FILE *fpIn;               /* Object file read file pointer add T.Tazaki 2003/05/14 */
+  unsigned char ucFlag;     /* add T.Tazaki 2003/05/14 */
+  extern int g_iAdvance;    /* add T.Tazaki 2003/05/14 */
+  extern int g_iPE;         /* add T.Tazaki 2003/11/18 */
+
   /* Starting the short option string with '-' is for programs that
      expect options and other ARGV-elements in any order and that care about
      the ordering of the two.  We describe each non-option ARGV-element
@@ -421,26 +426,26 @@ parse_args (argc, argv)
   for (i = 0; i < OPTION_COUNT; i++)
     {
       if (ld_options[i].shortopt != '\0')
-	{
-	  shortopts[is] = ld_options[i].shortopt;
-	  ++is;
-	  if (ld_options[i].opt.has_arg == required_argument
-	      || ld_options[i].opt.has_arg == optional_argument)
-	    {
-	      shortopts[is] = ':';
-	      ++is;
-	      if (ld_options[i].opt.has_arg == optional_argument)
-		{
-		  shortopts[is] = ':';
-		  ++is;
-		}
-	    }
-	}
+    {
+      shortopts[is] = ld_options[i].shortopt;
+      ++is;
+      if (ld_options[i].opt.has_arg == required_argument
+          || ld_options[i].opt.has_arg == optional_argument)
+        {
+          shortopts[is] = ':';
+          ++is;
+          if (ld_options[i].opt.has_arg == optional_argument)
+        {
+          shortopts[is] = ':';
+          ++is;
+        }
+        }
+    }
       if (ld_options[i].opt.name != NULL)
-	{
-	  longopts[il] = ld_options[i].opt;
-	  ++il;
-	}
+    {
+      longopts[il] = ld_options[i].opt;
+      ++il;
+    }
     }
   shortopts[is] = '\0';
   longopts[il].name = NULL;
@@ -458,8 +463,8 @@ parse_args (argc, argv)
      This will work for most normal cases.  */
   for (i = 1; i < argc; i++)
     if (strcmp (argv[i], "-G") == 0
-	&& (i + 1 >= argc
-	    || ! isdigit ((unsigned char) argv[i + 1][0])))
+    && (i + 1 >= argc
+        || ! isdigit ((unsigned char) argv[i + 1][0])))
       argv[i] = (char *) "--shared";
 
   /* Because we permit long options to start with a single dash, and
@@ -477,15 +482,15 @@ parse_args (argc, argv)
   for (i = 1; i < argc; i++)
     {
       if (argv[i][0] == '-'
-	  && argv[i][1] == 'l'
-	  && argv[i][2] != '\0')
-	{
-	  char *n;
-
-	  n = (char *) xmalloc (strlen (argv[i]) + 20);
-	  sprintf (n, "--library=%s", argv[i] + 2);
-	  argv[i] = n;
-	}
+      && argv[i][1] == 'l'
+      && argv[i][2] != '\0')
+    {
+      char *n;
+
+      n = (char *) xmalloc (strlen (argv[i]) + 20);
+      sprintf (n, "--library=%s", argv[i] + 2);
+      argv[i] = n;
+    }
     }
 
   last_optind = -1;
@@ -495,498 +500,532 @@ parse_args (argc, argv)
       int optc;
 
       /* Using last_optind lets us avoid calling ldemul_parse_args
-	 multiple times on a single option, which would lead to
-	 confusion in the internal static variables maintained by
-	 getopt.  This could otherwise happen for an argument like
-	 -nx, in which the -n is parsed as a single option, and we
-	 loop around to pick up the -x.  */
+     multiple times on a single option, which would lead to
+     confusion in the internal static variables maintained by
+     getopt.  This could otherwise happen for an argument like
+     -nx, in which the -n is parsed as a single option, and we
+     loop around to pick up the -x.  */
       if (optind != last_optind)
-	{
-	  if (ldemul_parse_args (argc, argv))
-	    continue;
-	  last_optind = optind;
-	}
+    {
+      if (ldemul_parse_args (argc, argv))
+        continue;
+      last_optind = optind;
+    }
 
       /* getopt_long_only is like getopt_long, but '-' as well as '--'
-	 can indicate a long option.  */
+     can indicate a long option.  */
       optc = getopt_long_only (argc, argv, shortopts, longopts, &longind);
 
       if (optc == -1)
-	break;
+    break;
       switch (optc)
-	{
-	default:
-	  fprintf (stderr,
-		   _("%s: use the --help option for usage information\n"),
-		   program_name);
-	  xexit (1);
-	case 1:			/* File name.  */
-	  lang_add_input_file (optarg, lang_input_file_is_file_enum,
-			       (char *) NULL);
-	  break;
-
-	case OPTION_IGNORE:
-	  break;
-	case 'a':
-	  /* For HP/UX compatibility.  Actually -a shared should mean
+    {
+    default:
+      fprintf (stderr,
+           _("%s: use the --help option for usage information\n"),
+           program_name);
+      xexit (1);
+    case 1:         /* File name.  */
+      lang_add_input_file (optarg, lang_input_file_is_file_enum,
+                   (char *) NULL);
+
+/* add T.Tazaki 2003/05/14 >>> */
+              /* Save Link Object file name table. for ELF header flag */
+            fpIn = fopen( optarg, "rb" );
+            if( fpIn != NULL )
+            {
+                fseek( fpIn, 39, SEEK_SET );
+                ucFlag = fgetc( fpIn );
+                if( ucFlag == 0x41 )    /* Advanced macro ? */
+                {
+/* >>>>> DELETED D.Fujimoto 2007/10/01 core macro link check moved to bfd/elf32-c33.c */
+//					if( g_iPE == 1 )	/* already link PE object file ? 	add T.Tazaki 2004/04/28 */
+//					{
+//						fprintf( stderr,"Warning: do not link Advanced macro object file and PE object file.\n" );
+//					}
+/* <<<<< DELETED D.Fujimoto 2007/10/01 core macro link check moved to bfd/elf32-c33.c */
+
+                    g_iAdvance = 1; /* on */
+                }
+                else if( ucFlag == 'P' )    /* PE macro ? 	add T.Tazaki 2003/11/18 */
+                {
+/* >>>>> DELETED D.Fujimoto 2007/10/01 core macro link check moved to bfd/elf32-c33.c */
+//					if( g_iAdvance == 1 )	/* already link Advanced object file ? 	add T.Tazaki 2004/04/28 */
+//					{
+//						fprintf( stderr,"Warning: do not link Advanced macro object file and PE object file.\n" );
+//					}
+/* <<<<< DELETED D.Fujimoto 2007/10/01 core macro link check moved to bfd/elf32-c33.c */
+
+                    g_iPE = 1; /* on */
+                }
+                fclose( fpIn );
+            }
+          break;
+/* add T.Tazaki 2003/05/14 <<< */
+      break;
+
+    case OPTION_IGNORE:
+      break;
+    case 'a':
+      /* For HP/UX compatibility.  Actually -a shared should mean
              ``use only shared libraries'' but, then, we don't
              currently support shared libraries on HP/UX anyhow.  */
-	  if (strcmp (optarg, "archive") == 0)
-	    config.dynamic_link = false;
-	  else if (strcmp (optarg, "shared") == 0
-		   || strcmp (optarg, "default") == 0)
-	    config.dynamic_link = true;
-	  else
-	    einfo (_("%P%F: unrecognized -a option `%s'\n"), optarg);
-	  break;
-	case OPTION_ASSERT:
-	  /* FIXME: We just ignore these, but we should handle them.  */
-	  if (strcmp (optarg, "definitions") == 0)
-	    ;
-	  else if (strcmp (optarg, "nodefinitions") == 0)
-	    ;
-	  else if (strcmp (optarg, "nosymbolic") == 0)
-	    ;
-	  else if (strcmp (optarg, "pure-text") == 0)
-	    ;
-	  else
-	    einfo (_("%P%F: unrecognized -assert option `%s'\n"), optarg);
-	  break;
-	case 'A':
-	  ldfile_add_arch (optarg);
-	  break;
-	case 'b':
-	  lang_add_target (optarg);
-	  break;
-	case 'c':
-	  ldfile_open_command_file (optarg);
-	  parser_input = input_mri_script;
-	  yyparse ();
-	  break;
-	case OPTION_CALL_SHARED:
-	  config.dynamic_link = true;
-	  break;
-	case OPTION_NON_SHARED:
-	  config.dynamic_link = false;
-	  break;
-	case OPTION_CREF:
-	  command_line.cref = true;
-	  link_info.notice_all = true;
-	  break;
-	case 'd':
-	  command_line.force_common_definition = true;
-	  break;
-	case OPTION_DEFSYM:
-	  lex_string = optarg;
-	  lex_redirect (optarg);
-	  parser_input = input_defsym;
-	  parsing_defsym = 1;
-	  yyparse ();
-	  parsing_defsym = 0;
-	  lex_string = NULL;
-	  break;
-	case OPTION_DEMANGLE:
-	  demangling = true;
-	  break;
-	case OPTION_DYNAMIC_LINKER:
-	  command_line.interpreter = optarg;
-	  break;
-	case OPTION_EB:
-	  command_line.endian = ENDIAN_BIG;
-	  break;
-	case OPTION_EL:
-	  command_line.endian = ENDIAN_LITTLE;
-	  break;
-	case OPTION_EMBEDDED_RELOCS:
-	  command_line.embedded_relocs = true;
-	  break;
-	case OPTION_EXPORT_DYNAMIC:
-	case 'E': /* HP/UX compatibility.  */
-	  command_line.export_dynamic = true;
-	  break;
-	case 'e':
-	  lang_add_entry (optarg, true);
-	  break;
-	case 'f':
-	  if (command_line.auxiliary_filters == NULL)
-	    {
-	      command_line.auxiliary_filters =
-		(char **) xmalloc (2 * sizeof (char *));
-	      command_line.auxiliary_filters[0] = optarg;
-	      command_line.auxiliary_filters[1] = NULL;
-	    }
-	  else
-	    {
-	      int c;
-	      char **p;
-
-	      c = 0;
-	      for (p = command_line.auxiliary_filters; *p != NULL; p++)
-		++c;
-	      command_line.auxiliary_filters =
-		(char **) xrealloc (command_line.auxiliary_filters,
-				    (c + 2) * sizeof (char *));
-	      command_line.auxiliary_filters[c] = optarg;
-	      command_line.auxiliary_filters[c + 1] = NULL;
-	    }
-	  break;
-	case 'F':
-	  command_line.filter_shlib = optarg;
-	  break;
-	case OPTION_FORCE_EXE_SUFFIX:
-	  command_line.force_exe_suffix = true;
-	  break;
-	case 'G':
-	  {
-	    char *end;
-	    g_switch_value = strtoul (optarg, &end, 0);
-	    if (*end)
-	      einfo (_("%P%F: invalid number `%s'\n"), optarg);
-	  }
-	  break;
-	case 'g':
-	  /* Ignore.  */
-	  break;
-	case OPTION_GC_SECTIONS:
-	  command_line.gc_sections = true;
-	  break;
-	case OPTION_HELP:
-	  help ();
-	  xexit (0);
-	  break;
-	case 'L':
-	  ldfile_add_library_path (optarg, true);
-	  break;
-	case 'l':
-	  lang_add_input_file (optarg, lang_input_file_is_l_enum,
-			       (char *) NULL);
-	  break;
-	case 'M':
-	  config.map_filename = "-";
-	  break;
-	case 'm':
-	  /* Ignore.  Was handled in a pre-parse.   */
-	  break;
-	case OPTION_MAP:
-	  config.map_filename = optarg;
-	  break;
-	case 'N':
-	  config.text_read_only = false;
-	  config.magic_demand_paged = false;
-	  config.dynamic_link = false;
-	  break;
-	case 'n':
-	  config.magic_demand_paged = false;
-	  config.dynamic_link = false;
-	  break;
-	case OPTION_NO_DEMANGLE:
-	  demangling = false;
-	  break;
-	case OPTION_NO_GC_SECTIONS:
-	  command_line.gc_sections = false;
-	  break;
-	case OPTION_NO_KEEP_MEMORY:
-	  link_info.keep_memory = false;
-	  break;
-	case OPTION_NO_UNDEFINED:
-	  link_info.no_undefined = true;
-	  break;
-	case OPTION_NO_WARN_MISMATCH:
-	  command_line.warn_mismatch = false;
-	  break;
-	case OPTION_NOINHIBIT_EXEC:
-	  force_make_executable = true;
-	  break;
-	case OPTION_NO_WHOLE_ARCHIVE:
-	  whole_archive = false;
-	  break;
-	case 'O':
-	  /* FIXME "-O<non-digits> <value>" used to set the address of
-	     section <non-digits>.  Was this for compatibility with
-	     something, or can we create a new option to do that
-	     (with a syntax similar to -defsym)?
-	     getopt can't handle two args to an option without kludges.  */
-
-	  /* Enable optimizations of output files.  */
-	  link_info.optimize = strtoul (optarg, NULL, 0) ? true : false;
-	  break;
-	case 'o':
-	  lang_add_output (optarg, 0); 
-	  break;
-	case OPTION_OFORMAT:
-	  lang_add_output_format (optarg, (char *) NULL, (char *) NULL, 0);
-	  break;
-	case 'i':
-	case 'r':
-	  link_info.relocateable = true;
-	  config.build_constructors = false;
-	  config.magic_demand_paged = false;
-	  config.text_read_only = false;
-	  config.dynamic_link = false;
-	  break;
-	case 'R':
-	  /* The GNU linker traditionally uses -R to mean to include
-	     only the symbols from a file.  The Solaris linker uses -R
-	     to set the path used by the runtime linker to find
-	     libraries.  This is the GNU linker -rpath argument.  We
-	     try to support both simultaneously by checking the file
-	     named.  If it is a directory, rather than a regular file,
-	     we assume -rpath was meant.  */
-	  {
-	    struct stat s;
-
-	    if (stat (optarg, &s) >= 0
-		&& ! S_ISDIR (s.st_mode))
-	      {
-		lang_add_input_file (optarg,
-				     lang_input_file_is_symbols_only_enum,
-				     (char *) NULL);
-		break;
-	      }
-	  }
-	  /* Fall through.  */
-	case OPTION_RPATH:
-	  if (command_line.rpath == NULL)
-	    command_line.rpath = buystring (optarg);
-	  else
-	    {
-	      size_t rpath_len = strlen (command_line.rpath);
-	      size_t optarg_len = strlen (optarg);
-	      char *buf;
-	      char *cp = command_line.rpath;
-
-	      /* First see whether OPTARG is already in the path.  */
-	      do
-		{
-		  size_t idx = 0;
-		  while (optarg[idx] != '\0' && optarg[idx] == cp[idx])
-		    ++idx;
-		  if (optarg[idx] == '\0'
-		      && (cp[idx] == '\0' || cp[idx] == ':'))
-		    /* We found it.  */
-		    break;
-
-		  /* Not yet found.  */
-		  cp = strchr (cp, ':');
-		  if (cp != NULL)
-		    ++cp;
-		}
-	      while (cp != NULL);
-
-	      if (cp == NULL)
-		{
-		  buf = xmalloc (rpath_len + optarg_len + 2);
-		  sprintf (buf, "%s:%s", command_line.rpath, optarg);
-		  free (command_line.rpath);
-		  command_line.rpath = buf;
-		}
-	    }
-	  break;
-	case OPTION_RPATH_LINK:
-	  if (command_line.rpath_link == NULL)
-	    command_line.rpath_link = buystring (optarg);
-	  else
-	    {
-	      char *buf;
-
-	      buf = xmalloc (strlen (command_line.rpath_link)
-			     + strlen (optarg)
-			     + 2);
-	      sprintf (buf, "%s:%s", command_line.rpath_link, optarg);
-	      free (command_line.rpath_link);
-	      command_line.rpath_link = buf;
-	    }
-	  break;
-	case OPTION_RELAX:
-	  command_line.relax = true;
-	  break;
-	case OPTION_RETAIN_SYMBOLS_FILE:
-	  add_keepsyms_file (optarg);
-	  break;
-	case 'S':
-	  link_info.strip = strip_debugger;
-	  break;
-	case 's':
-	  link_info.strip = strip_all;
-	  break;
-	case OPTION_SHARED:
-	  if (config.has_shared)
-	    link_info.shared = true;
-	  else
-	    einfo (_("%P%F: -shared not supported\n"));
-	  break;
-	case 'h':		/* Used on Solaris.  */
-	case OPTION_SONAME:
-	  command_line.soname = optarg;
-	  break;
-	case OPTION_SORT_COMMON:
-	  config.sort_common = true;
-	  break;
-	case OPTION_STATS:
-	  config.stats = true;
-	  break;
-	case OPTION_SYMBOLIC:
-	  link_info.symbolic = true;
-	  break;
-	case 't':
-	  trace_files = true;
-	  break;
-	case 'T':
-	  ldfile_open_command_file (optarg);
-	  parser_input = input_script;
-	  yyparse ();
-	  break;
-	case OPTION_TBSS:
-	  set_section_start (".bss", optarg);
-	  break;
-	case OPTION_TDATA:
-	  set_section_start (".data", optarg);
-	  break;
-	case OPTION_TTEXT:
-	  set_section_start (".text", optarg);
-	  break;
-	case OPTION_TRADITIONAL_FORMAT:
-	  link_info.traditional_format = true;
-	  break;
-	case OPTION_TASK_LINK:
-	  link_info.task_link = true;
-	  /* Fall through - do an implied -r option.  */
-	case OPTION_UR:
-	  link_info.relocateable = true;
-	  config.build_constructors = true;
-	  config.magic_demand_paged = false;
-	  config.text_read_only = false;
-	  config.dynamic_link = false;
-	  break;
-	case 'u':
-	  ldlang_add_undef (optarg);
-	  break;
-	case OPTION_VERBOSE:
-	  ldversion (1);
-	  version_printed = true;
-	  trace_file_tries = true;
-	  break;
-	case 'v':
-	  ldversion (0);
-	  version_printed = true;
-	  break;
-	case 'V':
-	  ldversion (1);
-	  version_printed = true;
-	  break;
-	case OPTION_VERSION:
-	  /* This output is intended to follow the GNU standards document.  */
-	  printf ("GNU ld %s\n", ld_program_version);
-	  printf (_("Copyright 2000 Free Software Foundation, Inc.\n"));
-	  printf (_("\
+      if (strcmp (optarg, "archive") == 0)
+        config.dynamic_link = false;
+      else if (strcmp (optarg, "shared") == 0
+           || strcmp (optarg, "default") == 0)
+        config.dynamic_link = true;
+      else
+        einfo (_("%P%F: unrecognized -a option `%s'\n"), optarg);
+      break;
+    case OPTION_ASSERT:
+      /* FIXME: We just ignore these, but we should handle them.  */
+      if (strcmp (optarg, "definitions") == 0)
+        ;
+      else if (strcmp (optarg, "nodefinitions") == 0)
+        ;
+      else if (strcmp (optarg, "nosymbolic") == 0)
+        ;
+      else if (strcmp (optarg, "pure-text") == 0)
+        ;
+      else
+        einfo (_("%P%F: unrecognized -assert option `%s'\n"), optarg);
+      break;
+    case 'A':
+      ldfile_add_arch (optarg);
+      break;
+    case 'b':
+      lang_add_target (optarg);
+      break;
+    case 'c':
+      ldfile_open_command_file (optarg);
+      parser_input = input_mri_script;
+      yyparse ();
+      break;
+    case OPTION_CALL_SHARED:
+      config.dynamic_link = true;
+      break;
+    case OPTION_NON_SHARED:
+      config.dynamic_link = false;
+      break;
+    case OPTION_CREF:
+      command_line.cref = true;
+      link_info.notice_all = true;
+      break;
+    case 'd':
+      command_line.force_common_definition = true;
+      break;
+    case OPTION_DEFSYM:
+      lex_string = optarg;
+      lex_redirect (optarg);
+      parser_input = input_defsym;
+      parsing_defsym = 1;
+      yyparse ();
+      parsing_defsym = 0;
+      lex_string = NULL;
+      break;
+    case OPTION_DEMANGLE:
+      demangling = true;
+      break;
+    case OPTION_DYNAMIC_LINKER:
+      command_line.interpreter = optarg;
+      break;
+    case OPTION_EB:
+      command_line.endian = ENDIAN_BIG;
+      break;
+    case OPTION_EL:
+      command_line.endian = ENDIAN_LITTLE;
+      break;
+    case OPTION_EMBEDDED_RELOCS:
+      command_line.embedded_relocs = true;
+      break;
+    case OPTION_EXPORT_DYNAMIC:
+    case 'E': /* HP/UX compatibility.  */
+      command_line.export_dynamic = true;
+      break;
+    case 'e':
+      lang_add_entry (optarg, true);
+      break;
+    case 'f':
+      if (command_line.auxiliary_filters == NULL)
+        {
+          command_line.auxiliary_filters =
+        (char **) xmalloc (2 * sizeof (char *));
+          command_line.auxiliary_filters[0] = optarg;
+          command_line.auxiliary_filters[1] = NULL;
+        }
+      else
+        {
+          int c;
+          char **p;
+
+          c = 0;
+          for (p = command_line.auxiliary_filters; *p != NULL; p++)
+        ++c;
+          command_line.auxiliary_filters =
+        (char **) xrealloc (command_line.auxiliary_filters,
+                    (c + 2) * sizeof (char *));
+          command_line.auxiliary_filters[c] = optarg;
+          command_line.auxiliary_filters[c + 1] = NULL;
+        }
+      break;
+    case 'F':
+      command_line.filter_shlib = optarg;
+      break;
+    case OPTION_FORCE_EXE_SUFFIX:
+      command_line.force_exe_suffix = true;
+      break;
+    case 'G':
+      {
+        char *end;
+        g_switch_value = strtoul (optarg, &end, 0);
+        if (*end)
+          einfo (_("%P%F: invalid number `%s'\n"), optarg);
+      }
+      break;
+    case 'g':
+      /* Ignore.  */
+      break;
+    case OPTION_GC_SECTIONS:
+      command_line.gc_sections = true;
+      break;
+    case OPTION_HELP:
+      help ();
+      xexit (0);
+      break;
+    case 'L':
+      ldfile_add_library_path (optarg, true);
+      break;
+    case 'l':
+      lang_add_input_file (optarg, lang_input_file_is_l_enum,
+                   (char *) NULL);
+      break;
+    case 'M':
+      config.map_filename = "-";
+      break;
+    case 'm':
+      /* Ignore.  Was handled in a pre-parse.   */
+      break;
+    case OPTION_MAP:
+      config.map_filename = optarg;
+      break;
+    case 'N':
+      config.text_read_only = false;
+      config.magic_demand_paged = false;
+      config.dynamic_link = false;
+      break;
+    case 'n':
+      config.magic_demand_paged = false;
+      config.dynamic_link = false;
+      break;
+    case OPTION_NO_DEMANGLE:
+      demangling = false;
+      break;
+    case OPTION_NO_GC_SECTIONS:
+      command_line.gc_sections = false;
+      break;
+    case OPTION_NO_KEEP_MEMORY:
+      link_info.keep_memory = false;
+      break;
+    case OPTION_NO_UNDEFINED:
+      link_info.no_undefined = true;
+      break;
+    case OPTION_NO_WARN_MISMATCH:
+      command_line.warn_mismatch = false;
+      break;
+    case OPTION_NOINHIBIT_EXEC:
+      force_make_executable = true;
+      break;
+    case OPTION_NO_WHOLE_ARCHIVE:
+      whole_archive = false;
+      break;
+    case 'O':
+      /* FIXME "-O<non-digits> <value>" used to set the address of
+         section <non-digits>.  Was this for compatibility with
+         something, or can we create a new option to do that
+         (with a syntax similar to -defsym)?
+         getopt can't handle two args to an option without kludges.  */
+
+      /* Enable optimizations of output files.  */
+      link_info.optimize = strtoul (optarg, NULL, 0) ? true : false;
+      break;
+    case 'o':
+      lang_add_output (optarg, 0); 
+      break;
+    case OPTION_OFORMAT:
+      lang_add_output_format (optarg, (char *) NULL, (char *) NULL, 0);
+      break;
+    case 'i':
+    case 'r':
+      link_info.relocateable = true;
+      config.build_constructors = false;
+      config.magic_demand_paged = false;
+      config.text_read_only = false;
+      config.dynamic_link = false;
+      break;
+    case 'R':
+      /* The GNU linker traditionally uses -R to mean to include
+         only the symbols from a file.  The Solaris linker uses -R
+         to set the path used by the runtime linker to find
+         libraries.  This is the GNU linker -rpath argument.  We
+         try to support both simultaneously by checking the file
+         named.  If it is a directory, rather than a regular file,
+         we assume -rpath was meant.  */
+      {
+        struct stat s;
+
+        if (stat (optarg, &s) >= 0
+        && ! S_ISDIR (s.st_mode))
+          {
+        lang_add_input_file (optarg,
+                     lang_input_file_is_symbols_only_enum,
+                     (char *) NULL);
+        break;
+          }
+      }
+      /* Fall through.  */
+    case OPTION_RPATH:
+      if (command_line.rpath == NULL)
+        command_line.rpath = buystring (optarg);
+      else
+        {
+          size_t rpath_len = strlen (command_line.rpath);
+          size_t optarg_len = strlen (optarg);
+          char *buf;
+          char *cp = command_line.rpath;
+
+          /* First see whether OPTARG is already in the path.  */
+          do
+        {
+          size_t idx = 0;
+          while (optarg[idx] != '\0' && optarg[idx] == cp[idx])
+            ++idx;
+          if (optarg[idx] == '\0'
+              && (cp[idx] == '\0' || cp[idx] == ':'))
+            /* We found it.  */
+            break;
+
+          /* Not yet found.  */
+          cp = strchr (cp, ':');
+          if (cp != NULL)
+            ++cp;
+        }
+          while (cp != NULL);
+
+          if (cp == NULL)
+        {
+          buf = xmalloc (rpath_len + optarg_len + 2);
+          sprintf (buf, "%s:%s", command_line.rpath, optarg);
+          free (command_line.rpath);
+          command_line.rpath = buf;
+        }
+        }
+      break;
+    case OPTION_RPATH_LINK:
+      if (command_line.rpath_link == NULL)
+        command_line.rpath_link = buystring (optarg);
+      else
+        {
+          char *buf;
+
+          buf = xmalloc (strlen (command_line.rpath_link)
+                 + strlen (optarg)
+                 + 2);
+          sprintf (buf, "%s:%s", command_line.rpath_link, optarg);
+          free (command_line.rpath_link);
+          command_line.rpath_link = buf;
+        }
+      break;
+    case OPTION_RELAX:
+      command_line.relax = true;
+      break;
+    case OPTION_RETAIN_SYMBOLS_FILE:
+      add_keepsyms_file (optarg);
+      break;
+    case 'S':
+      link_info.strip = strip_debugger;
+      break;
+    case 's':
+      link_info.strip = strip_all;
+      break;
+    case OPTION_SHARED:
+      if (config.has_shared)
+        link_info.shared = true;
+      else
+        einfo (_("%P%F: -shared not supported\n"));
+      break;
+    case 'h':       /* Used on Solaris.  */
+    case OPTION_SONAME:
+      command_line.soname = optarg;
+      break;
+    case OPTION_SORT_COMMON:
+      config.sort_common = true;
+      break;
+    case OPTION_STATS:
+      config.stats = true;
+      break;
+    case OPTION_SYMBOLIC:
+      link_info.symbolic = true;
+      break;
+    case 't':
+      trace_files = true;
+      break;
+    case 'T':
+      ldfile_open_command_file (optarg);
+      parser_input = input_script;
+      yyparse ();
+      break;
+    case OPTION_TBSS:
+      set_section_start (".bss", optarg);
+      break;
+    case OPTION_TDATA:
+      set_section_start (".data", optarg);
+      break;
+    case OPTION_TTEXT:
+      set_section_start (".text", optarg);
+      break;
+    case OPTION_TRADITIONAL_FORMAT:
+      link_info.traditional_format = true;
+      break;
+    case OPTION_TASK_LINK:
+      link_info.task_link = true;
+      /* Fall through - do an implied -r option.  */
+    case OPTION_UR:
+      link_info.relocateable = true;
+      config.build_constructors = true;
+      config.magic_demand_paged = false;
+      config.text_read_only = false;
+      config.dynamic_link = false;
+      break;
+    case 'u':
+      ldlang_add_undef (optarg);
+      break;
+    case OPTION_VERBOSE:
+      ldversion (1);
+      version_printed = true;
+      trace_file_tries = true;
+      break;
+    case 'v':
+      ldversion (0);
+      version_printed = true;
+      break;
+    case 'V':
+      ldversion (1);
+      version_printed = true;
+      break;
+    case OPTION_VERSION:
+      /* This output is intended to follow the GNU standards document.  */
+      printf ("GNU ld %s\n", ld_program_version);
+      printf (_("Copyright 2000 Free Software Foundation, Inc.\n"));
+      printf (_("\
 This program is free software; you may redistribute it under the terms of\n\
 the GNU General Public License.  This program has absolutely no warranty.\n"));
-	  {
-	    ld_emulation_xfer_type **ptr = ld_emulations;
+      {
+        ld_emulation_xfer_type **ptr = ld_emulations;
     
-	    printf (_("  Supported emulations:\n"));
-	    while (*ptr) 
-	      {
-		printf ("   %s\n", (*ptr)->emulation_name);
-		ptr++;
-	      }
-	  }
-	  xexit (0);
-	  break;
-	case OPTION_VERSION_SCRIPT:
-	  /* This option indicates a small script that only specifies
+        printf (_("  Supported emulations:\n"));
+        while (*ptr) 
+          {
+        printf ("   %s\n", (*ptr)->emulation_name);
+        ptr++;
+          }
+      }
+      xexit (0);
+      break;
+    case OPTION_VERSION_SCRIPT:
+      /* This option indicates a small script that only specifies
              version information.  Read it, but don't assume that
              we've seen a linker script.  */
-	  {
-	    boolean hold_had_script;
-
-	    hold_had_script = had_script;
-	    ldfile_open_command_file (optarg);
-	    had_script = hold_had_script;
-	    parser_input = input_version_script;
-	    yyparse ();
-	  }
-	  break;
-	case OPTION_VERSION_EXPORTS_SECTION:
-	  /* This option records a version symbol to be applied to the
-	     symbols listed for export to be found in the object files
-	     .exports sections.  */
-	  command_line.version_exports_section = optarg;
-	  break;
-	case OPTION_WARN_COMMON:
-	  config.warn_common = true;
-	  break;
-	case OPTION_WARN_CONSTRUCTORS:
-	  config.warn_constructors = true;
-	  break;
-	case OPTION_WARN_MULTIPLE_GP:
-	  config.warn_multiple_gp = true;
-	  break;
-	case OPTION_WARN_ONCE:
-	  config.warn_once = true;
-	  break;
-	case OPTION_WARN_SECTION_ALIGN:
-	  config.warn_section_align = true;
-	  break;
-	case OPTION_WHOLE_ARCHIVE:
-	  whole_archive = true;
-	  break;
-	case OPTION_WRAP:
-	  add_wrap (optarg);
-	  break;
-	case 'X':
-	  link_info.discard = discard_l;
-	  break;
-	case 'x':
-	  link_info.discard = discard_all;
-	  break;
-	case 'Y':
-	  if (strncmp (optarg, "P,", 2) == 0)
-	    optarg += 2;
-	  default_dirlist = xstrdup (optarg);
-	  break;
-	case 'y':
-	  add_ysym (optarg);
-	  break;
-	case 'z':
-	  /* We accept and ignore this option for Solaris
+      {
+        boolean hold_had_script;
+
+        hold_had_script = had_script;
+        ldfile_open_command_file (optarg);
+        had_script = hold_had_script;
+        parser_input = input_version_script;
+        yyparse ();
+      }
+      break;
+    case OPTION_VERSION_EXPORTS_SECTION:
+      /* This option records a version symbol to be applied to the
+         symbols listed for export to be found in the object files
+         .exports sections.  */
+      command_line.version_exports_section = optarg;
+      break;
+    case OPTION_WARN_COMMON:
+      config.warn_common = true;
+      break;
+    case OPTION_WARN_CONSTRUCTORS:
+      config.warn_constructors = true;
+      break;
+    case OPTION_WARN_MULTIPLE_GP:
+      config.warn_multiple_gp = true;
+      break;
+    case OPTION_WARN_ONCE:
+      config.warn_once = true;
+      break;
+    case OPTION_WARN_SECTION_ALIGN:
+      config.warn_section_align = true;
+      break;
+    case OPTION_WHOLE_ARCHIVE:
+      whole_archive = true;
+      break;
+    case OPTION_WRAP:
+      add_wrap (optarg);
+      break;
+    case 'X':
+      link_info.discard = discard_l;
+      break;
+    case 'x':
+      link_info.discard = discard_all;
+      break;
+    case 'Y':
+      if (strncmp (optarg, "P,", 2) == 0)
+        optarg += 2;
+      default_dirlist = xstrdup (optarg);
+      break;
+    case 'y':
+      add_ysym (optarg);
+      break;
+    case 'z':
+      /* We accept and ignore this option for Solaris
              compatibility.  Actually, on Solaris, optarg is not
              ignored.  Someday we should handle it correctly.  FIXME.  */
-	  break;
-	case OPTION_SPLIT_BY_RELOC:
-	  config.split_by_reloc = strtoul (optarg, NULL, 0);
-	  break; 
-	case OPTION_SPLIT_BY_FILE:
-	  config.split_by_file = true;
-	  break; 
-	case OPTION_CHECK_SECTIONS:
-	  command_line.check_section_addresses = true;
-	  break;
-	case OPTION_NO_CHECK_SECTIONS:
-	  command_line.check_section_addresses = false;
-	  break;
-	case '(':
-	  if (ingroup)
-	    {
-	      fprintf (stderr,
-		       _("%s: may not nest groups (--help for usage)\n"),
-		       program_name);
-	      xexit (1);
-	    }
-	  lang_enter_group ();
-	  ingroup = 1;
-	  break;
-	case ')':
-	  if (! ingroup)
-	    {
-	      fprintf (stderr,
-		       _("%s: group ended before it began (--help for usage)\n"),
-		       program_name);
-	      xexit (1);
-	    }
-	  lang_leave_group ();
-	  ingroup = 0;
-	  break;
+      break;
+    case OPTION_SPLIT_BY_RELOC:
+      config.split_by_reloc = strtoul (optarg, NULL, 0);
+      break; 
+    case OPTION_SPLIT_BY_FILE:
+      config.split_by_file = true;
+      break; 
+    case OPTION_CHECK_SECTIONS:
+      command_line.check_section_addresses = true;
+      break;
+    case OPTION_NO_CHECK_SECTIONS:
+      command_line.check_section_addresses = false;
+      break;
+    case '(':
+      if (ingroup)
+        {
+          fprintf (stderr,
+               _("%s: may not nest groups (--help for usage)\n"),
+               program_name);
+          xexit (1);
+        }
+      lang_enter_group ();
+      ingroup = 1;
+      break;
+    case ')':
+      if (! ingroup)
+        {
+          fprintf (stderr,
+               _("%s: group ended before it began (--help for usage)\n"),
+               program_name);
+          xexit (1);
+        }
+      lang_leave_group ();
+      ingroup = 0;
+      break;
       case OPTION_MPC860C0:
           link_info.mpc860c0 = 20;      /* default value (in bytes) */
           if (optarg)
@@ -997,8 +1036,8 @@ the GNU General Public License.  This program has absolutely no warranty.\n"));
               if (words == 0)
                 {
                   fprintf (stderr,
-			   _("%s: Invalid argument to option \"mpc860c0\"\n"),
-			   program_name);
+               _("%s: Invalid argument to option \"mpc860c0\"\n"),
+               program_name);
                   xexit (1);
                 }
               link_info.mpc860c0 = words * 4;   /* convert words to bytes */
@@ -1006,14 +1045,14 @@ the GNU General Public License.  This program has absolutely no warranty.\n"));
           command_line.relax = true;
           break;
 
-	case OPTION_INIT:
-	  link_info.init_function = optarg;
-	  break;
-	  
-	case OPTION_FINI:
-	  link_info.fini_function = optarg;
-	  break;
-	}
+    case OPTION_INIT:
+      link_info.init_function = optarg;
+      break;
+      
+    case OPTION_FINI:
+      link_info.fini_function = optarg;
+      break;
+    }
     }
 
   if (ingroup)
@@ -1037,11 +1076,11 @@ set_default_dirlist (dirlist_ptr)
     {
       p = strchr (dirlist_ptr, PATH_SEPARATOR);
       if (p != NULL)
-	*p = '\0';
+    *p = '\0';
       if (*dirlist_ptr != '\0')
-	ldfile_add_library_path (dirlist_ptr, true);
+    ldfile_add_library_path (dirlist_ptr, true);
       if (p == NULL)
-	break;
+    break;
       dirlist_ptr = p + 1;
     }
 }
@@ -1071,76 +1110,76 @@ help ()
   for (i = 0; i < OPTION_COUNT; i++)
     {
       if (ld_options[i].doc != NULL)
-	{
-	  boolean comma;
-	  int len;
-	  int j;
-
-	  printf ("  ");
-
-	  comma = false;
-	  len = 2;
-
-	  j = i;
-	  do
-	    {
-	      if (ld_options[j].shortopt != '\0'
-		  && ld_options[j].control != NO_HELP)
-		{
-		  printf ("%s-%c", comma ? ", " : "", ld_options[j].shortopt);
-		  len += (comma ? 2 : 0) + 2;
-		  if (ld_options[j].arg != NULL)
-		    {
-		      if (ld_options[j].opt.has_arg != optional_argument)
-			{
-			  printf (" ");
-			  ++len;
-			}
-		      printf ("%s", _(ld_options[j].arg));
-		      len += strlen (_(ld_options[j].arg));
-		    }
-		  comma = true;
-		}
-	      ++j;
-	    }
-	  while (j < OPTION_COUNT && ld_options[j].doc == NULL);
-
-	  j = i;
-	  do
-	    {
-	      if (ld_options[j].opt.name != NULL
-		  && ld_options[j].control != NO_HELP)
-		{
-		  printf ("%s-%s%s",
-			  comma ? ", " : "",
-			  ld_options[j].control == TWO_DASHES ? "-" : "",
-			  ld_options[j].opt.name);
-		  len += ((comma ? 2 : 0)
-			  + 1
-			  + (ld_options[j].control == TWO_DASHES ? 1 : 0)
-			  + strlen (ld_options[j].opt.name));
-		  if (ld_options[j].arg != NULL)
-		    {
-		      printf (" %s", _(ld_options[j].arg));
-		      len += 1 + strlen (_(ld_options[j].arg));
-		    }
-		  comma = true;
-		}
-	      ++j;
-	    }
-	  while (j < OPTION_COUNT && ld_options[j].doc == NULL);
-
-	  if (len >= 30)
-	    {
-	      printf ("\n");
-	      len = 0;
-	    }
-
-	  for (; len < 30; len++)
-	    putchar (' ');
-
-	  printf ("%s\n", _(ld_options[i].doc));
-	}
+    {
+      boolean comma;
+      int len;
+      int j;
+
+      printf ("  ");
+
+      comma = false;
+      len = 2;
+
+      j = i;
+      do
+        {
+          if (ld_options[j].shortopt != '\0'
+          && ld_options[j].control != NO_HELP)
+        {
+          printf ("%s-%c", comma ? ", " : "", ld_options[j].shortopt);
+          len += (comma ? 2 : 0) + 2;
+          if (ld_options[j].arg != NULL)
+            {
+              if (ld_options[j].opt.has_arg != optional_argument)
+            {
+              printf (" ");
+              ++len;
+            }
+              printf ("%s", _(ld_options[j].arg));
+              len += strlen (_(ld_options[j].arg));
+            }
+          comma = true;
+        }
+          ++j;
+        }
+      while (j < OPTION_COUNT && ld_options[j].doc == NULL);
+
+      j = i;
+      do
+        {
+          if (ld_options[j].opt.name != NULL
+          && ld_options[j].control != NO_HELP)
+        {
+          printf ("%s-%s%s",
+              comma ? ", " : "",
+              ld_options[j].control == TWO_DASHES ? "-" : "",
+              ld_options[j].opt.name);
+          len += ((comma ? 2 : 0)
+              + 1
+              + (ld_options[j].control == TWO_DASHES ? 1 : 0)
+              + strlen (ld_options[j].opt.name));
+          if (ld_options[j].arg != NULL)
+            {
+              printf (" %s", _(ld_options[j].arg));
+              len += 1 + strlen (_(ld_options[j].arg));
+            }
+          comma = true;
+        }
+          ++j;
+        }
+      while (j < OPTION_COUNT && ld_options[j].doc == NULL);
+
+      if (len >= 30)
+        {
+          printf ("\n");
+          len = 0;
+        }
+
+      for (; len < 30; len++)
+        putchar (' ');
+
+      printf ("%s\n", _(ld_options[i].doc));
+    }
     }
 
   /* Note: Various tools (such as libtool) depend upon the
diff --git a/ld/scripttempl/c33.sc b/ld/scripttempl/c33.sc
new file mode 100644
index 0000000..add0cc4
--- /dev/null
+++ b/ld/scripttempl/c33.sc
@@ -0,0 +1,98 @@
+cat << EOF
+/*=======================================================================
+
+	c33 ld default linker script
+
+	2002.02.28	start				T.Tazaki
+
+=========================================================================*/
+OUTPUT_FORMAT("elf32-c33", "elf32-c33",
+	      "elf32-c33")
+OUTPUT_ARCH(c33)
+SEARCH_DIR(.);
+SECTIONS
+{
+
+    __dp = 0x0;
+
+    . = 0x0;	
+	.comm  : { *(.comm) }
+        .bss   : { *(.bss)  }
+	.data  : { *(.data) }
+
+    . = 0xc00000;
+	.text   : { *(.text) }
+        .rodata : { *(.rodata) }
+
+  /* Read-only sections, merged into text segment: */
+  .interp	: { *(.interp) }
+  .hash		: { *(.hash) }
+  .dynsym	: { *(.dynsym) }
+  .dynstr	: { *(.dynstr) }
+  .rel.text	: { *(.rel.text) }
+  .rela.text	: { *(.rela.text) }
+  .rel.data	: { *(.rel.data) }
+  .rela.data	: { *(.rela.data) }
+  .rel.rodata	: { *(.rel.rodata) }
+  .rela.rodata	: { *(.rela.rodata) }
+  .rel.got	: { *(.rel.got) }
+  .rela.got	: { *(.rela.got) }
+  .rel.ctors	: { *(.rel.ctors) }
+  .rela.ctors	: { *(.rela.ctors) }
+  .rel.dtors	: { *(.rel.dtors) }
+  .rela.dtors	: { *(.rela.dtors) }
+  .rel.init	: { *(.rel.init) }
+  .rela.init	: { *(.rela.init) }
+  .rel.fini	: { *(.rel.fini) }
+  .rela.fini	: { *(.rela.fini) }
+  .rel.bss	: { *(.rel.bss) }
+  .rela.bss	: { *(.rela.bss) }
+  .rel.plt	: { *(.rel.plt) }
+  .rela.plt	: { *(.rela.plt) }
+  .init		: { KEEP (*(.init)) } =0
+  .plt		: { *(.plt) }
+
+
+  /* Stabs debugging sections.  */
+  .stab 0		: { *(.stab) }
+  .stabstr 0		: { *(.stabstr) }
+  .stab.excl 0		: { *(.stab.excl) }
+  .stab.exclstr 0	: { *(.stab.exclstr) }
+  .stab.index 0		: { *(.stab.index) }
+  .stab.indexstr 0	: { *(.stab.indexstr) }
+  .comment 0		: { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0	: { *(.debug) }
+  .line           0	: { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0	: { *(.debug_srcinfo) }
+  .debug_sfnames  0	: { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0	: { *(.debug_aranges) }
+  .debug_pubnames 0	: { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0	: { *(.debug_info) }
+  .debug_abbrev   0	: { *(.debug_abbrev) }
+  .debug_line     0	: { *(.debug_line) }
+  .debug_frame    0	: { *(.debug_frame) }
+  .debug_str      0	: { *(.debug_str) }
+  .debug_loc      0	: { *(.debug_loc) }
+  .debug_macinfo  0	: { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0	: { *(.debug_weaknames) }
+  .debug_funcnames 0	: { *(.debug_funcnames) }
+  .debug_typenames 0	: { *(.debug_typenames) }
+  .debug_varnames  0	: { *(.debug_varnames) }
+
+  /* These must appear regardless of  .  */
+}
+EOF
diff --git a/opcodes/Makefile.am b/opcodes/Makefile.am
index 77beb4d..27bb95f 100644
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -85,6 +85,8 @@ CFILES = \
 	tic80-opc.c \
 	v850-dis.c \
 	v850-opc.c \
+	c33-dis.c \
+	c33-opc.c \
 	vax-dis.c \
 	w65-dis.c \
 	z8k-dis.c \
@@ -145,6 +147,8 @@ ALL_MACHINES = \
 	tic30-dis.lo \
 	tic80-dis.lo \
 	tic80-opc.lo \
+	c33-dis.lo \
+	c33-opc.lo \
 	v850-dis.lo \
 	v850-opc.lo \
 	vax-dis.lo \
@@ -370,6 +374,10 @@ v850-dis.lo: v850-dis.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/v850.h \
   $(INCDIR)/dis-asm.h $(BFD_H) opintl.h
 v850-opc.lo: v850-opc.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/v850.h \
   opintl.h
+c33-dis.lo: c33-dis.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/c33.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) opintl.h
+c33-opc.lo: c33-opc.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/c33.h \
+  opintl.h
 vax-dis.lo: vax-dis.c $(INCDIR)/opcode/vax.h $(INCDIR)/dis-asm.h \
   $(BFD_H) $(INCDIR)/ansidecl.h
 w65-dis.lo: w65-dis.c w65-opc.h $(INCDIR)/dis-asm.h \
diff --git a/opcodes/Makefile.in b/opcodes/Makefile.in
index 0cf1c27..5f1fe32 100644
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -189,6 +189,8 @@ CFILES = \
 	tic80-opc.c \
 	v850-dis.c \
 	v850-opc.c \
+	c33-dis.c \
+	c33-opc.c \
 	vax-dis.c \
 	w65-dis.c \
 	z8k-dis.c \
@@ -252,6 +254,8 @@ ALL_MACHINES = \
 	tic80-opc.lo \
 	v850-dis.lo \
 	v850-opc.lo \
+	c33-dis.lo \
+	c33-opc.lo \
 	vax-dis.lo \
 	w65-dis.lo \
 	z8k-dis.lo
@@ -867,6 +871,10 @@ v850-dis.lo: v850-dis.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/v850.h \
   $(INCDIR)/dis-asm.h $(BFD_H) opintl.h
 v850-opc.lo: v850-opc.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/v850.h \
   opintl.h
+c33-dis.lo: c33-dis.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/c33.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) opintl.h
+c33-opc.lo: c33-opc.c $(INCDIR)/ansidecl.h $(INCDIR)/opcode/c33.h \
+  opintl.h
 vax-dis.lo: vax-dis.c $(INCDIR)/opcode/vax.h $(INCDIR)/dis-asm.h \
   $(BFD_H) $(INCDIR)/ansidecl.h
 w65-dis.lo: w65-dis.c w65-opc.h $(INCDIR)/dis-asm.h \
diff --git a/opcodes/c33-dis.c b/opcodes/c33-dis.c
new file mode 100644
index 0000000..699bc22
--- /dev/null
+++ b/opcodes/c33-dis.c
@@ -0,0 +1,2824 @@
+/* Disassemble V850 instructions.
+   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+
+#include <stdio.h>
+
+#include "sysdep.h"
+#include "opcode/c33.h" 
+#include "dis-asm.h"
+#include "opintl.h"
+
+static const char *const c33_reg_names[] =
+{ "%r0", "%r1", "%r2", "%r3", "%r4", "%r5", "%r6", "%r7", 
+  "%r8", "%r9", "%r10", "%r11", "%r12", "%r13", "%r14", "%r15", 
+};
+
+static const char *const c33_sreg_names[] =		/* add "idir,dbg__base" T.Tazaki 2003/11/18 */
+{ "%psr","%sp", "%alr", "%ahr", "%lco", "%lsa", "%lea", "%sor", "%ttbr", "%dp","%idir","%dbbr","","%usp", "%ssp", "%pc" };
+
+/* add tazaki 2001.09.12 >>>>> */
+
+/******* type definiton ******/
+typedef char    INT8;
+typedef short   INT16;
+typedef long    INT32;
+typedef unsigned char   UINT8;
+typedef unsigned short  UINT16;
+typedef unsigned long   UINT32;
+typedef unsigned long   ADDR;
+
+#define NO_ERR      0
+#define ERR         2
+#define ERR2        3
+#define QUIT		100 /* add D.Fujimoto 2007/10/17 */
+
+#define BIT0    0x01
+#define BIT1    0x02
+#define BIT2    0x04
+#define BIT3    0x08
+#define BIT4    0x10
+#define BIT5    0x20
+#define BIT6    0x40
+#define BIT7    0x80
+#define BIT8    0x100
+#define BIT9    0x200
+#define BIT10   0x400
+#define BIT11   0x800
+#define BIT12   0x1000
+#define BIT13   0x2000
+#define BIT14   0x4000
+#define BIT15   0x8000
+#define BIT16   0x10000
+#define BIT17   0x20000
+#define BIT18   0x40000
+#define BIT19   0x80000
+#define BIT20   0x100000
+#define BIT21   0x200000
+#define BIT22   0x400000
+#define BIT23   0x800000
+#define BIT24   0x1000000
+#define BIT25   0x2000000
+#define BIT26   0x4000000
+#define BIT27   0x8000000
+#define BIT28   0x10000000
+#define BIT29   0x20000000
+#define BIT30   0x40000000
+#define BIT31   0x80000000
+
+#define YES                 1
+#define NO                  0
+
+#define  CLASS_MASK  0xE000
+#define  CLASS0      0x0000
+#define  CLASS1      0x2000
+#define  CLASS2      0x4000
+#define  CLASS3      0x6000
+#define  CLASS5      0xA000
+#define  CLASS6      0xC000
+#define  CLASS7      0xE000 /* add tazaki 2001.09.19 */
+#define  CLASS6_DATA 0x1fff
+#define  EXT1        1
+#define  EXT2        2
+#define  EXT3        3
+#define  CALC1       10
+#define  CALC2       20
+#define  CALC3_BYTE  31
+#define  CALC3_HALF  32
+#define  CALC3_WORD  33
+#define  CALC4       40
+#define  CALC5       50
+
+#define  MASK1_0     0x3
+#define  MASK7_0     0xff
+#define  MASK9_4     0x3f0
+#define  MASK9_5     0x3e0
+#define  MASK9_6     0x3c0
+#define  MASK12_0    0x1fff
+#define  MASK12_3    0x1ff8
+#define  MASK31_6    0xffffffc0
+#define  MASK31_9    0xfffffe00
+#define  MASK31_19   0xfff80000
+#define  MASK31_22   0xffc00000
+
+/* #define  DEBUG33     1 */
+
+/* >>>>> D.Fujimoto 2007/10/04 string buffer size for objdump output */
+#define DUMP_OUTPUT_BUF_SIZE 512
+#define SYMBOL_NAME_BUF_SIZE	256
+/* <<<<< D.Fujimoto 2007/10/04 string buffer size for objdump output */
+
+/* >>>>> D.Fujimoto 2007/10/04 declare prototypes */
+static UINT8
+fnCrGetExtType(UINT32 ulCode,int *iExtType, int *iCalcType);
+static UINT32
+fnCrCalcImmVal(int nExtInst, int iCalcType, UINT32 ulExt1, UINT32 ulExt2, UINT32 ulCode);
+static UINT8
+fnCrGetXinst(UINT32 ulCode, UINT32 ulImmVal,int iExtType, ADDR tdAddr, INT8 *szXinst, int iArraySize, INT8 *szTmp, int iExtCnt, struct disassemble_info *info);
+static void
+vfnDisasm (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass0 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass1 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass2 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass3 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass4 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass5 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass6 (unsigned short uwCode, char *pszBuf);
+static void
+vfnDisasmClass7 (unsigned short uwCode, char *pszBuf);
+/* <<<<< D.Fujimoto 2007/10/04 declare prototypes */
+
+static int  g_iExtCnt = 0;
+static int  g_ExtImm[ 2 ];
+
+/* <<<<< add tazaki 2001.09.18 */
+/* Advanced Macro Opecode name class0 - bit5,4 = 0,1 */
+extern const char *c33_adv_opcodes[];
+
+/* Advanced Macro Opecode name class5 - bit12_8 = 111:11 */
+extern const char *c33_adv_class5_opcodes[];
+/* >>>>> add tazaki 2001.09.18 */
+
+/* <<<<< add tazaki 2002.02.29 */
+
+int     g_iShiftFlag =0;
+const   char    szOpShift[3][4] = { "sra","sla","sll" };
+const   char    szCond[10][4]   = { "gt","ge","lt","le","ugt","uge","ult","ule","eq","ne" };
+
+/* >>>>> ADDED D.Fujimoto 2007/10/03 for displaying symbol */
+#include <stdarg.h>
+static char dummy_buffer[4096], *dummy_p;
+static int
+dummy_sprintf (FILE *f, const char *format, ...)
+{
+        char *buf;
+        va_list args;
+        size_t n;
+
+        va_start (args, format);
+
+        vasprintf (&buf, format, args);
+
+        va_end (args);
+
+        n = strlen (buf);
+        if (dummy_p + n + 1 < dummy_buffer + sizeof(dummy_buffer)) {
+                strcpy(dummy_p, buf);
+                dummy_p += n;
+        } else {
+                n = 0;
+        }
+
+        free (buf);
+
+        return n;
+}
+
+static char *find_symbolname_for_address(bfd_vma vma, struct disassemble_info *info)
+{
+        char *name;
+        fprintf_ftype saved_fprintf_func;
+
+        if (!info->symbol_at_address_func(vma, info)) return NULL;
+
+        dummy_p = dummy_buffer;
+
+        saved_fprintf_func = info->fprintf_func;
+        info->fprintf_func = (fprintf_ftype)dummy_sprintf;
+
+        info->print_address_func(vma, info);
+
+        info->fprintf_func = saved_fprintf_func;
+
+        name = strrchr(dummy_buffer, '>');
+        if (!name) return NULL;
+        *name = '\0';
+        name = strchr(dummy_buffer, '<');
+        if (!name) return NULL;
+        return name + 1;
+}
+/* <<<<< ADDED D.Fujimoto 2007/10/03 */
+
+static int
+disassemble (memaddr, info, insn)
+     bfd_vma memaddr;
+     struct disassemble_info *info;
+     unsigned long insn;
+{
+/*  struct c33_opcode *          op = (struct c33_opcode *)c33_opcodes; */
+  struct c33_opcode *          op = (struct c33_opcode *)c33_advance_opcodes; /* tazaki 2001.12.05 */
+
+  const struct c33_operand *   operand;
+  int                           match = 0;
+  int               bytes_read;
+
+/* add tazaki 2001.07.31 >>>>> */
+    ADDR    tdAddr;            /* address of target instruction */
+    INT8    szExtString[DUMP_OUTPUT_BUF_SIZE];  /* extended instruntion string   */	// MOD D.Fujimoto 2007/10/04 string buffer size
+    int     nExtInst;          /* number of ext-instrcution */
+    int     iCalcType;         /* immediate value calculation type */
+    int     iExtType;          /* extension type */
+    int     i;
+    UINT32  ulImm;             /* extended immediate value */
+    UINT32  ulImm1;            /* immediate value of first ext_instruction */
+    UINT32  ulImm2;            /* immediate value of second ext_instruction */
+    UINT32  ulCode;            /* target instruction code */
+    INT8    szMessage[DUMP_OUTPUT_BUF_SIZE];    /* array of mnemonic or warning message */	// MOD D.Fujimoto 2007/10/04 string buffer size
+    INT8    szTmp[DUMP_OUTPUT_BUF_SIZE]; 	// MOD D.Fujimoto 2007/10/04 string buffer size
+    UINT8   ucErrFlag = NO_ERR;/* error flag */
+    INT8    szDisp[DUMP_OUTPUT_BUF_SIZE];        /* for Get string length compute */	// MOD D.Fujimoto 2007/10/04 string buffer size
+    INT8    szBuf[DUMP_OUTPUT_BUF_SIZE];         /* for Get string length compute work buffer */	// MOD D.Fujimoto 2007/10/04 string buffer size
+    INT8    szName[DUMP_OUTPUT_BUF_SIZE];	// MOD D.Fujimoto 2007/10/04 string buffer size
+    unsigned long   insn_wk;
+/* <<<<< add tazaki 2001.07.31 */
+
+  
+    bytes_read = 2;
+    insn &= 0xffff;
+
+    szDisp[0] = 0;  /* add tazaki 2001.08.03 */
+
+    g_iShiftFlag =0;
+
+
+    if ((insn & CLASS_MASK) == CLASS1) {     /* class1 */
+
+        g_iShiftFlag = 1;
+
+        /* Convert Opecode */
+        insn_wk = insn & 0xff00;
+
+        switch( insn_wk ){
+        case 0x2300: insn_wk = 0x8800;  break;  /* srl -->class 4 : srl */
+        case 0x2700: insn_wk = 0x8c00;  break;  /* sll -->class 4 : sll */
+        case 0x2b00: insn_wk = 0x9000;  break;  /* sra -->class 4 : sra */
+        case 0x2f00: insn_wk = 0x9400;  break;  /* sla -->class 4 : sla */
+        case 0x3300: insn_wk = 0x9800;  break;  /* rr  -->class 4 : rr  */
+        case 0x3700: insn_wk = 0x9c00;  break;  /* rl  -->class 4 : rl  */
+        default:
+            g_iShiftFlag = 0;
+            break;
+        }
+        insn = insn_wk | ( insn & 0x00ff );
+    }
+
+  /* Find the opcode.  */
+    while (op->name)
+    {
+        
+        if ((op->mask & insn) == op->opcode)
+        {
+            const unsigned char * opindex_ptr;
+            unsigned int          opnum;
+            unsigned int          memop;
+            unsigned short        uwOp1;
+            unsigned short        uwOp2;
+            int                   i;
+            int                   iLength;
+            
+
+            strcpy( szName, op->name );
+
+
+            /* Advanced Macro bit5,4 = 0,1 ？ add tazaki 2001.09.12 >>>  */
+            /* ONLY class0 */
+            if ((insn & CLASS_MASK) == CLASS0) {     /* class0 */
+                uwOp1 = insn & 0x1e00;
+                uwOp1 >>= 9;
+                if( uwOp1 < 4 ){
+                    if( insn & 0x0010 ){    /* bit5,4 = 0,1 ? */
+                        i = 0;
+                        while( c33_adv_opcodes[ i ] != 0 ){
+                            if( !strcmp( c33_adv_opcodes[ i ], szName ) ){
+                                break;
+                            }
+                            ++i;
+                        }
+                        if( c33_adv_opcodes[ i ] == 0 ){    /* No found ? */
+                            op++;
+                            continue;                       /* skip --> next search */
+                        }
+                    }
+                }
+            }
+            /* <<<  add tazaki 2001.09.12  */
+
+            /* Advanced Macro bit12-8=111:11 add tazaki 2001.09.18 >>>  */
+            /* ONLY class5 */
+            if ((insn & 0xff00) == 0xbf00) {     /* class5 111:11 */
+                if( (insn & 0x00c0) == 0x0000 ){    /* do.c imm6 ? */
+                    if( strcmp( c33_adv_class5_opcodes[ 0 ], szName )){
+                        op++;
+                        continue;
+                    }
+                }
+                if( (insn & 0x00c0) == 0x0040 ){    /* psrset imm5 ? */
+                    if( strcmp( c33_adv_class5_opcodes[ 1 ], szName )){
+                        op++;
+                        continue;
+                    }
+                }
+                if( (insn & 0x00c0) == 0x0080 ){    /* psrclr imm5 ? */
+                    if( strcmp( c33_adv_class5_opcodes[ 2 ], szName )){
+                        op++;
+                        continue;
+                    }
+                }
+
+            }
+            /* <<<  add tazaki 2001.09.12  */
+
+            /* add tazaki 2001.08.03 >>>>> ＴＡＢ数の計算 */
+
+            match = 1;
+
+            (*info->fprintf_func) (info->stream, "  %s", szName);
+            sprintf( szBuf,"  %s", szName );
+            strcat( szDisp,szBuf );
+
+            iLength = 8 - strlen( szName );
+            for( i = 0; i < iLength; ++i ){
+                (*info->fprintf_func) (info->stream, " ");
+                strcat( szDisp," " );
+            }
+            /* <<<<< add tazaki 2001.08.03 */
+            
+
+            memop = op->memop;
+            /* Now print the operands.
+
+             MEMOP is the operand number at which a memory
+             address specification starts, or zero if this
+             instruction has no memory addresses.
+
+             A memory address is always two arguments.
+
+             This information allows us to determine when to
+             insert commas into the output stream as well as
+             when to insert disp[reg] expressions onto the
+             output stream.  */
+      
+            for (opindex_ptr = op->operands, opnum = 1;
+                                    *opindex_ptr != 0;
+                                    opindex_ptr++, opnum++)
+            {
+                long    value;
+                long    value2;
+                long    value3;
+                int     flag;
+                int       status;
+                bfd_byte    buffer[ 4 ];
+                int     i_op_match;
+                
+                operand = &c33_operands[*opindex_ptr];
+                
+                if (operand->extract)
+                    value = (operand->extract) (insn, 0);
+                else
+                {
+                    value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
+                }
+
+                if (opnum > 1) {
+                    info->fprintf_func (info->stream, ",");
+                    sprintf( szBuf,"," );   /* add tazaki 2001.08.03 */
+                    strcat( szDisp,szBuf ); /* add tazaki 2001.08.03 */
+                }
+                /* extract the flags, ignorng ones which do not effect disassembly output. */
+                flag = operand->flags;
+
+                i_op_match = 0;
+                /* >>> add tazaki 2002.02.29 */
+
+                if( !strcmp( szName,"ext" ) )
+                {
+                    if ((insn & 0xff00) == 0x3b00) {     /* class1 001:11011 */
+                        if( (insn & 0x00f0) == 0x0000 ){    
+                            /* ext OP,imm2  */
+                            value = insn & 0x000c;
+                            value >>= 2;
+                            value2 = insn & 0x0003;
+                            if( value > 0 ){
+                                info->fprintf_func (info->stream, "%s,0x%x", szOpShift[ value - 1],value2 );
+                                sprintf( szBuf,"%s,0x%x", szOpShift[ value - 1],value2 );
+                                strcat( szDisp,szBuf ); 
+                                i_op_match = 1;
+                            }
+                        }
+                        else
+                        {
+                            /* ext cond  */
+                            value = insn & 0x00f0;
+                            value >>= 4;
+/* >>>>> MODIFIED D.Fujimoto 2008/05/22 disassemble hangs when processing with -D */
+//                            if( value >= 4 ){
+                            if( value >= 4 && value - 4 < 10 ){	// depends on szCond index
+/* <<<<< MODIFIED D.Fujimoto 2008/05/22 disassemble hangs when processing with -D */
+                                info->fprintf_func (info->stream, "%s", szCond[ value - 4] );
+                                sprintf( szBuf,"%s", szCond[ value - 4] );
+                                strcat( szDisp,szBuf ); 
+                                i_op_match = 1;
+                            }
+                        }
+                        
+                    }
+                    if ((insn & 0xff00) == 0x3f00) {     /* class1 001:11111 */
+                        if( (insn & 0x000f) != 0x0000 ){    
+                            /* ext %rs,OP,imm2 */
+                            value = insn & 0x00f0;
+                            value >>= 4;
+                            value2 = insn & 0x000c;
+                            value2 >>= 2;
+                            value3 = insn & 0x0003;
+                            if( value2 >= 1 ){
+                                info->fprintf_func (info->stream, "%s,%s,0x%x", 
+                                                c33_reg_names[value],
+                                                szOpShift[ value2 - 1 ],
+                                                value3
+                                                );
+                                sprintf( szBuf, "%s,%s,0x%x", 
+                                                c33_reg_names[value],
+                                                szOpShift[ value2 - 1 ],
+                                                value3
+                                                );
+                                strcat( szDisp,szBuf ); 
+                                i_op_match = 1;
+                            }
+                        }
+                        else
+                        {
+                            /* ext %rs */
+                            value = insn & 0x00f0;
+                            value >>= 4;
+                            info->fprintf_func (info->stream, "%s", c33_reg_names[value] );
+                            sprintf( szBuf,"%s", c33_reg_names[value] );
+                            strcat( szDisp,szBuf ); 
+                            i_op_match = 1;
+                        }
+                    }
+                }
+
+                if( i_op_match == 0 )
+                {
+                    if( flag == C33_OPERAND_LD_SREG ){
+                        flag = C33_OPERAND_SREG;
+                    }
+                    if( flag == (C33_OPERAND_PUSHS_SREG | C33_OPERAND_01) ){
+                        flag = C33_OPERAND_SREG;
+                    }
+                    if( flag == ( C33_OPERAND_DP | C33_OPERAND_01 ) ){
+                        flag &= ( C33_OPERAND_01 ^ 0xffff );
+                    }
+                    
+                    if( flag != C33_OPERAND_DPMEM && flag != C33_OPERAND_DP ) {
+                        flag &= - flag; 
+                    }
+                    
+                    switch (flag)
+                    {
+                    
+                    case C33_OPERAND_MEM    :
+                        info->fprintf_func (info->stream, "[0x%x]", value);
+                        sprintf( szBuf,"[0x%x]", value );
+                        strcat( szDisp,szBuf ); 
+                        break;
+
+                    case C33_OPERAND_SPMEM  :
+                        info->fprintf_func (info->stream, "[%%sp+0x%x]", value); /* [%sp+imm6] */
+                        sprintf( szBuf,"[%%sp+0x%x]", value );  
+                        strcat( szDisp,szBuf );
+                        break;
+
+                    case C33_OPERAND_DPMEM  :
+                        info->fprintf_func (info->stream, "[%%dp+0x%x]", value); /* [%dp+imm6] */
+                        sprintf( szBuf,"[%%dp+0x%x]", value );
+                        strcat( szDisp,szBuf );
+                        break;
+
+                    case C33_OPERAND_REG:  
+                        info->fprintf_func (info->stream, "%s", c33_reg_names[value]);
+                        sprintf( szBuf,"%s", c33_reg_names[value] );
+                        strcat( szDisp,szBuf );                     
+                        break;
+                        
+                    case C33_OPERAND_SREG:
+                        info->fprintf_func (info->stream, "%s", c33_sreg_names[value]);
+                        sprintf( szBuf,"%s", c33_sreg_names[value] );
+                        strcat( szDisp,szBuf );                     
+                        break;
+
+
+                    case C33_OPERAND_REGINC :
+                        info->fprintf_func (info->stream, "[%s]+", c33_reg_names[value]);
+                        sprintf( szBuf,"[%s]+", c33_reg_names[value] ); 
+                        strcat( szDisp,szBuf );                        
+                        break;
+
+                    case C33_OPERAND_RB :
+                        info->fprintf_func (info->stream, "[%s]", c33_reg_names[value]);
+                        sprintf( szBuf,"[%s]", c33_reg_names[value] );
+                        strcat( szDisp,szBuf );                        
+                        break;
+
+                    case C33_OPERAND_SP :
+                        info->fprintf_func (info->stream, "%%sp");
+                        sprintf( szBuf,"%%sp" );                
+                        strcat( szDisp,szBuf );                 
+                        break;
+                        
+                    case C33_OPERAND_DP :
+                        info->fprintf_func (info->stream, "%%dp");
+                        sprintf( szBuf,"%%dp" );            
+                        strcat( szDisp,szBuf );             
+                        break;
+                        
+                    case C33_OPERAND_IMM    :
+                        if( g_iShiftFlag == 1 ){
+                            value += 16;        /* shift : imm + 16 */
+                        }
+                    case C33_OPERAND_SIGNED :
+                    default:
+                        info->fprintf_func (info->stream, "0x%x", value);
+                        sprintf( szBuf,"0x%x", value );         
+                        strcat( szDisp,szBuf );                 
+                        break;
+
+                    }
+                }
+                else
+                {
+                    break;      // exit operand loop
+                }
+            }
+
+            /* All done. */
+            break;              /* exit while loop */
+        }
+        op++;
+    }
+
+    /* not found opcode ? */
+    if (!match)
+    {
+      info->fprintf_func (info->stream, " .short\t0x%04x", insn);
+      g_iExtCnt = 0;
+      return bytes_read;
+    }
+
+
+/* add tazaki 2001.07.31 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> */
+
+    /*==========================================*/
+    /* Extended Instruction Display             */
+    /*==========================================*/
+    /* insn : 16 bit    */
+
+    if( ( insn & CLASS_MASK ) == CLASS6 ){  /* ext ? */
+        if( g_iExtCnt == 2 ){
+            g_ExtImm[ 1 ] = insn & CLASS6_DATA;
+        }else{
+            g_ExtImm[g_iExtCnt] = insn & CLASS6_DATA;
+        }
+        if( g_iExtCnt < 2 ){
+            ++g_iExtCnt;        /* increment ext counter */
+        }
+        return bytes_read;
+    }
+    
+    ulCode = insn;
+    ulImm1 = ulImm2 = 0;
+    if( g_iExtCnt == 2 ){
+        ulImm1 = g_ExtImm[ 0 ];
+        ulImm2 = g_ExtImm[ 1 ];
+    }else if( g_iExtCnt == 1 ){
+        ulImm2 = g_ExtImm[ 0 ];
+    }
+
+    nExtInst = g_iExtCnt;
+
+    tdAddr = memaddr;           /* offset address set */
+
+/* >>>>> DELETED D.Fujimoto 2007/10/03 iExtCnt == 0 will also use these routines */
+//    if( g_iExtCnt > 0 ){
+/* <<<<< DELETED D.Fujimoto 2007/10/03 iExtCnt == 0 will also use these routines */
+
+        /* analize instruction code */ /* extention type and calculation type */
+        ucErrFlag = fnCrGetExtType(ulCode, &iExtType, &iCalcType);
+
+        if (ucErrFlag == NO_ERR) {                 /* the target instruction is extendable */
+            /* calculate extended immediate value */
+            ulImm = fnCrCalcImmVal(nExtInst, iCalcType, ulImm1, ulImm2, ulCode);
+            
+            /* make extended instruction */
+/* >>>>> MODIFIED D.Fujimoto 2007/10/03 added info as param */
+//            ucErrFlag = fnCrGetXinst(ulCode, ulImm, iExtType, tdAddr, szMessage, 256, szTmp);
+            ucErrFlag = fnCrGetXinst(ulCode, ulImm, iExtType, tdAddr, szMessage, DUMP_OUTPUT_BUF_SIZE, szTmp, g_iExtCnt, info);
+/* <<<<< MODIFIED D.Fujimoto 2007/10/03 added info as param */
+            
+            if (ucErrFlag == NO_ERR) {               /* not disassemble error */
+                if( strlen( szMessage ) > 0 ){
+                    strcpy( (INT8 *)szExtString, szMessage );
+                    szExtString[ strlen(szExtString)-1 ] = 0;
+
+                    for( i = 0; i < ( 26 - strlen( szDisp ) ); ++i ){
+                        info->fprintf_func (info->stream, " ");
+                    }
+                    info->fprintf_func (info->stream, "%s", szExtString);
+                }
+/* >>>>> ADDED D.Fujimoto 2007/10/10 display plain mnemonic */
+            } else if (ucErrFlag == QUIT) {
+				/* get mnemonic code */
+				vfnDisasm ((unsigned short)ulCode, szTmp);
+				for( i = 0; i < ( 26 - strlen( szDisp ) ); ++i ){
+					info->fprintf_func (info->stream, " ");
+				}
+				info->fprintf_func (info->stream, "%s", szTmp);
+/* <<<<< ADDED D.Fujimoto 2007/10/10 display plain mnemonic */
+			}
+/* >>>>> MODIFIED D.Fujimoto 2007/10/04 display when ERR and ERR2 */
+//        }else if (ucErrFlag == ERR) {
+		  } else {
+/* <<<<< MODIFIED D.Fujimoto 2007/10/04 display when ERR and ERR2 */
+            /* get mnemonic code */
+            vfnDisasm ((unsigned short)ulCode, szTmp);
+            for( i = 0; i < ( 26 - strlen( szDisp ) ); ++i ){
+                info->fprintf_func (info->stream, " ");
+            }
+            info->fprintf_func (info->stream, "%s", szTmp);
+        }
+
+/* >>>>> DELETED D.Fujimoto 2007/10/03 iExtCnt == 0 will also use these routines */
+//    }else{
+//        /* get mnemonic code */
+//        vfnDisasm ((unsigned short)ulCode, szTmp);
+//        for( i = 0; i < ( 26 - strlen( szDisp ) ); ++i ){
+//            info->fprintf_func (info->stream, " ");
+//        }
+//        info->fprintf_func (info->stream, "%s", szTmp);
+//
+//    }
+/* <<<<< DELETED D.Fujimoto 2007/10/03 iExtCnt == 0 will also use these routines */
+
+	g_iExtCnt = 0;  /* clear ext inst counter */
+    
+    return bytes_read;
+}
+
+static UINT8
+fnCrGetExtType(ulCode,iExtType,iCalcType)
+
+    /***************************************************************
+     *
+     *      --- Get the extention type and
+     *                  the immediate calculation type ---
+     *
+     *      Check the extention type (set to the parameter2) and
+     *      immediate value calculation type (set to the parameter3).
+     *
+     *      RETURN: NO_ERR: the target instruction is extendable
+     *              ERR   : the target instruction cannot be extended
+     *
+     ***************************************************************/
+
+    UINT32  ulCode;            /* target instruction */
+    int    *iExtType;          /* extention type, 1-3 */
+    int    *iCalcType;         /* immediate value calculation type, 1-5 */
+
+{
+    UINT32  ulOp1;             /* op1 */
+    UINT32  ulOp2;             /* op2 */
+    UINT8   ucErrFlag = ERR;   /* error flag */
+    
+    /* get the extention type and the immediate calculation type, according to the class */
+    switch (ulCode & CLASS_MASK) {               /* switch by class type */
+      case CLASS0:
+        if ((ulCode & 0xfff0 )== 0x0350) {    /* add %rd,%dp ? */
+            ucErrFlag = ERR2;               /* not show 3 operand. add tazaki 2001.12.21 */
+        }else{
+            ulOp1 = (ulCode >> 0x9) & 0xf;           /* bit12:9 */
+            if ((ulOp1 & 0xc) != 0x0) {              /* not OP1 = 00XX, illeagal */
+              ucErrFlag = NO_ERR;
+              *iExtType = EXT1;
+              *iCalcType = CALC1;
+            }
+        }
+        break;
+      
+      case CLASS1:
+        if (((ulCode & BIT8) == 0x0) && ((ulCode & BIT9) == 0x0)) {     /* load/store */
+          ucErrFlag = NO_ERR;
+          *iExtType = EXT2;
+          *iCalcType = CALC2;
+        }
+        else{
+            if (((ulCode & BIT8) == 0x0) && ((ulCode & BIT9) != 0x0)) {/* numeric/logical/compare */
+                if ( ((ulCode & BIT10) != 0x0) && ((ulCode & BIT11) != 0x0) && ((ulCode & BIT12) != 0x0)) { /* not ? */
+                    ulOp1 = (ulCode >> 0xa) & 0x7;                               
+                    if ((ulOp1 != 0x3) && (ulOp1 != 0x7)) {                      
+                        ucErrFlag = NO_ERR;
+                        *iExtType = EXT3;
+                        *iCalcType = CALC2;
+                    }
+                }else{
+                    ucErrFlag = ERR2;   /* not show 3 operand. add tazaki 2001.11.06 */
+                }
+            }
+        }
+        break;
+    
+      case CLASS2:
+        ucErrFlag = NO_ERR;
+        *iExtType = EXT1;
+        
+        ulOp1 = (ulCode >> 0xa) & 0x7;                                  /* bit12:10 */
+        if (((ulOp1 & 0x6) == 0x0) || (ulOp1 == 0x5)) {                 /* byte type */
+          *iCalcType = CALC3_BYTE;
+        }
+        else if (((ulOp1 & 0x6) == 0x2) || (ulOp1 == 0x6)) {            /* half word type */
+          *iCalcType = CALC3_HALF;
+        }
+        else {                                                          /* word type */
+          *iCalcType = CALC3_WORD;
+        }
+        break;
+      
+      case CLASS3:
+        ucErrFlag = NO_ERR;
+        *iExtType = EXT1;
+        
+        ulOp1 = (ulCode >> 0xa) & 0x7;           /* bit12:10 */
+        if ((ulOp1 & 0x6) == 0x0) {              /* OP1 = 00x, imm6 type */
+          *iCalcType = CALC4;
+        }
+        else {                                   /* sign6 type */
+          *iCalcType = CALC5;
+        }
+        break;
+      
+      case CLASS5:
+        ulOp1 = (ulCode >> 0xa) & 0x7;           /* bit12:10 */
+        ulOp2 = (ulCode >> 0x8) & 0x3;           /* bit9:8 */
+        if ((ulOp1 == 0x2) || (ulOp1 == 0x3) || (ulOp1 == 0x4) || (ulOp1 == 0x5)) {
+          if ((ulOp2 == 0x0) && ((ulCode & BIT3) == 0x0)) {
+            ucErrFlag = NO_ERR;
+            *iExtType = EXT2;
+            *iCalcType = CALC2;
+          }
+        }
+        break;
+
+    /* >>> add tazaki 2001.09.19 */
+
+      case CLASS7:
+        ucErrFlag = NO_ERR;
+        *iExtType = EXT1;
+        
+        ulOp1 = (ulCode >> 0xa) & 0x7;                                  /* bit12:10 */
+        if (((ulOp1 & 0x6) == 0x0) || (ulOp1 == 0x5)) {                 /* byte type */
+          *iCalcType = CALC3_BYTE;
+        }
+        else if (((ulOp1 & 0x6) == 0x2) || (ulOp1 == 0x6)) {            /* half word type */
+          *iCalcType = CALC3_HALF;
+        }
+        else {                                                          /* word type */
+          *iCalcType = CALC3_WORD;
+        }
+        break;
+    
+    /* >>> add tazaki 2001.09.19 */
+    
+    }
+    
+    return ucErrFlag;
+}
+
+
+
+static UINT32
+fnCrCalcImmVal(nExtInst,iCalcType,ulExt1,ulExt2,ulCode)
+
+    /***************************************************************
+     *
+     *      --- Calculate the extended immediate value ---
+     *
+     *      Calculate the extended immediate value according to the
+     *      extention type and the immediate value calculation type.
+     *
+     *      RETURN: extended immediate value
+     *
+     ***************************************************************/
+
+    int     nExtInst;          /* extention type, 1-3 */
+    int     iCalcType;         /* immediate value calculation type, 1-5 */
+    UINT32  ulExt1;            /* immediate value of ext1 */
+    UINT32  ulExt2;            /* immediate value of ext2 */
+    UINT32  ulCode;            /* target instruction code */
+
+{
+    UINT32  ulImm32;           /* extended immediate value */
+
+    /* clear not ext-instruction code */
+    if (nExtInst == 0) {
+      ulExt1 = 0x0;
+      ulExt2 = 0x0;
+    }
+    else if (nExtInst == 1) {
+      ulExt1 = 0x0;
+    }
+    
+    /* calculate immediate value according to iCalcType */
+    switch (iCalcType) {
+      case CALC1:                      /* ext1[bit12:3] + ext2[bit12:0] + IR[bit7:0]"0" */
+        ulImm32 = ((ulExt1 & MASK12_3) << 19)
+                     + ((ulExt2 & MASK12_0) << 9) + ((ulCode & MASK7_0) << 1);
+        
+        /* sign extention */
+        if (nExtInst == 0) {
+          if ((ulCode & BIT7) != 0x0) {
+            ulImm32 |= MASK31_9;
+          }
+        }
+        else if (nExtInst == 1) {
+          if ((ulExt2 & BIT12) != 0x0) {
+            ulImm32 |= MASK31_22;
+          }
+        }
+        break;
+      
+      case CALC2:                      /* ext1[bit12:0] + ext2[bit12:0] */
+        ulImm32 = ((ulExt1 & MASK12_0) << 13) + (ulExt2 & MASK12_0);
+        break;
+      
+      case CALC3_BYTE:
+      case CALC4:                      /* ext1[bit12:0] + ext2[bit12:0] + IR[bit9:4] */
+        ulImm32 = ((ulExt1 & MASK12_0) << 19)
+                     + ((ulExt2 & MASK12_0) << 6) + ((ulCode & MASK9_4) >> 4);
+        break;
+        
+      case CALC3_HALF:
+        if (nExtInst == 0) {           /* IR[bit9:4]"0" */
+          ulImm32 = (ulCode & MASK9_4) >> 3;
+          ulImm32 &= ~BIT0;
+        }
+        else {                         /* ext1[bit12:0] + ext2[bit12:0] + IR[bit9:5]"0" */
+          ulImm32 =((ulExt1 & MASK12_0) << 19)
+                     + ((ulExt2 & MASK12_0) << 6) + ((ulCode & MASK9_5) >> 4);
+          ulImm32 &= ~BIT0;
+        }
+        break;
+        
+      case CALC3_WORD:
+        if (nExtInst == 0) {           /* IR[bit9:4]"00" */
+          ulImm32 = (ulCode & MASK9_4) >> 2;
+          ulImm32 &= ~MASK1_0;
+        }
+        else {                         /* ext1[bit12:0] + ext2[bit12:0] + IR[bit9:6]"00" */
+          ulImm32 =((ulExt1 & MASK12_0) << 19)
+                     + ((ulExt2 & MASK12_0) << 6) + ((ulCode & MASK9_6) >> 4);
+          ulImm32 &= ~MASK1_0;
+        }
+        break;
+        
+      case CALC5:                      /* ext1[bit12:0] + ext2[bit12:0] + IR[bit9:4] */
+        ulImm32 = ((ulExt1 & MASK12_0) << 19)
+                     + ((ulExt2 & MASK12_0) << 6) + ((ulCode & MASK9_4) >> 4);
+        
+        /* sign extention */
+        if (nExtInst == 0) {
+          if ((ulCode & BIT9) != 0x0) {
+            ulImm32 |= MASK31_6;
+          }
+        }
+        else if (nExtInst == 1) {
+          if ((ulExt2 & BIT12) != 0x0) {
+            ulImm32 |= MASK31_19;
+          }
+        }
+        
+        break;
+        
+      default:                         /* this may not be occured */
+        ulImm32 = 0;
+        break;
+    } /* end of switch */
+    
+    return ulImm32;
+}
+
+/* >>>>> MODIFIED D.Fujimoto 2007/10/03 added params for displaying symbols */
+//static UINT8
+//fnCrGetXinst(ulCode,ulImmVal,iExtType,tdAddr,szXinst,iArraySize,szTmp)
+static UINT8
+fnCrGetXinst(ulCode,ulImmVal,iExtType,tdAddr,szXinst,iArraySize,szTmp, iExtCnt, info)
+/* <<<<< MODIFIED D.Fujimoto 2007/10/03 added params for displaying symbols */
+
+    /***************************************************************
+     *
+     *      --- Make output string ---
+     *
+     *      Get extended mnemonic code from instruction code.
+     *      Replace extended immediate value with original immediate
+     *      value or add extended immediate value according to the
+     *      extention type.
+     *      If instruction is one of branch instruction, destination
+     *      address is added to the extended mnemonic code.
+     *
+     *      RETURN: NO_ERR  success
+     *              ERR     cannot get correct mnemonic
+     *
+     ***************************************************************/
+
+    UINT32  ulCode;            /* target instruction code */
+    UINT32  ulImmVal;          /* extended immediate value */
+    int     iExtType;          /* extention type, 1-3 */
+    ADDR    tdAddr;            /* address of target instruction */
+    INT8   *szXinst;           /* extended mnemonic code */
+    int     iArraySize;        /* size of szXinst */
+    INT8   *szTmp;           /* extended mnemonic code */
+/* >>>>> ADDED D.Fujimoto 2007/10/03 added params for displaying symbols */
+    int     iExtCnt;         /* size of szXinst */
+    struct disassemble_info *info;
+/* <<<<< ADDED D.Fujimoto 2007/10/03 added params for displaying symbols */
+{
+/*  INT8    szTmp[256];   */   /* temporal array */
+/* >>>>> MOD D.Fujimoto 2007/10/03 increased buffer for long symbol names */
+//    INT8    szImm32[32];       /* immediate value */
+    INT8    szImm32[DUMP_OUTPUT_BUF_SIZE];       /* immediate value */
+/* <<<<< MOD D.Fujimoto 2007/10/03 increased buffer for long symbol names */
+    INT8   *pchCutText;        /* pointer to the character to be replaced */
+    INT8   *pchNextToCutText;  /* pointer next to the character to be replaced */
+    INT8   *pchMnemonic;       /* pointer to the extended mnemonic code */
+    INT8   *pchCopyChar;       /* pointer to the original memonic code */
+    UINT32  ulOp1;             /* OP code to check if branch instruction or not */
+    UINT8   ucErrFlag = ERR;   /* error flag */
+    int     iIsBranch = NO;    /* branch instruction check flag */
+/* >>>>> ADDED D.Fujimoto 2007/10/03 added params for displaying symbols */
+	char 	*name;				/* symbol name for display */
+	char nameBuf[SYMBOL_NAME_BUF_SIZE];	// length should be under szImm32
+	int iAbbrevStrLength;
+	UINT32 sign8Val = 0;
+	enum eOpcode {add, sub, cmp, ld, and, or, xor, not};
+	enum eOpcode opc3 = ld;		// class3 opecode
+/* <<<<< ADDED D.Fujimoto 2007/10/03 added params for displaying symbols */
+
+/* >>>>> MOD D.Fujimoto 2007/10/03 increased buffer for long symbol names */
+//  if( iArraySize > 256){
+    if( iArraySize > DUMP_OUTPUT_BUF_SIZE){
+        return ucErrFlag;
+    }
+/* <<<<< MOD D.Fujimoto 2007/10/03 increased buffer for long symbol names */
+    
+    /* get mnemonic code */
+    vfnDisasm ((unsigned short)ulCode, szTmp);
+    
+    /* set the pointer, according to the extention type */
+    switch(iExtType) {
+      case EXT1: /* immediate value ---> extended immediate value */
+        pchCutText = szTmp;
+        
+        /* search immediate value */
+        while((pchCutText = strchr(pchCutText, '0')) != NULL) {
+          if (strncmp(pchCutText, "0x", 2) == 0) {        /* immediate value starts with "0x" */
+            pchNextToCutText = pchCutText + 2;
+            while (isxdigit(*pchNextToCutText) != 0) {    /* search the end of immediate value */
+              ++pchNextToCutText;
+            }
+            
+            ucErrFlag = NO_ERR;
+            break;
+          }
+          else {
+            ++pchCutText;                                 /* feed for next search */
+          }
+        }
+        break;
+        
+      case EXT2: /* add displace ment */
+/* >>>>> MODIFIED D.Fujimoto 2007/10/10 display plain mnemonic */
+//        pchNextToCutText = strchr(szTmp, ']');
+//        if (pchNextToCutText != NULL) {
+//          pchCutText = pchNextToCutText;
+//          ucErrFlag = NO_ERR;
+//        }
+
+		if (iExtCnt != 0) {
+	        pchNextToCutText = strchr(szTmp, ']');
+	        if (pchNextToCutText != NULL) {
+	          pchCutText = pchNextToCutText;
+	          ucErrFlag = NO_ERR;
+	        }
+		} else {
+			// do not add displacement, disasm shown in disassemble()
+			ucErrFlag = QUIT;	
+		}
+/* <<<<< MODIFIED D.Fujimoto 2007/10/10 display plain mnemonic */
+
+        break;
+        
+      case EXT3: /* three opeland */
+        pchNextToCutText = strchr(szTmp, '\0');
+        if (pchNextToCutText != NULL) {
+          pchCutText = pchNextToCutText;
+          ucErrFlag = NO_ERR;
+        }
+        break;
+        
+      default:
+        break;
+    }
+    
+    /* get extended mnemonic code */
+    if (ucErrFlag == NO_ERR) {
+/* >>>>> MODIFIED D.Fujimoto 2007/10/10 do not add 'x' when iExtCnt is 0 */
+//      pchMnemonic = szXinst;
+//      *pchMnemonic = 'x';
+//      ++pchMnemonic;
+
+		pchMnemonic = szXinst;
+		if (iExtCnt != 0) {
+			*pchMnemonic = 'x';
+			++pchMnemonic;
+
+      
+	      /* special case */
+	      if (strncmp(szTmp, "or", 2) == 0) {        /* or ---> xoor */
+	        *pchMnemonic = 'o';
+	        ++pchMnemonic;
+	      }
+		}
+/* <<<<< MODIFIED D.Fujimoto 2007/10/10 do not add 'x' when iExtCnt is 0 */
+      
+      for (pchCopyChar = szTmp; pchCopyChar < pchCutText;) {
+        *pchMnemonic = *pchCopyChar;
+        ++pchMnemonic;
+        ++pchCopyChar;
+      }
+      
+      switch (iExtType) {
+        case EXT1: /* immediate value ---> extended immediate value */
+            ;                                    /* null */
+          break;
+        
+        case EXT2: /* add displace ment */
+          *pchMnemonic = '+';
+          ++pchMnemonic;
+          break;
+        
+        case EXT3: /* three opeland */
+          *pchMnemonic = ',';
+          ++pchMnemonic;
+          break;
+        
+      }
+      
+      /* change immediate value */
+      /* set branch instruction flag, in case of branch instruction */
+      if ((ulCode & CLASS_MASK) == CLASS0) {     /* class0 */
+        ulOp1 = (ulCode >> 0x9) & 0xf;           /* bit12:9 */
+        if ((ulOp1 & 0xc) != 0x0) {              /* branch inst is not OP1 = 00XX, illeagal */
+          iIsBranch = YES;
+/* >>>>> ADDED D.Fujimoto 2007/10/04 display sign8 val for branches when ext count is 0 */
+		  sign8Val = ulCode & 0xff;
+/* <<<<< ADDED D.Fujimoto 2007/10/04 display sign8 val for branches when ext count is 0 */
+        }
+      }
+      
+      if (iIsBranch == YES) {
+        tdAddr += ulImmVal;                      /* destination address */
+/* >>>>> MODIFIED D.Fujimoto 2007/10/04 display sign8 val for branches when ext count is 0 */
+//	        sprintf(szImm32, "0x%-8lx (0x%08lX)", ulImmVal, tdAddr);
+		if (iExtCnt == 0) {
+			// sign8
+	        sprintf(szImm32, "0x%-8lx (0x%08lX)", sign8Val, tdAddr);
+		} else {
+	        sprintf(szImm32, "0x%-8lx (0x%08lX)", ulImmVal, tdAddr);
+		}
+/* <<<<< MODIFIED D.Fujimoto 2007/10/04 display sign8 val for branches when ext count is 0 */
+        strcpy(pchMnemonic, szImm32);
+
+/* >>>>> ADDED D.Fujimoto 2007/10/03 */
+		// show symbol for branch
+		name = find_symbolname_for_address((bfd_vma) tdAddr, info);
+		if (name) {
+			// avoid buffer overflow for szImm32
+			iAbbrevStrLength = strlen("...");
+			if (strlen(name) > SYMBOL_NAME_BUF_SIZE ) {								// length of " <>", "..." and '\0'
+				strncpy(nameBuf, name, SYMBOL_NAME_BUF_SIZE);						// copy string
+				strncpy(nameBuf + (SYMBOL_NAME_BUF_SIZE - iAbbrevStrLength - 1), "...", iAbbrevStrLength);	// replace 
+				nameBuf[SYMBOL_NAME_BUF_SIZE - 1] = '\0';
+			} else {
+				strcpy(nameBuf, name);
+			}
+			sprintf(szImm32, " <%s>", nameBuf);
+            strcat(pchMnemonic, szImm32);
+		}
+
+        strcat(pchMnemonic, pchNextToCutText);  /* maybe none */
+
+/* <<<<< ADDED D.Fujimoto 2007/10/03 */
+
+      } else {	// not branch
+/* >>>>> ADDED D.Fujimoto 2007/10/09 */
+		// determine class3 opecode
+		if ((ulCode & CLASS_MASK) == CLASS3) {
+			switch ((ulCode & 0xfc00)) {
+				case 0x6000:
+					opc3 = add;
+					break;
+				case 0x6400:
+					opc3 = sub;
+					break;
+				case 0x6800:
+					opc3 = cmp;
+					break;
+				case 0x6c00:
+					opc3 = ld;
+					break;
+				case 0x7000:
+					opc3 = and;
+					break;
+				case 0x7400:
+					opc3 = or;
+					break;
+				case 0x7800:
+					opc3 = xor;
+					break;
+				case 0x7c00:
+					opc3 = not;
+					break;
+			}
+		} else if (iExtCnt == 0) {
+			// recalculate imm6 value
+			if ((ulCode & CLASS_MASK) == CLASS2) {
+				// ld.* %rd, [%sp+imm6] 
+				// ld.* [%sp+imm6], %rs 
+				ulImmVal = (ulCode & MASK9_4) >> 4;
+			} else if ((ulCode & CLASS_MASK) == CLASS7) {
+				// ld.* %rd, [%dp+imm6]
+				// ld.* [%dp+imm6], %rs
+				ulImmVal = (ulCode & MASK9_4) >> 4;
+			}
+		}
+
+/* <<<<< ADDED D.Fujimoto 2007/10/09 */
+
+        sprintf(szImm32, "0x%lx", ulImmVal);
+        strcpy(pchMnemonic, szImm32);            /* change immediate value */
+        strcat(pchMnemonic, pchNextToCutText);
+
+/* >>>>> ADDED D.Fujimoto 2007/10/09 */
+		// skip insns that do not take label operands
+		if ((ulCode & CLASS_MASK) == CLASS3 && opc3 == ld) {
+			// show symbol for normal insn
+			name = find_symbolname_for_address((bfd_vma) ulImmVal, info);
+			if (name) {
+				// avoid buffer overflow for szImm32
+				iAbbrevStrLength = strlen("...");
+				if (strlen(name) > SYMBOL_NAME_BUF_SIZE ) {								// length of " <>", "..." and '\0'
+					strncpy(nameBuf, name, SYMBOL_NAME_BUF_SIZE);						// copy string
+					strncpy(nameBuf + (SYMBOL_NAME_BUF_SIZE - iAbbrevStrLength - 1), "...", iAbbrevStrLength);	// replace 
+					nameBuf[SYMBOL_NAME_BUF_SIZE - 1] = '\0';
+				} else {
+					strcpy(nameBuf, name);
+				}
+				sprintf(szImm32, " <%s>", nameBuf);
+				strcat(pchMnemonic, szImm32);
+			}
+		}
+/* <<<<< ADDED D.Fujimoto 2007/10/09 */
+
+      }
+      strcat(pchMnemonic, "\n");
+    }
+    
+    return ucErrFlag;
+}
+
+/************************************************
+ *  vfnDisasm : execute dis-assemble    *
+ ************************************************/
+
+static void
+vfnDisasm (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+{
+    unsigned short  uwClass;
+
+    /*@ extract class */
+    uwClass = uwCode & 0xe000;
+    uwClass >>= 13;
+
+    switch (uwClass) {      /* class */
+
+    case 0:         /* class 0 */
+    vfnDisasmClass0 (uwCode, pszBuf);
+    break;
+
+    case 1:         /* class 1 */
+    vfnDisasmClass1 (uwCode, pszBuf);
+    break;
+
+    case 2:         /* class 2 */
+    vfnDisasmClass2 (uwCode, pszBuf);
+    break;
+
+    case 3:         /* class 3 */
+    vfnDisasmClass3 (uwCode, pszBuf);
+    break;
+
+    case 4:         /* class 4 */
+    vfnDisasmClass4 (uwCode, pszBuf);
+    break;
+
+    case 5:         /* class 5 */
+    vfnDisasmClass5 (uwCode, pszBuf);
+    break;
+
+    case 6:         /* class 6 */
+    vfnDisasmClass6 (uwCode, pszBuf);
+    break;
+
+    case 7:         /* class 7 */
+    vfnDisasmClass7 (uwCode, pszBuf);
+    break;
+    }
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass0 : execute dis-assemble class0       *
+ ****************************************************************/
+
+static void
+vfnDisasmClass0 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+{
+    unsigned short  uwOp1, uwDelay, uwOp2;
+    unsigned short  uwBit0_3, uwBit4_5, uwBit0_7;
+    char            szTmpBuf[10];
+    char           *spSpecialReg[16];
+    int             i;
+    int             iLoop;
+
+    /*@ initialize */   
+    spSpecialReg[0]  = "%psr";
+    spSpecialReg[1]  = "%sp";
+    spSpecialReg[2]  = "%alr";
+    spSpecialReg[3]  = "%ahr";
+    spSpecialReg[4]  = "%lco";
+    spSpecialReg[5]  = "%lsa";
+    spSpecialReg[6]  = "%lea";
+    spSpecialReg[7]  = "%sor";
+    spSpecialReg[8]  = "%ttbr";
+    spSpecialReg[9]  = "%dp";
+    spSpecialReg[10] = "%idir";		/* "" -->"%idir"      T.Tazaki 20003/11/18 */
+    spSpecialReg[11] = "%dbbr"; 	/* "" -->"%dbbr"      T.Tazaki 20003/11/18 */
+    spSpecialReg[12] = "";
+    spSpecialReg[13] = "%usp";
+    spSpecialReg[14] = "%ssp";
+    spSpecialReg[15] = "%pc";
+
+    /*@ extract op1 */
+    uwOp1 = uwCode & 0x1e00;
+    uwOp1 >>= 9;
+
+    /*@ extract "d" */
+    uwDelay = uwCode & 0x0100;
+    uwDelay >>= 8;
+
+    if (uwOp1 < 4) {
+        /*@ Yes op1 : 0000 - 0011 */
+
+        /*@ extract op2 from code */
+        uwOp2 = uwCode & 0x00c0;
+        uwOp2 >>= 6;
+        /*@ extract bit4_5 from code */
+        uwBit4_5 = uwCode & 0x0030;
+        uwBit4_5 >>= 4;
+        /*@ extract bit0_3 from code */
+        uwBit0_3 = uwCode & 0x000f;
+
+        /*@ check if code is OK */
+        if (uwBit4_5 == 0) {
+            switch (uwOp1 << 2 | uwOp2) {   /* instruction */
+
+            case 0:     /* 0000:00 nop */
+
+                /*@ check if code is OK */
+                if ((uwDelay != 0) || (uwBit0_3 != 0)) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "nop");
+                }
+                break;
+
+            case 1:     /* 0000:01 slp */
+
+                /*@ check if code is OK */
+                if ((uwDelay != 0) || (uwBit0_3 != 0)) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "slp");
+                }
+                break;
+
+            case 2:     /* 0000:10 halt */
+
+                /*@ check if code is OK */
+                if ((uwDelay != 0) || (uwBit0_3 != 0)) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "halt");
+                }
+                break;
+
+            case 3:     /* 0000:11 reserved */
+
+                /*@ error */
+                (void) sprintf (pszBuf, "***");
+                break;
+
+            case 4:     /* 0001:00 pushn rs */
+
+                /*@ check if code is OK */
+                if (uwDelay != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "pushn    %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 5:     /* 0001:01 popn %rd */
+
+                /*@ check if code is OK */
+                if (uwDelay != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "popn     %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 6:     /* 0001:10 reserved */
+                /*@ error */
+                (void) sprintf (pszBuf, "***");
+                break;
+     
+            case 7:     /* 0001:11 jpr %rb */
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "jpr.d    %%r%d", uwBit0_3);
+                }
+                else {
+                    (void) sprintf (pszBuf, "jpr      %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 8:     /* 0010:00 brk */
+
+                /*@ check if code is OK */
+                if (uwBit0_3 == 0) {
+                    if (uwDelay != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                    }
+                    else {
+                    (void) sprintf (pszBuf, "brk");
+                    }
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 9:     /* 0010:01 retd */
+
+                /*@ check if code is OK */
+                if (uwBit0_3 == 0) {
+                    /*@ check if code is OK */
+                    if (uwDelay != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                    }
+                    else {
+                    (void) sprintf (pszBuf, "retd");
+                    }
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 10:        /* 0010:10 int imm2 */
+
+                /*@ check if code is OK */
+                if ((uwBit0_3 & 0xc) == 0) {
+                    /*@ check if code is OK */
+                    if (uwDelay != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                    }
+                    else {
+                    (void) sprintf (pszBuf, "int      0x%x", uwBit0_3);
+                    }
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 11:        /* 0010:11 reti */
+
+                /*@ check if code is OK */
+                if (uwBit0_3 == 0) {
+                    /*@ check if code is OK */
+                    if (uwDelay != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                    }
+                    else {
+                    (void) sprintf (pszBuf, "reti");
+                    }
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 12:        /* 0011:00 call rb */
+
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "call.d   %%r%d", uwBit0_3);
+                }
+                else {
+                    (void) sprintf (pszBuf, "call     %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 13:        /* 0011:01 ret */
+
+                /*@ check if code is OK */
+                if (uwBit0_3 == 0) {
+                    /*@ check if code is OK */
+                    if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "ret.d");
+                    }
+                    else {
+                    (void) sprintf (pszBuf, "ret");
+                    }
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 14:        /* 0011:10 jp rb */
+
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "jp.d     %%r%d", uwBit0_3);
+                }
+                else {
+                    (void) sprintf (pszBuf, "jp       %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 15:        /* 0011:11 reserved */
+
+                if (uwDelay == 0) {
+                    (void) sprintf (pszBuf, "retm");    /* 2002/10/01 */
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+            }
+        }
+        else if (uwBit4_5 == 1) 
+        {
+            switch (uwOp1 << 2 | uwOp2) {   /* instruction */
+
+            case 0:     /* 0000:00 push %rs , d=1 mac.w %rs*/
+
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "mac.w    %%r%d", uwBit0_3);
+                }
+                else {
+                    (void) sprintf (pszBuf, "push     %%r%d", uwBit0_3);
+                }
+                break;
+            
+            case 1:     /* 0000:01 pop %rd , d=1 mac.hw %rs*/
+
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "mac.hw   %%r%d", uwBit0_3);
+                }
+                else {
+                    (void) sprintf (pszBuf, "pop      %%r%d", uwBit0_3);
+                }
+                break;
+            
+            case 2:     /* 0000:10 pushs %ss , d=1 macclr */
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "macclr");
+                }else{
+//                  if (((uwBit0_3 >= 0) && (uwBit0_3 <= 9)) || ((uwBit0_3 >= 13) && (uwBit0_3 <= 15))){	/* change T.Tazaki 2003/11/18 */
+                    if (((uwBit0_3 >= 0) && (uwBit0_3 <= 11)) || ((uwBit0_3 >= 13) && (uwBit0_3 <= 15))){
+                        (void) sprintf (pszBuf, "pushs    %s", spSpecialReg[uwBit0_3]);
+                    }
+                    else {
+                        (void) sprintf (pszBuf, "***");
+                    }
+                }
+                break;
+            
+            case 3:     /* 0000:11 pops %sd , d=1 ld.cf */
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "ld.cf");
+                }else{
+//                  if (((uwBit0_3 >= 0) && (uwBit0_3 <= 9)) || ((uwBit0_3 >= 13) && (uwBit0_3 <= 15))){	/* change T.Tazaki 2003/11/18 */
+                    if (((uwBit0_3 >= 0) && (uwBit0_3 <= 11)) || ((uwBit0_3 >= 13) && (uwBit0_3 <= 15))){
+                        (void) sprintf (pszBuf, "pops     %s", spSpecialReg[uwBit0_3]);
+                    }
+                    else {
+                        (void) sprintf (pszBuf, "***");
+                    }
+                }
+                break;
+            
+            case 4:     /* 0001:00 divu.w %rb */
+                (void) sprintf (pszBuf, "divu.w   %%r%d", uwBit0_3);
+                break;
+
+            case 5:     /* 0001:01 div.w %rb , d=1 add &rd,%dp */
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "add      %%r%d,%%dp", uwBit0_3);
+                }else {
+                    (void) sprintf (pszBuf, "div.w    %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 6:    /* 0001:10 repeat %rb */
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "***");
+                }else {
+                    (void) sprintf (pszBuf, "repeat   %%r%d", uwBit0_3);
+                }
+                break;
+
+            case 7:    /* 0001:11 repeat imm4 */
+                if (uwDelay != 0) {
+                    (void) sprintf (pszBuf, "***");
+                }else {
+                    (void) sprintf (pszBuf, "repeat   0x%x", uwBit0_3);
+                }
+                break;
+
+            default:
+                /*@ error */
+                (void) sprintf (pszBuf, "***");
+                break;
+            }
+        }else{
+            /*@ error */
+            (void) sprintf (pszBuf, "***");
+        }
+    }
+    else {
+        /*@ No  op1 : 0100 - 1111 */
+
+        /*@ extract bit0_7 from code */
+        uwBit0_7 = uwCode & 0x00ff;
+
+        switch (uwOp1) {    /* instruction */
+
+        case 4:     /* 0100 jrgt sign9 */
+            (void) sprintf (pszBuf, "jrgt");
+            break;
+
+        case 5:     /* 0101 jrge sign9 */
+
+            (void) sprintf (pszBuf, "jrge");
+            break;
+
+        case 6:     /* 0110 jrlt sign9 */
+
+            (void) sprintf (pszBuf, "jrlt");
+            break;
+
+        case 7:     /* 0111 jrle sign9 */
+
+            (void) sprintf (pszBuf, "jrle");
+            break;
+
+        case 8:     /* 1000 jrugt sign9 */
+
+            (void) sprintf (pszBuf, "jrugt");
+            break;
+
+        case 9:     /* 1001 jruge sign9 */
+
+            (void) sprintf (pszBuf, "jruge");
+            break;
+
+        case 10:        /* 1010 jrult sign9 */
+
+            (void) sprintf (pszBuf, "jrult");
+            break;
+
+        case 11:        /* 1011 jrule sign9 */
+
+            (void) sprintf (pszBuf, "jrule");
+            break;
+
+        case 12:        /* 1100 jreq sign9 */
+
+            (void) sprintf (pszBuf, "jreq");
+            break;
+
+        case 13:        /* 1101 jrne sign9 */
+
+            (void) sprintf (pszBuf, "jrne");
+            break;
+
+        case 14:        /* 1110 call sign9 */
+
+            (void) sprintf (pszBuf, "call");
+            break;
+
+        case 15:        /* 1111 jp sign9 */
+
+            (void) sprintf (pszBuf, "jp");
+            break;
+        }
+        /*@ check if "d" bit exist */
+        if (uwDelay != 0) {
+            /*@ add ".d" to mnemonic */
+            (void) strcat (pszBuf, ".d");
+        }
+        iLoop = 9 - strlen( pszBuf );
+        for( i = 0; i < iLoop; ++i ){
+            (void) strcat (pszBuf, " ");
+        }
+
+        /*@ format mnemonic */
+        /*    pszBuf[8] = 0;    */
+
+        /*@ convert immediate value to string */
+        (void) sprintf (&szTmpBuf[0], "0x%x", uwBit0_7);
+
+        /*@ concatenate mnemonic and string */
+        (void) strcat (pszBuf, &szTmpBuf[0]);
+    }
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass1 : execute dis-assemble class1       *
+ ****************************************************************/
+
+
+static void
+vfnDisasmClass1 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwOp1, uwOp2;
+    unsigned short  uwBit0_3, uwBit4_7, uwBit0_1, uwBit2_3;
+
+    /*@ extract op1 from code */
+    uwOp1 = uwCode & 0x1c00;
+    uwOp1 >>= 10;
+    /*@ extract op2 from code */
+    uwOp2 = uwCode & 0x0300;    /* uwCode[9:8] */
+    uwOp2 >>= 8;
+    /*@ extract bit4_7 from code */
+    uwBit4_7 = uwCode & 0x00f0;
+    uwBit4_7 >>= 4;
+    /*@ extract bit0_3 from code */
+    uwBit0_3 = uwCode & 0x000f;
+
+    uwBit2_3 = uwBit0_3 & 0x000c;
+    uwBit2_3 >>= 2;
+    uwBit0_1 = uwBit0_3 & 0x0003;
+
+    switch (uwOp2) {        /* op2 */
+
+    case 0:         /* 00 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:00 ld.b rd,[rb] */
+
+                (void) sprintf (pszBuf, "ld.b     %%r%d,[%%r%d]", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:00 ld.ub rd,[rb] */
+
+                (void) sprintf (pszBuf, "ld.ub    %%r%d,[%%r%d]", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:00 ld.h rd,[rb] */
+
+                (void) sprintf (pszBuf, "ld.h     %%r%d,[%%r%d]", uwBit0_3, uwBit4_7);
+                break;
+
+            case 3:     /* 011:00 ld.uh rd,[rb] */
+
+                (void) sprintf (pszBuf, "ld.uh    %%r%d,[%%r%d]", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:00 ld.w rd,[rb] */
+
+                (void) sprintf (pszBuf, "ld.w     %%r%d,[%%r%d]", uwBit0_3, uwBit4_7);
+                break;
+
+            case 5:     /* 101:00 ld.b [rb],rs */
+
+                (void) sprintf (pszBuf, "ld.b     [%%r%d],%%r%d", uwBit4_7, uwBit0_3);
+                break;
+
+            case 6:     /* 110:00 ld.h [rb],rs */
+
+                (void) sprintf (pszBuf, "ld.h     [%%r%d],%%r%d", uwBit4_7, uwBit0_3);
+                break;
+
+            case 7:     /* 111:00 ld.w [rb],rs */
+
+                (void) sprintf (pszBuf, "ld.w     [%%r%d],%%r%d", uwBit4_7, uwBit0_3);
+                break;
+            }
+
+            break;
+
+    case 1:         /* 01 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:01 ld.b  rd,[rb]+ */
+
+                (void) sprintf (pszBuf, "ld.b     %%r%d,[%%r%d]+", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:01 ld.ub rd,[rb]+ */
+
+                (void) sprintf (pszBuf, "ld.ub    %%r%d,[%%r%d]+", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:01 ld.h  rd,[rb]+ */
+
+                (void) sprintf (pszBuf, "ld.h     %%r%d,[%%r%d]+", uwBit0_3, uwBit4_7);
+                break;
+
+            case 3:     /* 011:01 ld.uh rd,[rb]+ */
+
+                (void) sprintf (pszBuf, "ld.uh    %%r%d,[%%r%d]+", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:01 ld.w  rd,[rb]+ */
+
+                (void) sprintf (pszBuf, "ld.w     %%r%d,[%%r%d]+", uwBit0_3, uwBit4_7);
+                break;
+
+            case 5:     /* 101:01 ld.b  [rb]+,rs */
+
+                (void) sprintf (pszBuf, "ld.b     [%%r%d]+,%%r%d", uwBit4_7, uwBit0_3);
+                break;
+
+            case 6:     /* 110:01 ld.h  [rb]+,rs */
+
+                (void) sprintf (pszBuf, "ld.h     [%%r%d]+,%%r%d", uwBit4_7, uwBit0_3);
+                break;
+
+            case 7:     /* 111:01 ld.w  [rb]+,rs */
+
+                (void) sprintf (pszBuf, "ld.w     [%%r%d]+,%%r%d", uwBit4_7, uwBit0_3);
+                break;
+            }
+
+            break;
+
+    case 2:         /* 10 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:10 add   rd,rs */
+
+                (void) sprintf (pszBuf, "add      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:10 sub   rd,rs */
+
+                (void) sprintf (pszBuf, "sub      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:10 cmp   rd,rs */
+
+                (void) sprintf (pszBuf, "cmp      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 3:     /* 011:10 ld.w  rd,rs */
+
+                (void) sprintf (pszBuf, "ld.w     %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:10 and   rd,rs */
+
+                (void) sprintf (pszBuf, "and      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 5:     /* 101:10 or    rd,rs */
+
+                (void) sprintf (pszBuf, "or       %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 6:     /* 110:10 xor   rd,rs */
+
+                (void) sprintf (pszBuf, "xor      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 7:     /* 111:10 not   rd,rs */
+
+                (void) sprintf (pszBuf, "not      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+            }
+
+            break;
+
+    case 3:         /* 11 */
+    
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:11 srl   rd,imm4 */
+            
+                /* class4-->class1 convert，add 16 */
+                uwBit4_7 += 16;
+
+                (void) sprintf (pszBuf, "srl      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:11 sll   rd,imm4 */
+            
+                /* class4-->class1 convert，add 16 */
+                uwBit4_7 += 16;
+
+                (void) sprintf (pszBuf, "sll      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:11 sra   rd,imm4 */
+            
+                /* class4-->class1 convert，add 16 */
+                uwBit4_7 += 16;
+
+                (void) sprintf (pszBuf, "sra      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 3:     /* 011:11 sla  rd,imm4 */
+            
+                /* class4-->class1 convert，add 16 */
+                uwBit4_7 += 16;
+
+                (void) sprintf (pszBuf, "sla      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:11 rr   rd,imm4 */
+            
+                /* class4-->class1 convert，add 16 */
+                uwBit4_7 += 16;
+
+                (void) sprintf (pszBuf, "rr       %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 5:     /* 101:11 rl   rd,imm4 */
+            
+                /* class4-->class1 convert，add 16 */
+                uwBit4_7 += 16;
+
+                (void) sprintf (pszBuf, "rl       %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 6:
+
+                if( uwBit4_7 == 0 ) {
+                    
+                    /* ext  OP,imm2 */
+                    if( uwBit2_3 > 0 ) {
+                        (void) sprintf (pszBuf, "ext      %s,0x%x", szOpShift[ uwBit2_3 - 1 ], uwBit0_1);
+                    }
+                }else{
+                    /* ext Cond */
+                    if( uwBit4_7 >= 4 && uwBit4_7 <= 0x0d ) {
+                        (void) sprintf (pszBuf, "ext      %s",szCond[ uwBit4_7 - 4 ] );
+                    }
+                }
+                break;
+
+            case 7:
+
+                if( uwBit0_3 == 0 ) {
+                    
+                    /* ext  %rs */
+                    (void) sprintf (pszBuf, "ext      %%r%d", uwBit4_7);
+                }else{
+                    /* ext %rs,OP,imm2 */
+                    if( uwBit2_3 > 0 ) {
+                        (void) sprintf (pszBuf, "ext      %%r%d,%s,0x%x", 
+                                            uwBit4_7,szOpShift[ uwBit2_3 - 1 ], uwBit0_1);
+                    }
+                }
+
+                break;
+            }
+
+            break;
+    }
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass2 : execute dis-assemble class2       *
+ ****************************************************************/
+
+static void
+vfnDisasmClass2 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwOp1;
+    unsigned short  uwBit0_3, uwBit4_9;
+
+    /*@ extract op1 from code */
+    uwOp1 = uwCode & 0x1c00;
+    uwOp1 >>= 10;
+    /*@ extract bit4_9 from code */
+    uwBit4_9 = uwCode & 0x03f0;
+    uwBit4_9 >>= 4;
+    /*@ extract bit0_3 from code */
+    uwBit0_3 = uwCode & 0x000f;
+
+    switch (uwOp1) {        /* op1 */
+
+    case 0:         /* 000 ld.b rd,[sp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.b     %%r%d,[%%sp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 1:         /* 001 ld.ub rd,[sp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.ub    %%r%d,[%%sp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 2:         /* 010 ld.h rd,[sp+imm7] */
+
+    (void) sprintf (pszBuf, "ld.h     %%r%d,[%%sp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 3:         /* 011 ld.uh rd,[sp+imm7] */
+
+    (void) sprintf (pszBuf, "ld.uh    %%r%d,[%%sp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 4:         /* 100 ld.w rd,[sp+imm8] */
+
+    (void) sprintf (pszBuf, "ld.w     %%r%d,[%%sp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 5:         /* 101 ld.b [sp+imm6],rs */
+
+    (void) sprintf (pszBuf, "ld.b     [%%sp+0x%x],%%r%d", uwBit4_9, uwBit0_3);
+    break;
+
+    case 6:         /* 110 ld.h [sp+imm7],rs */
+
+    (void) sprintf (pszBuf, "ld.h     [%%sp+0x%x],%%r%d", uwBit4_9, uwBit0_3);
+    break;
+
+    case 7:         /* 111 ld.w [sp+imm8],rs */
+
+    (void) sprintf (pszBuf, "ld.w     [%%sp+0x%x],%%r%d", uwBit4_9, uwBit0_3);
+    break;
+    }
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass3 : execute dis-assemble class3       *
+ ****************************************************************/
+
+
+static void
+vfnDisasmClass3 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwOp1;
+    unsigned short  uwBit0_3, uwBit4_9;
+    unsigned long   ulSign32;
+
+    /*@ extract op1 from code */
+    uwOp1 = uwCode & 0x1c00;
+    uwOp1 >>= 10;
+    /*@ extract bit4_9 from code */
+    uwBit4_9 = uwCode & 0x03f0;
+    uwBit4_9 >>= 4;
+    /*@ extract bit0_3 from code */
+    uwBit0_3 = uwCode & 0x000f;
+
+    switch (uwOp1) {        /* op1 */
+
+    case 0:         /* 000 add rd,imm6 */
+
+    (void) sprintf (pszBuf, "add      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    break;
+
+    case 1:         /* 001 sub rd,imm6 */
+
+    (void) sprintf (pszBuf, "sub      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    break;
+
+    case 2:         /* 010 cmp rd,sign6 */
+
+/* >>>>> add tazaki 2001.10.10 */
+    if( uwBit4_9 & 0x20 ){      
+        if( g_iExtCnt > 0 ){
+            (void) sprintf (pszBuf, "cmp      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+        }else{
+            ulSign32 = 0xffffffc0 + uwBit4_9;   /* Mark extension */
+            (void) sprintf (pszBuf, "xcmp     %%r%d,0x%x", uwBit0_3, ulSign32);
+        }
+    }else{
+        (void) sprintf (pszBuf, "cmp      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    }
+/* <<<<< add tazaki 2001.10.10 */
+/*      (void) sprintf (pszBuf, "cmp\tr%d,0x%x", uwBit0_3, uwBit4_9);   del tazaki 2001.10.10 */
+    break;
+
+    case 3:         /* 011 ld.w rd,sign6 */
+
+/* >>>>> add tazaki 2001.10.10 */
+    if( uwBit4_9 & 0x20 ){
+        if( g_iExtCnt > 0 ){
+            (void) sprintf (pszBuf, "ld.w     %%r%d,0x%x", uwBit0_3, uwBit4_9);
+        }else{
+            ulSign32 = 0xffffffc0 + uwBit4_9;   /* Mark extension */
+            (void) sprintf (pszBuf, "xld.w    %%r%d,0x%x", uwBit0_3, ulSign32);
+        }
+    }else{
+        (void) sprintf (pszBuf, "ld.w     %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    }
+/* <<<<< add tazaki 2001.10.10 */
+/*     (void) sprintf (pszBuf, "ld.w\tr%d,0x%x", uwBit0_3, uwBit4_9); del tazaki 2001.10.10 */
+    break;
+
+    case 4:         /* 100 and rd,sign6 */
+/* >>>>> add tazaki 2001.10.10 */
+    if( uwBit4_9 & 0x20 ){
+        if( g_iExtCnt > 0 ){
+            (void) sprintf (pszBuf, "and      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+        }else{
+            ulSign32 = 0xffffffc0 + uwBit4_9;   /* Mark extension */
+            (void) sprintf (pszBuf, "xand     %%r%d,0x%x", uwBit0_3, ulSign32);
+        }
+    }else{
+        (void) sprintf (pszBuf, "and      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    }
+/* <<<<< add tazaki 2001.10.10 */
+
+/*    (void) sprintf (pszBuf, "and\tr%d,0x%x", uwBit0_3, uwBit4_9); del tazaki 2001.10.10 */
+    break;
+
+    case 5:         /* 101 or rd,sign6 */
+
+/* >>>>> add tazaki 2001.10.10 */
+    if( uwBit4_9 & 0x20 ){
+        if( g_iExtCnt > 0 ){
+            (void) sprintf (pszBuf, "or       %%r%d,0x%x", uwBit0_3, uwBit4_9);
+        }else{
+            ulSign32 = 0xffffffc0 + uwBit4_9;   /* Mark extension */
+            (void) sprintf (pszBuf, "xoor     %%r%d,0x%x", uwBit0_3, ulSign32);
+        }
+    }else{
+        (void) sprintf (pszBuf, "or       %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    }
+/* <<<<< add tazaki 2001.10.10 */
+/*    (void) sprintf (pszBuf, "or\tr%d,0x%x", uwBit0_3, uwBit4_9); del tazaki 2001.10.10 */
+    break;
+
+    case 6:         /* 110 xor rd,sign6 */
+
+/* >>>>> add tazaki 2001.10.10 */
+    if( uwBit4_9 & 0x20 ){
+        if( g_iExtCnt > 0 ){
+            (void) sprintf (pszBuf, "xor      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+        }else{
+            ulSign32 = 0xffffffc0 + uwBit4_9;   /* Mark extension */
+            (void) sprintf (pszBuf, "xxor     %%r%d,0x%x", uwBit0_3, ulSign32);
+        }
+    }else{
+        (void) sprintf (pszBuf, "xor      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    }
+/* <<<<< add tazaki 2001.10.10 */
+/*    (void) sprintf (pszBuf, "xor\tr%d,0x%x", uwBit0_3, uwBit4_9);  del tazaki 2001.10.10 */
+    break;
+
+    case 7:         /* 111 not rd,sign6 */
+
+/* >>>>> add tazaki 2001.10.10 */
+    if( uwBit4_9 & 0x20 ){
+        if( g_iExtCnt > 0 ){
+            (void) sprintf (pszBuf, "not      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+        }else{
+            ulSign32 = 0xffffffc0 + uwBit4_9;   /* Mark extension */
+            (void) sprintf (pszBuf, "xnot     %%r%d,0x%x", uwBit0_3, ulSign32);
+        }
+    }else{
+        (void) sprintf (pszBuf, "not      %%r%d,0x%x", uwBit0_3, uwBit4_9);
+    }
+/* <<<<< add tazaki 2001.10.10 */
+/*    (void) sprintf (pszBuf, "not\tr%d,0x%x", uwBit0_3, uwBit4_9);  del tazaki 2001.10.10 */
+    break;
+    }
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass4 : execute dis-assemble class4       *
+ ****************************************************************/
+
+static void
+vfnDisasmClass4 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwOp1, uwOp2;
+    unsigned short  uwBit0_3, uwBit4_7, uwBit0_9;
+
+    /*@ extract op1 from code */
+    uwOp1 = uwCode & 0x1c00;
+    uwOp1 >>= 10;
+    /*@ extract op2 from code */
+    uwOp2 = uwCode & 0x0300;
+    uwOp2 >>= 8;
+    /*@ extract bit0_9 from code */
+    uwBit0_9 = uwCode & 0x03ff;
+    /*@ extract bit4_7 from code */
+    uwBit4_7 = uwCode & 0x00f0;
+    uwBit4_7 >>= 4;
+    /*@ extract bit0_3 from code */
+    uwBit0_3 = uwCode & 0x000f;
+
+    if (uwOp1 == 0) {
+    /* 000 add sp,imm12 */
+    (void) sprintf (pszBuf, "add      %%sp,0x%x", uwBit0_9);
+    }
+    else if (uwOp1 == 1) {
+    /* 001 sub sp,imm12 */
+    (void) sprintf (pszBuf, "sub      %%sp,0x%x", uwBit0_9);
+    }
+    else {
+    /*@ op1 : 010 - 111 */
+
+    switch (uwOp2) {    /* op2 */
+
+    case 0:     /* op2 = 00 */
+
+        if( g_iShiftFlag == 1 ){
+            uwBit4_7 += 16;
+        }
+
+        switch (uwOp1) {    /* op1 */
+
+        case 2:     /* 010 srl rd,imm4 */
+
+        (void) sprintf (pszBuf, "srl      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+        break;
+
+        case 3:     /* 011 sll rd,imm4 */
+
+        (void) sprintf (pszBuf, "sll      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+        break;
+
+        case 4:     /* 100 sra rd,imm4 */
+
+        (void) sprintf (pszBuf, "sra      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+        break;
+
+        case 5:     /* 101 sla rd,imm4 */
+
+        (void) sprintf (pszBuf, "sla      %%r%d,0x%x", uwBit0_3, uwBit4_7);
+        break;
+
+        case 6:     /* 110 rr rd,imm4 */
+
+        (void) sprintf (pszBuf, "rr       %%r%d,0x%x", uwBit0_3, uwBit4_7);
+        break;
+
+        case 7:     /* 111 rl rd,imm4 */
+
+        (void) sprintf (pszBuf, "rl       %%r%d,0x%x", uwBit0_3, uwBit4_7);
+        break;
+        }
+
+        break;
+
+    case 1:     /* op2 = 01 */
+
+        switch (uwOp1) {    /* op1 */
+
+        case 2:     /* 010 srl rd,rs */
+
+        (void) sprintf (pszBuf, "srl      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 3:     /* 011 sll rd,rs */
+
+        (void) sprintf (pszBuf, "sll      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 4:     /* 100 sra rd,rs */
+
+        (void) sprintf (pszBuf, "sra      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 5:     /* 101 sla rd,rs */
+
+        (void) sprintf (pszBuf, "sla      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 6:     /* 110 rr rd,rs */
+
+        (void) sprintf (pszBuf, "rr       %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 7:     /* 111 rl rd,rs */
+
+        (void) sprintf (pszBuf, "rl       %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+        }
+
+        break;
+
+    case 2:     /* op2 = 10 */
+
+        switch (uwOp1) {    /* op1 */
+
+        case 2:     /* scan0 rd,rs */
+
+        (void) sprintf (pszBuf, "scan0    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 3:     /* scan1 rd,rs */
+
+        (void) sprintf (pszBuf, "scan1    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 4:     /* swap rd,rs */
+
+        (void) sprintf (pszBuf, "swap     %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 5:     /* mirror rd,rs */
+
+        (void) sprintf (pszBuf, "mirror   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 6:     /* swaph rd,rs */
+
+        (void) sprintf (pszBuf, "swaph    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        case 7:     /* sat.b rd,rs */
+
+        (void) sprintf (pszBuf, "sat.b    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+
+        /*@ error */
+        (void) sprintf (pszBuf, "***");
+        break;
+        }
+
+        break;
+
+    case 3:     /* op2 = 11 */
+
+        switch (uwOp1) {    /* op1 */
+
+        case 2:     /* div0s rs */
+
+        (void) sprintf (pszBuf, "div0s    %%r%d", uwBit4_7);
+        break;
+
+        case 3:     /* div0u rs */
+
+        (void) sprintf (pszBuf, "div0u    %%r%d", uwBit4_7);
+        break;
+
+        case 4:     /* div1 rs */
+
+        (void) sprintf (pszBuf, "div1     %%r%d", uwBit4_7);
+        break;
+
+        case 5:     /* div2s rs */
+
+        (void) sprintf (pszBuf, "div2s    %%r%d", uwBit4_7);
+        break;
+
+        case 6:     /* div3s */
+
+        (void) sprintf (pszBuf, "div3s");
+        break;
+
+        case 7:     /* sat.ub rd,rs */
+
+        (void) sprintf (pszBuf, "sat.ub   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+        break;
+        }
+
+        break;
+    }
+    }
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass5 : execute dis-assemble class5       *
+ ****************************************************************/
+
+static void
+vfnDisasmClass5 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwOp1, uwOp2, uwOp3;
+    unsigned short  uwBit0_3, uwBit4_7, uwBit0_5;
+    char           *spSpecialReg[16];
+
+    /*@ initialize */   
+    spSpecialReg[0]  = "%psr";
+    spSpecialReg[1]  = "%sp";
+    spSpecialReg[2]  = "%alr";
+    spSpecialReg[3]  = "%ahr";
+    spSpecialReg[4]  = "%lco";
+    spSpecialReg[5]  = "%lsa";
+    spSpecialReg[6]  = "%lea";
+    spSpecialReg[7]  = "%sor";
+    spSpecialReg[8]  = "%ttbr";
+    spSpecialReg[9]  = "%dp";
+    spSpecialReg[10] = "%idir";		/* "" -->"%idir"      T.Tazaki 20003/11/18 */
+    spSpecialReg[11] = "%dbbr";		/* "" -->"%dbbr"      T.Tazaki 20003/11/18 */
+    spSpecialReg[12] = "";
+    spSpecialReg[13] = "%usp";
+    spSpecialReg[14] = "%ssp";
+    spSpecialReg[15] = "%pc";
+
+    /*@ extract op1 from code */
+    uwOp1 = uwCode & 0x1c00;
+    uwOp1 >>= 10;
+    /*@ extract op2 from code */
+    uwOp2 = uwCode & 0x0300;
+    uwOp2 >>= 8;
+    /*@ extract op3 from code */
+    uwOp3 = uwCode & 0x00c0;
+    uwOp3 >>= 6;
+    /*@ extract bit4_7 from code */
+    uwBit4_7 = uwCode & 0x00f0;
+    uwBit4_7 >>= 4;
+    /*@ extract bit0_3 from code */
+    uwBit0_3 = uwCode & 0x000f;
+    /*@ extract bit0_5 from code */
+    uwBit0_5 = uwCode & 0x003f;
+
+    switch (uwOp2) {        /* op2 */
+
+    case 0:         /* 00 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:00 ld.w %sd,rs */
+
+                /*@ check if code is OK */
+                if (((uwBit0_3 >= 0) && (uwBit0_3 <= 9)) || ((uwBit0_3 >= 13) && (uwBit0_3 <= 15))){
+                    (void) sprintf (pszBuf, "ld.w     %s,%%r%d", spSpecialReg[uwBit0_3], uwBit4_7);
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 1:     /* 001:00 ld.w rd,%ss */
+
+                /*@ check if code is OK */
+//              if (((uwBit4_7 >= 0) && (uwBit4_7 <= 9)) || ((uwBit4_7 >= 13) && (uwBit4_7 <= 15))){	/* change T.Tazaki 2003/11/18 */
+                if (((uwBit4_7 >= 0) && (uwBit4_7 <= 11)) || ((uwBit4_7 >= 13) && (uwBit4_7 <= 15))){
+                    (void) sprintf (pszBuf, "ld.w     %%r%d,%s", uwBit0_3, spSpecialReg[uwBit4_7]);
+                }
+                else {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                break;
+
+            case 2:     /* 010:00 btst [rb],imm3 */
+
+                /*@ check if code is OK */
+                if ((uwBit0_3 & 0x8) != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "btst     [%%r%d],0x%d", uwBit4_7, uwBit0_3);
+                }
+                break;
+
+            case 3:     /* 011:00 bclr [rb],imm3 */
+
+                /*@ check if code is OK */
+                if ((uwBit0_3 & 0x8) != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "bclr     [%%r%d],0x%d", uwBit4_7, uwBit0_3);
+                }
+                break;
+
+            case 4:     /* 100:00 bset [rb],imm3 */
+
+                /*@ check if code is OK */
+                if ((uwBit0_3 & 0x8) != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "bset     [%%r%d],0x%d", uwBit4_7, uwBit0_3);
+                }
+                break;
+
+            case 5:     /* 101:00 bnot [rb],imm3 */
+
+                /*@ check if code is OK */
+                if ((uwBit0_3 & 0x8) != 0) {
+                    /*@ error */
+                    (void) sprintf (pszBuf, "***");
+                }
+                else {
+                    (void) sprintf (pszBuf, "bnot     [%%r%d],0x%d", uwBit4_7, uwBit0_3);
+                }
+                break;
+
+            case 6:     /* 110:00 adc  rd,rs */
+
+                (void) sprintf (pszBuf, "adc      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 7:     /* 111:00 sbc  rd,rs */
+
+                (void) sprintf (pszBuf, "sbc      %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+            }
+
+            break;
+
+    case 1:         /* 01 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:01 ld.b  rd,rs */
+
+                (void) sprintf (pszBuf, "ld.b     %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:01 ld.ub  rd,rs */
+
+                (void) sprintf (pszBuf, "ld.ub    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:01 ld.h  rd,rs */
+
+                (void) sprintf (pszBuf, "ld.h     %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 3:     /* 011:01 ld.uh rd,rs */
+
+                (void) sprintf (pszBuf, "ld.uh    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:01 ld.c rd,imm4 */
+
+                (void) sprintf (pszBuf, "ld.c     %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 5:     /* 101:01 ld.c imm4,rs */
+
+                (void) sprintf (pszBuf, "ld.c     0x%x,%%r%d", uwBit4_7, uwBit0_3);
+                break;
+
+            case 6:     /* 110:01 loop rc,ra */
+
+                (void) sprintf (pszBuf, "loop     %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 7:     /* 111:01 sat.w rd,rs */
+
+                (void) sprintf (pszBuf, "sat.w    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            default:
+                /*@ error */
+                (void) sprintf (pszBuf, "***");
+                break;
+            }
+
+            break;
+
+    case 2:         /* 10 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:10 mlt.h  rd,rs */
+
+                (void) sprintf (pszBuf, "mlt.h    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:10 mltu.h  rd,rs */
+
+                (void) sprintf (pszBuf, "mltu.h   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:10 mlt.w  rd,rs */
+
+                (void) sprintf (pszBuf, "mlt.w    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 3:     /* 011:10 mltu.w rd,rs */
+
+                (void) sprintf (pszBuf, "mltu.w   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:10 mac rs */
+
+                (void) sprintf (pszBuf, "mac      %%r%d", uwBit4_7);
+                break;
+
+            case 5:     /* 101:10 sat.h rd,rs */
+
+                (void) sprintf (pszBuf, "sat.h    %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 6:     /* 110:10 loop rc,imm4 */
+
+                (void) sprintf (pszBuf, "loop     %%r%d,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 7:     /* 111:10 sat.uw rd,rs */
+
+                (void) sprintf (pszBuf, "sat.uw   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            default:
+            
+                /*@ error */
+                (void) sprintf (pszBuf, "***");
+                break;
+            }
+
+            break;
+
+    case 3:         /* 11 */
+
+            switch (uwOp1) {    /* op1 */
+
+            case 0:     /* 000:11 mlt.hw  rd,rs */
+
+                (void) sprintf (pszBuf, "mlt.hw   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 1:     /* 001:11 mac1.h  rd,rs */
+
+                (void) sprintf (pszBuf, "mac1.h   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 2:     /* 010:11 mac1.hw  rd,rs */
+
+                (void) sprintf (pszBuf, "mac1.hw  %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 4:     /* 100:11 mac1.w  rd,rs */
+
+                (void) sprintf (pszBuf, "mac1.w   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 5:     /* 101:11 sat.uh  rd,rs */
+
+                (void) sprintf (pszBuf, "sat.uh   %%r%d,%%r%d", uwBit0_3, uwBit4_7);
+                break;
+
+            case 6:     /* 110:11 loop  imm4,imm4 */
+
+                (void) sprintf (pszBuf, "loop     0x%x,0x%x", uwBit0_3, uwBit4_7);
+                break;
+
+            case 7:     /* 111:11 */
+
+                switch( uwOp3 ) {   /* op3 */
+
+                case 0: /* 111:11:00    do.c imm6 */
+                        (void) sprintf (pszBuf, "do.c     0x%x", uwBit0_5);
+                        break;
+                case 1: /* 111:11:01    psrset imm5 */
+                        (void) sprintf (pszBuf, "psrset   0x%x", uwBit0_5);
+                        break;
+                case 2: /* 111:11:10    psrclr imm5 */
+                        (void) sprintf (pszBuf, "psrclr   0x%x", uwBit0_5);
+                        break;
+                default:
+                        /*@ error */
+                        (void) sprintf (pszBuf, "***");
+                        break;
+                }
+                break;
+
+            default:
+                /*@ error */
+                (void) sprintf (pszBuf, "***");
+                break;
+            }
+            
+            break;
+    }
+}
+
+/****************************************************************
+ *  vfnDisasmClass6 : execute dis-assemble class6       *
+ ****************************************************************/
+
+static void
+vfnDisasmClass6 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwBit0_12;
+
+    /*@ extract bit0_12 from code */
+    uwBit0_12 = uwCode & 0x1fff;
+
+    (void) sprintf (pszBuf, "ext      0x%x", uwBit0_12);
+
+    return;
+}
+
+/****************************************************************
+ *  vfnDisasmClass7 : execute dis-assemble class7       *
+ ****************************************************************/
+
+static void
+vfnDisasmClass7 (uwCode, pszBuf)
+     unsigned short  uwCode;    /* 16bit code */
+     char           *pszBuf;
+
+
+{
+    unsigned short  uwOp1;
+    unsigned short  uwBit0_3, uwBit4_9;
+
+    /*@ extract op1 from code */
+    uwOp1 = uwCode & 0x1c00;
+    uwOp1 >>= 10;
+    /*@ extract bit4_9 from code */
+    uwBit4_9 = uwCode & 0x03f0;
+    uwBit4_9 >>= 4;
+    /*@ extract bit0_3 from code */
+    uwBit0_3 = uwCode & 0x000f;
+
+    switch (uwOp1) {        /* op1 */
+
+    case 0:         /* 000 ld.b rd,[dp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.b     %%r%d,[%%dp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 1:         /* 001 ld.ub rd,[dp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.ub    %%r%d,[%%dp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 2:         /* 010 ld.h rd,[dp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.h     %%r%d,[%%dp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 3:         /* 011 ld.uh rd,[dp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.uh    %%r%d,[%%dp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 4:         /* 100 ld.w rd,[dp+imm6] */
+
+    (void) sprintf (pszBuf, "ld.w     %%r%d,[%%dp+0x%x]", uwBit0_3, uwBit4_9);
+    break;
+
+    case 5:         /* 101 ld.b [dp+imm6],rs */
+
+    (void) sprintf (pszBuf, "ld.b     [%%dp+0x%x],%%r%d", uwBit4_9, uwBit0_3);
+    break;
+
+    case 6:         /* 110 ld.h [dp+imm6],rs */
+
+    (void) sprintf (pszBuf, "ld.h     [%%dp+0x%x],%%r%d", uwBit4_9, uwBit0_3);
+    break;
+
+    case 7:         /* 111 ld.w [dp+imm6],rs */
+
+    (void) sprintf (pszBuf, "ld.w     [%%dp+0x%x],%%r%d", uwBit4_9, uwBit0_3);
+    break;
+    }
+
+    return;
+}
+
+/* <<<<<<<<<<<<<<< add tazaki 2001.07.31 */
+
+
+int 
+print_insn_c33 (memaddr, info)
+     bfd_vma memaddr;
+     struct disassemble_info * info;
+{
+    int           status;
+    bfd_byte      buffer[ 4 ];
+    unsigned long insn = 0;
+
+    /* First figure out how big the opcode is.  */
+
+    status = info->read_memory_func (memaddr, buffer, 2, info);
+    if (status == 0)
+    {
+        insn = bfd_getl16 (buffer);
+    }
+
+    if (status != 0)
+    {
+        info->memory_error_func (status, memaddr, info);
+        return -1;
+    }
+
+    /* Make sure we tell our caller how many bytes we consumed.  */
+    return disassemble (memaddr, info, insn);
+}
diff --git a/opcodes/c33-opc.c b/opcodes/c33-opc.c
new file mode 100644
index 0000000..797dd1a
--- /dev/null
+++ b/opcodes/c33-opc.c
@@ -0,0 +1,2146 @@
+/* Assemble V850 instructions.
+   Copyright (C) 1996 Free Software Foundation, Inc.
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "opcode/c33.h"
+#include <stdio.h>
+#include "opintl.h"
+
+#if 0   /* c33 */
+/* regular opcode */
+#define OP(x)       ((x & 0x3f) << 5)
+#define OP_MASK     OP (0x3f)
+#endif  /* c33 */
+
+/* c33 addition */
+#define OP_CLASS0_1(x)  ((x & 0x3ff) << 6)
+#define OP_CLASS0_2(x)  ((x & 0xff) << 8)
+#define OP_CLASS1(x)    ((x & 0xff) << 8)   
+#define OP_CLASS2(x)    ((x & 0x3f) << 10)
+#define OP_CLASS3(x)    ((x & 0x3f) << 10)
+#define OP_CLASS4_1(x)  ((x & 0x3f) << 10)
+#define OP_CLASS4_2(x)  OP_CLASS1(x)            /* shift/rotate,div */
+#define OP_CLASS5(x)    OP_CLASS1(x)
+#define OP_CLASS6(x)    ((x & 0x7) << 13)
+#define OP_CLASS7(x)    ((x & 0x3f) << 10)
+
+#define OP_CLASS0_1_MASK    OP_CLASS0_1(0x3ff)
+#define OP_CLASS0_2_MASK    OP_CLASS0_2(0xff)
+#define OP_CLASS1_MASK      OP_CLASS1(0xff)
+#define OP_CLASS2_MASK      OP_CLASS2(0x3f)
+#define OP_CLASS3_MASK      OP_CLASS3(0x3f)
+#define OP_CLASS4_1_MASK    OP_CLASS4_1(0xff)
+#define OP_CLASS4_2_MASK    OP_CLASS4_2(0xff)
+#define OP_CLASS5_MASK      OP_CLASS5(0xff)
+#define OP_CLASS6_MASK      OP_CLASS6(0x7)
+#define OP_CLASS7_MASK      OP_CLASS7(0x3f)
+
+
+#if 0
+/* The functions used to insert and extract complicated operands.  */
+
+/* Note: There is a conspiracy between these functions and
+   v850_insert_operand() in gas/config/tc-v850.c.  Error messages
+   containing the string 'out of range' will be ignored unless a
+   specific command line option is given to GAS.  */
+
+static const char * not_valid    = N_ ("displacement value is not in range and is not aligned");
+static const char * out_of_range = N_ ("displacement value is out of range");
+static const char * not_aligned  = N_ ("displacement value is not aligned");
+
+static const char * immediate_out_of_range = N_ ("immediate value is out of range");
+
+static unsigned long
+insert_d5_4 (insn, value, errmsg)
+     unsigned long insn;
+     long          value;
+     const char ** errmsg;
+{
+  if (value > 0x1f || value < 0)
+    {
+      if (value & 1)
+    * errmsg = _(not_valid);
+      else
+    *errmsg = _(out_of_range);
+    }
+  else if (value & 1)
+    * errmsg = _(not_aligned);
+
+  value >>= 1;
+
+  return (insn | (value & 0x0f));
+}
+
+static unsigned long
+extract_d5_4 (insn, invalid)
+     unsigned long insn;
+     int *         invalid;
+{
+  unsigned long ret = (insn & 0x0f);
+
+  return ret << 1;
+}
+#endif
+
+
+/* Warning: code in gas/config/tc-v850.c examines the contents of this array.
+   If you change any of the values here, be sure to look for side effects in
+   that code. */
+const struct c33_operand c33_operands[] =
+{
+#define UNUSED  0
+  { 0, 0, NULL, NULL, 0, 0 }, 
+
+#define SP      1
+  { 0, 0, NULL, NULL, C33_OPERAND_SP, 0}, 
+
+#define RD      2                               
+  { 4, 0, NULL, NULL, C33_OPERAND_REG, 0}, 
+
+#define RS      3                               
+  { 4, 0, NULL, NULL, C33_OPERAND_REG, 0 },
+
+#define RS2     4                               
+  { 4, 4, NULL, NULL, C33_OPERAND_REG, 0},
+
+#define SD      5
+  { 4, 0, NULL, NULL, C33_OPERAND_SREG, 0}, 
+
+#define SS      6
+  { 4, 4, NULL, NULL, C33_OPERAND_SREG, 0}, 
+
+#define RB0     7
+  { 4, 0, NULL, NULL, C33_OPERAND_REG, 0},
+
+#define RB      8
+  { 4, 4, NULL, NULL, C33_OPERAND_RB, 0},
+
+#define MEM_IMM13   9                                   /* sld,sbit */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM, 13},
+
+#define MEM_IMM26   10                                  /* xld,xbit */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM, 26},
+
+#define REGINC  11                          
+  { 4, 4, NULL, NULL, C33_OPERAND_REGINC, 0},
+
+#define SIGN6   12                          
+  { 6, 4, NULL, NULL, C33_OPERAND_SIGNED, 6}, 
+
+#define SIGN8   13                          
+  { 8, 0, NULL, NULL, C33_OPERAND_SIGNED, 8}, 
+
+#define SIGN32  14                          
+  { 6, 4, NULL, NULL, C33_OPERAND_SIGNED, 32}, 
+
+#define IMM2    15                      
+  { 2, 0, NULL, NULL, C33_OPERAND_IMM, 2}, 
+
+#define IMM3    16                              
+  { 3, 0, NULL, NULL, C33_OPERAND_IMM, 3}, 
+
+#define IMM4    17                              
+  { 4, 4, NULL, NULL, C33_OPERAND_IMM, 4}, 
+
+#define IMM5    18                          
+  { 4, 4, NULL, NULL, C33_OPERAND_IMM, 5}, 
+
+#define IMM6    19
+  { 6, 4, NULL, NULL, C33_OPERAND_IMM, 6}, 
+
+#define IMM10   20
+  { 10, 0, NULL, NULL, C33_OPERAND_IMM, 10}, 
+
+#define IMM32   21
+  { 6, 4, NULL, NULL, C33_OPERAND_IMM, 32}, 
+
+#define SPIMM6  22                              
+  { 6, 4, NULL, NULL, C33_OPERAND_SPMEM, 6}, 
+
+#define SPIMM32 23                                  /* xld,sld,xbit,sbit */
+  { 6, 4, NULL, NULL, C33_OPERAND_SPMEM, 32}, 
+
+#define IMM13_LABEL 24                          
+//  { 13, 0, NULL, NULL, C33_OPERAND_IMM | C33_OPERAND_LABEL, 13},    /* ext */ 
+  { 13, 0, NULL, NULL, C33_OPERAND_SIGNED | C33_OPERAND_LABEL, 13},    /* ext */ 	/* change 2005/04/07 T.Tazaki */
+
+#define SIGN32_LABELIMM32   25
+  { 8, 0, NULL, NULL, C33_OPERAND_SIGNED | C33_OPERAND_LABEL | C33_OPERAND_PC, 32}, /* jp,call */
+
+#define SIGN32_SYMBOLIMM32  26
+  { 6, 4, NULL, NULL, C33_OPERAND_SIGNED | C33_OPERAND_SYMBOL, 32}, /* xld.w*/
+
+#define SIGN6_SYMBOLIMM6    27
+  { 6, 4, NULL, NULL, C33_OPERAND_SIGNED | C33_OPERAND_SYMBOL, 6}, /* ld.w */
+
+#define SYMBOLIMM19 28
+  { 6, 4, NULL, NULL, C33_OPERAND_IMM | C33_OPERAND_SYMBOL, 19}, /* sld.w */
+
+#define SIGN8_LABELIMM8 29
+  { 8, 0, NULL, NULL, C33_OPERAND_SIGNED | C33_OPERAND_LABEL | C33_OPERAND_PC, 8}, /* jp,call */
+
+#define SIGN32_LABELIMM22   30
+  { 8, 0, NULL, NULL, C33_OPERAND_SIGNED | C33_OPERAND_LABEL | C33_OPERAND_PC, 22}, /* scall,sjp,sjrxx */
+
+#define RD01    31
+  { 4, 0, NULL, NULL, C33_OPERAND_REG | C33_OPERAND_01, 0},     /* Advanced macro class0  */
+
+#define RS01    32
+  { 4, 0, NULL, NULL, C33_OPERAND_REG | C33_OPERAND_01, 0 },    /* Advanced macro class0  */
+
+#define SS01    33
+  { 4, 0, NULL, NULL, C33_OPERAND_SREG | C33_OPERAND_01, 0},    /* Advanced macro class0 */
+
+#define SD01    34
+  { 4, 0, NULL, NULL, C33_OPERAND_SREG | C33_OPERAND_01, 0},    /* Advanced macro class0 */
+
+#define RB01    35
+  { 4, 0, NULL, NULL, C33_OPERAND_REG | C33_OPERAND_01, 0},     /* Advanced macro class0  */
+
+#define IMM4_01 36                              
+  { 4, 0, NULL, NULL, C33_OPERAND_IMM | C33_OPERAND_01, 5},     /* Advanced macro class0  */
+
+#define IMM5_2  37
+  { 4, 0, NULL, NULL, C33_OPERAND_IMM, 5},                      /* Advanced macro : loop  */
+
+#define IMM6_OP3    38
+  { 6, 0, NULL, NULL, C33_OPERAND_IMM, 6}, 
+
+#define IMM5_OP3_01 39
+  { 5, 0, NULL, NULL, C33_OPERAND_IMM | C33_OPERAND_OP3_01, 5}, /* Advanced macro : psrset  */
+
+#define IMM5_OP3_10 40
+  { 5, 0, NULL, NULL, C33_OPERAND_IMM | C33_OPERAND_OP3_10, 5}, /* Advanced macro : psrclr  */
+
+#define DPIMM6  41
+  { 6, 4, NULL, NULL, C33_OPERAND_DPMEM, 6},                    /* Advanced macro : ld.x [%dp+imm6] */
+
+#define DPIMM32 42
+  { 6, 4, NULL, NULL, C33_OPERAND_DPMEM, 32},                   /* Advanced macro : xld.x [%dp+imm32] */
+
+#define DP_SYMBOL19 43
+  { 6, 4, NULL, NULL, C33_OPERAND_MEM | C33_OPERAND_DP_SYMBOL, 19}, /* Advanced macro : ald.w [symbol+imm]  */
+
+#define DP_SYMBOL32 44
+  { 6, 4, NULL, NULL, C33_OPERAND_MEM | C33_OPERAND_DP_SYMBOL, 32}, /* Advanced macro : xld.w [symbol+imm]  */
+
+#define DP      45
+  { 4, 0, NULL, NULL, C33_OPERAND_DP | C33_OPERAND_01, 0},          /* Advanced macro : add %rd,%dp */
+
+#define DP_OFF_SYMBOL6  46
+  { 6, 4, NULL, NULL, C33_OPERAND_MEM | C33_OPERAND_DPSYMBOL6, 6},  /* Advanced macro : ld.x [%dp+dpoff_l(symbol)] */
+
+#define DP_OFF_SYMBOL6_2    47
+  { 6, 4, NULL, NULL, C33_OPERAND_MEM | C33_OPERAND_DPSYMBOL6_2, 6},    /* Advanced macro : ld.x [%dp+dpoff_l(symbol)] */
+
+#define COND    48
+  { 4, 4, NULL, NULL, C33_OPERAND_COND, 6},                             /* Advanced macro : ext condition */
+
+#define OP_SHIFT    49
+  { 2, 2, NULL, NULL, C33_OPERAND_OP_SHIFT, 0},                         /* Advanced macro : ext condition */
+
+#define IMM5_LABEL  50
+  { 4, 4, NULL, NULL, C33_OPERAND_IMM | C33_OPERAND_LABEL, 5},         /* Advanced macro : loop */
+
+#define SD_LD   51
+  { 4, 0, NULL, NULL, C33_OPERAND_LD_SREG, 0},                         /* Advanced macro,PE : ld.w %sd */
+
+#define SS02    52
+  { 4, 0, NULL, NULL, C33_OPERAND_PUSHS_SREG | C33_OPERAND_01, 0},  /* Advanced macro,PE : pushs */
+
+#define SD02    53
+  { 4, 0, NULL, NULL, C33_OPERAND_PUSHS_SREG | C33_OPERAND_01, 0},  /* Advanced macro,PE : pops */
+
+/* add T.Tazaki 2004/07/23 >>> */
+#define XLDB_RD_MEM_IMM26   54                                      /* xld.b %rd,[symbol+imm32] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDB_RD, 26},
+#define XLDB_WR_MEM_IMM26   55                                      /* xld.b [symbol+imm32],%rs */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDB_WR, 26},
+#define XLDH_RD_MEM_IMM26   56                                      /* xld.h %rd,[symbol+imm32] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDH_RD, 26},
+#define XLDH_WR_MEM_IMM26   57                                      /* xld.h [symbol+imm32],%rs */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDH_WR, 26},
+#define XLDW_RD_MEM_IMM26   58                                      /* xld.w %rd,[symbol+imm32] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDW_RD, 26},
+#define XLDW_WR_MEM_IMM26   59                                      /* xld.w [symbol+imm32],%rs */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDW_WR, 26},
+#define XLDUB_RD_MEM_IMM26  60                                      /* xld.ub %rd,[symbol+imm32] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDUB_RD, 26},
+#define XLDUH_RD_MEM_IMM26  61                                      /* xld.uh %rd,[symbol+imm32] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDUH_RD, 26},
+#define XBTST_MEM_IMM26     62                                      /* xbtst [symbol+imm32],imm3 */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XBTST, 26},
+#define XBCLR_MEM_IMM26     63                                      /* xbclr [symbol+imm32],imm3 */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XBCLR, 26},
+#define XBSET_MEM_IMM26     64                                      /* xbset [symbol+imm32],imm3 */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XBSET, 26},
+#define XBNOT_MEM_IMM26     65                                      /* xbnot [symbol+imm32],imm3 */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XBNOT, 26},
+
+#define ALDB_RD_MEM_IMM19   66                                      /* ald.b %rd,[symbol+imm19] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDB_RD, 19},
+#define ALDB_WR_MEM_IMM19   67                                      /* ald.b [symbol+imm19],%rs */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDB_WR, 19},
+#define ALDH_RD_MEM_IMM19   68                                      /* ald.h %rd,[symbol+imm19] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDH_RD, 19},
+#define ALDH_WR_MEM_IMM19   69                                      /* ald.h [symbol+imm19],%rs */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDH_WR, 19},
+#define ALDW_RD_MEM_IMM19   70                                      /* ald.w %rd,[symbol+imm19] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDW_RD, 19},
+#define ALDW_WR_MEM_IMM19   71                                      /* ald.w [symbol+imm19],%rs */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDW_WR, 19},
+#define ALDUB_RD_MEM_IMM19  72                                      /* ald.ub %rd,[symbol+imm19] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDUB_RD, 19},
+#define ALDUH_RD_MEM_IMM19  73                                      /* ald.uh %rd,[symbol+imm19] */
+  { 4, 4, NULL, NULL, C33_OPERAND_MEM | C33_XLDUH_RD, 19},
+#define RB_IMM26   			74
+  { 4, 4, NULL, NULL, C33_OPERAND_RB | C33_OPERAND_26, 0},     		/* xld.x [%rb+imm26] */
+
+/* add T.Tazaki 2004/07/23 <<< */
+
+};
+
+
+/* The opcode table.    < STANDARD MACRO >
+
+   The format of the opcode table is:
+
+   NAME     OPCODE          MASK               { OPERANDS }    MEMOP
+
+   NAME is the name of the instruction.
+   OPCODE is the instruction opcode.
+   MASK is the opcode mask; this is used to tell the disassembler
+     which bits in the actual opcode must match OPCODE.
+   OPERANDS is the list of operands.
+   MEMOP specifies which operand (if any) is a memory operand.
+   PROCESSORS specifies which CPU(s) support the opcode.
+   
+   The disassembler reads the table in order and prints the first
+   instruction which matches, so this table is sorted to put more
+   specific instructions before more general instructions.  It is also
+   sorted by major opcode.
+
+   The table is also sorted by name.  This is used by the assembler.
+   When parsing an instruction the assembler finds the first occurance
+   of the name of the instruciton in this table and then attempts to
+   match the instruction's arguments with description of the operands
+   associated with the entry it has just found in this table.  If the
+   match fails the assembler looks at the next entry in this table.
+   If that entry has the same name as the previous entry, then it
+   tries to match the instruction against that entry and so on.  This
+   is how the assembler copes with multiple, different formats of the
+   same instruction.  */
+
+/* It is necessary to put in order and describe the same command. */
+/* It is meaningful in the order of the row of a command.
+    REGINC is bad if there is nothing before RB. */
+/* The operand in which a symbol is possible will not become, 
+if it gets used after the operand for which a symbol is improper. */
+/*************************************************************************************************/
+/*  NO use default data area mode 																 */
+/*************************************************************************************************/
+const struct c33_opcode c33_opcodes32[] =
+{
+/* class 0 */
+{ "nop",    OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "slp",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "halt",   OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "pushn",  OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RS},               0,  0},
+{ "popn",   OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RD},               0,  0},
+{ "brk",    OP_CLASS0_1(0x10),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retd",   OP_CLASS0_1(0x11),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "int",    OP_CLASS0_1(0x12),      OP_CLASS0_1_MASK,       {IMM2},             0,  0},
+{ "reti",   OP_CLASS0_1(0x13),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+
+{ "call",   OP_CLASS0_1(0x18),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call",   OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "call.d", OP_CLASS0_1(0x1c),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call.d", OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "scall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "scall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xcall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xcall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ret",    OP_CLASS0_1(0x19),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "ret.d",  OP_CLASS0_1(0x1d),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "jp",     OP_CLASS0_1(0x1a),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp",     OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jp.d",   OP_CLASS0_1(0x1e),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp.d",   OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrgt",   OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrgt.d", OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrge",   OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrge.d", OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrlt",   OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrlt.d", OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrle",   OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrle.d", OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrugt",  OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrugt.d",OP_CLASS0_2(0x11),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jruge",  OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jruge.d",OP_CLASS0_2(0x13),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrult",  OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrult.d",OP_CLASS0_2(0x15),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrule",  OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrule.d",OP_CLASS0_2(0x17),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jreq",   OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jreq.d", OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrne",   OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrne.d", OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ld.b",   OP_CLASS5(0xa1),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.b",   OP_CLASS1(0x21),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.b",   OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.b",   OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.b",   OP_CLASS1(0x35),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.b",   OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.b",   OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.b",  OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.b",  OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB_IMM26},      0,  0},				/* change 2004/07/23 T.Tazaki */
+{ "xld.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDB_RD_MEM_IMM26},     0,  0},		/* change 2004/07/23 T.Tazaki */
+{ "xld.b",  OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  1},
+{ "xld.b",  OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB_IMM26,RS},      0,  0},				/* change 2004/07/23 T.Tazaki */
+{ "xld.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDB_WR_MEM_IMM26,RS},     0,  0},		/* change 2004/07/23 T.Tazaki */
+
+{ "ld.ub",  OP_CLASS5(0xa5),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.ub",  OP_CLASS1(0x25),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.ub",  OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.ub",  OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.ub", OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.ub", OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB_IMM26},      0,  0},				/* change 2004/07/23 T.Tazaki */
+{ "xld.ub", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDUB_RD_MEM_IMM26},     0,  0},	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.h",   OP_CLASS5(0xa9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.h",   OP_CLASS1(0x29),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.h",   OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.h",   OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.h",   OP_CLASS1(0x39),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.h",   OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.h",   OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.h",  OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.h",  OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},				/* change 2004/07/23 T.Tazaki */
+{ "xld.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDH_RD_MEM_IMM26},     0,  0},		/* change 2004/07/23 T.Tazaki */
+{ "xld.h",  OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  2},
+{ "xld.h",  OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB_IMM26,RS},      0,  0},				/* change 2004/07/23 T.Tazaki */
+{ "xld.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDH_WR_MEM_IMM26,RS},     0,  0},		/* change 2004/07/23 T.Tazaki */
+
+{ "ld.uh",  OP_CLASS5(0xad),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.uh",  OP_CLASS1(0x2d),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.uh",  OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.uh",  OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.uh", OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.uh", OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB_IMM26},      0,  0},				/* change 2004/07/23 T.Tazaki */
+{ "xld.uh", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDUH_RD_MEM_IMM26},     0,  0},	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.w",   OP_CLASS1(0x2e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS5(0xa4),        OP_CLASS5_MASK,         {RD,SS},            0,  0},
+{ "ld.w",   OP_CLASS1(0x31),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.w",   OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.w",   OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.w",   OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN6_SYMBOLIMM6},      0,  0},
+{ "ld.w",   OP_CLASS5(0xa0),        OP_CLASS5_MASK,         {SD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS1(0x3d),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.w",   OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.w",  OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  4},
+{ "xld.w",  OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  4},
+{ "xld.w",  OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB_IMM26},      0,  0},           /* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDW_RD_MEM_IMM26},     0,  0},   /* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB_IMM26,RS},      0,  0}, 		  /* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDW_WR_MEM_IMM26,RS},     0,  0},   /* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN32_SYMBOLIMM32},    0,  0},
+
+{ "add",    OP_CLASS1(0x22),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "add",    OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "add",    OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "sub",    OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "sub",    OP_CLASS1(0x26),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "sub",    OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "xsub",   OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xsub",   OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "cmp",    OP_CLASS1(0x2a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "cmp",    OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xcmp",   OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+{ "and",    OP_CLASS1(0x32),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "and",    OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xand",   OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "or",     OP_CLASS1(0x36),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "or",     OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xoor",   OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "xor",    OP_CLASS1(0x3a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "xor",    OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xxor",   OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "not",    OP_CLASS1(0x3e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "not",    OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xnot",   OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+/* class 4 */
+
+{ "srl",    OP_CLASS4_2(0x89),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "srl",    OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsrl",   OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "sll",    OP_CLASS4_2(0x8d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sll",    OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsll",   OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "sra",    OP_CLASS4_2(0x91),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sra",    OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsra",   OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "sla",    OP_CLASS4_2(0x95),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sla",    OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsla",   OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "rr",     OP_CLASS4_2(0x99),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rr",     OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xrr",    OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "rl",     OP_CLASS4_2(0x9d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rl",     OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xrl",    OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+
+{ "scan0",  OP_CLASS4_2(0x8a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "scan1",  OP_CLASS4_2(0x8e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "swap",   OP_CLASS4_2(0x92),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "mirror", OP_CLASS4_2(0x96),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "div0s",  OP_CLASS4_2(0x8b),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div0u",  OP_CLASS4_2(0x8f),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div1",   OP_CLASS4_2(0x93),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div2s",  OP_CLASS4_2(0x97),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div3s",  OP_CLASS4_2(0x9b),      OP_CLASS4_2_MASK,       {UNUSED},           0,  0},
+
+/* class 5 */
+
+{ "btst",   OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbtst",  OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},    0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbtst",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBTST_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bclr",   OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbclr",  OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},    0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbclr",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBCLR_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bset",   OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbset",  OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},    0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbset",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBSET_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bnot",   OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbnot",  OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},    0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbnot",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBNOT_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+
+{ "adc",    OP_CLASS5(0xb8),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "sbc",    OP_CLASS5(0xbc),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.h",  OP_CLASS5(0xa2),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.h", OP_CLASS5(0xa6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.w",  OP_CLASS5(0xaa),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.w", OP_CLASS5(0xae),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mac",    OP_CLASS5(0xb2),        OP_CLASS5_MASK,         {RS2},              0,  0},
+
+/* class 6 */
+
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+/* The opcode table.    < ADVANCED MACRO > */
+
+const struct c33_opcode c33_advance_opcodes32[] =
+{
+/* class 0 */
+{ "nop",    OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "slp",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "halt",   OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "pushn",  OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RS},               0,  0},
+{ "popn",   OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RD},               0,  0},
+{ "jpr",    OP_CLASS0_1(0x0b),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* Adv */
+{ "jpr.d",  OP_CLASS0_1(0x0f),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* Adv */
+{ "brk",    OP_CLASS0_1(0x10),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retd",   OP_CLASS0_1(0x11),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "int",    OP_CLASS0_1(0x12),      OP_CLASS0_1_MASK,       {IMM2},             0,  0},
+{ "reti",   OP_CLASS0_1(0x13),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "push",   OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* Adv */
+{ "pop",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {RD01},             0,  0}, /* Adv */
+{ "pushs",  OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {SS02},             0,  0}, /* Adv */
+{ "pops",   OP_CLASS0_1(0x03),      OP_CLASS0_1_MASK,       {SD02},             0,  0}, /* Adv */
+{ "mac.w",  OP_CLASS0_1(0x04),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* Adv */
+{ "mac.hw", OP_CLASS0_1(0x05),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* Adv */
+{ "macclr", OP_CLASS0_1(0x06),      OP_CLASS0_1_MASK,       {UNUSED},           0,  10},/* Adv */
+{ "ld.cf",  OP_CLASS0_1(0x07),      OP_CLASS0_1_MASK,       {UNUSED},           0,  10},/* Adv */
+{ "div.w",  OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* Adv */
+{ "divu.w", OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* Adv */
+{ "repeat", OP_CLASS0_1(0x0a),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* Adv */
+{ "repeat", OP_CLASS0_1(0x0b),      OP_CLASS0_1_MASK,       {IMM4_01},          0,  0}, /* Adv */
+
+{ "call",   OP_CLASS0_1(0x18),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call",   OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "call.d", OP_CLASS0_1(0x1c),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call.d", OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "scall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "scall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xcall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xcall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ret",    OP_CLASS0_1(0x19),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retm",   OP_CLASS0_1(0x1b),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},/* Adv */ /* 2002/10/01 */
+{ "ret.d",  OP_CLASS0_1(0x1d),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "jp",     OP_CLASS0_1(0x1a),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp",     OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jp.d",   OP_CLASS0_1(0x1e),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp.d",   OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrgt",   OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrgt.d", OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrge",   OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrge.d", OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrlt",   OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrlt.d", OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrle",   OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrle.d", OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrugt",  OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrugt.d",OP_CLASS0_2(0x11),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jruge",  OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jruge.d",OP_CLASS0_2(0x13),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrult",  OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrult.d",OP_CLASS0_2(0x15),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrule",  OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrule.d",OP_CLASS0_2(0x17),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jreq",   OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jreq.d", OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrne",   OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrne.d", OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ld.b",   OP_CLASS5(0xa1),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.b",   OP_CLASS1(0x21),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.b",   OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.b",   OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.b",   OP_CLASS1(0x35),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.b",   OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.b",   OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+{ "ld.b",   OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.b",   OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DPIMM6,RS},        0,  0}, /* Adv */
+{ "ld.b",   OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.b",   OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DP_OFF_SYMBOL6,RS},0,  0}, /* Adv */
+
+{ "xld.b",  OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  1}, /* Adv */
+{ "xld.b",  OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DPIMM32,RS},       0,  1}, /* Adv */
+{ "xld.b",  OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.b",  OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  1},
+//{ "xld.b",  OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+//{ "xld.b",  OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DP_SYMBOL32,RS},   0,  0}, /* Adv */
+{ "xld.b",  OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB_IMM26},      0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDB_RD_MEM_IMM26},   0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "xld.b",  OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB_IMM26,RS},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDB_WR_MEM_IMM26,RS},   0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.ub",  OP_CLASS5(0xa5),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.ub",  OP_CLASS1(0x25),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.ub",  OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.ub",  OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.ub",  OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.ub",  OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+
+{ "xld.ub", OP_CLASS2(0x39),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  1}, /* Adv */
+{ "xld.ub", OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+//{ "xld.ub", OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.ub", OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.ub", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDUB_RD_MEM_IMM26},   0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.h",   OP_CLASS5(0xa9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.h",   OP_CLASS1(0x29),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.h",   OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.h",   OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.h",   OP_CLASS1(0x39),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.h",   OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.h",   OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+{ "ld.h",   OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DPIMM6,RS},        0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DP_OFF_SYMBOL6,RS},0,  0}, /* Adv */
+
+{ "xld.h",  OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  2}, /* Adv */
+{ "xld.h",  OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DPIMM32,RS},       0,  2}, /* Adv */
+{ "xld.h",  OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.h",  OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  2},
+//{ "xld.h",  OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+//{ "xld.h",  OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DP_SYMBOL32,RS},   0,  0}, /* Adv */
+{ "xld.h",  OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDH_RD_MEM_IMM26},   0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "xld.h",  OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB_IMM26,RS},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDH_WR_MEM_IMM26,RS},   0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.uh",  OP_CLASS5(0xad),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.uh",  OP_CLASS1(0x2d),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.uh",  OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.uh",  OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.uh",  OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.uh",  OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+
+{ "xld.uh", OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  2}, /* Adv */
+{ "xld.uh", OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+//{ "xld.uh", OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.uh", OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.uh",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,        {RD,XLDUH_RD_MEM_IMM26},   0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.w",   OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DPIMM6,RS},        0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DP_OFF_SYMBOL6,RS},0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS1(0x2e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS5(0xa4),        OP_CLASS5_MASK,         {RD,SS},            0,  0},
+{ "ld.w",   OP_CLASS1(0x31),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.w",   OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.w",   OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.w",   OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN6_SYMBOLIMM6},  0,  0},
+{ "ld.w",   OP_CLASS5(0xa0),        OP_CLASS5_MASK,         {SD_LD,RS2},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3d),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.w",   OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.w",  OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  4}, /* Adv */
+{ "xld.w",  OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DPIMM32,RS},       0,  4}, /* Adv */
+{ "xld.w",  OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  4},
+{ "xld.w",  OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  4},
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN32_SYMBOLIMM32},    0,  0},
+//{ "xld.w",  OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+//{ "xld.w",  OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DP_SYMBOL32,RS},   0,  0}, /* Adv */
+{ "xld.w",  OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDW_RD_MEM_IMM26},     0,  0},	/* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB_IMM26,RS},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDW_WR_MEM_IMM26,RS},     0,  0},	/* change 2004/07/23 T.Tazaki */
+
+
+//{ "ald.b",  OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+//{ "ald.b",  OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DP_SYMBOL19,RS},       0,  0}, /* Adv */
+//{ "ald.ub", OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+//{ "ald.h",  OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+//{ "ald.h",  OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DP_SYMBOL19,RS},       0,  0}, /* Adv */
+//{ "ald.uh", OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+//{ "ald.w",  OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+//{ "ald.w",  OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DP_SYMBOL19,RS},       0,  0}, /* Adv */
+
+{ "ald.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,ALDB_RD_MEM_IMM19},       0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {ALDB_WR_MEM_IMM19,RS},       0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.ub", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,ALDUB_RD_MEM_IMM19},      0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,ALDH_RD_MEM_IMM19},       0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {ALDH_WR_MEM_IMM19,RS},       0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.uh", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,ALDUH_RD_MEM_IMM19},      0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,ALDW_RD_MEM_IMM19},       0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+{ "ald.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {ALDW_WR_MEM_IMM19,RS},       0,  0}, /* Adv */	/* change 2004/07/23 T.Tazaki */
+
+
+{ "add",    OP_CLASS0_1(0x0d),      OP_CLASS0_1_MASK,       {RD01,DP},          0,  0},     /* Adv */
+{ "add",    OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "add",    OP_CLASS3(0x18),        OP_CLASS1_MASK,         {RD,DP_OFF_SYMBOL6_2},0,0},     /* Adv */
+{ "add",    OP_CLASS1(0x22),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "add",    OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "sub",    OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "sub",    OP_CLASS1(0x26),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "sub",    OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "xsub",   OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xsub",   OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "cmp",    OP_CLASS1(0x2a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "cmp",    OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xcmp",   OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+{ "and",    OP_CLASS1(0x32),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "and",    OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xand",   OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "or",     OP_CLASS1(0x36),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "or",     OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xoor",   OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "xor",    OP_CLASS1(0x3a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "xor",    OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xxor",   OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "not",    OP_CLASS1(0x3e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "not",    OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xnot",   OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+/* class 4 */
+
+{ "srl",    OP_CLASS4_2(0x89),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "srl",    OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},/* Adv */
+{ "xsrl",   OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sll",    OP_CLASS4_2(0x8d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sll",    OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xsll",   OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sra",    OP_CLASS4_2(0x91),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sra",    OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xsra",   OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sla",    OP_CLASS4_2(0x95),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sla",    OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xsla",   OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rr",     OP_CLASS4_2(0x99),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rr",     OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xrr",    OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rl",     OP_CLASS4_2(0x9d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rl",     OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xrl",    OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+
+{ "swaph",  OP_CLASS4_2(0x9a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* Adv */
+{ "sat.b",  OP_CLASS4_2(0x9e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* Adv */
+{ "sat.ub", OP_CLASS4_2(0x9f),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* Adv */
+{ "scan0",  OP_CLASS4_2(0x8a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "scan1",  OP_CLASS4_2(0x8e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "swap",   OP_CLASS4_2(0x92),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "mirror", OP_CLASS4_2(0x96),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "div0s",  OP_CLASS4_2(0x8b),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div0u",  OP_CLASS4_2(0x8f),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div1",   OP_CLASS4_2(0x93),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div2s",  OP_CLASS4_2(0x97),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div3s",  OP_CLASS4_2(0x9b),      OP_CLASS4_2_MASK,       {UNUSED},           0,  0},
+
+/* class 5 */
+
+{ "btst",   OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbtst",  OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbtst",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBTST_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bclr",   OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbclr",  OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbclr",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBCLR_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bset",   OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbset",  OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbset",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBSET_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bnot",   OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbnot",  OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbnot",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBNOT_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+
+{ "adc",    OP_CLASS5(0xb8),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "sbc",    OP_CLASS5(0xbc),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.h",  OP_CLASS5(0xa2),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.hw", OP_CLASS5(0xa3),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "mltu.h", OP_CLASS5(0xa6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.w",  OP_CLASS5(0xaa),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.w", OP_CLASS5(0xae),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mac",    OP_CLASS5(0xb2),        OP_CLASS5_MASK,         {RS2},              0,  0},
+{ "mac1.h", OP_CLASS5(0xa7),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "mac1.hw",OP_CLASS5(0xab),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "mac1.w", OP_CLASS5(0xb3),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "ld.c",   OP_CLASS5(0xb1),        OP_CLASS5_MASK,         {RD,IMM5},          0,  0}, /* Adv */
+{ "ld.c",   OP_CLASS5(0xb5),        OP_CLASS5_MASK,         {IMM5,RS},          0,  0}, /* Adv */
+{ "sat.h",  OP_CLASS5(0xb6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "sat.uh", OP_CLASS5(0xb7),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "loop",   OP_CLASS5(0xb9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "loop",   OP_CLASS5(0xba),        OP_CLASS5_MASK,         {RD,IMM5_LABEL},    0,  0}, /* Adv */
+{ "loop",   OP_CLASS5(0xbb),        OP_CLASS5_MASK,         {IMM5_2,IMM5_LABEL},0,  0}, /* Adv */
+{ "sat.w",  OP_CLASS5(0xbd),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "sat.uw", OP_CLASS5(0xbe),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "do.c",   OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM6_OP3},         0, 0},  /* Adv */
+{ "psrset", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_01},      0, 0},  /* Adv */
+{ "psrclr", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_10},      0, 0},  /* Adv */
+
+{ "ext",    OP_CLASS1(0x3f),        OP_CLASS1_MASK,         {RS2,OP_SHIFT,IMM2},0,  0}, /* Adv */
+{ "ext",    OP_CLASS1(0x3f),        OP_CLASS1_MASK,         {RS2},              0,  0}, /* Adv */
+{ "ext",    OP_CLASS1(0x3b),        OP_CLASS1_MASK,         {COND},             0,  0}, /* Adv */
+{ "ext",    OP_CLASS1(0x3b),        OP_CLASS1_MASK,         {OP_SHIFT,IMM2},    0,  0}, /* Adv */
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+const struct c33_opcode c33_ext_opcodes[] =
+{
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+{ 0, 0, 0, {0}, 0, 0 }
+
+} ;
+
+
+/* Advanced Macro Opecode name class0 - bit5,4 = 0,1 */
+const char *c33_adv_opcodes[] =
+{
+ "push",    
+ "pop",     
+ "pushs",
+ "pops",
+ "mac.w",
+ "mac.hw",
+ "macclr",
+ "ld.cf",
+ "div.w",
+ "divu.w",
+ "repeat",
+ "add",
+ 0
+};
+
+/* Advanced Macro Opecode name class5 - bit12_8 = 111:11 */
+const char *c33_adv_class5_opcodes[] =
+{
+ "do.c",
+ "psrset",
+ "psrclr",
+ 0
+};
+
+#if 0	/* 下へ移動  T.Tazaki 2004/07/30 */
+const int c33_num_opcodes =
+  sizeof (c33_opcodes) / sizeof (c33_opcodes[0]);
+#endif
+
+
+/* The opcode table.    < PE MACRO > */
+
+const struct c33_opcode c33_pe_opcodes32[] =
+{
+/* class 0 */
+{ "nop",    OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "slp",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "halt",   OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "pushn",  OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RS},               0,  0},
+{ "popn",   OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RD},               0,  0},
+{ "jpr",    OP_CLASS0_1(0x0b),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* PE */
+{ "jpr.d",  OP_CLASS0_1(0x0f),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* PE */
+{ "brk",    OP_CLASS0_1(0x10),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retd",   OP_CLASS0_1(0x11),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "int",    OP_CLASS0_1(0x12),      OP_CLASS0_1_MASK,       {IMM2},             0,  0},
+{ "reti",   OP_CLASS0_1(0x13),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "push",   OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* PE */
+{ "pop",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {RD01},             0,  0}, /* PE */
+{ "pushs",  OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {SS02},             0,  0}, /* PE */
+{ "pops",   OP_CLASS0_1(0x03),      OP_CLASS0_1_MASK,       {SD02},             0,  0}, /* PE */
+{ "ld.cf",  OP_CLASS0_1(0x07),      OP_CLASS0_1_MASK,       {UNUSED},           0,  10},  /* PE */ /* add 2004/07/07 T.Tazaki */
+//{ "div.w",  OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* PE */ /* del 2004/07/07 T.Tazaki */
+//{ "divu.w", OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* PE */ /* del 2004/07/07 T.Tazaki */
+
+{ "call",   OP_CLASS0_1(0x18),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call",   OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "call.d", OP_CLASS0_1(0x1c),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call.d", OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "scall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "scall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xcall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xcall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ret",    OP_CLASS0_1(0x19),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "ret.d",  OP_CLASS0_1(0x1d),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "jp",     OP_CLASS0_1(0x1a),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp",     OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jp.d",   OP_CLASS0_1(0x1e),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp.d",   OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrgt",   OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrgt.d", OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrge",   OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrge.d", OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrlt",   OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrlt.d", OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrle",   OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrle.d", OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrugt",  OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrugt.d",OP_CLASS0_2(0x11),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jruge",  OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jruge.d",OP_CLASS0_2(0x13),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrult",  OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrult.d",OP_CLASS0_2(0x15),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrule",  OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrule.d",OP_CLASS0_2(0x17),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jreq",   OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jreq.d", OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrne",   OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrne.d", OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ld.b",   OP_CLASS5(0xa1),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.b",   OP_CLASS1(0x21),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.b",   OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.b",   OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.b",   OP_CLASS1(0x35),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.b",   OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.b",   OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.b",  OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.b",  OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDB_RD_MEM_IMM26},     0,  0},	/* change 2004/07/23 T.Tazaki */
+{ "xld.b",  OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  1},
+{ "xld.b",  OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB_IMM26,RS},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.b",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDB_WR_MEM_IMM26,RS},     0,  0},	/* change 2004/07/23 T.Tazaki */
+
+{ "ld.ub",  OP_CLASS5(0xa5),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.ub",  OP_CLASS1(0x25),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.ub",  OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.ub",  OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.ub", OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.ub", OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.ub", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDUB_RD_MEM_IMM26},     0,  0},/* change 2004/07/23 T.Tazaki */
+
+{ "ld.h",   OP_CLASS5(0xa9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.h",   OP_CLASS1(0x29),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.h",   OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.h",   OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.h",   OP_CLASS1(0x39),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.h",   OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.h",   OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.h",  OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.h",  OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDH_RD_MEM_IMM26},     0,  0},/* change 2004/07/23 T.Tazaki */
+{ "xld.h",  OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  2},
+{ "xld.h",  OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB_IMM26,RS},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.h",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDH_WR_MEM_IMM26,RS},     0,  0},/* change 2004/07/23 T.Tazaki */
+
+{ "ld.uh",  OP_CLASS5(0xad),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.uh",  OP_CLASS1(0x2d),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.uh",  OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.uh",  OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.uh", OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.uh", OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.uh", OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDUH_RD_MEM_IMM26},     0,  0},/* change 2004/07/23 T.Tazaki */
+
+{ "ld.w",   OP_CLASS1(0x2e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS5(0xa4),        OP_CLASS5_MASK,         {RD,SS},            0,  0},
+{ "ld.w",   OP_CLASS1(0x31),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.w",   OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.w",   OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.w",   OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN6_SYMBOLIMM6},      0,  0},
+{ "ld.w",   OP_CLASS5(0xa0),        OP_CLASS5_MASK,         {SD_LD,RS2},        0,  0},	/* PE 	ld %sd,%rs */
+{ "ld.w",   OP_CLASS1(0x3d),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.w",   OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.w",  OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  4},
+{ "xld.w",  OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  4},
+{ "xld.w",  OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB_IMM26},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,XLDW_RD_MEM_IMM26},     0,  0},/* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB_IMM26,RS},     0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XLDW_WR_MEM_IMM26,RS},     0,  0},/* change 2004/07/23 T.Tazaki */
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN32_SYMBOLIMM32},    0,  0},
+
+{ "add",    OP_CLASS1(0x22),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "add",    OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "add",    OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "sub",    OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "sub",    OP_CLASS1(0x26),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "sub",    OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "xsub",   OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xsub",   OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "cmp",    OP_CLASS1(0x2a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "cmp",    OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xcmp",   OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+{ "and",    OP_CLASS1(0x32),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "and",    OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xand",   OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "or",     OP_CLASS1(0x36),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "or",     OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xoor",   OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "xor",    OP_CLASS1(0x3a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "xor",    OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xxor",   OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "not",    OP_CLASS1(0x3e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "not",    OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xnot",   OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+/* class 4 */
+
+{ "srl",    OP_CLASS4_2(0x89),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "srl",    OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsrl",   OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sll",    OP_CLASS4_2(0x8d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sll",    OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsll",   OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sra",    OP_CLASS4_2(0x91),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sra",    OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsra",   OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sla",    OP_CLASS4_2(0x95),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sla",    OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsla",   OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rr",     OP_CLASS4_2(0x99),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rr",     OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xrr",    OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rl",     OP_CLASS4_2(0x9d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rl",     OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xrl",    OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+
+{ "scan0",  OP_CLASS4_2(0x8a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "scan1",  OP_CLASS4_2(0x8e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "swaph",  OP_CLASS4_2(0x9a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* PE */
+{ "swap",   OP_CLASS4_2(0x92),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "mirror", OP_CLASS4_2(0x96),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+//{ "div0s",  OP_CLASS4_2(0x8b),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div0u",  OP_CLASS4_2(0x8f),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div1",   OP_CLASS4_2(0x93),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div2s",  OP_CLASS4_2(0x97),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div3s",  OP_CLASS4_2(0x9b),      OP_CLASS4_2_MASK,       {UNUSED},           0,  0},
+
+/* class 5 */
+
+{ "btst",   OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbtst",  OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbtst",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBTST_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bclr",   OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbclr",  OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbclr",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBCLR_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bset",   OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbset",  OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbset",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBSET_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+{ "bnot",   OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbnot",  OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB_IMM26,IMM3},   0,  0},			/* change T.Tazaki 2004/07/26 */
+{ "xbnot",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {XBNOT_MEM_IMM26,IMM3},   0,  0},	/* change T.Tazaki 2004/07/23 */
+
+{ "adc",    OP_CLASS5(0xb8),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "sbc",    OP_CLASS5(0xbc),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.h",  OP_CLASS5(0xa2),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.h", OP_CLASS5(0xa6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.w",  OP_CLASS5(0xaa),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.w", OP_CLASS5(0xae),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mac",    OP_CLASS5(0xb2),        OP_CLASS5_MASK,         {RS2},              0,  0},
+{ "ld.c",   OP_CLASS5(0xb1),        OP_CLASS5_MASK,         {RD,IMM5},          0,  0}, /* PE */	/* add T.Tazaki 2004/07/07 */
+{ "ld.c",   OP_CLASS5(0xb5),        OP_CLASS5_MASK,         {IMM5,RS},          0,  0}, /* PE */	/* add T.Tazaki 2004/07/07 */
+{ "do.c",   OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM6_OP3},         0, 0},  /* PE */	/* add T.Tazaki 2004/07/07 */
+{ "psrset", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_01},      0, 0},  /* PE */
+{ "psrclr", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_10},      0, 0},  /* PE */
+
+/* class 6 */
+
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+/*************************************************************************************************/
+/*  Use default data area mode 																	 */
+/*************************************************************************************************/
+const struct c33_opcode c33_opcodes[] =
+{
+/* class 0 */
+{ "nop",    OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "slp",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "halt",   OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "pushn",  OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RS},               0,  0},
+{ "popn",   OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RD},               0,  0},
+{ "brk",    OP_CLASS0_1(0x10),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retd",   OP_CLASS0_1(0x11),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "int",    OP_CLASS0_1(0x12),      OP_CLASS0_1_MASK,       {IMM2},             0,  0},
+{ "reti",   OP_CLASS0_1(0x13),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+
+{ "call",   OP_CLASS0_1(0x18),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call",   OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "call.d", OP_CLASS0_1(0x1c),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call.d", OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "scall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "scall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xcall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xcall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ret",    OP_CLASS0_1(0x19),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "ret.d",  OP_CLASS0_1(0x1d),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "jp",     OP_CLASS0_1(0x1a),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp",     OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jp.d",   OP_CLASS0_1(0x1e),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp.d",   OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrgt",   OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrgt.d", OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrge",   OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrge.d", OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrlt",   OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrlt.d", OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrle",   OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrle.d", OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrugt",  OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrugt.d",OP_CLASS0_2(0x11),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jruge",  OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jruge.d",OP_CLASS0_2(0x13),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrult",  OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrult.d",OP_CLASS0_2(0x15),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrule",  OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrule.d",OP_CLASS0_2(0x17),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jreq",   OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jreq.d", OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrne",   OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrne.d", OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ld.b",   OP_CLASS5(0xa1),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.b",   OP_CLASS1(0x21),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.b",   OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.b",   OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.b",   OP_CLASS1(0x35),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.b",   OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.b",   OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.b",  OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.b",  OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.b",  OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  1},
+{ "xld.b",  OP_CLASS1(0x34),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ld.ub",  OP_CLASS5(0xa5),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.ub",  OP_CLASS1(0x25),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.ub",  OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.ub",  OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.ub", OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.ub", OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+
+{ "ld.h",   OP_CLASS5(0xa9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.h",   OP_CLASS1(0x29),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.h",   OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.h",   OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.h",   OP_CLASS1(0x39),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.h",   OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.h",   OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.h",  OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.h",  OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.h",  OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  2},
+{ "xld.h",  OP_CLASS1(0x38),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ld.uh",  OP_CLASS5(0xad),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.uh",  OP_CLASS1(0x2d),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.uh",  OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.uh",  OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.uh", OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.uh", OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+
+{ "ld.w",   OP_CLASS1(0x2e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS5(0xa4),        OP_CLASS5_MASK,         {RD,SS},            0,  0},
+{ "ld.w",   OP_CLASS1(0x31),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.w",   OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.w",   OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.w",   OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN6_SYMBOLIMM6},      0,  0},
+{ "ld.w",   OP_CLASS5(0xa0),        OP_CLASS5_MASK,         {SD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS1(0x3d),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.w",   OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.w",  OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  4},
+{ "xld.w",  OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  4},
+{ "xld.w",  OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.w",  OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN32_SYMBOLIMM32},    0,  0},
+
+{ "add",    OP_CLASS1(0x22),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "add",    OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "add",    OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "sub",    OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "sub",    OP_CLASS1(0x26),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "sub",    OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "xsub",   OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xsub",   OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "cmp",    OP_CLASS1(0x2a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "cmp",    OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xcmp",   OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+{ "and",    OP_CLASS1(0x32),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "and",    OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xand",   OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "or",     OP_CLASS1(0x36),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "or",     OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xoor",   OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "xor",    OP_CLASS1(0x3a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "xor",    OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xxor",   OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "not",    OP_CLASS1(0x3e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "not",    OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xnot",   OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+/* class 4 */
+
+{ "srl",    OP_CLASS4_2(0x89),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "srl",    OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsrl",   OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "sll",    OP_CLASS4_2(0x8d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sll",    OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsll",   OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "sra",    OP_CLASS4_2(0x91),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sra",    OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsra",   OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "sla",    OP_CLASS4_2(0x95),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sla",    OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xsla",   OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "rr",     OP_CLASS4_2(0x99),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rr",     OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xrr",    OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+{ "rl",     OP_CLASS4_2(0x9d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rl",     OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM4},          0,  5},
+{ "xrl",    OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  6},
+
+{ "scan0",  OP_CLASS4_2(0x8a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "scan1",  OP_CLASS4_2(0x8e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "swap",   OP_CLASS4_2(0x92),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "mirror", OP_CLASS4_2(0x96),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "div0s",  OP_CLASS4_2(0x8b),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div0u",  OP_CLASS4_2(0x8f),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div1",   OP_CLASS4_2(0x93),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div2s",  OP_CLASS4_2(0x97),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div3s",  OP_CLASS4_2(0x9b),      OP_CLASS4_2_MASK,       {UNUSED},           0,  0},
+
+/* class 5 */
+
+{ "btst",   OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbtst",  OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bclr",   OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbclr",  OP_CLASS5(0xac),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bset",   OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbset",  OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bnot",   OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbnot",  OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+
+{ "adc",    OP_CLASS5(0xb8),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "sbc",    OP_CLASS5(0xbc),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.h",  OP_CLASS5(0xa2),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.h", OP_CLASS5(0xa6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.w",  OP_CLASS5(0xaa),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.w", OP_CLASS5(0xae),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mac",    OP_CLASS5(0xb2),        OP_CLASS5_MASK,         {RS2},              0,  0},
+
+/* class 6 */
+
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+/* The opcode table.    < ADVANCED MACRO > */
+
+const struct c33_opcode c33_advance_opcodes[] =
+{
+/* class 0 */
+{ "nop",    OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "slp",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "halt",   OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "pushn",  OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RS},               0,  0},
+{ "popn",   OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RD},               0,  0},
+{ "jpr",    OP_CLASS0_1(0x0b),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* Adv */
+{ "jpr.d",  OP_CLASS0_1(0x0f),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* Adv */
+{ "brk",    OP_CLASS0_1(0x10),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retd",   OP_CLASS0_1(0x11),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "int",    OP_CLASS0_1(0x12),      OP_CLASS0_1_MASK,       {IMM2},             0,  0},
+{ "reti",   OP_CLASS0_1(0x13),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "push",   OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* Adv */
+{ "pop",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {RD01},             0,  0}, /* Adv */
+{ "pushs",  OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {SS02},             0,  0}, /* Adv */
+{ "pops",   OP_CLASS0_1(0x03),      OP_CLASS0_1_MASK,       {SD02},             0,  0}, /* Adv */
+{ "mac.w",  OP_CLASS0_1(0x04),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* Adv */
+{ "mac.hw", OP_CLASS0_1(0x05),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* Adv */
+{ "macclr", OP_CLASS0_1(0x06),      OP_CLASS0_1_MASK,       {UNUSED},           0,  10},/* Adv */
+{ "ld.cf",  OP_CLASS0_1(0x07),      OP_CLASS0_1_MASK,       {UNUSED},           0,  10},/* Adv */
+{ "div.w",  OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* Adv */
+{ "divu.w", OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* Adv */
+{ "repeat", OP_CLASS0_1(0x0a),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* Adv */
+{ "repeat", OP_CLASS0_1(0x0b),      OP_CLASS0_1_MASK,       {IMM4_01},          0,  0}, /* Adv */
+
+{ "call",   OP_CLASS0_1(0x18),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call",   OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "call.d", OP_CLASS0_1(0x1c),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call.d", OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "scall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "scall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xcall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xcall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ret",    OP_CLASS0_1(0x19),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retm",   OP_CLASS0_1(0x1b),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},/* Adv */ /* 2002/10/01 */
+{ "ret.d",  OP_CLASS0_1(0x1d),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "jp",     OP_CLASS0_1(0x1a),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp",     OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jp.d",   OP_CLASS0_1(0x1e),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp.d",   OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrgt",   OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrgt.d", OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrge",   OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrge.d", OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrlt",   OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrlt.d", OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrle",   OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrle.d", OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrugt",  OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrugt.d",OP_CLASS0_2(0x11),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jruge",  OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jruge.d",OP_CLASS0_2(0x13),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrult",  OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrult.d",OP_CLASS0_2(0x15),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrule",  OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrule.d",OP_CLASS0_2(0x17),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jreq",   OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jreq.d", OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrne",   OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrne.d", OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ld.b",   OP_CLASS5(0xa1),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.b",   OP_CLASS1(0x21),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.b",   OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.b",   OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.b",   OP_CLASS1(0x35),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.b",   OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.b",   OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+{ "ld.b",   OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.b",   OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DPIMM6,RS},        0,  0}, /* Adv */
+{ "ld.b",   OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.b",   OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DP_OFF_SYMBOL6,RS},0,  0}, /* Adv */
+
+{ "xld.b",  OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  1}, /* Adv */
+{ "xld.b",  OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DPIMM32,RS},       0,  1}, /* Adv */
+{ "xld.b",  OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.b",  OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  1},
+{ "xld.b",  OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.b",  OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DP_SYMBOL32,RS},   0,  0}, /* Adv */
+{ "xld.b",  OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.b",  OP_CLASS1(0x34),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ld.ub",  OP_CLASS5(0xa5),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.ub",  OP_CLASS1(0x25),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.ub",  OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.ub",  OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.ub",  OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.ub",  OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+
+{ "xld.ub", OP_CLASS2(0x39),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  1}, /* Adv */
+{ "xld.ub", OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.ub", OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.ub", OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+
+{ "ld.h",   OP_CLASS5(0xa9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.h",   OP_CLASS1(0x29),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.h",   OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.h",   OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.h",   OP_CLASS1(0x39),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.h",   OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.h",   OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+{ "ld.h",   OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DPIMM6,RS},        0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.h",   OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DP_OFF_SYMBOL6,RS},0,  0}, /* Adv */
+
+{ "xld.h",  OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  2}, /* Adv */
+{ "xld.h",  OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DPIMM32,RS},       0,  2}, /* Adv */
+{ "xld.h",  OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.h",  OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  2},
+{ "xld.h",  OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.h",  OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DP_SYMBOL32,RS},   0,  0}, /* Adv */
+{ "xld.h",  OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.h",  OP_CLASS1(0x38),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ld.uh",  OP_CLASS5(0xad),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.uh",  OP_CLASS1(0x2d),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.uh",  OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.uh",  OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.uh",  OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.uh",  OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+
+{ "xld.uh", OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  2}, /* Adv */
+{ "xld.uh", OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.uh", OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.uh", OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+
+{ "ld.w",   OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DPIMM6},        0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DPIMM6,RS},        0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DP_OFF_SYMBOL6},0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DP_OFF_SYMBOL6,RS},0,  0}, /* Adv */
+{ "ld.w",   OP_CLASS1(0x2e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS5(0xa4),        OP_CLASS5_MASK,         {RD,SS},            0,  0},
+{ "ld.w",   OP_CLASS1(0x31),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.w",   OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.w",   OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.w",   OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN6_SYMBOLIMM6},  0,  0},
+{ "ld.w",   OP_CLASS5(0xa0),        OP_CLASS5_MASK,         {SD_LD,RS2},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3d),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.w",   OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.w",  OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DPIMM32},       0,  4}, /* Adv */
+{ "xld.w",  OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DPIMM32,RS},       0,  4}, /* Adv */
+{ "xld.w",  OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  4},
+{ "xld.w",  OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  4},
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN32_SYMBOLIMM32},    0,  0},
+{ "xld.w",  OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DP_SYMBOL32},   0,  0}, /* Adv */
+{ "xld.w",  OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DP_SYMBOL32,RS},   0,  0}, /* Adv */
+{ "xld.w",  OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.w",  OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ald.b",  OP_CLASS7(0x38),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+{ "ald.b",  OP_CLASS7(0x3d),        OP_CLASS7_MASK,         {DP_SYMBOL19,RS},       0,  0}, /* Adv */
+
+{ "ald.ub", OP_CLASS7(0x39),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+
+{ "ald.h",  OP_CLASS7(0x3a),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+{ "ald.h",  OP_CLASS7(0x3e),        OP_CLASS7_MASK,         {DP_SYMBOL19,RS},       0,  0}, /* Adv */
+
+{ "ald.uh", OP_CLASS7(0x3b),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+
+{ "ald.w",  OP_CLASS7(0x3c),        OP_CLASS7_MASK,         {RD,DP_SYMBOL19},       0,  0}, /* Adv */
+{ "ald.w",  OP_CLASS7(0x3f),        OP_CLASS7_MASK,         {DP_SYMBOL19,RS},       0,  0}, /* Adv */
+
+{ "add",    OP_CLASS0_1(0x0d),      OP_CLASS0_1_MASK,       {RD01,DP},          0,  0},     /* Adv */
+{ "add",    OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "add",    OP_CLASS3(0x18),        OP_CLASS1_MASK,         {RD,DP_OFF_SYMBOL6_2},0,0},     /* Adv */
+{ "add",    OP_CLASS1(0x22),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "add",    OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "sub",    OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "sub",    OP_CLASS1(0x26),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "sub",    OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "xsub",   OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xsub",   OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "cmp",    OP_CLASS1(0x2a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "cmp",    OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xcmp",   OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+{ "and",    OP_CLASS1(0x32),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "and",    OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xand",   OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "or",     OP_CLASS1(0x36),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "or",     OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xoor",   OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "xor",    OP_CLASS1(0x3a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "xor",    OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xxor",   OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "not",    OP_CLASS1(0x3e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "not",    OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xnot",   OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+/* class 4 */
+
+{ "srl",    OP_CLASS4_2(0x89),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "srl",    OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},/* Adv */
+{ "xsrl",   OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sll",    OP_CLASS4_2(0x8d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sll",    OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xsll",   OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sra",    OP_CLASS4_2(0x91),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sra",    OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xsra",   OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sla",    OP_CLASS4_2(0x95),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sla",    OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xsla",   OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rr",     OP_CLASS4_2(0x99),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rr",     OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xrr",    OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rl",     OP_CLASS4_2(0x9d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rl",     OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* Adv */
+{ "xrl",    OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+
+{ "swaph",  OP_CLASS4_2(0x9a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* Adv */
+{ "sat.b",  OP_CLASS4_2(0x9e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* Adv */
+{ "sat.ub", OP_CLASS4_2(0x9f),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* Adv */
+{ "scan0",  OP_CLASS4_2(0x8a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "scan1",  OP_CLASS4_2(0x8e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "swap",   OP_CLASS4_2(0x92),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "mirror", OP_CLASS4_2(0x96),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "div0s",  OP_CLASS4_2(0x8b),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div0u",  OP_CLASS4_2(0x8f),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div1",   OP_CLASS4_2(0x93),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div2s",  OP_CLASS4_2(0x97),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+{ "div3s",  OP_CLASS4_2(0x9b),      OP_CLASS4_2_MASK,       {UNUSED},           0,  0},
+
+/* class 5 */
+
+{ "btst",   OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbtst",  OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bclr",   OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbclr",  OP_CLASS5(0xac),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bset",   OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbset",  OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bnot",   OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbnot",  OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+
+{ "adc",    OP_CLASS5(0xb8),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "sbc",    OP_CLASS5(0xbc),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.h",  OP_CLASS5(0xa2),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.hw", OP_CLASS5(0xa3),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "mltu.h", OP_CLASS5(0xa6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.w",  OP_CLASS5(0xaa),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.w", OP_CLASS5(0xae),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mac",    OP_CLASS5(0xb2),        OP_CLASS5_MASK,         {RS2},              0,  0},
+{ "mac1.h", OP_CLASS5(0xa7),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "mac1.hw",OP_CLASS5(0xab),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "mac1.w", OP_CLASS5(0xb3),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "ld.c",   OP_CLASS5(0xb1),        OP_CLASS5_MASK,         {RD,IMM5},          0,  0}, /* Adv */
+{ "ld.c",   OP_CLASS5(0xb5),        OP_CLASS5_MASK,         {IMM5,RS},          0,  0}, /* Adv */
+{ "sat.h",  OP_CLASS5(0xb6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "sat.uh", OP_CLASS5(0xb7),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "loop",   OP_CLASS5(0xb9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "loop",   OP_CLASS5(0xba),        OP_CLASS5_MASK,         {RD,IMM5_LABEL},    0,  0}, /* Adv */
+{ "loop",   OP_CLASS5(0xbb),        OP_CLASS5_MASK,         {IMM5_2,IMM5_LABEL},0,  0}, /* Adv */
+{ "sat.w",  OP_CLASS5(0xbd),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "sat.uw", OP_CLASS5(0xbe),        OP_CLASS5_MASK,         {RD,RS2},           0,  0}, /* Adv */
+{ "do.c",   OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM6_OP3},         0, 0},  /* Adv */
+{ "psrset", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_01},      0, 0},  /* Adv */
+{ "psrclr", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_10},      0, 0},  /* Adv */
+
+{ "ext",    OP_CLASS1(0x3f),        OP_CLASS1_MASK,         {RS2,OP_SHIFT,IMM2},0,  0}, /* Adv */
+{ "ext",    OP_CLASS1(0x3f),        OP_CLASS1_MASK,         {RS2},              0,  0}, /* Adv */
+{ "ext",    OP_CLASS1(0x3b),        OP_CLASS1_MASK,         {COND},             0,  0}, /* Adv */
+{ "ext",    OP_CLASS1(0x3b),        OP_CLASS1_MASK,         {OP_SHIFT,IMM2},    0,  0}, /* Adv */
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+
+/* The opcode table.    < PE MACRO > */
+
+const struct c33_opcode c33_pe_opcodes[] =
+{
+/* class 0 */
+{ "nop",    OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "slp",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "halt",   OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "pushn",  OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RS},               0,  0},
+{ "popn",   OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RD},               0,  0},
+{ "jpr",    OP_CLASS0_1(0x0b),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* PE */
+{ "jpr.d",  OP_CLASS0_1(0x0f),      OP_CLASS0_1_MASK,       {RB0},              0,  0}, /* PE */
+{ "brk",    OP_CLASS0_1(0x10),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "retd",   OP_CLASS0_1(0x11),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "int",    OP_CLASS0_1(0x12),      OP_CLASS0_1_MASK,       {IMM2},             0,  0},
+{ "reti",   OP_CLASS0_1(0x13),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "push",   OP_CLASS0_1(0x00),      OP_CLASS0_1_MASK,       {RS01},             0,  0}, /* PE */
+{ "pop",    OP_CLASS0_1(0x01),      OP_CLASS0_1_MASK,       {RD01},             0,  0}, /* PE */
+{ "pushs",  OP_CLASS0_1(0x02),      OP_CLASS0_1_MASK,       {SS02},             0,  0}, /* PE */
+{ "pops",   OP_CLASS0_1(0x03),      OP_CLASS0_1_MASK,       {SD02},             0,  0}, /* PE */
+{ "ld.cf",  OP_CLASS0_1(0x07),      OP_CLASS0_1_MASK,       {UNUSED},           0,  10},  /* PE */ /* add 2004/07/07 T.Tazaki */
+//{ "div.w",  OP_CLASS0_1(0x09),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* PE */ /* del 2004/07/07 T.Tazaki */
+//{ "divu.w", OP_CLASS0_1(0x08),      OP_CLASS0_1_MASK,       {RB01},             0,  0}, /* PE */ /* del 2004/07/07 T.Tazaki */
+
+{ "call",   OP_CLASS0_1(0x18),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call",   OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "call.d", OP_CLASS0_1(0x1c),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "call.d", OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "scall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "scall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xcall",  OP_CLASS0_2(0x1c),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xcall.d",OP_CLASS0_2(0x1d),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ret",    OP_CLASS0_1(0x19),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "ret.d",  OP_CLASS0_1(0x1d),      OP_CLASS0_1_MASK,       {UNUSED},           0,  0},
+{ "jp",     OP_CLASS0_1(0x1a),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp",     OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jp.d",   OP_CLASS0_1(0x1e),      OP_CLASS0_1_MASK,       {RB0},              0,  0},
+{ "jp.d",   OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjp",    OP_CLASS0_2(0x1e),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjp.d",  OP_CLASS0_2(0x1f),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrgt",   OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrgt.d", OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrgt",  OP_CLASS0_2(0x08),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrgt.d",OP_CLASS0_2(0x09),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrge",   OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrge.d", OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrge",  OP_CLASS0_2(0x0A),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrge.d",OP_CLASS0_2(0x0B),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrlt",   OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrlt.d", OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrlt",  OP_CLASS0_2(0x0C),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrlt.d",OP_CLASS0_2(0x0D),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrle",   OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrle.d", OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrle",  OP_CLASS0_2(0x0E),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrle.d",OP_CLASS0_2(0x0F),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrugt",  OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrugt.d",OP_CLASS0_2(0x11),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrugt", OP_CLASS0_2(0x10),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrugt.d",OP_CLASS0_2(0x11),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jruge",  OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jruge.d",OP_CLASS0_2(0x13),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjruge", OP_CLASS0_2(0x12),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjruge.d",OP_CLASS0_2(0x13),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrult",  OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrult.d",OP_CLASS0_2(0x15),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrult", OP_CLASS0_2(0x14),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrult.d",OP_CLASS0_2(0x15),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrule",  OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrule.d",OP_CLASS0_2(0x17),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrule", OP_CLASS0_2(0x16),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrule.d",OP_CLASS0_2(0x17),     OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jreq",   OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jreq.d", OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjreq",  OP_CLASS0_2(0x18),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjreq.d",OP_CLASS0_2(0x19),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "jrne",   OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "jrne.d", OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN8_LABELIMM8},  0,  0},
+{ "sjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "sjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM22},0,  0},
+{ "xjrne",  OP_CLASS0_2(0x1a),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+{ "xjrne.d",OP_CLASS0_2(0x1b),      OP_CLASS0_2_MASK,       {SIGN32_LABELIMM32},0,  0},
+
+{ "ld.b",   OP_CLASS5(0xa1),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.b",   OP_CLASS1(0x21),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.b",   OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.b",   OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.b",   OP_CLASS1(0x35),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.b",   OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.b",   OP_CLASS1(0x34),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.b",  OP_CLASS2(0x10),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.b",  OP_CLASS1(0x20),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.b",  OP_CLASS2(0x15),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  1},
+{ "xld.b",  OP_CLASS1(0x34),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ld.ub",  OP_CLASS5(0xa5),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.ub",  OP_CLASS1(0x25),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.ub",  OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.ub",  OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.ub", OP_CLASS2(0x11),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  1},
+{ "xld.ub", OP_CLASS1(0x24),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+
+{ "ld.h",   OP_CLASS5(0xa9),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.h",   OP_CLASS1(0x29),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.h",   OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.h",   OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.h",   OP_CLASS1(0x39),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.h",   OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.h",   OP_CLASS1(0x38),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.h",  OP_CLASS2(0x12),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.h",  OP_CLASS1(0x28),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.h",  OP_CLASS2(0x16),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  2},
+{ "xld.h",  OP_CLASS1(0x38),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+
+{ "ld.uh",  OP_CLASS5(0xad),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "ld.uh",  OP_CLASS1(0x2d),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.uh",  OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.uh",  OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+
+{ "xld.uh", OP_CLASS2(0x13),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  2},
+{ "xld.uh", OP_CLASS1(0x2c),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+
+{ "ld.w",   OP_CLASS1(0x2e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "ld.w",   OP_CLASS5(0xa4),        OP_CLASS5_MASK,         {RD,SS},            0,  0},
+{ "ld.w",   OP_CLASS1(0x31),        OP_CLASS1_MASK,         {RD,REGINC},        0,  0},
+{ "ld.w",   OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM6},        0,  0},
+{ "ld.w",   OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,RB},            0,  0},
+{ "ld.w",   OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN6_SYMBOLIMM6},      0,  0},
+{ "ld.w",   OP_CLASS5(0xa0),        OP_CLASS5_MASK,         {SD_LD,RS2},        0,  0},	/* PE 	ld %sd,%rs */
+{ "ld.w",   OP_CLASS1(0x3d),        OP_CLASS1_MASK,         {REGINC,RS},        0,  0},
+{ "ld.w",   OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM6,RS},        0,  0},
+{ "ld.w",   OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {RB,RS},            0,  0},
+
+{ "xld.w",  OP_CLASS2(0x14),        OP_CLASS2_MASK,         {RD,SPIMM32},       0,  4},
+{ "xld.w",  OP_CLASS2(0x17),        OP_CLASS2_MASK,         {SPIMM32,RS},       0,  4},
+{ "xld.w",  OP_CLASS1(0x30),        OP_CLASS1_MASK,         {RD,MEM_IMM26},     0,  0},
+{ "xld.w",  OP_CLASS1(0x3c),        OP_CLASS1_MASK,         {MEM_IMM26,RS},     0,  0},
+{ "xld.w",  OP_CLASS3(0x1b),        OP_CLASS3_MASK,         {RD,SIGN32_SYMBOLIMM32},    0,  0},
+
+{ "add",    OP_CLASS1(0x22),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "add",    OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "add",    OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS4_1(0x20),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xadd",   OP_CLASS3(0x18),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "sub",    OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "sub",    OP_CLASS1(0x26),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "sub",    OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM6},          0,  0},
+{ "xsub",   OP_CLASS4_1(0x21),      OP_CLASS4_1_MASK,       {SP,IMM10},         0,  0},
+{ "xsub",   OP_CLASS3(0x19),        OP_CLASS3_MASK,         {RD,IMM32},         0,  0},
+
+{ "cmp",    OP_CLASS1(0x2a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "cmp",    OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xcmp",   OP_CLASS3(0x1a),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+{ "and",    OP_CLASS1(0x32),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "and",    OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xand",   OP_CLASS3(0x1c),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "or",     OP_CLASS1(0x36),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "or",     OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xoor",   OP_CLASS3(0x1d),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "xor",    OP_CLASS1(0x3a),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "xor",    OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xxor",   OP_CLASS3(0x1e),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+{ "not",    OP_CLASS1(0x3e),        OP_CLASS1_MASK,         {RD,RS2},           0,  0},
+{ "not",    OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN6},         0,  0},
+{ "xnot",   OP_CLASS3(0x1f),        OP_CLASS3_MASK,         {RD,SIGN32},        0,  0},
+
+/* class 4 */
+
+{ "srl",    OP_CLASS4_2(0x89),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "srl",    OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsrl",   OP_CLASS4_2(0x88),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sll",    OP_CLASS4_2(0x8d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sll",    OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsll",   OP_CLASS4_2(0x8C),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sra",    OP_CLASS4_2(0x91),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sra",    OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsra",   OP_CLASS4_2(0x90),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "sla",    OP_CLASS4_2(0x95),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "sla",    OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xsla",   OP_CLASS4_2(0x94),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rr",     OP_CLASS4_2(0x99),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rr",     OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xrr",    OP_CLASS4_2(0x98),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+{ "rl",     OP_CLASS4_2(0x9d),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "rl",     OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7}, /* PE */
+{ "xrl",    OP_CLASS4_2(0x9c),      OP_CLASS4_2_MASK,       {RD,IMM5},          0,  7},
+
+{ "scan0",  OP_CLASS4_2(0x8a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "scan1",  OP_CLASS4_2(0x8e),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "swaph",  OP_CLASS4_2(0x9a),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0}, /* PE */
+{ "swap",   OP_CLASS4_2(0x92),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+{ "mirror", OP_CLASS4_2(0x96),      OP_CLASS4_2_MASK,       {RD,RS2},           0,  0},
+//{ "div0s",  OP_CLASS4_2(0x8b),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div0u",  OP_CLASS4_2(0x8f),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div1",   OP_CLASS4_2(0x93),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div2s",  OP_CLASS4_2(0x97),      OP_CLASS4_2_MASK,       {RS2},              0,  0},
+//{ "div3s",  OP_CLASS4_2(0x9b),      OP_CLASS4_2_MASK,       {UNUSED},           0,  0},
+
+/* class 5 */
+
+{ "btst",   OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbtst",  OP_CLASS5(0xa8),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bclr",   OP_CLASS5(0xac),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbclr",  OP_CLASS5(0xac),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bset",   OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbset",  OP_CLASS5(0xb0),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+{ "bnot",   OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {RB,IMM3},          0,  0},
+{ "xbnot",  OP_CLASS5(0xb4),        OP_CLASS5_MASK,         {MEM_IMM26,IMM3},   0,  0},
+
+{ "adc",    OP_CLASS5(0xb8),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "sbc",    OP_CLASS5(0xbc),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.h",  OP_CLASS5(0xa2),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.h", OP_CLASS5(0xa6),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mlt.w",  OP_CLASS5(0xaa),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mltu.w", OP_CLASS5(0xae),        OP_CLASS5_MASK,         {RD,RS2},           0,  0},
+{ "mac",    OP_CLASS5(0xb2),        OP_CLASS5_MASK,         {RS2},              0,  0},
+{ "ld.c",   OP_CLASS5(0xb1),        OP_CLASS5_MASK,         {RD,IMM5},          0,  0}, /* PE */	/* add T.Tazaki 2004/07/07 */
+{ "ld.c",   OP_CLASS5(0xb5),        OP_CLASS5_MASK,         {IMM5,RS},          0,  0}, /* PE */	/* add T.Tazaki 2004/07/07 */
+{ "do.c",   OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM6_OP3},         0, 0},  /* PE */	/* add T.Tazaki 2004/07/07 */
+{ "psrset", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_01},      0, 0},  /* PE */
+{ "psrclr", OP_CLASS5(0xbf),        OP_CLASS5_MASK,         {IMM5_OP3_10},      0, 0},  /* PE */
+
+/* class 6 */
+
+{ "ext",    OP_CLASS6(0x6),         OP_CLASS6_MASK,         {IMM13_LABEL},      0,  0},
+
+{ 0, 0, 0, {0}, 0, 0 },
+
+} ;
+
+/* 上から移動  T.Tazaki 2004/07/30 */
+const int c33_num_opcodes =
+  sizeof (c33_opcodes) / sizeof (c33_opcodes[0]);
diff --git a/opcodes/configure b/opcodes/configure
index 72c9726..946b73f 100755
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -3948,6 +3948,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_tahoe_arch)		;;
 	bfd_tic30_arch)		ta="$ta tic30-dis.lo" ;;
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
+	bfd_c33_arch)		ta="$ta c33-opc.lo c33-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff --git a/opcodes/configure.in b/opcodes/configure.in
index 6ef461f..2efc16f 100644
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -163,6 +163,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_tahoe_arch)		;;
 	bfd_tic30_arch)		ta="$ta tic30-dis.lo" ;;
 	bfd_tic80_arch)		ta="$ta tic80-dis.lo tic80-opc.lo" ;;
+	bfd_c33_arch)		ta="$ta c33-opc.lo c33-dis.lo" ;;
 	bfd_v850_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850e_arch)		ta="$ta v850-opc.lo v850-dis.lo" ;;
 	bfd_v850ea_arch)	ta="$ta v850-opc.lo v850-dis.lo" ;;
diff --git a/opcodes/disassemble.c b/opcodes/disassemble.c
index 373b652..8784007 100644
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -55,6 +55,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 #define ARCH_z8k
 #endif
 
+#define	ARCH_c33	/* 追加 2001.1.15 ide */
 
 disassembler_ftype
 disassembler (abfd)
@@ -259,6 +260,14 @@ disassembler (abfd)
       disassemble = print_insn_vax;
       break;
 #endif
+
+#ifdef ARCH_c33		/* add */
+    case bfd_arch_c33:
+      disassemble = print_insn_c33;
+      break;
+#endif
+
+
     default:
       return 0;
     }
-- 
1.5.4.3

